# Add this ONE LINE at the top of your script:
import builtins; builtins.print = lambda *a, **k: None if not __import__('os').environ.get('DEBUG') else print(*a, **k)

# IMMEDIATE SPLASH SCREEN - BEFORE ANY HEAVY IMPORTS
import sys
import os

# STEP 1: Minimal Qt imports only for splash screen
try:
    from PyQt6.QtWidgets import QApplication, QSplashScreen
    from PyQt6.QtGui import QPixmap, QColor  
    from PyQt6.QtCore import Qt
    
    # High DPI setup and WebEngine setup before QApplication
    if hasattr(Qt.ApplicationAttribute, 'AA_UseHighDpiPixmaps'):
        QApplication.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps, True)
    if hasattr(Qt, 'HighDpiScaleFactorRoundingPolicy'):
        QApplication.setHighDpiScaleFactorRoundingPolicy(Qt.HighDpiScaleFactorRoundingPolicy.PassThrough)
    
    # CRITICAL: Set OpenGL context sharing for WebEngine BEFORE creating QApplication
    QApplication.setAttribute(Qt.ApplicationAttribute.AA_ShareOpenGLContexts, True)
    
    # STEP 2: Create QApplication and show splash IMMEDIATELY
    if __name__ == '__main__':
        app = QApplication(sys.argv)
        app.setApplicationName('Scriptoria')
        app.setOrganizationName('Delisi Media')
        app.setOrganizationDomain('delisi.media')
        
        # Load splash image
        base_path = os.path.dirname(os.path.abspath(__file__))
        splash_path = os.path.join(base_path, 'Img', 'splash-screen.png')
        splash_pix = QPixmap(splash_path)
        
        if splash_pix.isNull():
            splash_pix = QPixmap(500, 500)
            splash_pix.fill(QColor("#f3f3f3"))
        else:
            splash_pix = splash_pix.scaled(500, 500, Qt.AspectRatioMode.IgnoreAspectRatio, Qt.TransformationMode.SmoothTransformation)
        
        # Create and show splash immediately
        splash = QSplashScreen(splash_pix, Qt.WindowType.WindowStaysOnTopHint | Qt.WindowType.FramelessWindowHint)
        screen = QApplication.primaryScreen().availableGeometry()
        x = (screen.width() - splash_pix.width()) // 2
        y = (screen.height() - splash_pix.height()) // 2
        splash.move(x, y)
        splash.show()
        splash.showMessage("Loading Scriptoria...", Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignCenter, QColor("white"))
        app.processEvents()
        
        # STEP 3: Now do ALL imports with progress updates
        splash.showMessage("Loading core modules...", Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignCenter, QColor("white"))
        app.processEvents()
        
except ImportError:
    # Fallback if PyQt6 not available
    app = None
    splash = None

# NOW DO ALL THE HEAVY IMPORTS AFTER SPLASH IS SHOWN
import platform

# Start animated loading dots in background
if splash and app:
    from PyQt6.QtCore import QTimer
    
    # Dot animation state
    dot_counter = [0]  # Use list for mutable reference
    
    def update_dots():
        """Update dots animation continuously"""
        if splash and app:
            dots = "." * ((dot_counter[0] % 4) + 1)  # Cycle 1-4 dots
            splash.showMessage(f"Loading modules{dots}", Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignCenter, QColor("white"))
            app.processEvents()
            dot_counter[0] += 1
    
    # Start timer for continuous dot animation
    dot_timer = QTimer()
    dot_timer.timeout.connect(update_dots)
    dot_timer.start(150)  # Update every 150ms for smooth animation

# All imports happen here while dots animate continuously
import re
import json
import random
import types
import datetime
import uuid
import copy
import webbrowser
import traceback
import shutil
import tempfile
import string
import difflib
import subprocess
import time
import pyaudio
import asyncio
from bs4 import BeautifulSoup, NavigableString, Doctype, Tag
from html.parser import HTMLParser
from pathlib import Path
import google.generativeai as genai
import concurrent.futures
import fitz
from pdfminer.high_level import extract_pages
from pdfminer.layout import LAParams, LTTextContainer
from PyQt6.QtMultimedia import QMediaPlayer, QAudioOutput
from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QSpinBox, QVBoxLayout, QHBoxLayout, QStyleOptionButton, QStyle, QGraphicsDropShadowEffect, QTabBar,
    QPushButton, QTextEdit, QFileDialog, QMessageBox,QGroupBox,QFrame, QProgressBar, QRadioButton, QStyledItemDelegate, QSpacerItem,
    QTabWidget, QStatusBar, QSplitter, QSizePolicy, QMenu, QGridLayout,QToolButton, QButtonGroup, QListView, QToolTip,QWidgetAction, QInputDialog,
    QDialog, QDialogButtonBox, QSlider, QProgressDialog, QScrollArea, QListWidget, QListWidgetItem, QAbstractItemView, QLineEdit, QFormLayout, QColorDialog, QComboBox, QCheckBox, QToolBar, QTextBrowser, QLayout, QLabel
)
from PyQt6.QtGui import (
    QScreen,QTextFormat, QPageLayout, QImage, QTextCursor, QGuiApplication, QPageSize, QTextBlockFormat, QSyntaxHighlighter, QPolygon, QPen, QAction, QIcon, QShortcut, QKeySequence, QPainter, QBrush, QDesktopServices, QDrag, QFontMetrics, QWheelEvent,QTextCharFormat, QPainterPath,  QCursor, QDropEvent, QTextDocument, QCloseEvent, QFont, QPalette, QMouseEvent, QPixmap
)
from PyQt6.QtCore import (
    QRegularExpression, QSizeF, QEventLoop,QTime, QMarginsF, QRectF, QSettings, QThread, pyqtSignal, QUrl, pyqtSlot, QPointF, QObject, QRect, QPoint, QSize, QUrl, QMimeData, QEvent, QDateTime, QRectF, QPropertyAnimation, QAbstractAnimation,  QEasingCurve, QSignalBlocker, QByteArray, QModelIndex, QCoreApplication, QTimer, Qt, QThreadPool, QRunnable, QMetaObject, Q_ARG, Q_RETURN_ARG
)

from PyQt6.QtWebEngineWidgets import QWebEngineView
from PyQt6.QtWebEngineCore import QWebEnginePage, QWebEngineSettings
from PyQt6.QtWebChannel import QWebChannel
from PyQt6.QtPrintSupport import QPrinter

# Stop the dot animation and show final message
if splash and app:
    # Stop the timer
    if 'dot_timer' in locals():
        dot_timer.stop()
    
    splash.showMessage("Starting main window...", Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignCenter, QColor("white"))
    app.processEvents()

###Un-comment the below to enable Javascript debugging, and then look in the console for debugging link.
#os.environ["QTWEBENGINE_REMOTE_DEBUGGING"] = "9222"  

# Define at module/class level
ITEM_WIDGET_STYLE = """
    QWidget {
        border: 1px solid #d0d0d0;
        outline: none;
    }
    QWidget QWidget {
        border: none;
    }
"""

STAR_BUTTON_STYLE = """
    QPushButton {
        margin-right: 5px;
        margin-top: 7px;
    }
"""

CUSTOM_TOOLTIP_STYLE = """
QLabel#CustomTooltipLabel {
    color: #333333;              /* Text color (e.g., dark gray) */
    background-color: #ffffe0;   /* Background color (e.g., light yellow) */
    border: 1px solid #c0c0c0;   /* Border color (e.g., slightly darker gray) */
    border-radius: 3px;          /* Slightly rounded corners */
    padding: 4px 6px;            /* Padding around the text */
    font-size: 11px;             /* Explicit font size */
    /* opacity: 230; */          /* Opacity often better handled by widget properties if needed */
}
"""


STAR_BUTTON_FAVORITE_STYLE = "QPushButton { color: #FFD700; font-size: 18px; }"
STAR_BUTTON_NORMAL_STYLE = "QPushButton { color: gray; font-size: 18px; }"

EDIT_NOTES_BUTTON_STYLE = """
    QPushButton {
        border: none;
        background-color: transparent;
        padding: 0px;
    }
"""

NOTES_EDIT_STYLE = """
    QLineEdit {
        border: 1px solid #e0e0e0;
        border-radius: 3px;
        padding: 4px 8px;
        background-color: #f8f9fa;
        font-size: 12px;
        color: #444;
        margin-left: 2px;f
        margin-top: 4px;
        margin-bottom: 2px;
    }
    QLineEdit::placeholder {
        color: #999;
        font-style: italic;
        font-weight: normal;
    }
"""



# --- Collapsible Widget Class ---
class CollapsibleWidget(QWidget):
    """Small widget that represents the collapsed state of the Script Editor."""
    
    expandClicked = pyqtSignal()  # Signal emitted when widget is clicked to expand
    restoreMainWindow = pyqtSignal()  # Signal to restore main window from taskbar click
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.initUI()
        
    def initUI(self):
        # Configure widget properties
        self.setWindowFlags(Qt.WindowType.Window | Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setFixedSize(145, 35)  # Compact size
        
        # Set floating-specific icon
        icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Img', 'storyboard-floating.ico')
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))
        else:
            # Fallback to main icon if floating icon doesn't exist
            fallback_icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Img', 'storyboard.ico')
            if os.path.exists(fallback_icon_path):
                self.setWindowIcon(QIcon(fallback_icon_path))
                
        # Set window title for taskbar identification
        self.setWindowTitle("Scriptoria - Floating")
        
        # Make sure window can receive focus for taskbar clicks
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        self.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating, False)
        
        # Main layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(2, 2, 2, 2)
        
        # Create frame to hold content with rounded corners - Using Scriptoria theme
        self.frame = QFrame()
        self.frame.setObjectName("collapsibleFrame")
        self.frame.setStyleSheet("""
            QFrame#collapsibleFrame {
                background-color: #4a90e2;
                color: white;
                border-radius: 6px;
                border: 1px solid #357abd;
            }
        """)
        
        # Layout for frame content
        frame_layout = QHBoxLayout(self.frame)
        frame_layout.setContentsMargins(6, 2, 6, 2)  # Compact padding
        
        # Add icon (optional)
        try:
            icon_path = os.path.join("Img", "storyboard.ico")
            if os.path.exists(icon_path):
                icon_label = QLabel()
                # Compact logo size for smaller widget
                icon_pixmap = QIcon(icon_path).pixmap(24, 18)
                icon_label.setPixmap(icon_pixmap)
                icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                frame_layout.addWidget(icon_label)
            else:
                # Fallback - use a simple circle icon
                icon_label = QLabel("●")
                icon_label.setStyleSheet("color: white; font-size: 14px;")
                frame_layout.addWidget(icon_label)
        except Exception as e:
            print(f"Error loading icon: {e}")
            # Use a simple circle as fallback
            icon_label = QLabel("●")
            icon_label.setStyleSheet("color: white; font-size: 14px;")
            frame_layout.addWidget(icon_label)
        
        # Add text label
        self.label = QLabel("Script Editor")
        self.label.setStyleSheet("color: white; font-weight: bold;")
        frame_layout.addWidget(self.label)
        
        # Add expand button
        expand_btn = QPushButton("↗")
        expand_btn.setToolTip("Expand")
        expand_btn.setFlat(True)
        expand_btn.setFixedSize(20, 20)  # Smaller expand button
        expand_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        expand_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: white;
                border: none;
                font-size: 14px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 0.2);
                border-radius: 4px;
            }
        """)
        expand_btn.clicked.connect(self.expandClicked.emit)
        frame_layout.addWidget(expand_btn)
        
        # Add frame to main layout
        layout.addWidget(self.frame)
        
        # Make widget draggable
        self.old_pos = None
        self.dragging = False
        
    def changeEvent(self, event):
        """Handle window state changes including taskbar activation."""
        if event.type() == QEvent.Type.WindowActivate:
            # Window was activated (clicked on taskbar) - restore main window
            self.restoreMainWindow.emit()
        super().changeEvent(event)
        
    def mousePressEvent(self, event):
        """Handle mouse press for dragging."""
        if event.button() == Qt.MouseButton.LeftButton:
            self.old_pos = event.globalPosition().toPoint()
            self.dragging = False  # Reset dragging state
        else:
            super().mousePressEvent(event)
    
    def mouseReleaseEvent(self, event):
        """Handle mouse release for clicking expansion."""
        if event.button() == Qt.MouseButton.LeftButton:
            # Only emit expand signal if we didn't drag (or barely moved)
            if self.old_pos is not None and not self.dragging:
                self.expandClicked.emit()
        self.old_pos = None
        self.dragging = False
        super().mouseReleaseEvent(event)
    
    def mouseMoveEvent(self, event):
        """Handle mouse move for dragging."""
        if event.buttons() & Qt.MouseButton.LeftButton and self.old_pos is not None:
            # Calculate movement delta
            current_pos = event.globalPosition().toPoint()
            delta = current_pos - self.old_pos
            
            # If we moved more than a few pixels, consider it a drag operation
            if delta.manhattanLength() > 3:
                self.dragging = True
                self.move(self.pos() + delta)
                self.old_pos = current_pos
        else:
            super().mouseMoveEvent(event)
    
    def enterEvent(self, event):
        """Mouse hover effect."""
        self.frame.setStyleSheet("""
            QFrame#collapsibleFrame {
                background-color: #357abd;
                color: white;
                border-radius: 6px;
                border: 1px solid #2a5f8f;
            }
        """)
        super().enterEvent(event)
    
    def leaveEvent(self, event):
        """Reset hover effect."""
        self.frame.setStyleSheet("""
            QFrame#collapsibleFrame {
                background-color: #4a90e2;
                color: white;
                border-radius: 6px;
                border: 1px solid #357abd;
            }
        """)
        super().leaveEvent(event)
        
    def showEvent(self, event):
        """Position widget on screen when shown."""
        # Don't reposition the widget (positioning is handled by collapse_to_widget)
        super().showEvent(event)


# --- Custom Paint Event Widgets ---
class CustomStarButton(QWidget):
    """Custom star button using paint events for better performance"""
    
    clicked = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(24, 24)
        self.is_checked = False
        self.is_hovered = False
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        
    def setChecked(self, checked):
        if self.is_checked != checked:
            self.is_checked = checked
            self.update()
            
    def isChecked(self):
        return self.is_checked
        
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.is_checked = not self.is_checked
            self.update()
            self.clicked.emit()
            event.accept()  # Stop event propagation
        else:
            super().mousePressEvent(event)
        
    def enterEvent(self, event):
        self.is_hovered = True
        self.update()
        super().enterEvent(event)
        
    def leaveEvent(self, event):
        self.is_hovered = False
        self.update()
        super().leaveEvent(event)
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Define colors
        if self.is_checked:
            pen_color = QColor(255, 215, 0)  # Gold border for favorite
            fill_color = QColor(255, 215, 0)  # Gold fill for favorite
        else:
            pen_color = QColor(128, 128, 128)  # Gray border for normal
            fill_color = Qt.GlobalColor.transparent  # Transparent fill for empty star
            
        # Apply hover effect
        if self.is_hovered:
            pen_color = pen_color.lighter(120)
            if self.is_checked:
                fill_color = fill_color.lighter(120)
            
        # Set pen and brush
        painter.setPen(QPen(pen_color, 1))  # 1px border thickness
        if self.is_checked:
            painter.setBrush(QBrush(fill_color))
        else:
            painter.setBrush(Qt.BrushStyle.NoBrush)  # No fill for empty star
        
        # Draw star shape
        center = self.rect().center()
        # Scale radius based on widget size to prevent cutoff
        widget_size = min(self.width(), self.height())
        radius = max(4, int(widget_size * 0.4))  # Use 40% of widget size, minimum 4px
        
        # Create star path
        star_path = QPainterPath()
        
        # 5-pointed star coordinates
        import math
        outer_points = []
        inner_points = []
        
        for i in range(5):
            # Outer points
            angle = math.pi * 2 * i / 5 - math.pi / 2  # Start from top
            x = center.x() + radius * math.cos(angle)
            y = center.y() + radius * math.sin(angle)
            outer_points.append(QPointF(x, y))
            
            # Inner points (smaller radius, offset by half angle)
            inner_angle = angle + math.pi / 5
            inner_radius = radius * 0.4
            x = center.x() + inner_radius * math.cos(inner_angle)
            y = center.y() + inner_radius * math.sin(inner_angle)
            inner_points.append(QPointF(x, y))
        
        # Build star path
        star_path.moveTo(outer_points[0])
        for i in range(5):
            star_path.lineTo(inner_points[i])
            star_path.lineTo(outer_points[(i + 1) % 5])
        star_path.closeSubpath()
        
        painter.drawPath(star_path)
        

class CustomCheckBox(QWidget):
    """Custom checkbox using paint events for better performance"""
    
    stateChanged = pyqtSignal(int)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(24, 24)
        self.is_checked = False
        self.is_hovered = False
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        
    def setChecked(self, checked):
        if self.is_checked != checked:
            self.is_checked = checked
            self.update()
            self.stateChanged.emit(2 if checked else 0)  # Qt.CheckState.Checked : Qt.CheckState.Unchecked
            
    def isChecked(self):
        return self.is_checked
        
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.setChecked(not self.is_checked)
            event.accept()  # Stop event propagation
        else:
            super().mousePressEvent(event)
        
    def enterEvent(self, event):
        self.is_hovered = True
        self.update()
        super().enterEvent(event)
        
    def leaveEvent(self, event):
        self.is_hovered = False
        self.update()
        super().leaveEvent(event)
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Calculate checkbox area (centered, slightly smaller than widget)
        margin = 3
        rect = self.rect().adjusted(margin, margin, -margin, -margin)
        
        # Define colors
        border_color = QColor(100, 100, 100)
        
        if self.is_checked:
            # Fill entire square with green when checked
            fill_color = QColor(50, 150, 50)  # Green fill
            check_color = QColor(255, 255, 255)  # White checkmark
        else:
            fill_color = QColor(240, 240, 240)  # Light gray background
            
        if self.is_hovered:
            border_color = border_color.darker(120)
            if not self.is_checked:
                fill_color = QColor(230, 230, 230)
            
        # Draw checkbox background
        painter.setPen(QPen(border_color, 1))
        painter.setBrush(QBrush(fill_color))
        painter.drawRoundedRect(rect, 2, 2)


# Define custom exception for cancellation
class OperationCanceledError(Exception):
    pass

def get_data_folder():
    """Gets the path to the 'data' subfolder."""
    try:
        # Get base path correctly for frozen (PyInstaller) or script execution
        if getattr(sys, 'frozen', False):
            base_path = os.path.dirname(sys.executable)
        else:
            base_path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(base_path, "data")
    except Exception as e:
        print(f"Error determining data folder path: {e}")
        return os.path.join(os.getcwd(), "data") # Fallback

# --- Worker Class (Keep GeminiWorker as defined previously) ---

# --- Worker Class (Keep GeminiWorker as defined previously) ---
class GeminiWorker(QObject):
    """
    A robust, unified worker for Gemini API calls in a separate thread.
    Supports streaming, non-streaming, "thinking" budget, and reliable cancellation.
    """
    finished = pyqtSignal(str)
    error = pyqtSignal(str)
    progress = pyqtSignal(str)
    streaming_chunk = pyqtSignal(str)

    def __init__(self, model, full_prompt, enable_streaming=True, thinking_budget=0):
        super().__init__()
        self.model = model
        self.full_prompt = full_prompt
        self.enable_streaming = enable_streaming
        self.thinking_budget = thinking_budget if not enable_streaming else 0 # Thinking is for non-streaming

        self._is_running = True
        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)
        self._api_future = None

    def run(self):
        """
        Starts the Gemini processing by submitting the appropriate task to the thread pool.
        The main QThread remains responsive for cancellation.
        """
        if not self._is_running:
            return

        try:
            if self.enable_streaming:
                self.progress.emit("Connecting to Gemini API...")
                self._api_future = self._executor.submit(self._execute_streaming_task)
            else:
                if self.thinking_budget > 0:
                    self.progress.emit(f"Generating content (thinking budget: {self.thinking_budget} tokens)...")
                else:
                    self.progress.emit("Generating content...")
                self._api_future = self._executor.submit(self._execute_non_streaming_task)
        except Exception as e:
            self.error.emit(f"Failed to start worker: {e}")

    def stop(self):
        """
        Stops the worker and attempts to cancel the ongoing API call.
        Sets a flag to ensure loops terminate and shuts down the executor.
        """
        self.progress.emit("Process ended.")
        self._is_running = False
        
        # Shutdown the executor. This will attempt to cancel the running future.
        # `cancel_futures=True` is available in Python 3.9+ and is very helpful.
        if self._executor:
            self._executor.shutdown(wait=False, cancel_futures=True)

    def _parse_response_text(self, response_part) -> str:
        """Safely extracts text from a Gemini response object (chunk or full)."""
        try:
            # The most common and direct way
            if hasattr(response_part, 'text'):
                return response_part.text
            # Check inside 'parts'
            if hasattr(response_part, 'parts'):
                return "".join(part.text for part in response_part.parts if hasattr(part, 'text'))
            # Check inside 'candidates'
            if hasattr(response_part, 'candidates') and response_part.candidates:
                content = response_part.candidates[0].content
                return "".join(part.text for part in content.parts if hasattr(part, 'text'))
        except Exception:
            # If parsing fails for any reason, return empty string
            return ""
        return ""

    def _execute_streaming_task(self):
        """
        Task to be run in the executor for STREAMING calls.
        This loop is blocking, but since it's in the executor, the main thread is safe.
        """
        try:
            response_stream = self.model.generate_content(self.full_prompt, stream=True)
            full_result = ""
            for chunk in response_stream:
                if not self._is_running:
                    self.progress.emit("Streaming cancelled.")
                    return  # Exit the task

                chunk_text = self._parse_response_text(chunk)
                if chunk_text:
                    full_result += chunk_text
                    self.streaming_chunk.emit(chunk_text)

            self.finished.emit(full_result)
        except Exception as e:
            self._handle_api_error(e)

    def _execute_non_streaming_task(self):
        """
        Task to be run in the executor for NON-STREAMING calls.
        Includes logic for the 'thinking' feature.
        """
        try:
            generation_config = None
            if self.thinking_budget > 0:
                try:
                    from google.generativeai.types import GenerateContentConfig, ThinkingConfig
                    thinking_config = ThinkingConfig(thinking_budget=self.thinking_budget)
                    generation_config = GenerateContentConfig(thinking_config=thinking_config)
                except ImportError:
                    self.progress.emit("Warning: 'ThinkingConfig' not found. Proceeding without it.")

            response = self.model.generate_content(self.full_prompt, generation_config=generation_config)

            if not self._is_running:
                self.progress.emit("Processing cancelled.")
                return # Exit the task

            # Parse final response
            result = self._parse_response_text(response)
            self.finished.emit(result)

            # Report token usage if available
            if hasattr(response, 'usage_metadata'):
                usage = response.usage_metadata
                usage_parts = [
                    f"Input: {usage.prompt_token_count}",
                    f"Thinking: {getattr(usage, 'thoughts_token_count', 0)}",
                    f"Output: {usage.candidates_token_count}",
                    f"Total: {usage.total_token_count}"
                ]
                self.progress.emit(f"Usage (tokens): {' | '.join(usage_parts)}")

        except Exception as e:
            self._handle_api_error(e)

    def _handle_api_error(self, e):
        """Centralized error message formatting."""
        error_message = str(e)
        if "API_KEY_INVALID" in error_message or "permission" in error_message.lower():
            final_message = f"API Key / Authentication Error. Please check your key. Details: {e}"
        elif "quota" in error_message.lower():
            final_message = f"Quota Exceeded. You may have hit usage limits. Details: {e}"
        elif "DeadlineExceeded" in error_message:
            final_message = f"Network Timeout. Check your connection or try again. Details: {e}"
        elif "ResourceExhausted" in error_message:
            final_message = f"Resource Error. The service may be busy. Details: {e}"
        else:
            final_message = f"An API error occurred: {e}"
        
        self.error.emit(final_message)

class GeminiWorkerWithThinking(QObject):
    """
    Enhanced Worker object to handle Gemini API calls with thinking capabilities.
    Supports Gemini 2.5 models with the thinking_budget parameter.
    """
    finished = pyqtSignal(str)  # Signal emitted when processing is done, carrying the result string
    error = pyqtSignal(str)     # Signal emitted on error, carrying the error message string
    progress = pyqtSignal(str)  # Signal for status updates (optional)

    def __init__(self, model, full_prompt, thinking_budget=0):
        super().__init__()
        self.model = model
        self.full_prompt = full_prompt
        self.thinking_budget = thinking_budget
        self._is_running = True
        self._api_future = None
        self._executor = None

    def _make_api_call(self):
        """Makes the actual API call with thinking configuration - runs in executor thread."""
        # Create thinking configuration if budget > 0
        thinking_config = None
        generation_config = None
        
        if self.thinking_budget > 0:
            try:
                # Import the necessary types for thinking configuration
                from google.generativeai.types import GenerateContentConfig, ThinkingConfig
                
                # Create thinking configuration
                thinking_config = ThinkingConfig(thinking_budget=self.thinking_budget)
                generation_config = GenerateContentConfig(thinking_config=thinking_config)
            except ImportError:
                # If thinking config isn't available, proceed without it
                generation_config = None

        # Make the API call using the pre-configured model instance with thinking config
        if generation_config:
            return self.model.generate_content(self.full_prompt, config=generation_config)
        else:
            return self.model.generate_content(self.full_prompt)

    def run(self):
        """Starts the Gemini processing with thinking configuration and proper cancellation support."""
        if not self._is_running:
            self.progress.emit("Processing stopped.")
            return

        try:
            import concurrent.futures
            
            if self.thinking_budget > 0:
                self.progress.emit(f"Generating content with Gemini (thinking budget: {self.thinking_budget} tokens)...")
            else:
                self.progress.emit("Generating content with Gemini...")

            # Create executor for the API call
            self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)
            
            # Submit the API call to the executor
            self._api_future = self._executor.submit(self._make_api_call)
            
            # Wait for completion with periodic cancellation checks
            response = None
            try:
                # Keep checking if cancelled while waiting (check every 0.5 seconds)
                while self._is_running and not self._api_future.done():
                    try:
                        response = self._api_future.result(timeout=0.5)
                        break
                    except concurrent.futures.TimeoutError:
                        continue
                
                # If cancelled while waiting, cancel the future
                if not self._is_running:
                    self.progress.emit("Cancelling API request...")
                    if self._api_future and not self._api_future.done():
                        self._api_future.cancel()
                    self.progress.emit("Processing stopped.")
                    return
                    
                # If we get here, get the result
                if self._api_future.done() and not self._api_future.cancelled():
                    response = self._api_future.result()
                else:
                    self.error.emit("API call was cancelled or failed unexpectedly")
                    return

            except concurrent.futures.CancelledError:
                self.progress.emit("API request was cancelled.")
                return
            except Exception as future_error:
                self.error.emit(f"API execution error: {future_error}")
                return

            if not self._is_running: # Final check
                self.progress.emit("Processing stopped.")
                return

            # --- Parse Response ---
            # Check the structure and extract text safely
            result = ""
            try:
                # Common case: Simple text response
                if hasattr(response, 'text'):
                    result = response.text
                # Handle cases with parts (common for multimodal or chunked responses)
                elif hasattr(response, 'parts') and response.parts:
                     result = "".join(part.text for part in response.parts if hasattr(part, 'text'))
                # Handle candidate structure (common in newer API versions)
                elif hasattr(response, 'candidates') and response.candidates:
                     first_candidate = response.candidates[0]
                     if hasattr(first_candidate, 'content') and hasattr(first_candidate.content, 'parts') and first_candidate.content.parts:
                         result = "".join(part.text for part in first_candidate.content.parts if hasattr(part, 'text'))
                     else:
                         # Fallback if structure is different
                         result = f"Received unexpected candidate structure: {first_candidate}"
                else:
                    # Fallback if the structure is unknown or response is empty/unexpected
                    result = f"Could not extract text from response. Response structure: {type(response)}"
                    print(f"Unexpected Gemini response structure: {response}")

                # Add usage info if available (Gemini 2.5 models with thinking)
                if hasattr(response, 'usage_metadata'):
                    usage_info = []
                    
                    if hasattr(response.usage_metadata, 'prompt_token_count'):
                        usage_info.append(f"Input tokens: {int(response.usage_metadata.prompt_token_count):,}")
                    
                    if hasattr(response.usage_metadata, 'candidates_token_count'):
                        usage_info.append(f"Output tokens: {int(response.usage_metadata.candidates_token_count):,}")
                        
                    if hasattr(response.usage_metadata, 'thoughts_token_count'):
                        usage_info.append(f"Thinking tokens: {int(response.usage_metadata.thoughts_token_count):,}")
                        
                    if hasattr(response.usage_metadata, 'total_token_count'):
                        usage_info.append(f"Total tokens: {int(response.usage_metadata.total_token_count):,}")
                    
                    if usage_info:
                        self.progress.emit("API usage: " + " | ".join(usage_info))

            except Exception as parse_error:
                print(f"Error parsing Gemini response: {parse_error!r}")
                self.error.emit(f"Error parsing response: {parse_error}")
                return # Stop if parsing failed

            self.finished.emit(result)

        except Exception as e:
            error_message = str(e)
            # Specific error checks for better user feedback
            if "API_KEY_INVALID" in error_message or "permission" in error_message.lower() or "authenticate" in error_message.lower():
                error_message = f"API Key / Authentication Error: {error_message}. Please check your key."
            elif "quota" in error_message.lower():
                 error_message = f"Quota Exceeded: {error_message}. You might have hit usage limits."
            elif "DeadlineExceeded" in error_message:
                 error_message = f"Network Timeout: {error_message}. Check connection or try again."
            elif "ResourceExhausted" in error_message:
                error_message = f"Resource Error: {error_message}. The service might be busy, try again later."
            # Add more specific error checks if needed
            print(f"Error during API call: {e!r}") # Log detailed error
            self.error.emit(f"API Call Error: {error_message}")
        finally:
            # Cleanup executor and futures
            if self._api_future and not self._api_future.done():
                self._api_future.cancel()
            if self._executor:
                self._executor.shutdown(wait=False)

    def stop(self):
        """Safely stops the worker and cancels any ongoing API calls."""
        self._is_running = False
        
        # Cancel the API future if it's running
        if self._api_future and not self._api_future.done():
            self._api_future.cancel()
            
        # Shutdown the executor
        if self._executor:
            self._executor.shutdown(wait=False)
            
        self.progress.emit("Processing stopped.")

# --- Custom Gemini Processor Dialog Class (Complete) ---
class GeminiProcessorDialog(QDialog):
    # --- Add this signal ---
    pasteToInputRequested = pyqtSignal(str)  # Signal to request pasting text into the main input

    def __init__(self, parent=None, prompt_content=""):
        super().__init__(parent)
        self.current_prompt_content = prompt_content
        self.model = None # Model will be configured internally
        self.thread = None
        self.worker = None
        self.current_prompt_content = prompt_content
        self._is_processing = False # State variable
        self.api_key_file_path = self._get_api_key_path() # Define path once
        self.model_config_path = os.path.join(os.path.dirname(self.api_key_file_path), "model_config.json")

        self.setWindowTitle("Gemini API Captions Processor")
        self.setMinimumSize(850, 750) # Width, Height

        # --- Setup UI ---
        self._setup_ui()
        self._connect_signals()

        # --- Load Key & Configure API on Startup ---
        self._load_and_configure_gemini()

    def _get_api_key_path(self):
        """Gets the full path for the API key file in the 'data' subfolder."""
        try:
            # Get base path correctly for frozen (PyInstaller) or script execution
            if getattr(sys, 'frozen', False):
                # If the application is run as a bundle/frozen executable
                base_path = os.path.dirname(sys.executable)
            else:
                # If the application is run as a script
                base_path = os.path.dirname(os.path.abspath(__file__))

            data_folder = os.path.join(base_path, "data")
            # Create data folder if it doesn't exist (important for first run)
            os.makedirs(data_folder, exist_ok=True)
            return os.path.join(data_folder, "api_key.txt")
        except Exception as e:
            print(f"Error determining API key path: {e}")
            # Fallback to current working directory if path fails (less ideal)
            return os.path.join(os.getcwd(), "api_key.txt")

    def _setup_ui(self):
        """Builds the user interface for the dialog."""
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(5)
        main_layout.setContentsMargins(10, 5, 10, 5)

        # --- Header with Logo ---
        header_layout = QHBoxLayout()
        self.logo_label = QLabel()
        try:
            # Determine base path for resources
            if getattr(sys, 'frozen', False):
                base_path = os.path.dirname(sys.executable)
            else:
                # Assuming the script is run from the project root or similar
                base_path = os.path.dirname(os.path.abspath(__file__))
            logo_path = os.path.join(base_path, "img", "Gemini-logo.png") # Ensure 'img' folder exists

            if os.path.exists(logo_path):
                pixmap = QPixmap(logo_path)
                pixmap = pixmap.scaledToHeight(40, Qt.TransformationMode.SmoothTransformation)
                self.logo_label.setPixmap(pixmap)
                self.logo_label.setFixedSize(pixmap.width(), 40)
                header_layout.addWidget(self.logo_label)
            else:
                print(f"Warning: Logo image not found at '{logo_path}'")
        except Exception as e:
            print(f"Error loading logo: {e}")

        header_text = QLabel("Process with Gemini API")
        header_text.setStyleSheet("font-size: 16px; font-weight: bold; margin-left: 0px;")
        header_layout.addWidget(header_text)
        header_layout.addStretch()
        main_layout.addLayout(header_layout)

        # --- Instructions ---
        instruction = QLabel("It is easy and free to setup and use a Gemini API Key. Rates can occur, however, after extensive daily usage.")
        instruction.setStyleSheet("font-size: 12px; margin-bottom: 10px;")
        instruction.setWordWrap(True)
        main_layout.addWidget(instruction)

        # --- API Key Management Section ---
        api_key_group_widget = QWidget()
        api_key_layout = QHBoxLayout(api_key_group_widget)
        api_key_layout.setContentsMargins(0, 5, 0, 5)

        api_label = QLabel("Gemini API Key:")
        self.api_key_input = QLineEdit()
        self.api_key_input.setPlaceholderText("Enter your API Key and press Save")
        self.api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.api_key_input.setMinimumWidth(350)
        self.api_key_input.setStyleSheet("padding: 5px; border: 1px solid #ccc; border-radius: 3px;")
        self.api_key_input.setToolTip("Enter your Google AI Studio API Key here.\nIt will be saved locally for future use.")

        self.save_api_key_button = QPushButton("Save Key")
        self.save_api_key_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.save_api_key_button.setStyleSheet("""
            QPushButton { padding: 5px 15px; background-color: #e0e0e0; border: 1px solid #bdbdbd; border-radius: 3px; font-size: 11px; }
            QPushButton:hover { background-color: #d6d6d6; }
            QPushButton:pressed { background-color: #bdbdbd; }
        """)
        self.save_api_key_button.setToolTip("Save the entered API Key locally and attempt to configure.")

        self.get_api_key_button = QPushButton("Get API Key")
        self.get_api_key_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.get_api_key_button.setStyleSheet("""
            QPushButton {
                padding: 5px 10px; background-color: transparent; border: none;
                color: #4285F4; text-decoration: underline;
                font-size: 11px; margin-left: 5px;
            }
            QPushButton:hover { color: #1a73e8; }
            QPushButton:pressed { color: #0f61d3; }
        """)
        self.get_api_key_button.setToolTip("Open the Google AI Studio page to generate an API Key (opens web browser).")

        api_key_layout.addWidget(api_label)
        api_key_layout.addWidget(self.api_key_input, 1)
        api_key_layout.addWidget(self.save_api_key_button)
        api_key_layout.addWidget(self.get_api_key_button)
        api_key_layout.addStretch(0)
        main_layout.addWidget(api_key_group_widget)

        # --- NEW: Model Selection Section ---
        model_selection_widget = QWidget()
        model_selection_layout = QHBoxLayout(model_selection_widget)
        model_selection_layout.setContentsMargins(0, 5, 0, 5)

        model_label = QLabel("Gemini Model:")
        model_selection_layout.addWidget(model_label)

        # Create model dropdown (removed Gemini 2.0 Flash as it's outdated)
        self.model_dropdown = QComboBox()
        self.model_dropdown.addItem("Gemini 2.5 Flash", "gemini-2.5-flash")
        self.model_dropdown.addItem("Custom Configuration", "custom")
        self.model_dropdown.setMinimumWidth(300)
        self.model_dropdown.setStyleSheet("padding: 5px; border: 1px solid #ccc; border-radius: 3px;")
        self.model_dropdown.setToolTip("Select which Gemini model to use.\n\nGemini 2.5 Flash Free Tier Limits:\n• 15 requests per minute\n• 1 million tokens per minute\n• 1,500 requests per day\n• Free context caching up to 1M tokens")
        model_selection_layout.addWidget(self.model_dropdown, 1)

        # Add Advanced Settings button
        self.advanced_settings_button = QPushButton("Advanced Settings")
        self.advanced_settings_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.advanced_settings_button.setStyleSheet("""
            QPushButton { padding: 5px 15px; background-color: #e0e0e0; border: 1px solid #bdbdbd; border-radius: 3px; font-size: 11px; }
            QPushButton:hover { background-color: #d6d6d6; }
            QPushButton:pressed { background-color: #bdbdbd; }
        """)
        model_selection_layout.addWidget(self.advanced_settings_button)

        # Add a "Thinking:" label and slider for Gemini 2.5 models
        thinking_label = QLabel("Thinking Budget:")
        self.thinking_slider = QSlider(Qt.Orientation.Horizontal)
        self.thinking_slider.setMinimum(0)
        self.thinking_slider.setMaximum(24576)  # Max thinking budget for Gemini 2.5 Flash
        self.thinking_slider.setValue(8000)  # Default thinking budget
        self.thinking_slider.setTickInterval(1024)
        self.thinking_slider.setTickPosition(QSlider.TickPosition.TicksBelow)
        self.thinking_slider.setStyleSheet("""
            QSlider::groove:horizontal {
                height: 8px;
                background: #E0E0E0;
                border-radius: 4px;
            }
            QSlider::handle:horizontal {
                background: #8E24AA;
                border: 1px solid #5E24AA;
                width: 18px;
                margin: -6px 0;
                border-radius: 10px;
            }
            QSlider::sub-page:horizontal {
                background: #AB47BC;
                border-radius: 4px;
            }
        """)
        
        self.thinking_value_label = QLabel("8000")
        self.thinking_value_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.thinking_value_label.setFixedWidth(60)
        
        thinking_layout = QHBoxLayout()
        thinking_layout.addWidget(thinking_label)
        thinking_layout.addWidget(self.thinking_slider, 1)
        thinking_layout.addWidget(self.thinking_value_label)
        
        # Initially hide thinking options - will show based on model selection
        self.thinking_widget = QWidget()
        self.thinking_widget.setLayout(thinking_layout)
        self.thinking_widget.setVisible(True)  # Initially visible for the default 2.5 Flash model
        
        model_selection_layout.addStretch(0)
        main_layout.addWidget(model_selection_widget)
        main_layout.addWidget(self.thinking_widget)

        # --- Horizontal Layout for Text Edits ---
        text_edits_layout = QHBoxLayout()
        text_edits_layout.setSpacing(15)

        # --- Left Side (Input) ---
        input_layout = QVBoxLayout()
        input_layout.setSpacing(5) # Reduced spacing for the header+textarea

        # --- Input Header Layout (Label + Paste Button) ---
        input_header_layout = QHBoxLayout()
        input_header_layout.setSpacing(8)
        input_header_layout.setContentsMargins(0, 0, 0, 0)

        input_label = QLabel("Raw Transcript:")
        input_label.setStyleSheet("font-size: 12px; font-weight: bold; margin-right: 5px;")
        input_header_layout.addWidget(input_label, 0) # Add label

        # --- Create the "Paste from Cleaner" button ---
        self.paste_button = QPushButton("Paste Cleaned Captions")
        self.paste_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.paste_button.setToolTip("Paste the 'Cleaned Text' from the 'Process Captions' tab here.\nAppends '#TRANSCRIBE' automatically.")
        self.paste_button.setStyleSheet("""
            QPushButton {
                font-size: 10px;
                padding: 2px 6px;
                background-color: #f0f0f0;
                border: 1px solid #cccccc;
                border-radius: 3px;
                color: #333;
                max-height: 20px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
                border-color: #bbbbbb;
            }
            QPushButton:pressed {
                background-color: #d0d0d0;
            }
        """)
        input_header_layout.addWidget(self.paste_button, 0) # Add button next to label
        input_header_layout.addStretch(1) # Push label and button left

        # Add the header layout to the main input layout
        input_layout.addLayout(input_header_layout)

        # --- Input Text Edit ---
        self.transcript_input = QTextEdit()
        self.transcript_input.setPlaceholderText("Paste your cleaned captions here or use the 'Paste Cleaned Captions' button...") # Updated placeholder
        self.transcript_input.setStyleSheet("""
            QTextEdit {
                background-color: white; border: 1px solid #CCCCCC; border-radius: 5px;
                padding: 8px; font-size: 13px;
                font-family: 'SF Pro Text', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', sans-serif;
            }""")
        self.transcript_input.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        input_layout.addWidget(self.transcript_input) # Add text edit below the header

        # --- Right Side (Output) ---
        output_layout = QVBoxLayout()
        
        # Create header layout for output (similar to input header)
        output_header_layout = QHBoxLayout()
        output_header_layout.setContentsMargins(0, 0, 0, 0)
        
        output_label = QLabel("Formatted Transcript:")
        output_label.setStyleSheet("font-size: 12px; font-weight: bold;")
        output_header_layout.addWidget(output_label, 0) # Add label

        # --- Create the "Copy Formatted Transcript" button (similar to Paste button) ---
        self.copy_button = QPushButton("Copy Formatted Transcript")
        self.copy_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.copy_button.setEnabled(False)
        self.copy_button.setToolTip("Copy the formatted transcript to clipboard")
        self.copy_button.setStyleSheet("""
            QPushButton {
                font-size: 10px;
                padding: 2px 6px;
                background-color: #f0f0f0;
                border: 1px solid #cccccc;
                border-radius: 3px;
                color: #333;
                max-height: 20px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
                border-color: #bbbbbb;
            }
            QPushButton:pressed {
                background-color: #d0d0d0;
            }
            QPushButton:disabled { 
                background-color: #EEEEEE; 
                color: #AAAAAA; 
                border-color: #E0E0E0; 
                cursor: default; 
            }
        """)
        output_header_layout.addWidget(self.copy_button, 0) # Add button next to label
        output_header_layout.addStretch(1) # Push label and button left

        # Add the header layout to the main output layout
        output_layout.addLayout(output_header_layout)
        
        self.output_text = QTextEdit()
        self.output_text.setReadOnly(True)
        self.output_text.setPlaceholderText("Processed transcript will appear here...")
        self.output_text.setStyleSheet("""
            QTextEdit {
                background-color: #F5F5F5; border: 1px solid #CCCCCC; border-radius: 5px;
                padding: 8px; font-size: 13px;
                font-family: 'SF Pro Text', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', sans-serif; color: #333;
            }""")
        self.output_text.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        output_layout.addWidget(self.output_text)

        # Add input and output layouts to the horizontal layout
        text_edits_layout.addLayout(input_layout, 1)
        text_edits_layout.addLayout(output_layout, 1)
        main_layout.addLayout(text_edits_layout, 1) # Vertical stretch

        # --- Progress Section ---
        progress_layout = QHBoxLayout()
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 0) # Indeterminate
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setFixedHeight(10)
        self.progress_bar.setStyleSheet("""
            QProgressBar { border: 1px solid #CCCCCC; border-radius: 5px; background-color: #F5F5F5; }
            QProgressBar::chunk { background-color: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #AB47BC, stop:1 #8E24AA); border-radius: 5px; width: 20px; }
        """)
        self.progress_bar.hide()

        self.status_label = QLabel("")
        self.status_label.setStyleSheet("font-size: 12px; color: #757575;")
        self.status_label.setMinimumWidth(200)

        # --- Process Button (at the bottom) ---
        process_button_layout = QHBoxLayout()
        self.process_button = QPushButton("Process Transcript")
        self.process_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.process_button.setStyleSheet("""
            QPushButton {
                background-color: #8E24AA; color: white; border: none; padding: 12px 15x;
                border-radius: 5px; font-size: 14px; font-weight: bold; min-width: 175px; margin-top: 10px;
            }
            QPushButton:hover { background-color: #7B1FA2; }
            QPushButton:pressed { background-color: #6A1B9A; }
            QPushButton:disabled { background-color: #E1BEE7; color: #9E9E9E; cursor: default; }
        """)
        self.process_button.setEnabled(False)
        self.process_button.setToolTip("Requires a valid saved API Key.")
        
        # --- Cancel Button (hidden by default) ---
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.cancel_button.setStyleSheet("""
            QPushButton {
                background-color: #D32F2F; color: white; border: none; padding: 12px 15x;
                border-radius: 5px; font-size: 14px; font-weight: bold; min-width: 100px; margin-top: 10px;
            }
            QPushButton:hover { background-color: #B71C1C; }
            QPushButton:pressed { background-color: #8D0000; }
        """)
        self.cancel_button.setVisible(False)  # Hidden by default

        process_button_layout.addWidget(self.status_label, 1)
        main_layout.addLayout(process_button_layout, 0) # No vertical stretch
        process_button_layout.addWidget(self.progress_bar, 2)
        process_button_layout.addStretch()
        process_button_layout.addWidget(self.cancel_button)
        process_button_layout.addWidget(self.process_button)

    def _connect_signals(self):
        """Connects UI elements to their respective handler methods."""
        self.process_button.clicked.connect(self.process_transcript)
        self.copy_button.clicked.connect(self.copy_to_clipboard)
        
        # Connect model dropdown and thinking slider
        self.model_dropdown.currentIndexChanged.connect(self._handle_model_change)
        self.thinking_slider.valueChanged.connect(self._update_thinking_value)
        
        # Connect advanced settings button
        self.advanced_settings_button.clicked.connect(self._show_advanced_settings)

        # --- Connect Paste Button (with safety check) ---
        if hasattr(self, 'paste_button'):
            # Check parent validity before connecting
            parent_window = self.parent()
            if parent_window and hasattr(parent_window, 'cleaner_output_text'):
                self.paste_button.clicked.connect(self._paste_from_cleaner)
                print("Paste button connected successfully.")
            else:
                # Disable button if parent is invalid or missing the attribute
                self.paste_button.setEnabled(False)
                self.paste_button.setToolTip("Cannot access cleaner output from parent window.")
                print("Paste button disabled: Parent invalid or missing 'cleaner_output_text'.")

        # Connect API key management buttons
        self.save_api_key_button.clicked.connect(self._save_api_key)
        self.get_api_key_button.clicked.connect(self._open_api_key_link)
        # Trigger configuration attempt when enter is pressed in API key field
        self.api_key_input.returnPressed.connect(self._save_api_key)
        
        # Connect cancel button
        self.cancel_button.clicked.connect(self.cancel_processing)

    def _handle_model_change(self, index):
        """Handle changes to the model selection dropdown."""
        model_id = self.model_dropdown.currentData()
        
        # Show/hide thinking controls based on model
        is_thinking_model = model_id.startswith("gemini-2.5")
        self.thinking_widget.setVisible(is_thinking_model)
        
        if model_id == "custom":
            self._show_advanced_settings()
        else:
            # Reconfigure the model with the new selection
            self._load_and_configure_gemini()
    
    def _update_thinking_value(self, value):
        """Update the thinking value label when slider changes."""
        self.thinking_value_label.setText(str(value))

    def _show_advanced_settings(self):
        """Show dialog for advanced model settings."""
        # Get current config
        config = self._load_model_config()
        
        # Create dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Advanced Model Configuration")
        dialog.setMinimumWidth(500)
        
        layout = QVBoxLayout(dialog)
        
        # Model name
        model_name_layout = QHBoxLayout()
        model_name_label = QLabel("Model ID:")
        model_name_input = QLineEdit(config.get("model_name", "gemini-2.5-pro-exp-03-25"))
        model_name_layout.addWidget(model_name_label)
        model_name_layout.addWidget(model_name_input, 1)
        layout.addLayout(model_name_layout)
        
        # Temperature
        temp_layout = QHBoxLayout()
        temp_label = QLabel("Temperature:")
        temp_slider = QSlider(Qt.Orientation.Horizontal)
        temp_slider.setMinimum(0)
        temp_slider.setMaximum(20)  # 0.0 to 2.0
        temp_slider.setValue(int(config.get("temperature", 0.2) * 10))
        temp_slider.setTickInterval(2)
        temp_slider.setTickPosition(QSlider.TickPosition.TicksBelow)
        temp_value = QLabel(f"{config.get('temperature', 0.2):.1f}")
        
        def update_temp_label(value):
            temp_value.setText(f"{value/10:.1f}")
            
        temp_slider.valueChanged.connect(update_temp_label)
        
        temp_layout.addWidget(temp_label)
        temp_layout.addWidget(temp_slider, 1)
        temp_layout.addWidget(temp_value)
        layout.addLayout(temp_layout)
        
        # Top-p
        top_p_layout = QHBoxLayout()
        top_p_label = QLabel("Top-p:")
        top_p_slider = QSlider(Qt.Orientation.Horizontal)
        top_p_slider.setMinimum(0)
        top_p_slider.setMaximum(100)  # 0.0 to 1.0
        top_p_slider.setValue(int(config.get("top_p", 0.95) * 100))
        top_p_slider.setTickInterval(10)
        top_p_slider.setTickPosition(QSlider.TickPosition.TicksBelow)
        top_p_value = QLabel(f"{config.get('top_p', 0.95):.2f}")
        
        def update_top_p_label(value):
            top_p_value.setText(f"{value/100:.2f}")
            
        top_p_slider.valueChanged.connect(update_top_p_label)
        
        top_p_layout.addWidget(top_p_label)
        top_p_layout.addWidget(top_p_slider, 1)
        top_p_layout.addWidget(top_p_value)
        layout.addLayout(top_p_layout)
        
        # Top-k
        top_k_layout = QHBoxLayout()
        top_k_label = QLabel("Top-k:")
        top_k_input = QSpinBox()
        top_k_input.setMinimum(0)
        top_k_input.setMaximum(100)
        top_k_input.setValue(config.get("top_k", 0))
        top_k_layout.addWidget(top_k_label)
        top_k_layout.addWidget(top_k_input, 1)
        layout.addLayout(top_k_layout)
        
        # Max output tokens
        max_tokens_layout = QHBoxLayout()
        max_tokens_label = QLabel("Max Output Tokens:")
        max_tokens_input = QSpinBox()
        max_tokens_input.setMinimum(1)
        max_tokens_input.setMaximum(64000)
        max_tokens_input.setValue(config.get("max_output_tokens", 64000))
        max_tokens_layout.addWidget(max_tokens_label)
        max_tokens_layout.addWidget(max_tokens_input, 1)
        layout.addLayout(max_tokens_layout)
        
        # Save as default checkbox
        save_default_cb = QCheckBox("Save as default custom configuration")
        save_default_cb.setChecked(True)
        layout.addWidget(save_default_cb)
        
        # Add note about experimental features
        note_label = QLabel("Note: Some newer Gemini models support advanced features like thinking budgets that can be configured after saving.")
        note_label.setWordWrap(True)
        note_label.setStyleSheet("color: #757575; font-size: 11px;")
        layout.addWidget(note_label)
        
        # Buttons
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)
        
        # Show dialog
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Save the configuration
            new_config = {
                "model_name": model_name_input.text(),
                "temperature": round(temp_slider.value() / 10, 1),
                "top_p": round(top_p_slider.value() / 100, 2),
                "top_k": top_k_input.value(),
                "max_output_tokens": max_tokens_input.value(),
            }
            
            # If custom selected in dropdown and save as default is checked
            if save_default_cb.isChecked():
                self._save_model_config(new_config)
                
            # Update current dropdown selection if we're on "Custom"
            if self.model_dropdown.currentData() == "custom":
                # Add a custom item with the actual model name if not already there
                found = False
                for i in range(self.model_dropdown.count()):
                    if self.model_dropdown.itemData(i) == new_config["model_name"]:
                        self.model_dropdown.setCurrentIndex(i)
                        found = True
                        break
                
                if not found:
                    # Remove any previous custom config entries
                    for i in range(self.model_dropdown.count()):
                        if self.model_dropdown.itemData(i) not in ["gemini-2.5-flash", 
                                                               "gemini-2.5-pro-exp-03-25", 
                                                               "custom"]:
                            self.model_dropdown.removeItem(i)
                            break
                    
                    # Add the new custom config
                    display_name = f"Custom: {new_config['model_name']}"
                    self.model_dropdown.addItem(display_name, new_config["model_name"])
                    self.model_dropdown.setCurrentText(display_name)
            
            # Show feedback
            self.status_label.setText(f"Model config updated: {new_config['model_name']}")
            self.status_label.setStyleSheet("font-size: 12px; color: #388E3C;")
            QTimer.singleShot(3000, lambda: self.status_label.setText(""))

    def _load_model_config(self):
        """Load custom model configuration from JSON file."""
        try:
            if os.path.exists(self.model_config_path):
                with open(self.model_config_path, "r", encoding="utf-8") as f:
                    return json.load(f)
        except Exception as e:
            print(f"Error loading model config: {e}")
            
        # Default config
        return {
            "model_name": "gemini-2.5-pro-exp-03-25",
            "temperature": 0.2,
            "top_p": 0.95,
            "top_k": 0,
            "max_output_tokens": 64000,
        }
        
    def _save_model_config(self, config):
        """Save custom model configuration to JSON file."""
        try:
            # Ensure directory exists
            os.makedirs(os.path.dirname(self.model_config_path), exist_ok=True)
            
            with open(self.model_config_path, "w", encoding="utf-8") as f:
                json.dump(config, f, indent=2)
                
            print(f"Model config saved to {self.model_config_path}")
            return True
        except Exception as e:
            print(f"Error saving model config: {e}")
            return False

    def _paste_from_cleaner(self):
        """Handles pasting text from the main window's cleaner output."""
        print("Paste from Cleaner button clicked.") # Debug
        parent_window = self.parent()

        # Double-check parent validity and attribute existence
        if not parent_window:
            QMessageBox.warning(self, "Error", "Cannot access the parent window.")
            print("Error: Parent window not found.")
            return
        if not hasattr(parent_window, 'cleaner_output_text'):
            QMessageBox.warning(self, "Error", "Cannot find the 'cleaner_output_text' widget in the parent window.")
            print("Error: Parent window does not have 'cleaner_output_text' attribute.")
            return

        try:
            # Access the cleaner output text widget directly via the parent reference
            source_widget = parent_window.cleaner_output_text
            text_to_paste = source_widget.toPlainText()
            print(f"Text retrieved from cleaner: {len(text_to_paste)} characters.") # Debug

            if not text_to_paste.strip():
                self.status_label.setText("Cleaner tab output is empty.")
                self.status_label.setStyleSheet("font-size:12px; color:#FFA000;") # Orange warning
                QTimer.singleShot(3000, lambda: self.status_label.setText("") if "empty" in self.status_label.text() else None)
                print("Source text is empty, not pasting.")
                return

            # Construct the final text with the suffix
            # Use rstrip() to remove trailing whitespace/newlines before adding the suffix
            final_text = text_to_paste.rstrip() + "\n\n#TRANSCRIBE"

            # Clear target and set new text
            self.transcript_input.setPlainText(final_text)
            print("Pasted text and added '#TRANSCRIBE' suffix.") # Debug

            # Provide user feedback
            self.status_label.setText("Pasted text from Cleaner tab.")
            self.status_label.setStyleSheet("font-size: 12px; color: #388E3C;") # Green success
            # Clear status after a few seconds
            QTimer.singleShot(3000, lambda: self.status_label.setText("") if "Pasted text" in self.status_label.text() else None)

        except Exception as e:
            error_msg = f"Could not paste text: {e}"
            QMessageBox.critical(self, "Paste Error", error_msg)
            print(f"Error in _paste_from_cleaner: {e}")
            traceback.print_exc() # Print full traceback for debugging
            self.status_label.setText("Error during paste.")
            self.status_label.setStyleSheet("font-size: 12px; color: #D32F2F;") # Red error

    # --- API Key File Handling ---
    def _load_api_key(self):
        """Loads API key from the designated file path."""
        try:
            if os.path.exists(self.api_key_file_path):
                with open(self.api_key_file_path, "r", encoding='utf-8') as f:
                    key = f.read().strip()
                    # Basic validation: Check if key looks roughly like a Gemini key
                    # WARNING: This is NOT a guarantee of validity, just a basic sanity check.
                    if key and len(key) > 30 and key.startswith("AIzaSy"):
                        return key
                    elif key:
                        print(f"Warning: Key loaded from {self.api_key_file_path} seems unusual (length/prefix).")
                        return key # Still return it, let API validation handle it
            return None # File doesn't exist or is empty/doesn't pass basic check
        except Exception as e:
            print(f"Error loading API key from {self.api_key_file_path}: {e!r}")
            self.status_label.setText(f"Error loading saved key: {e}")
            self.status_label.setStyleSheet("font-size: 12px; color: #D32F2F;")
            return None

    def _save_api_key(self):
        """Saves the API key from the input field to the designated file path."""
        api_key = self.api_key_input.text().strip()
        if not api_key:
            QMessageBox.warning(self, "Empty Key", "Please enter an API key before saving.")
            return

        # Basic validation before saving
        if not (len(api_key) > 30 and api_key.startswith("AIzaSy")):
             reply = QMessageBox.warning(self, "Unusual Key Format",
                                         "The entered text doesn't look like a standard Gemini API Key.\n"
                                         "Standard keys usually start with 'AIzaSy' and are longer.\n\n"
                                         "Save anyway?",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)
             if reply == QMessageBox.StandardButton.No:
                  return

        try:
            # Ensure data directory exists (handled in _get_api_key_path on init, but double-check)
            data_folder = os.path.dirname(self.api_key_file_path)
            os.makedirs(data_folder, exist_ok=True)

            with open(self.api_key_file_path, "w", encoding='utf-8') as f:
                f.write(api_key)

            print(f"API Key saved to {self.api_key_file_path}")
            self.status_label.setText("API Key saved. Attempting configuration...")
            self.status_label.setStyleSheet("font-size: 12px; color: #388E3C;") # Green
            # Clear status after a few seconds
            QTimer.singleShot(3000, lambda: self.status_label.setText("") if self.status_label.text() == "API Key saved. Attempting configuration..." else None)

            # Immediately try to configure with the newly saved key
            self._load_and_configure_gemini()

        except Exception as e:
            print(f"Error saving API key to {self.api_key_file_path}: {e!r}")
            QMessageBox.critical(self, "Save Error", f"Could not save API key:\n{e}")
            self.status_label.setText(f"Error saving key: {e}")
            self.status_label.setStyleSheet("font-size: 12px; color: #D32F2F;") # Red

    def _open_api_key_link(self):
        """Opens the Google AI Studio API key page in the default web browser."""
        url = "https://aistudio.google.com/apikey"
        try:
            # This call uses the default browser automatically
            if not webbrowser.open(url):
                 print(f"Warning: webbrowser.open returned False for {url}.")
                 QMessageBox.information(self, "Get API Key", f"Could not automatically open the browser.\n\nPlease visit:\n{url}")
        except Exception as e:
            print(f"Error trying to open browser link '{url}': {e!r}")
            QMessageBox.warning(self, "Browser Error", f"Could not open link:\n{e}")

    def _load_and_configure_gemini(self):
        """Loads key from file and configures the Gemini model instance."""
        if not genai:
            self.status_label.setText("Error: google.generativeai library not found.")
            self.status_label.setStyleSheet("font-size: 12px; color: #D32F2F; font-weight: bold;")
            self.process_button.setEnabled(False)
            self.model = None
            return False

        api_key = self._load_api_key()
        if not api_key:
            self.status_label.setText("Gemini API Key needed. Enter/Save key above.")
            self.status_label.setStyleSheet("font-size: 12px; color: #FFA000;")
            self.process_button.setEnabled(False)
            self.model = None
            return False

        # Mask the loaded key in the input
        self.api_key_input.setText(api_key)
        self.status_label.setText("Configuring Gemini with saved key...")
        self.status_label.setStyleSheet("font-size: 12px; color: #757575;")

        try:
            # Only configure if API key changed (avoid redundant network calls)
            if not hasattr(self, '_cached_api_key') or self._cached_api_key != api_key:
                genai.configure(api_key=api_key)
                self._cached_api_key = api_key

            # Get selected model name and configuration
            model_id = self.model_dropdown.currentData()
            
            # If "custom" is selected, load from saved config
            if model_id == "custom":
                config = self._load_model_config()
                model_name = config["model_name"]
                generation_config = {
                    "temperature": config["temperature"],
                    "top_p": config["top_p"],
                    "top_k": config["top_k"],
                    "max_output_tokens": config["max_output_tokens"],
                }
            else:
                # Use selected model with default generation settings
                model_name = model_id
                generation_config = {
                    "temperature": 0.2,
                    "top_p": 0.95,
                    "top_k": 0,
                    "max_output_tokens": 64000,
                }

            # Create model instance with caching to avoid recreation
            model_cache_key = f"{model_name}_{hash(str(generation_config))}"
            if not hasattr(self, '_cached_model_key') or self._cached_model_key != model_cache_key:
                self.model = genai.GenerativeModel(
                    model_name=model_name,
                    generation_config=generation_config
                )
                self._cached_model_key = model_cache_key
            # else: reuse existing self.model

            # Expose max_output_tokens for easy access later
            self.max_output_tokens = generation_config["max_output_tokens"]

            print(f"Gemini model '{model_name}' configured successfully.")
            self.status_label.setText(f"Gemini API Ready ({model_name})")
            self.status_label.setStyleSheet("font-size: 12px; color: #388E3C;")
            self.process_button.setEnabled(True)
            self.process_button.setToolTip("Ready to process transcript.")
            return True

        except (ValueError, TypeError) as config_err:
            print(f"Config error: {config_err!r}")
            self.status_label.setText(f"Config Error: {config_err}")
            self.status_label.setStyleSheet("font-size: 12px; color: #D32F2F; font-weight: bold;")
            self.process_button.setEnabled(False)
            self.model = None
            return False

        except Exception as e:
            print(f"Error configuring Gemini: {e!r}")
            e_str = str(e).lower()
            if any(key in e_str for key in ("api_key_invalid", "authentication failed", "permission denied")):
                msg = "API Config Error: Invalid/Rejected Key or Permissions"
            elif "deadlineexceeded" in e_str:
                msg = "API Config Error: Network Timeout"
            elif "notfound" in e_str:
                msg = f"API Config Error: Model '{model_name}' not found"
            else:
                msg = f"API Config Error: {e}"

            self.status_label.setText(msg)
            self.status_label.setStyleSheet("font-size: 12px; color: #D32F2F; font-weight: bold;")
            self.process_button.setEnabled(False)
            self.model = None
            self.process_button.setToolTip("API configuration failed.")
            return False

    def process_transcript(self):
        """
        Handles the 'Process Transcript' click: builds prompt,
        estimates tokens, shows modern disclaimer, then dispatches.
        """
        # 1. Ensure configured
        if not self.model:
            QMessageBox.warning(self, "API Not Ready",
                                "Gemini API is not configured.\n"
                                "Please save a valid key and try again.")
            if not self._load_and_configure_gemini():
                return
        # 2. Prevent double-click
        if self.thread and self.thread.isRunning():
            QMessageBox.warning(self, "Busy", "Already processing. Please wait.")
            return

        # 3. Gather prompt & transcript
        prompt_text = self.current_prompt_content or self._get_default_prompt()
        transcript = self.transcript_input.toPlainText().strip()
        if not transcript:
            self.status_label.setText("Please paste a transcript first.")
            self.status_label.setStyleSheet("font-size:12px; color:#FFA000;")
            QTimer.singleShot(3000, lambda: self.status_label.setText(""))
            return

        # 4. Combine for full prompt & debug
        separators = "\n\n--- START OF TRANSCRIPT TO PROCESS ---\n\n"
        end_sep    = "\n\n--- END OF TRANSCRIPT TO PROCESS ---"
        full_text = prompt_text + separators + transcript + end_sep

        # (Optional debug prints omitted here for brevity…)

        # 5. Estimate tokens
        estimated_input_tokens = (len(full_text) + 3) // 4
        estimated_transcript_tokens = (len(transcript) + 3) // 4
        estimated_output_tokens = int(estimated_transcript_tokens * 1.2) # 20% more than input for safety
        max_output_tokens       = getattr(self, "max_output_tokens", None)

        # Make sure we're using the latest selected model
        self._load_and_configure_gemini()
        
        # Build sleek confirmation dialog
        dlg = QDialog(self)
        dlg.setWindowTitle("Confirm & Proceed")
        dlg.setStyleSheet("""
            QDialog { background: #FFF; }
            QLabel#title    { font-size:18px; font-weight:bold; margin-bottom:8px; }
            QLabel#subtitle { font-size:12px; color:#555; margin-bottom:12px; }
            QLabel#details  { font-size:13px; margin-bottom:6px; }
            QLabel#warn     { font-size:12px; color:#D32F2F; margin-top:4px; }
            QDialogButtonBox { margin-top:15px; }
            QPushButton     { min-width:80px; padding:6px 10px; border-radius:4px; }
            QPushButton#proceed { background:#4A148C; color:#FFF; }
            QPushButton#cancel  { background:#EEE; }
            QPushButton#proceed:hover { background:#6A1B9A; }
            QPushButton#cancel:hover  { background:#E0E0E0; }
        """)
        layout = QVBoxLayout(dlg)

        # Title & subtitle
        raw_name   = self.model.model_name
        clean_name = re.sub(r'^models[\\/]', '', raw_name)
        title = QLabel(f"Using <b>{clean_name}</b>")
        title.setObjectName("title")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title)

        # Set subtitle based on model
        if "2.5-pro-exp" in raw_name:
            subtitle_text = "Free Tier: 250,000 tokens/min • 25 requests/day"
        elif "2.5-flash-preview" in raw_name:
            subtitle_text = "Free Tier: 250,000 tokens/min • 500 requests/day"
        elif "2.5-flash" in raw_name:
            subtitle_text = "Free Tier: 1M tokens/min • 15 requests/min • 1,500 requests/day"
        else:
            subtitle_text = "Rates unknown"
            
        subtitle = QLabel(subtitle_text)
        subtitle.setObjectName("subtitle")
        subtitle.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(subtitle)

        # Details (input/output/token limits)
        details = QLabel(
            f"<b>Input tokens:</b> ~{estimated_input_tokens:,}<br>"
            f"<b>Output tokens:</b> ~{estimated_output_tokens:,} (estimate)<br>"
            f"<b>Model max output:</b> {self.max_output_tokens:,}"
        )
        details.setObjectName("details")
        details.setTextFormat(Qt.TextFormat.RichText)
        layout.addWidget(details)

        # Add thinking budget info for 2.5 models
        if raw_name.startswith("gemini-2.5") and hasattr(self, 'thinking_slider'):
            thinking_budget = self.thinking_slider.value()
            thinking_info = QLabel(
                f"<b>Thinking budget:</b> {thinking_budget:,} tokens"
            )
            thinking_info.setObjectName("details")
            thinking_info.setTextFormat(Qt.TextFormat.RichText)
            layout.addWidget(thinking_info)

        if estimated_output_tokens > self.max_output_tokens:
            warn = QLabel(
                f"⚠️ Estimated output (~{estimated_output_tokens:,}) exceeds limit ({self.max_output_tokens:,})"
            )
            warn.setObjectName("warn")
            warn.setAlignment(Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(warn)

        # Standard button box with Ok/Cancel
        from PyQt6.QtWidgets import QDialogButtonBox
        box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | 
            QDialogButtonBox.StandardButton.Cancel,
            Qt.Orientation.Horizontal
        )
        # Rename and restyle
        ok_btn     = box.button(QDialogButtonBox.StandardButton.Ok)
        cancel_btn = box.button(QDialogButtonBox.StandardButton.Cancel)
        ok_btn.setText("Proceed");     ok_btn.setObjectName("proceed")
        cancel_btn.setText("Cancel");  cancel_btn.setObjectName("cancel")

        # Correct wiring
        box.accepted.connect(dlg.accept)
        box.rejected.connect(dlg.reject)
        layout.addWidget(box)

        # Execute and check against the proper enum
        result = dlg.exec()
        if result == QDialog.DialogCode.Accepted:
            # User clicked "Proceed"—continue to dispatch your worker
            pass  # ← your existing thread‐startup code here
        else:
            # Cancel or closed
            self.status_label.setText("Processing canceled.")
            return

        # 7. Kick off the worker thread
        self.cleanup_thread()
        self._is_processing = True
        self.process_button.setEnabled(False)
        self.progress_bar.show()
        self.status_label.setText("Preparing request...")
        self.status_label.setStyleSheet("font-size:12px; color:#757575;")
        self.output_text.clear()
        self.copy_button.setEnabled(False)
        
        # Initialize streaming variables
        self._streaming_started = False
        self._accumulated_text = ""

        # 8. Create worker with appropriate config
        self.thread = QThread(self)
        
        # Configure thinking budget for Gemini 2.5 models
        if raw_name.startswith("gemini-2.5") and hasattr(self, 'thinking_slider'):
            thinking_budget = self.thinking_slider.value()
            
            # Create worker with thinking config - using the enhanced worker
            self.worker = GeminiWorkerWithThinking(
                self.model, 
                full_text, 
                thinking_budget
            )
        else:
            # Use standard worker for other models
            self.worker = GeminiWorker(self.model, full_text)
            
        # Connect worker signals and start
        self.worker.moveToThread(self.thread)
        self.worker.finished.connect(self.on_processing_finished)
        self.worker.error.connect(self.on_processing_error)
        self.worker.progress.connect(self.update_status)
        # Connect streaming signal for real-time text updates
        self.worker.streaming_chunk.connect(self.on_streaming_chunk)
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.error.connect(self.thread.quit)
        self.thread.start()
        print("Gemini worker thread started.")
        
        # Show cancel button and hide process button during processing
        self.process_button.setVisible(False)
        self.cancel_button.setVisible(True)

    def copy_to_clipboard(self):
        """Copies the content, asks for confirmation, then optionally signals
           to paste into the main input and closes the dialog."""
        try:
            text_to_copy = self.output_text.toPlainText()
            if not text_to_copy:
                # Optionally provide feedback if trying to copy empty text
                # self.status_label.setText("Nothing to copy.")
                # QTimer.singleShot(2000, lambda: self.status_label.setText(""))
                return

            # 1. Copy to system clipboard (always do this)
            clipboard = QApplication.instance().clipboard()
            if not clipboard:
                print("Error: Could not access clipboard.")
                QMessageBox.warning(self, "Clipboard Error", "Could not access the system clipboard.")
                return
            clipboard.setText(text_to_copy)
            print("Gemini output copied to system clipboard.")

            # 2. Show Confirmation Dialog
            msg_box = QMessageBox(self)
            msg_box.setIcon(QMessageBox.Icon.Information)
            msg_box.setWindowTitle("Copy Successful")
            msg_box.setText("Successfully copied the formatted captions.")
            msg_box.setInformativeText("Would you like to proceed directly to the Create Transcript tab to paste?")
            msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            msg_box.setDefaultButton(QMessageBox.StandardButton.Yes)

            result = msg_box.exec()

            # 3. Handle Confirmation Result
            if result == QMessageBox.StandardButton.Yes:
                # User wants to proceed
                print("User chose to proceed. Emitting pasteToInputRequested signal.")
                self.pasteToInputRequested.emit(text_to_copy)
                print("Closing GeminiProcessorDialog.")
                self.accept() # Close the dialog successfully
            else:
                # User chose No or closed the dialog - provide feedback but stay open
                print("User chose not to proceed immediately.")
                original_text = self.copy_button.text()
                # Keep the button disabled only if there is text to ensure it's not accidentally clicked again immediately
                # but enable it after the "Copied!" message clears if there's still text.
                was_enabled = self.copy_button.isEnabled()
                self.copy_button.setText("Copied!")
                self.copy_button.setEnabled(False) # Briefly disable after copy

                # Use a lambda to restore text and potentially re-enable
                def restore_button():
                    self.copy_button.setText(original_text)
                    # Re-enable only if there's still text in the output
                    self.copy_button.setEnabled(bool(self.output_text.toPlainText()))

                QTimer.singleShot(1500, restore_button)

        except Exception as e:
            print(f"Error in Gemini copy_to_clipboard: {e!r}")
            QMessageBox.warning(self, "Clipboard Error", f"Could not copy text or ask for confirmation:\n{e}")

    # --- Slot Methods (executed in Main Thread) ---
    def on_processing_finished(self, result):
        """Handles the successful completion of the Gemini API call."""
        print("Processing finished signal received.")
        # If we were streaming, the text is already in the output area
        if not self._streaming_started:
            self.output_text.setText(result)
        self.status_label.setText("Processing complete!")
        self.status_label.setStyleSheet("font-size: 12px; color: #388E3C;") # Darker Green
        self.copy_button.setEnabled(bool(result or self.output_text.toPlainText())) # Enable copy if there's result text
        self.cleanup_thread() # Clean up thread and reset UI state

    def on_processing_error(self, error_message):
        """Handles errors signaled by the Gemini worker thread."""
        print(f"Processing error signal received: {error_message}")
        # Display simplified error in output area, full error in dialog
        simplified_error = error_message.split('\n')[0] # Often the first line is most indicative
        self.output_text.setText(f"Error Occurred:\n{simplified_error}")
        self.status_label.setText("An error occurred during processing.")
        self.status_label.setStyleSheet("font-size: 12px; color: #D32F2F; font-weight: bold;") # Darker Red
        self.copy_button.setEnabled(False)
        self.show_error_dialog(error_message) # Show detailed error dialog
        self.cleanup_thread() # Clean up thread and reset UI state

    def update_status(self, status):
        """Updates the status label with messages from the worker."""
        self.status_label.setText(status)
        # Keep style consistent or adjust based on status message if needed
        self.status_label.setStyleSheet("font-size: 12px; color: #757575;")
        
    def on_streaming_chunk(self, chunk):
        """Handles streaming chunks from the Gemini worker."""
        if not self._streaming_started:
            self._streaming_started = True
            self.status_label.setText("Receiving response...")
            # Clear output area for fresh streaming content
            self.output_text.clear()
            self._accumulated_text = ""
            
        # Accumulate the text and update display
        self._accumulated_text += chunk
        self.output_text.setPlainText(self._accumulated_text)
        
        # Auto-scroll to bottom to show latest content
        cursor = self.output_text.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        self.output_text.setTextCursor(cursor)
        
    def cancel_processing(self):
        """Cancels the current processing operation."""
        if self._is_processing and self.worker:
            print("Canceling processing...")
            self.status_label.setText("Canceling...")
            self.status_label.setStyleSheet("font-size: 12px; color: #D32F2F;")
            
            # Stop the worker
            self.worker.stop()
            
            # Clean up
            self.cleanup_thread()
            
            # Update status
            self.status_label.setText("Processing canceled.")
            self.status_label.setStyleSheet("font-size: 12px; color: #757575;")

    # --- Override Close Event ---
    def closeEvent(self, event: QCloseEvent):
        """Allows force-closing by cancelling ongoing processing."""
        if self._is_processing:
            # Ask user if they want to cancel processing and close
            reply = QMessageBox.question(self, "Cancel Processing?",
                                       "Transcript processing is currently in progress.\nDo you want to cancel and close?",
                                       QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                       QMessageBox.StandardButton.No)
            
            if reply == QMessageBox.StandardButton.Yes:
                # User wants to cancel - stop processing and close
                if self.worker and hasattr(self.worker, 'stop'):
                    self.worker.stop()
                self.cleanup_thread()
                event.accept()  # Allow the dialog to close
            else:
                # User doesn't want to cancel
                event.ignore()  # Prevent the dialog from closing
        else:
            self.cleanup_thread() # Ensure any lingering thread resources are cleaned up
            event.accept()  # Allow the dialog to close

    # --- Helper Methods ---
    def cleanup_thread(self):
        """Safely clean up thread and worker resources, reset UI state."""
        print("Cleanup thread called.")
        was_processing = self._is_processing
        self._is_processing = False # Reset state flag *first*
        
        # Reset streaming variables
        self._streaming_started = False
        self._accumulated_text = ""
        
        # Show process button and hide cancel button
        self.process_button.setVisible(True)
        self.cancel_button.setVisible(False)

        # Re-enable process button only if the API model is currently configured
        self.process_button.setEnabled(self.model is not None)
        if self.model is None:
             self.process_button.setToolTip("API not configured. Save a valid key.")
        else:
             self.process_button.setToolTip("Ready to process transcript.")

        self.progress_bar.hide()

        # Stop and clean up the thread/worker if they exist
        if self.thread and self.thread.isRunning():
            print("Attempting to stop running worker thread...")
            if self.worker and hasattr(self.worker, 'stop'):
                self.worker.stop() # Signal worker to stop processing if possible
            self.thread.quit() # Ask thread's event loop to exit
            if not self.thread.wait(1500): # Wait a bit for graceful exit
                print("Warning: Worker thread did not quit gracefully after 1.5s. Termination might be needed if it hangs.")
                # self.thread.terminate() # Use terminate() cautiously as it can lead to resource leaks

        # Schedule deletion of objects after event loop processing
        if self.worker:
            self.worker.deleteLater()
            print("Worker scheduled for deletion.")
        if self.thread:
            self.thread.deleteLater()
            print("Thread scheduled for deletion.")

        self.thread = None
        self.worker = None
        # Optionally clear status if processing just ended
        # if was_processing and "complete" not in self.status_label.text().lower() and "error" not in self.status_label.text().lower():
        #    self.status_label.setText("")

    def show_error_dialog(self, error_message):
        """Displays a detailed error message box to the user."""
        error_dialog = QMessageBox(self)
        error_dialog.setIcon(QMessageBox.Icon.Critical)
        error_dialog.setWindowTitle("Processing Error")
        error_dialog.setText("<b>An error occurred while processing the transcript with the Gemini API.</b>")
        error_dialog.setInformativeText("Please review the details below.")

        detailed_text = f"<b>Error details:</b>\n{error_message}\n\n"
        detailed_text += "<b>Troubleshooting suggestions:</b>\n"
        detailed_text += "- Verify your internet connection.\n"
        detailed_text += "- Ensure your saved Gemini API key is valid, active, and has permissions for the selected model.\n"
        detailed_text += "- Check your API usage quotas on the Google Cloud Console or AI Studio.\n"
        detailed_text += "- Try processing a shorter transcript segment to isolate potential content issues.\n"
        detailed_text += "- If the error mentions permissions or authentication, double-check the saved API key.\n"
        detailed_text += "- Check the application's console output (terminal window) for more technical clues.\n\n"
        detailed_text += "If the problem persists, consult the Google Generative AI documentation."

        error_dialog.setDetailedText(detailed_text) # Use detailed text for scrollable info
        error_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
        error_dialog.setDefaultButton(QMessageBox.StandardButton.Ok)
        error_dialog.exec()

    def _get_default_prompt(self):
        """Returns a fallback default prompt string if needed."""
        # You should ideally load this from self.current_prompt_content passed during init
        # This is just a hardcoded fallback
        print("Warning: Using hardcoded default prompt inside GeminiProcessorDialog.")
        return """No matter what the user types, simply respond: The default prompt is unavailable, please create a prompt."""


class DragDropListWidget(QListWidget):
    """Custom QListWidget with drag and drop reordering capability"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)
        self.setDefaultDropAction(Qt.DropAction.MoveAction)
        # Enable drag and drop
        self.setAcceptDrops(True)
        self.setDragEnabled(True)
        
    def dropEvent(self, event):
        """Handle drop events and emit custom signal for reordering"""
        try:
            if event.source() == self:
                # Perform the default drop first
                super().dropEvent(event)
                
                # Notify parent about reordering with error handling
                parent = self.parent()
                if parent and hasattr(parent, 'on_list_reordered'):
                    try:
                        parent.on_list_reordered()
                    except Exception as e:
                        print(f"Error in reorder callback: {e}")
            else:
                # Accept the event even if it's not from this widget
                super().dropEvent(event)
        except Exception as e:
            print(f"Error in dropEvent: {e}")
            # Try to accept the event to prevent crashes
            event.accept()


class ThemePresetManager:
    """Class to manage theme presets with JSON storage in the application's Data folder"""
    
    def __init__(self, parent=None):
        self.parent = parent
        
        # Get the application's root directory
        import os
        import sys
        
        # Find the application root directory
        if getattr(sys, 'frozen', False):
            # If running as a bundled executable (PyInstaller)
            app_root = os.path.dirname(sys.executable)
        else:
            # If running from script
            app_root = os.path.dirname(os.path.abspath(sys.argv[0]))
        
        # Create Data directory if it doesn't exist
        data_dir = os.path.join(app_root, "Data")
        if not os.path.exists(data_dir):
            try:
                os.makedirs(data_dir)
                print(f"Created Data directory at: {data_dir}")
            except Exception as e:
                print(f"Error creating Data directory: {str(e)}")
        
        # Set the presets file path
        self.presets_file = os.path.join(data_dir, "theme_presets.json")
        print(f"Theme presets will be stored at: {self.presets_file}")
        
        # Load existing presets
        self.presets = self._load_presets()
        
    def _load_presets(self):
        """Load presets from JSON file"""
        if os.path.exists(self.presets_file):
            try:
                with open(self.presets_file, 'r') as f:
                    presets = json.load(f)
                # Ensure we have the new format with order
                if "presets" in presets and "order" not in presets:
                    presets["order"] = list(presets["presets"].keys())
                return presets
            except Exception as e:
                print(f"Error loading theme presets: {str(e)}")
        return {"presets": {}, "order": []}
        
    def _save_presets(self):
        """Save presets to JSON file"""
        try:
            with open(self.presets_file, 'w') as f:
                json.dump(self.presets, f, indent=2)
            return True
        except Exception as e:
            print(f"Error saving theme presets: {str(e)}")
            return False
            
    def get_preset_names(self):
        """Get list of all preset names in the correct order"""
        order = self.presets.get("order", [])
        presets = self.presets.get("presets", {})
        
        # Return names in order, plus any new ones not in order list
        ordered_names = [name for name in order if name in presets]
        unordered_names = [name for name in presets.keys() if name not in order]
        
        return ordered_names + unordered_names
        
    def get_preset(self, name):
        """Get a specific preset by name"""
        return self.presets.get("presets", {}).get(name, None)
        
    def save_preset(self, name, themes):
        """Save a new preset or update existing one"""
        if "presets" not in self.presets:
            self.presets["presets"] = {}
        if "order" not in self.presets:
            self.presets["order"] = []
            
        # Add to presets
        self.presets["presets"][name] = themes
        
        # Add to order if it's a new preset
        if name not in self.presets["order"]:
            self.presets["order"].append(name)
            
        return self._save_presets()
        
    def delete_preset(self, name):
        """Delete a preset by name"""
        if name in self.presets.get("presets", {}):
            del self.presets["presets"][name]
            # Also remove from order
            if name in self.presets.get("order", []):
                self.presets["order"].remove(name)
            return self._save_presets()
        return False
        
    def reorder_presets(self, new_order):
        """Update the order of presets"""
        self.presets["order"] = new_order
        return self._save_presets()
        
    # Fix #1: Updated show_manage_presets_dialog method with improved list styling
    def show_manage_presets_dialog(self):
        """Show dialog to manage (rename/delete) presets"""
        dialog = QDialog(self.parent)
        dialog.setWindowTitle("Manage Theme Presets")
        dialog.resize(500, 400)
        layout = QVBoxLayout(dialog)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
    
        # Track changes
        changes_made = {"renamed": False, "deleted": False}
    
        # Explanatory text
        info_label = QLabel("Manage your saved theme presets. Select a preset to rename or delete it.")
        info_label.setWordWrap(True)
        layout.addWidget(info_label)
        
        # Drag and drop instruction
        drag_info_label = QLabel("💡 Tip: Drag and drop presets to reorder them")
        drag_info_label.setStyleSheet("color: #666; font-style: italic; font-size: 11px; margin: 0px;")
        layout.addWidget(drag_info_label)
    
        # List of presets with drag and drop support
        preset_list = DragDropListWidget(dialog)
        preset_list.setStyleSheet("""
            QListWidget {
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 5px;
                background: white;
                outline: none; /* Remove focus outline */
            }
            QListWidget::item {
                padding: 8px;
                border-bottom: 1px solid #eee;
                border-left: 3px solid transparent;
            }
            QListWidget::item:selected {
                background-color: #e3f2fd;
                color: #333;
                outline: none; /* Remove selection outline */
                border-left: 3px solid #2196F3;
            }
            QListWidget::item:hover {
                background-color: #f5f5f5;
            }
        """)
    
        # Add presets to the list
        preset_names = self.get_preset_names()
        for name in preset_names:
            preset_list.addItem(name)
        
        if not preset_names:
            empty_item = QListWidgetItem("No saved presets")
            empty_item.setFlags(Qt.ItemFlag.NoItemFlags)
            preset_list.addItem(empty_item)
    
        layout.addWidget(preset_list, 1)  # Give it stretch factor
    
        # Buttons layout
        buttons_layout = QHBoxLayout()
    
        rename_btn = QPushButton("Rename")
        rename_btn.setStyleSheet("""
            QPushButton {
                background-color: #e3f2fd;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: 500;
            }
            QPushButton:hover {
                background-color: #bbdefb;
            }
            QPushButton:disabled {
                background-color: #e0e0e0;
                color: #9e9e9e;
            }
        """)
    
        delete_btn = QPushButton("Delete")
        delete_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffebee;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: 500;
            }
            QPushButton:hover {
                background-color: #ffcdd2;
            }
            QPushButton:disabled {
                background-color: #e0e0e0;
                color: #9e9e9e;
            }
        """)
    
        close_btn = QPushButton("Close")
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: 500;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
        """)
    
        buttons_layout.addWidget(rename_btn)
        buttons_layout.addWidget(delete_btn)
        buttons_layout.addStretch(1)
        buttons_layout.addWidget(close_btn)
    
        layout.addLayout(buttons_layout)
    
        def update_button_states():
            selected_items = preset_list.selectedItems()
            has_selection = len(selected_items) > 0 and bool(selected_items[0].flags() & Qt.ItemFlag.ItemIsSelectable)
            rename_btn.setEnabled(has_selection)
            delete_btn.setEnabled(has_selection)
    
        preset_list.itemSelectionChanged.connect(update_button_states)
        update_button_states()  # Initial state
        
        # Add reordering functionality to the dialog
        def on_list_reordered():
            """Handle list reordering - save new order"""
            try:
                new_order = []
                for i in range(preset_list.count()):
                    item = preset_list.item(i)
                    if item and item.flags() & Qt.ItemFlag.ItemIsSelectable:  # Skip "No saved presets" items
                        new_order.append(item.text())
                
                if new_order:  # Only save if we have valid items
                    success = self.reorder_presets(new_order)
                    if success:
                        changes_made["reordered"] = True
                        print(f"Presets reordered successfully: {new_order}")
                    else:
                        print("Failed to save preset order")
            except Exception as e:
                print(f"Error handling list reorder: {e}")
        
        # Connect the reordering handler to the dialog
        dialog.on_list_reordered = on_list_reordered
    
        # Button handlers
        def handle_rename():
            selected_items = preset_list.selectedItems()
            if not selected_items:
                return
            
            current_name = selected_items[0].text()
            new_name, ok = QInputDialog.getText(
                dialog, 
                "Rename Preset",
                f"Enter new name for preset '{current_name}':",
                QLineEdit.EchoMode.Normal,
                current_name
            )
        
            if ok and new_name.strip() and new_name != current_name:
                # Check if name already exists
                if new_name in self.get_preset_names():
                    reply = QMessageBox.question(
                        dialog,
                        "Confirm Overwrite",
                        f"A preset named '{new_name}' already exists. Overwrite it?",
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                    )
                    if reply != QMessageBox.StandardButton.Yes:
                        return
            
                # Get the preset data
                preset_data = self.get_preset(current_name)
            
                # Save with new name
                if self.save_preset(new_name, preset_data):
                    # Delete old preset if new name is different
                    if new_name != current_name:
                        self.delete_preset(current_name)
                
                    # Update the list
                    preset_list.clear()
                    for name in self.get_preset_names():
                        preset_list.addItem(name)
                
                    # Mark that changes were made
                    changes_made["renamed"] = True
                
                    # Show success message
                    QMessageBox.information(dialog, "Success", f"Preset renamed to '{new_name}'.")
                else:
                    QMessageBox.warning(dialog, "Error", "Failed to rename preset.")
    
        def handle_delete():
            selected_items = preset_list.selectedItems()
            if not selected_items:
                return
            
            current_name = selected_items[0].text()
        
            reply = QMessageBox.question(
                dialog,
                "Confirm Delete",
                f"Are you sure you want to delete preset '{current_name}'?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
        
            if reply == QMessageBox.StandardButton.Yes:
                if self.delete_preset(current_name):
                    # Update the list
                    preset_list.clear()
                    preset_names = self.get_preset_names()
                
                    if preset_names:
                        for name in preset_names:
                            preset_list.addItem(name)
                    else:
                        empty_item = QListWidgetItem("No saved presets")
                        empty_item.setFlags(Qt.ItemFlag.NoItemFlags)
                        preset_list.addItem(empty_item)
                
                    # Mark that changes were made
                    changes_made["deleted"] = True
                
                    # Update button states
                    update_button_states()
                
                    # Show success message
                    QMessageBox.information(dialog, "Success", f"Preset '{current_name}' deleted.")
                else:
                    QMessageBox.warning(dialog, "Error", "Failed to delete preset.")
    
        rename_btn.clicked.connect(handle_rename)
        delete_btn.clicked.connect(handle_delete)
        close_btn.clicked.connect(dialog.accept)
    
        dialog.exec()
    
        # Return whether changes were made
        return changes_made


    # Fix #3: Updated functions in convert_text method for setting preset name and handling the no-preset case

    # In the convert_text method, modify/add these functions:




class TTSWorker(QObject):
    finished = pyqtSignal(str)  # Emits the temporary file path on success
    error = pyqtSignal(str)     # Emits an error message on failure

    def __init__(self, text: str):
        super().__init__()
        self.text = text

    def run(self):
        try:
            from gtts import gTTS
            import tempfile
            # Generate speech (this is a blocking network call)
            tts = gTTS(text=self.text, lang='en')
            tmp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".mp3")
            tmp_path = tmp_file.name
            tmp_file.close()  # Close file so gTTS can write to it
            tts.save(tmp_path)
            self.finished.emit(tmp_path)
        except Exception as e:
            self.error.emit(str(e))

import os
import shutil
import platform
import tempfile
import gc
import time
import subprocess
import fitz

from PyQt6.QtWidgets import (QLabel, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                             QPushButton, QMessageBox, QFileDialog, QScrollArea, QSpinBox, QApplication)
from PyQt6.QtCore import Qt, QRect, QPoint, QPointF
from PyQt6.QtGui import QPixmap, QImage, QPainter, QPen, QColor, QBrush, QPainterPath


class PDFViewer(QLabel):
    """Custom label for displaying PDFs with cropping functionality"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.is_cropping = False
        self.is_dragging = False  # Track if we're currently in a drag operation
        self.start_point = None
        self.end_point = None
        self.crop_rect = QRect()
        self.setMouseTracking(True)
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)  # Center the PDF

    def enable_crop_mode(self, enabled):
        """Enable or disable crop mode"""
        self.is_cropping = enabled
        self.is_dragging = False  # Reset dragging state
        self.setCursor(Qt.CursorShape.CrossCursor if enabled else Qt.CursorShape.ArrowCursor)
        if not enabled:
            self.crop_rect = QRect()
            self.start_point = None
            self.end_point = None
        self.update()

    def get_pdf_area(self):
        """Get the actual area where the PDF is displayed within the label"""
        if not self.pixmap():
            return QRect()
            
        # Get the label size
        label_size = self.size()
        pixmap_size = self.pixmap().size()
        
        # Calculate the top-left position of the PDF (considering alignment)
        x = max(0, (label_size.width() - pixmap_size.width()) // 2)
        y = max(0, (label_size.height() - pixmap_size.height()) // 2)
        
        # Return the area
        return QRect(x, y, pixmap_size.width(), pixmap_size.height())

    def screen_to_pdf_coords(self, pos):
        """Convert screen coordinates to PDF coordinates"""
        pdf_area = self.get_pdf_area()
        
        # Adjust coordinates relative to PDF area
        pdf_x = pos.x() - pdf_area.left()
        pdf_y = pos.y() - pdf_area.top()
        
        # Ensure coordinates are within the PDF
        pdf_x = max(0, min(pdf_x, pdf_area.width()))
        pdf_y = max(0, min(pdf_y, pdf_area.height()))
        
        return QPoint(pdf_x, pdf_y)

    def mousePressEvent(self, event):
        if not self.is_cropping or not self.pixmap():
            return super().mousePressEvent(event)
            
        if event.button() == Qt.MouseButton.LeftButton:
            # Convert to PDF coordinates
            self.start_point = self.screen_to_pdf_coords(event.pos())
            self.end_point = self.start_point
            self.crop_rect = QRect()
            self.is_dragging = True  # Start dragging
            print(f"Crop started at PDF coordinates: {self.start_point.x()}, {self.start_point.y()}")
            self.update()

    def mouseMoveEvent(self, event):
        if not self.is_cropping or not self.pixmap():
            return super().mouseMoveEvent(event)
            
        # Only update if we're actively dragging (mouse button is down)
        if not self.is_dragging:
            return super().mouseMoveEvent(event)
        
        # Convert to PDF coordinates
        self.end_point = self.screen_to_pdf_coords(event.pos())
        
        # Create rect and ensure it's within PDF bounds
        self.crop_rect = QRect(self.start_point, self.end_point).normalized()
        pdf_area = QRect(0, 0, self.pixmap().width(), self.pixmap().height())
        self.crop_rect = self.crop_rect.intersected(pdf_area)
        
        print(f"Crop area (PDF coords): {self.crop_rect}")
        self.update()

        # --- Auto-scroll functionality ---
        scroll_area = self.get_scroll_area()
        if scroll_area:
            margin = 20  # pixels from edge to start scrolling
            # Map the current mouse position relative to the scroll area's viewport
            viewport_pos = self.mapTo(scroll_area.viewport(), event.pos())
            v_scrollbar = scroll_area.verticalScrollBar()
            h_scrollbar = scroll_area.horizontalScrollBar()

            # Vertical auto-scroll
            if viewport_pos.y() < margin:
                new_val = v_scrollbar.value() - 20
                v_scrollbar.setValue(new_val)
            elif viewport_pos.y() > scroll_area.viewport().height() - margin:
                new_val = v_scrollbar.value() + 20
                v_scrollbar.setValue(new_val)

            # Horizontal auto-scroll
            if viewport_pos.x() < margin:
                new_val = h_scrollbar.value() - 20
                h_scrollbar.setValue(new_val)
            elif viewport_pos.x() > scroll_area.viewport().width() - margin:
                new_val = h_scrollbar.value() + 20
                h_scrollbar.setValue(new_val)

    def mouseReleaseEvent(self, event):
        if not self.is_cropping or not self.pixmap():
            return super().mouseReleaseEvent(event)
            
        if event.button() == Qt.MouseButton.LeftButton and self.is_dragging:
            # End the dragging operation
            self.is_dragging = False
            
            # Only process if we have a valid start point
            if self.start_point:
                # Convert to PDF coordinates
                self.end_point = self.screen_to_pdf_coords(event.pos())
                
                # Create final crop rectangle
                self.crop_rect = QRect(self.start_point, self.end_point).normalized()
                pdf_area = QRect(0, 0, self.pixmap().width(), self.pixmap().height())
                self.crop_rect = self.crop_rect.intersected(pdf_area)
                
                print(f"Crop finished at PDF coordinates: {self.end_point.x()}, {self.end_point.y()}")
                print(f"Final crop rectangle: {self.crop_rect}")
                
                # Signal that crop is complete if rectangle is valid
                if self.crop_rect.width() > 10 and self.crop_rect.height() > 10:
                    parent = self.window()
                    if parent and hasattr(parent, 'crop_selection_made'):
                        parent.crop_selection_made()
                else:
                    # Only show a message for errors
                    parent = self.window()
                    if parent:
                        QMessageBox.warning(parent, "Small Selection", 
                                          "Selection too small. Please make a larger selection.")
                
                self.update()

    def paintEvent(self, event):
        super().paintEvent(event)
        
        if not self.is_cropping or not self.pixmap() or self.crop_rect.isEmpty():
            return
            
        # Get the PDF area within the label
        pdf_area = self.get_pdf_area()
        
        # Create a painter
        painter = QPainter(self)
        
        # Calculate the crop rect position in screen coordinates
        screen_rect = QRect(
            self.crop_rect.left() + pdf_area.left(),
            self.crop_rect.top() + pdf_area.top(),
            self.crop_rect.width(),
            self.crop_rect.height()
        )
        
        # Draw overlay outside the crop area
        overlay_color = QColor(0, 0, 0, 120)
        
        # Top
        if screen_rect.top() > pdf_area.top():
            painter.fillRect(
                QRect(pdf_area.left(), pdf_area.top(), 
                      pdf_area.width(), screen_rect.top() - pdf_area.top()),
                overlay_color
            )
        
        # Bottom
        if screen_rect.bottom() < pdf_area.bottom():
            painter.fillRect(
                QRect(pdf_area.left(), screen_rect.bottom() + 1,
                      pdf_area.width(), pdf_area.bottom() - screen_rect.bottom()),
                overlay_color
            )
        
        # Left
        if screen_rect.left() > pdf_area.left():
            painter.fillRect(
                QRect(pdf_area.left(), screen_rect.top(),
                      screen_rect.left() - pdf_area.left(), screen_rect.height()),
                overlay_color
            )
        
        # Right
        if screen_rect.right() < pdf_area.right():
            painter.fillRect(
                QRect(screen_rect.right() + 1, screen_rect.top(),
                      pdf_area.right() - screen_rect.right(), screen_rect.height()),
                overlay_color
            )
        
        # Draw the selection border
        painter.setPen(QPen(Qt.GlobalColor.red, 2, Qt.PenStyle.SolidLine))
        painter.drawRect(screen_rect)
        
        # Draw corner markers
        marker_size = 10
        marker_pen = QPen(Qt.GlobalColor.yellow, 1)
        painter.setPen(marker_pen)
        
        # Draw corner markers at all four corners
        corners = [
            (screen_rect.topLeft(), (1, 1)),
            (screen_rect.topRight(), (-1, 1)),
            (screen_rect.bottomLeft(), (1, -1)),
            (screen_rect.bottomRight(), (-1, -1))
        ]
        
        for corner, direction in corners:
            painter.drawLine(
                corner.x(), corner.y(),
                corner.x() + marker_size * direction[0], corner.y()
            )
            painter.drawLine(
                corner.x(), corner.y(),
                corner.x(), corner.y() + marker_size * direction[1]
            )
        
        # Show dimensions in black for clear contrast against white
        painter.setPen(QPen(Qt.GlobalColor.black))
        text = f"{self.crop_rect.width()} × {self.crop_rect.height()}"
        painter.drawText(screen_rect.center(), text)

    def get_scroll_area(self):
        """Helper to find the parent QScrollArea, if any."""
        widget = self.parentWidget()
        while widget:
            if widget.inherits("QScrollArea"):
                return widget
            widget = widget.parentWidget()
        return None


class SimplePDFCropper(QMainWindow):
    def __init__(self, on_finish_callback=None):
        super().__init__()
        self.on_finish_callback = on_finish_callback
        self.setWindowTitle("PDF Cropper")
        self.setGeometry(100, 100, 1000, 900)
    
        self.pdf_document = None
        self.current_page = 0
        self.total_pages = 0
        self.zoom = 1.0
        self.last_saved_path = None  # Track the last saved file path
    
        self.init_ui()

    def init_ui(self):
        # Main widget and layout
        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        main_layout = QVBoxLayout(main_widget)
    
        # Button bar
        button_layout = QHBoxLayout()
    
        # Make "Start Crop" button more prominent and place it at the left
        self.crop_btn = QPushButton("Start Crop")
        self.crop_btn.setCheckable(True)
        self.crop_btn.clicked.connect(self.toggle_crop)
        self.crop_btn.setEnabled(True)
        self.crop_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 6px 12px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:checked {
                background-color: #f44336;
            }
        """)
        self.crop_btn.setMinimumWidth(120)
        button_layout.addWidget(self.crop_btn)
    
        button_layout.addSpacing(15)  # Add some spacing after the crop button
    
        # Navigation buttons
        self.prev_btn = QPushButton("Previous")
        self.prev_btn.clicked.connect(self.prev_page)
        self.prev_btn.setEnabled(False)
        button_layout.addWidget(self.prev_btn)
    
        self.page_lbl = QLabel("Page: 0 / 0")
        button_layout.addWidget(self.page_lbl)
    
        self.next_btn = QPushButton("Next")
        self.next_btn.clicked.connect(self.next_page)
        self.next_btn.setEnabled(False)
        button_layout.addWidget(self.next_btn)
    
        # Zoom control
        button_layout.addWidget(QLabel("Zoom:"))
        self.zoom_spinner = QSpinBox()
        self.zoom_spinner.setRange(50, 200)
        self.zoom_spinner.setValue(100)
        self.zoom_spinner.setSuffix("%")
        self.zoom_spinner.setSingleStep(10)
        self.zoom_spinner.valueChanged.connect(self.change_zoom)
        button_layout.addWidget(self.zoom_spinner)
    
        # Add spacer to push action buttons to the right
        button_layout.addStretch(1)
    
        # Save button
        self.save_btn = QPushButton("Save Cropped PDF")
        self.save_btn.clicked.connect(self.save_cropped_pdf)
        self.save_btn.setEnabled(False)
        button_layout.addWidget(self.save_btn)
    
        # "Don't Crop" button - now placed next to Save
        self.dont_crop_btn = QPushButton("Don't Crop")
        self.dont_crop_btn.clicked.connect(self.dont_crop)
        self.dont_crop_btn.setToolTip("Close without cropping and open the original PDF")
        button_layout.addWidget(self.dont_crop_btn)
    
        main_layout.addLayout(button_layout)
    
        # Scroll area for the PDF
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        main_layout.addWidget(self.scroll_area)
    
        # PDF viewer widget
        self.pdf_viewer = PDFViewer()
        self.pdf_viewer.setText("PDF will load automatically")
        self.pdf_viewer.setStyleSheet("background-color: #f0f0f0;")
    
        self.scroll_area.setWidget(self.pdf_viewer)
    
        self.statusBar().showMessage("PDF Cropper ready. Click 'Start Crop' to select an area.")

    def wheelEvent(self, event):
        """Enable Control + scroll to zoom in and out"""
        if event.modifiers() & Qt.KeyboardModifier.ControlModifier:
            delta = event.angleDelta().y()
            # Adjust zoom: increase if scrolling up, decrease if scrolling down
            current_value = self.zoom_spinner.value()
            if delta > 0:
                new_value = min(current_value + self.zoom_spinner.singleStep(), self.zoom_spinner.maximum())
            else:
                new_value = max(current_value - self.zoom_spinner.singleStep(), self.zoom_spinner.minimum())
            self.zoom_spinner.setValue(new_value)
            event.accept()
        else:
            super().wheelEvent(event)
    
    def dont_crop(self):
        """Close the dialog without cropping and trigger callback with original PDF"""
        # Get the original PDF path
        original_path = self.pdf_document.name if self.pdf_document else None
    
        # Close the dialog
        self.close()
    
        # Call the callback with the original PDF path
        if hasattr(self, 'on_finish_callback') and self.on_finish_callback and original_path:
            self.on_finish_callback(original_path)

    def open_pdf_file(self, file_path):
        """
        Open the specified PDF file in the cropper.
    
        Args:
            file_path (str): Path to the PDF file to open
    
        Returns:
            bool: True if successful, False otherwise
        """
        if not file_path or not os.path.exists(file_path):
            QMessageBox.critical(self, "Error", f"File not found: {file_path}")
            return False
        
        try:
            # Close any previously open document
            if self.pdf_document:
                self.pdf_document.close()
            
            # Open the new document
            self.pdf_document = fitz.open(file_path)
            self.total_pages = len(self.pdf_document)
            self.current_page = 0
        
            # Update UI
            self.page_lbl.setText(f"Page: {self.current_page + 1} / {self.total_pages}")
            self.statusBar().showMessage(f"Opened: {os.path.basename(file_path)}")
        
            # Enable/disable buttons
            self.crop_btn.setEnabled(True)
            self.prev_btn.setEnabled(False)
            self.next_btn.setEnabled(self.total_pages > 1)
        
            # Reset crop
            self.crop_btn.setChecked(False)
            self.pdf_viewer.enable_crop_mode(False)
            self.save_btn.setEnabled(False)
        
            # Display the first page
            self.render_current_page()
        
            # Activate the window and make sure it's visible and on top
            self.setWindowState(self.windowState() & ~Qt.WindowState.WindowMinimized)
            self.show()
            self.activateWindow()
            self.raise_()
        
            # Process events to ensure window is shown properly
            QApplication.processEvents()
        
            return True
        
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not open PDF: {str(e)}")
            return False
    
    def open_pdf(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Open PDF File", "", "PDF Files (*.pdf)"
        )
        
        if not file_path:
            return
            
        try:
            # Close any previously open document
            if self.pdf_document:
                self.pdf_document.close()
                
            # Open the new document
            self.pdf_document = fitz.open(file_path)
            self.total_pages = len(self.pdf_document)
            self.current_page = 0
            
            # Update UI
            self.page_lbl.setText(f"Page: {self.current_page + 1} / {self.total_pages}")
            self.statusBar().showMessage(f"Opened: {os.path.basename(file_path)}")
            
            # Enable/disable buttons
            self.crop_btn.setEnabled(True)
            self.prev_btn.setEnabled(False)
            self.next_btn.setEnabled(self.total_pages > 1)
            
            # Reset crop
            self.crop_btn.setChecked(False)
            self.pdf_viewer.enable_crop_mode(False)
            self.save_btn.setEnabled(False)
            
            # Display the first page
            self.render_current_page()
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not open PDF: {str(e)}")
    
    def render_current_page(self):
        if not self.pdf_document:
            return
            
        try:
            # Get the page
            page = self.pdf_document[self.current_page]
            
            # Get zoom factor
            zoom_factor = self.zoom
            
            # Render to pixmap
            pix = page.get_pixmap(matrix=fitz.Matrix(zoom_factor, zoom_factor))
            
            # Convert to QImage
            img = QImage(pix.samples, pix.width, pix.height,
                        pix.stride, QImage.Format.Format_RGB888)
            
            # Convert to QPixmap and display
            pixmap = QPixmap.fromImage(img)
            self.pdf_viewer.setPixmap(pixmap)
            
            # Update page label
            self.page_lbl.setText(f"Page: {self.current_page + 1} / {self.total_pages}")
            
            # Display page dimensions in status bar
            pdf_width = page.rect.width
            pdf_height = page.rect.height
            self.statusBar().showMessage(
                f"PDF page: {pdf_width:.1f} x {pdf_height:.1f} points. " +
                f"Display: {pixmap.width()} x {pixmap.height()} pixels."
            )
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to render page: {str(e)}")
    
    def prev_page(self):
        if self.pdf_document and self.current_page > 0:
            self.current_page -= 1
            self.render_current_page()
            
            # Reset crop
            self.crop_btn.setChecked(False)
            self.pdf_viewer.enable_crop_mode(False)
            self.save_btn.setEnabled(False)
            
            # Update navigation buttons
            self.prev_btn.setEnabled(self.current_page > 0)
            self.next_btn.setEnabled(True)
    
    def next_page(self):
        if self.pdf_document and self.current_page < self.total_pages - 1:
            self.current_page += 1
            self.render_current_page()
            
            # Reset crop
            self.crop_btn.setChecked(False)
            self.pdf_viewer.enable_crop_mode(False)
            self.save_btn.setEnabled(False)
            
            # Update navigation buttons
            self.prev_btn.setEnabled(True)
            self.next_btn.setEnabled(self.current_page < self.total_pages - 1)
    
    def change_zoom(self, value):
        self.zoom = value / 100.0
        if self.pdf_document:
            self.render_current_page()
    
    def toggle_crop(self, checked):
        """Toggle crop mode on/off and update button text"""
        self.pdf_viewer.enable_crop_mode(checked)
        self.crop_btn.setText("Stop Crop" if checked else "Start Crop")
    
        if checked:
            self.statusBar().showMessage("Drag to select an area to crop")
            QMessageBox.information(self, "Crop Mode", 
                                   "Click and drag to select the area you want to keep.\n")
        else:
            # Clear any existing selection when disabling crop mode
            self.pdf_viewer.crop_rect = QRect()
            self.pdf_viewer.start_point = None
            self.pdf_viewer.end_point = None
            self.save_btn.setEnabled(False)
        
            if self.pdf_document:
                page = self.pdf_document[self.current_page]
                self.statusBar().showMessage(
                    f"PDF page: {page.rect.width:.1f} x {page.rect.height:.1f} points."
                )
            else:
                self.statusBar().showMessage("Ready")
    
    def crop_selection_made(self):
        """Called when a valid crop selection is made"""
        print("Valid crop selection made")
        self.save_btn.setEnabled(True)
        
        # Update status bar with clear instructions
        self.statusBar().showMessage("✅ Selection complete! Click 'Save Cropped PDF' to export or 'Disable Crop' to cancel.")
        
        # Change the crop button appearance to indicate active selection
        self.crop_btn.setText("Cancel Selection")
        # Optionally flash the save button to draw attention to it
        for _ in range(2):
            self.save_btn.setStyleSheet("background-color: #4CAF50; color: white;")
            QApplication.processEvents()
            time.sleep(0.1)
            self.save_btn.setStyleSheet("")
            QApplication.processEvents()
            time.sleep(0.1)
    
    def save_cropped_pdf(self):
        """Save the cropped PDF with permission error fallback to save dialog"""
        if not self.pdf_document or self.pdf_viewer.crop_rect.isEmpty():
            QMessageBox.warning(self, "No Selection", "Please select an area to crop first.")
            return

        target_path = ""
        if hasattr(self.pdf_document, "name") and self.pdf_document.name:
            target_path = self.pdf_document.name
        else:
            QMessageBox.critical(self, "Error", "Cannot determine the PDF file path.")
            return

        temp_path = None
        output_pdf = None  # Initialize here

        try:
            fd, temp_path = tempfile.mkstemp(suffix='.pdf')
            os.close(fd)  # Close the file descriptor immediately

            print(f"Using temporary file: {temp_path}")

            # Get current page and crop rectangle
            page = self.pdf_document[self.current_page]
            crop_rect = self.pdf_viewer.crop_rect

            # Calculate scale factors using the actual pixmap dimensions
            x_scale = page.rect.width / self.pdf_viewer.pixmap().width()
            y_scale = page.rect.height / self.pdf_viewer.pixmap().height()

            # Convert crop rectangle coordinates from pixmap space to PDF space
            x0 = crop_rect.left() * x_scale
            y0 = crop_rect.top() * y_scale
            x1 = crop_rect.right() * x_scale
            y1 = crop_rect.bottom() * y_scale

            # Create a PDF rectangle and ensure it is within the media box
            pdf_rect = fitz.Rect(x0, y0, x1, y1)
            pdf_rect = pdf_rect & page.rect  # Intersection with the page's media box

            print(f"Computed PDF crop rectangle: {pdf_rect}")


            print(f"PDF coordinates after intersection: {pdf_rect}")

            filename = self.pdf_document.name
            original_page = self.current_page

            self.pdf_document.close()
            self.pdf_document = None

            self.pdf_viewer.clear()
            self.pdf_viewer.setText("Processing...")
            QApplication.processEvents()

            # Create a new PDF document
            output_pdf = fitz.open()
            source_pdf = fitz.open(filename)
            output_pdf.insert_pdf(source_pdf, from_page=original_page, to_page=original_page)
            new_page = output_pdf[0]
            new_page.set_cropbox(pdf_rect)

            output_pdf.save(temp_path)
            output_pdf.close()
            source_pdf.close()

            gc.collect()
            QApplication.processEvents()
    
            replaced = False
            save_path = target_path
    
            try:
                if platform.system() == 'Windows':
                    if os.path.exists(target_path):
                        try:
                            os.remove(target_path)
                            shutil.copy2(temp_path, target_path)
                            replaced = True
                        except PermissionError:
                            print(f"Cannot directly remove file: {target_path}")
                    
                            try:
                                shutil.move(temp_path, target_path)
                                print(f"Used shutil.move to replace file")
                                replaced = True
                            except Exception as e:
                                print(f"shutil.move failed: {e}")
                                try:
                                    subprocess.run(['cmd', '/c', f'copy /Y "{temp_path}" "{target_path}"'], 
                                                  shell=True, check=True)
                                    print(f"Used system command to replace file")
                                    replaced = True
                                except Exception as e:
                                    print(f"System command failed: {e}")
                                    replaced = False
                    else:
                        shutil.copy2(temp_path, target_path)
                        replaced = True
                else:
                    shutil.copy2(temp_path, target_path)
                    replaced = True
        
                if replaced:
                    print(f"Successfully copied from {temp_path} to {target_path}")
                else:
                    raise PermissionError("Failed to replace the file using any method")
        
            except Exception as e:
                print(f"Permission error: {e}")
                replaced = False
    
            if not replaced:
                QMessageBox.warning(
                    self,
                    "Permission Error",
                    "Cannot overwrite the original file. It may be in use by another program.\n\n"
                    "Please select a different location to save the cropped PDF."
                )
        
                default_name = os.path.basename(target_path)
                default_dir = os.path.dirname(target_path)
                new_path, _ = QFileDialog.getSaveFileName(
                    self,
                    "Save Cropped PDF As",
                    os.path.join(default_dir, f"cropped_{default_name}"),
                    "PDF Files (*.pdf)"
                )
        
                if not new_path:
                    self.statusBar().showMessage("Crop operation canceled")
                    return
        
                if not new_path.lower().endswith('.pdf'):
                    new_path += '.pdf'
        
                try:
                    shutil.copy2(temp_path, new_path)
                    print(f"Saved to alternate location: {new_path}")
                    save_path = new_path
                    replaced = True
                except Exception as e:
                    QMessageBox.critical(
                        self,
                        "Save Error",
                        f"Could not save to the selected location: {str(e)}"
                    )
                    return
    
            if replaced:
                self.last_saved_path = save_path
                self.statusBar().showMessage(f"Saved cropped PDF to: {save_path}")
            
                open_response = QMessageBox.question(
                    self,
                    "PDF Saved",
                    f"The cropped PDF has been saved to:\n{save_path}\n\nWould you like to open it now?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.Yes
                )
            
                self.close()
            
                if hasattr(self, 'on_finish_callback') and self.on_finish_callback and self.last_saved_path:
                    if open_response == QMessageBox.StandardButton.Yes:
                        self.on_finish_callback(self.last_saved_path)
                    else:
                        self.on_finish_callback(None)
            else:
                QMessageBox.critical(
                    self,
                    "Save Error",
                    "Failed to save the cropped PDF. Please try again or choose a different location."
                )
        
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save cropped PDF: {str(e)}")
            import traceback
            traceback.print_exc()
        finally:
            if temp_path and os.path.exists(temp_path):
                try:
                    os.remove(temp_path)
                    print(f"Cleaned up temporary file: {temp_path}")
                except Exception as ex:
                    print(f"Warning: Could not remove temporary file: {temp_path}, Error: {str(ex)}")

    # Simplified callback implementation for export_to_pdf function
    def on_cropper_finish(saved_path):
        """Called when the PDF Cropper finishes and closes"""
        if saved_path is None:
            return
        
        if not saved_path or not os.path.exists(saved_path):
            return
    
        try:
            if platform.system() == 'Windows':
                os.startfile(saved_path)
            elif platform.system() == 'Darwin':
                subprocess.call(('open', saved_path))
            else:
                subprocess.call(('xdg-open', saved_path))
        except Exception as e:
            print(f"Error opening PDF with default viewer: {e}")
            QMessageBox.warning(
                None,
                "Open Error",
                f"Could not open the PDF with the default viewer: {str(e)}"
            )

    def closeEvent(self, event):
        if self.on_finish_callback and self.last_saved_path:
            self.on_finish_callback(self.last_saved_path)
        super().closeEvent(event)


class GeminiAPIKeysDialog(QDialog):
    """
    Dialog for managing multiple Gemini API keys.
    Allows storing up to 5 API keys and setting any as default.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Manage Gemini API Keys")
        self.setMinimumSize(600, 500)
        self.setModal(True)
        
        # Get paths for API key storage
        self.api_key_file_path = self._get_api_key_path()
        self.stored_keys_file_path = os.path.join(os.path.dirname(self.api_key_file_path), "stored_api_keys.json")
        
        # Load existing keys
        self.default_key = self._load_default_key()
        self.stored_keys = self._load_stored_keys()
        
        self._setup_ui()
        self._connect_signals()
        self._refresh_display()

    def _get_api_key_path(self):
        """Gets the full path for the API key file in the 'data' subfolder."""
        try:
            if getattr(sys, 'frozen', False):
                base_path = os.path.dirname(sys.executable)
            else:
                base_path = os.path.dirname(os.path.abspath(__file__))
            data_folder = os.path.join(base_path, "data")
            os.makedirs(data_folder, exist_ok=True)
            return os.path.join(data_folder, "api_key.txt")
        except Exception as e:
            print(f"Error determining API key path: {e}")
            return os.path.join(os.getcwd(), "api_key.txt")

    def _load_default_key(self):
        """Load the current default API key from api_key.txt"""
        try:
            if os.path.exists(self.api_key_file_path):
                with open(self.api_key_file_path, 'r', encoding='utf-8') as f:
                    return f.read().strip()
        except Exception as e:
            print(f"Error loading default API key: {e}")
        return ""

    def _load_stored_keys(self):
        """Load stored API keys from JSON file"""
        try:
            if os.path.exists(self.stored_keys_file_path):
                with open(self.stored_keys_file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    keys = data.get('keys', [])
                    
                    # Migrate old format (strings) to new format (dicts with nickname)
                    migrated_keys = []
                    for key in keys:
                        if isinstance(key, str):
                            # Old format: just the key string
                            migrated_keys.append({
                                'key': key,
                                'nickname': f"API Key {len(migrated_keys) + 1}"
                            })
                        elif isinstance(key, dict) and 'key' in key:
                            # New format: dict with key and nickname
                            if 'nickname' not in key:
                                key['nickname'] = f"API Key {len(migrated_keys) + 1}"
                            migrated_keys.append(key)
                    
                    # Save migrated format if we changed anything
                    if migrated_keys != keys:
                        self.stored_keys = migrated_keys
                        self._save_stored_keys()
                    
                    return migrated_keys
        except Exception as e:
            print(f"Error loading stored API keys: {e}")
        return []

    def _save_stored_keys(self):
        """Save stored API keys to JSON file"""
        try:
            data = {'keys': self.stored_keys}
            with open(self.stored_keys_file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            print(f"Error saving stored API keys: {e}")
            QMessageBox.warning(self, "Error", f"Failed to save API keys: {e}")

    def _save_default_key(self, key):
        """Save the default API key to api_key.txt"""
        try:
            with open(self.api_key_file_path, 'w', encoding='utf-8') as f:
                f.write(key)
            self.default_key = key
        except Exception as e:
            print(f"Error saving default API key: {e}")
            QMessageBox.warning(self, "Error", f"Failed to save default API key: {e}")

    def _setup_ui(self):
        """Setup the user interface"""
        layout = QVBoxLayout(self)
        layout.setSpacing(20)
        layout.setContentsMargins(20, 20, 20, 20)

        # Title
        title_label = QLabel("Manage Gemini API Keys")
        title_label.setStyleSheet("font-size: 18px; font-weight: bold; margin-bottom: 10px;")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title_label)

        # Get API Key link
        link_layout = QHBoxLayout()
        link_layout.addStretch()
        get_key_label = QLabel('<a href="https://aistudio.google.com/apikey">Get API Key</a>')
        get_key_label.setStyleSheet("font-size: 12px; color: #4285F4;")
        get_key_label.setOpenExternalLinks(True)
        get_key_label.setTextFormat(Qt.TextFormat.RichText)
        link_layout.addWidget(get_key_label)
        link_layout.addStretch()
        layout.addLayout(link_layout)

        # Default API Key section
        default_group = QGroupBox("Default API Key")
        default_group.setStyleSheet("QGroupBox { font-weight: bold; padding-top: 10px; }")
        default_layout = QVBoxLayout(default_group)

        self.default_key_display = QLineEdit()
        self.default_key_display.setReadOnly(True)
        self.default_key_display.setEchoMode(QLineEdit.EchoMode.Password)
        self.default_key_display.setStyleSheet("background-color: #f5f5f5; padding: 8px;")
        default_layout.addWidget(self.default_key_display)

        show_default_btn = QPushButton("Show/Hide")
        show_default_btn.clicked.connect(self._toggle_default_visibility)
        show_default_btn.setMaximumWidth(100)
        default_layout.addWidget(show_default_btn)

        layout.addWidget(default_group)

        # Stored API Keys section
        stored_group = QGroupBox("Stored API Keys (Up to 5)")
        stored_group.setStyleSheet("QGroupBox { font-weight: bold; padding-top: 10px; }")
        stored_layout = QVBoxLayout(stored_group)

        # Scroll area for stored keys
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setMinimumHeight(200)
        
        self.keys_widget = QWidget()
        self.keys_layout = QVBoxLayout(self.keys_widget)
        self.keys_layout.setSpacing(10)
        
        scroll_area.setWidget(self.keys_widget)
        stored_layout.addWidget(scroll_area)

        # Add new key section
        add_key_layout = QVBoxLayout()
        
        # Nickname input
        nickname_layout = QHBoxLayout()
        nickname_label = QLabel("Nickname:")
        nickname_label.setMinimumWidth(70)
        self.new_nickname_input = QLineEdit()
        self.new_nickname_input.setPlaceholderText("Enter a nickname for this key...")
        self.new_nickname_input.setStyleSheet("padding: 8px;")
        nickname_layout.addWidget(nickname_label)
        nickname_layout.addWidget(self.new_nickname_input, 1)
        
        # API key input
        key_layout = QHBoxLayout()
        key_label = QLabel("API Key:")
        key_label.setMinimumWidth(70)
        self.new_key_input = QLineEdit()
        self.new_key_input.setPlaceholderText("Enter new API key...")
        self.new_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.new_key_input.setStyleSheet("padding: 8px;")
        key_layout.addWidget(key_label)
        key_layout.addWidget(self.new_key_input, 1)
        
        # Add button
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        add_key_btn = QPushButton("Add Key")
        add_key_btn.clicked.connect(self._add_new_key)
        add_key_btn.setStyleSheet("""
            QPushButton {
                background-color: #4285F4; color: white; border: none; 
                padding: 8px 15px; border-radius: 4px; font-weight: bold;
            }
            QPushButton:hover { background-color: #3367D6; }
            QPushButton:pressed { background-color: #2851A3; }
        """)
        button_layout.addWidget(add_key_btn)
        
        add_key_layout.addLayout(nickname_layout)
        add_key_layout.addLayout(key_layout)
        add_key_layout.addLayout(button_layout)
        stored_layout.addLayout(add_key_layout)

        layout.addWidget(stored_group)

        # Dialog buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: #E0E0E0; border: 1px solid #BDBDBD; 
                padding: 8px 20px; border-radius: 4px;
            }
            QPushButton:hover { background-color: #D6D6D6; }
        """)
        
        button_layout.addWidget(close_btn)
        layout.addLayout(button_layout)

    def _connect_signals(self):
        """Connect UI signals"""
        self.new_key_input.returnPressed.connect(self._add_new_key)
        self.new_nickname_input.returnPressed.connect(self._add_new_key)

    def _create_key_widget(self, key_data, index):
        """Create a widget for displaying and managing a stored key"""
        widget = QWidget()
        widget.setStyleSheet("QWidget { background: #FAFAFA; border-radius: 2px; outline: 0px; }")
        layout = QHBoxLayout(widget)
        layout.setContentsMargins(8, 4, 8, 4)
        layout.setSpacing(8)

        # Nickname and key in left section
        info_layout = QVBoxLayout()
        info_layout.setContentsMargins(0, 0, 0, 0)
        info_layout.setSpacing(1)

        # Nickname
        nickname = key_data.get('nickname', 'Unnamed Key')
        nickname_label = QLabel(nickname)
        nickname_label.setStyleSheet("font-weight: bold; color: #333; font-size: 11px; outline: 0px;")
        info_layout.addWidget(nickname_label)

        # Key display (masked)
        api_key = key_data.get('key', key_data) if isinstance(key_data, dict) else key_data
        key_display = QLineEdit(api_key)
        key_display.setReadOnly(True)
        key_display.setEchoMode(QLineEdit.EchoMode.Password)
        key_display.setStyleSheet("border: none; background: transparent; font-family: monospace; font-size: 10px; color: #666; outline: 0px;")
        key_display.setMaximumHeight(18)
        info_layout.addWidget(key_display)

        layout.addLayout(info_layout, 1)

        # Compact buttons
        buttons_layout = QHBoxLayout()
        buttons_layout.setContentsMargins(0, 0, 0, 0)
        buttons_layout.setSpacing(3)

        # Show/Hide button
        show_btn = QPushButton("Show")
        show_btn.setFixedSize(45, 24)
        show_btn.setStyleSheet("QPushButton { border: none; background: #E8E8E8; border-radius: 2px; font-size: 9px; outline: 0px; padding: 0px 3px; } QPushButton:hover { background: #D8D8D8; }")
        show_btn.clicked.connect(lambda: self._toggle_key_visibility(key_display, show_btn))
        buttons_layout.addWidget(show_btn)

        # Set as Default button
        default_btn = QPushButton("Default")
        default_btn.setFixedSize(55, 24)
        default_btn.setStyleSheet("QPushButton { background: #8E24AA; color: white; border: none; border-radius: 2px; font-size: 9px; outline: 0px; padding: 0px 3px; } QPushButton:hover { background: #7B1FA2; }")
        default_btn.clicked.connect(lambda: self._set_as_default(api_key))
        buttons_layout.addWidget(default_btn)

        # Delete button
        delete_btn = QPushButton("Delete")
        delete_btn.setFixedSize(45, 24)
        delete_btn.setStyleSheet("QPushButton { background: #D32F2F; color: white; border: none; border-radius: 2px; font-size: 9px; outline: 0px; padding: 0px 3px; } QPushButton:hover { background: #B71C1C; }")
        delete_btn.clicked.connect(lambda: self._delete_key(index))
        buttons_layout.addWidget(delete_btn)

        layout.addLayout(buttons_layout)
        return widget

    def _refresh_display(self):
        """Refresh the display of all keys"""
        # Update default key display
        self.default_key_display.setText(self.default_key if self.default_key else "No default key set")

        # Clear existing key widgets and layout items
        while self.keys_layout.count():
            child = self.keys_layout.takeAt(0)
            if child.widget():
                child.widget().setParent(None)

        # Add stored key widgets
        for i, key in enumerate(self.stored_keys):
            key_widget = self._create_key_widget(key, i)
            self.keys_layout.addWidget(key_widget)

        # Add stretch to push widgets to top
        self.keys_layout.addStretch()

    def _toggle_default_visibility(self):
        """Toggle visibility of default key"""
        if self.default_key_display.echoMode() == QLineEdit.EchoMode.Password:
            self.default_key_display.setEchoMode(QLineEdit.EchoMode.Normal)
        else:
            self.default_key_display.setEchoMode(QLineEdit.EchoMode.Password)

    def _toggle_key_visibility(self, key_display, show_btn):
        """Toggle visibility of a stored key"""
        if key_display.echoMode() == QLineEdit.EchoMode.Password:
            key_display.setEchoMode(QLineEdit.EchoMode.Normal)
            show_btn.setText("Hide")
        else:
            key_display.setEchoMode(QLineEdit.EchoMode.Password)
            show_btn.setText("Show")

    def _add_new_key(self):
        """Add a new API key to storage"""
        new_key = self.new_key_input.text().strip()
        new_nickname = self.new_nickname_input.text().strip()
        
        if not new_key:
            QMessageBox.warning(self, "Warning", "Please enter an API key.")
            return

        if not new_nickname:
            QMessageBox.warning(self, "Warning", "Please enter a nickname for this key.")
            return

        if len(self.stored_keys) >= 5:
            QMessageBox.warning(self, "Warning", "Maximum of 5 stored keys allowed.")
            return

        # Check if key already exists
        for stored_key in self.stored_keys:
            stored_api_key = stored_key.get('key', stored_key) if isinstance(stored_key, dict) else stored_key
            if stored_api_key == new_key:
                QMessageBox.warning(self, "Warning", "This API key is already stored.")
                return

        # Check if nickname already exists
        for stored_key in self.stored_keys:
            if isinstance(stored_key, dict) and stored_key.get('nickname', '').lower() == new_nickname.lower():
                QMessageBox.warning(self, "Warning", "A key with this nickname already exists.")
                return

        # Add new key with nickname
        key_data = {
            'key': new_key,
            'nickname': new_nickname
        }
        self.stored_keys.append(key_data)
        self._save_stored_keys()
        self.new_key_input.clear()
        self.new_nickname_input.clear()
        self._refresh_display()

    def _set_as_default(self, key):
        """Set a stored key as the default"""
        reply = QMessageBox.question(
            self, "Set as Default", 
            "Set this key as the default for all Gemini functionality?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            self._save_default_key(key)
            self._refresh_display()
            QMessageBox.information(self, "Success", "Default API key updated successfully!")

    def _delete_key(self, index):
        """Delete a stored key"""
        if 0 <= index < len(self.stored_keys):
            key_data = self.stored_keys[index]
            if isinstance(key_data, dict):
                nickname = key_data.get('nickname', 'Unnamed Key')
                api_key = key_data.get('key', '')
                key_preview = api_key[:8] + "..." if len(api_key) > 8 else api_key
                display_name = f"'{nickname}' ({key_preview})"
            else:
                # Handle old format (string)
                key_preview = key_data[:8] + "..." if len(key_data) > 8 else key_data
                display_name = key_preview
                
            reply = QMessageBox.question(
                self, "Delete Key", 
                f"Delete API key {display_name}?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                del self.stored_keys[index]
                self._save_stored_keys()
                self._refresh_display()


class AIQueryDialog(QDialog):
    """
    Non-modal dialog for querying AI about selected text from the transcript.
    """
    def __init__(self, parent=None, selected_text="", title="", speech_section="", main_window=None):
        super().__init__(parent)
        self.selected_text = selected_text
        self.title = title
        self.speech_section = speech_section
        self.main_window = main_window  # Reference to main window for shared cache
        self.model = None
        self.thread = None
        self.worker = None
        self._is_processing = False
        
        # Timer for elapsed time tracking
        self._processing_timer = QTimer()
        self._processing_timer.timeout.connect(self._update_timer_display)
        self._start_time = None
        
        # Get API key file path
        self.api_key_file_path = self._get_api_key_path()
        
        self.setWindowTitle("Scriptoria AI - Query Selected Text")
        self.setMinimumSize(725, 800)  # Set height to 800px
        self.resize(950, 800)  # Set height to 800px
        self.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, False)  # Keep dialog alive
        
        # Enable maximize and close buttons (no minimize)
        self.setWindowFlags(
            Qt.WindowType.Window |
            Qt.WindowType.WindowMaximizeButtonHint |
            Qt.WindowType.WindowCloseButtonHint |
            Qt.WindowType.WindowSystemMenuHint
        )
        
        self._setup_ui()
        self._connect_signals()
        self._load_api_key()
        
    def _get_api_key_path(self):
        """Gets the full path for the API key file in the 'data' subfolder."""
        try:
            if getattr(sys, 'frozen', False):
                base_path = os.path.dirname(sys.executable)
            else:
                base_path = os.path.dirname(os.path.abspath(__file__))
            
            data_folder = os.path.join(base_path, "data")
            os.makedirs(data_folder, exist_ok=True)
            return os.path.join(data_folder, "api_key.txt")
        except Exception as e:
            print(f"Error determining API key path: {e}")
            return os.path.join(os.getcwd(), "api_key.txt")
    
    def refresh_with_new_content(self, selected_text, title, speech_section):
        """Refresh the dialog with new content instead of creating a new dialog."""
        # Update the instance variables
        self.selected_text = selected_text
        self.title = title
        self.speech_section = speech_section
        
        # Clear conversation history
        self.conversation_history = []
        
        # Update selected text display
        if hasattr(self, 'selected_text_display'):
            self.selected_text_display.setPlainText(selected_text)
        
        # Clear chat area
        if hasattr(self, 'chat_area'):
            self.chat_area.clear()
        
        # Clear any active processing - safely terminate ongoing operations
        if self._is_processing:
            print("Terminating ongoing AI operation to start new request...")
            self._update_status_message("Canceling previous request...")
            
            if self.worker:
                self.worker.stop()
            
            # Stop timer and clean up
            self._stop_processing_timer()
            self._cleanup_processing()
        
        # Update window title if needed
        self.setWindowTitle("Scriptoria AI - Query Selected Text")
        
        # Show dialog only if it's not already visible (to avoid recentering)
        if not self.isVisible():
            self.show()
        
        # Bring to front without moving position
        self.raise_()
        self.activateWindow()
    
    def closeEvent(self, event):
        """Handle close event to clean up main window reference."""
        # Clear the reference in main window when dialog is actually closed
        if self.main_window and hasattr(self.main_window, '_ai_query_dialog'):
            self.main_window._ai_query_dialog = None
        super().closeEvent(event)
    
    def _start_processing_timer(self, status_message="Processing..."):
        """Start the timer and show status/timer labels."""
        import time
        self._start_time = time.time()
        self._processing_timer.start(100)  # Update every 100ms
        
        # Show and update status
        self.status_label.setText(status_message)
        self.status_label.setVisible(True)
        self.timer_label.setVisible(True)
        self._update_timer_display()
    
    def _stop_processing_timer(self):
        """Stop the timer and hide status/timer labels."""
        self._processing_timer.stop()
        self.status_label.setVisible(False)
        self.timer_label.setVisible(False)
        self._start_time = None
    
    def _update_timer_display(self):
        """Update the timer display with elapsed time."""
        if self._start_time is not None:
            import time
            elapsed = time.time() - self._start_time
            minutes = int(elapsed // 60)
            seconds = int(elapsed % 60)
            milliseconds = int((elapsed % 1) * 1000)
            
            if minutes > 0:
                time_str = f"{minutes:02d}:{seconds:02d}.{milliseconds//100:01d}"
            else:
                time_str = f"{seconds:02d}.{milliseconds//100:01d}s"
            
            self.timer_label.setText(f"⏱ {time_str}")
    
    def _update_status_message(self, message):
        """Update the status message while keeping timer running."""
        if self.status_label.isVisible():
            self.status_label.setText(message)
    
    def _setup_ui(self):
        """Create the UI components with compact chat-like design."""
        main_layout = QHBoxLayout(self)
        main_layout.setSpacing(10)

        # Left panel - Controls and context
        left_panel = QWidget()
        left_panel.setFixedWidth(275)
        left_layout = QVBoxLayout(left_panel)
        left_layout.setSpacing(10)

        # Menu bar (compact)
        menu_bar = QWidget()
        menu_layout = QGridLayout(menu_bar)
        menu_layout.setContentsMargins(0, 0, 0, 0)
        menu_layout.setSpacing(5)

        # API Key input (compact)
        menu_layout.addWidget(QLabel("API Key:"), 0, 0)
        self.api_key_input = QLineEdit()
        self.api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.api_key_input.setPlaceholderText("Enter Gemini API Key...")
        menu_layout.addWidget(self.api_key_input, 0, 1)

        # Model selection (compact)
        menu_layout.addWidget(QLabel("Model:"), 1, 0)
        self.model_combo = QComboBox()
        self.model_combo.addItem("Gemini 2.5 Flash", "gemini-2.5-flash")
        self.model_combo.addItem("Gemini 2.5 Flash Lite", "gemini-2.5-flash-lite")
        menu_layout.addWidget(self.model_combo, 1, 1)

        left_layout.addWidget(menu_bar)

        # Combined text and actions container - keep them together!
        combined_container = QWidget()
        combined_layout = QVBoxLayout(combined_container)
        combined_layout.setContentsMargins(0, 0, 0, 0)
        combined_layout.setSpacing(10)  # Fixed spacing between text and actions

        # Selected text section
        self.text_section = QWidget()
        self.text_section.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)  # FIXED HEIGHT FOR ENTIRE SECTION
        text_layout = QVBoxLayout(self.text_section)
        text_layout.setContentsMargins(0, 0, 0, 0)
        text_layout.setSpacing(2)  # Reduced spacing to keep label and text closer

        # --- START OF CHANGES ---
        # The problematic toggle button has been removed entirely and replaced
        # with a simple, static QLabel.
        selected_text_label = QLabel("Selected Text:")
        selected_text_label.setStyleSheet("font-weight: bold; color: #333;")
        text_layout.addWidget(selected_text_label)
        # --- END OF CHANGES ---

        # Selected text display (now always visible)
        self.selected_text_display = QTextEdit()
        self.selected_text_display.setPlainText(self.selected_text)
        self.selected_text_display.setReadOnly(True)
        self.selected_text_display.setMaximumHeight(120)
        self.selected_text_display.setMinimumHeight(120)  # FORCE EXACT HEIGHT
        self.selected_text_display.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)  # FIXED HEIGHT POLICY
        self.selected_text_display.setStyleSheet("""
            QTextEdit {
                background-color: #f8f9fa;
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 6px;
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 11px;
            }
        """)
        text_layout.addWidget(self.selected_text_display)
        
        # NO STRETCH - keep text section tight
        # text_layout.addStretch(0)  # REMOVE THIS - it might be causing expansion

        combined_layout.addWidget(self.text_section)

        # Quick actions section (compact) - NOW INSIDE COMBINED CONTAINER
        self.actions_section = QWidget()
        self.actions_section.setMaximumHeight(120)  # Fixed height like selected text section
        self.actions_section.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Fixed)  # No vertical expansion
        actions_layout = QVBoxLayout(self.actions_section)
        actions_layout.setContentsMargins(0, 0, 0, 0)
        actions_layout.setSpacing(5)

        self.actions_label = QLabel("Quick Actions:")
        actions_layout.addWidget(self.actions_label)

        self.summarize_btn = QPushButton("Quick Summarize")
        self.summarize_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.summarize_btn.clicked.connect(self._summarize_text)
        actions_layout.addWidget(self.summarize_btn)

        self.footnotes_btn = QPushButton("Get Footnotes")
        self.footnotes_btn.setStyleSheet("""
            QPushButton {
                background-color: #FF9800;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
        """)
        self.footnotes_btn.clicked.connect(self._get_footnotes)
        actions_layout.addWidget(self.footnotes_btn)

        self.simplify_btn = QPushButton("Simplify English")
        self.simplify_btn.setStyleSheet("""
            QPushButton {
                background-color: #9C27B0;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
            }
            QPushButton:hover {
                background-color: #7B1FA2;
            }
        """)
        self.simplify_btn.clicked.connect(self._simplify_english)
        actions_layout.addWidget(self.simplify_btn)
        
        # Keep actions section tight - same as text section
        actions_layout.addStretch(0)  # No stretch - keep buttons tight

        combined_layout.addWidget(self.actions_section)
        
        # NO stretch in combined layout - keep everything tight
        # combined_layout.addStretch()  # DON'T ADD THIS

        # Add the combined container to left layout
        left_layout.addWidget(combined_container)

        # Progress bar (compact)
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        self.progress_bar.setMaximumHeight(6)
        self.progress_bar.setStyleSheet("""
            QProgressBar {
                border: 1px solid #ccc;
                border-radius: 3px;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #4CAF50;
                border-radius: 2px;
            }
        """)
        left_layout.addWidget(self.progress_bar)
        
        # Status and timer display (compact)
        status_container = QWidget()
        status_layout = QVBoxLayout(status_container)
        status_layout.setContentsMargins(0, 5, 0, 0)
        status_layout.setSpacing(2)
        
        # Status label for current step
        self.status_label = QLabel("")
        self.status_label.setVisible(False)
        self.status_label.setStyleSheet("color: #666; font-size: 10px; font-style: italic;")
        self.status_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        status_layout.addWidget(self.status_label)
        
        # Timer label for elapsed time
        self.timer_label = QLabel("")
        self.timer_label.setVisible(False)
        self.timer_label.setStyleSheet("color: #888; font-size: 9px; font-family: monospace;")
        self.timer_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        status_layout.addWidget(self.timer_label)
        
        left_layout.addWidget(status_container)

        # Add stretch AFTER all controls to keep them anchored at the top
        left_layout.addStretch()

        main_layout.addWidget(left_panel)

        # Right panel - Chat conversation (DOMINATES)
        self.chat_panel = QWidget()
        self.chat_panel.setMinimumWidth(450)
        chat_layout = QVBoxLayout(self.chat_panel)
        chat_layout.setContentsMargins(10, 10, 10, 10)
        chat_layout.setSpacing(10)

        # Chat header
        chat_header = QLabel("Chat")
        chat_header.setStyleSheet("""
            QLabel {
                font-size: 16px;
                font-weight: bold;
                color: #333;
                padding: 8px;
                background-color: #f0f0f0;
                border-radius: 4px;
            }
        """)
        #chat_layout.addWidget(chat_header)

        # Chat display area (DOMINATES the space)
        self.chat_display = QTextEdit()
        self.chat_display.setReadOnly(True)
        self.chat_display.setPlaceholderText("Your conversation with Scriptoria AI will appear here...")
        self.chat_display.setAcceptRichText(True)
        self.chat_display.setStyleSheet("""
            QTextEdit {
                border: 1px solid #ddd;
                border-radius: 6px;
                padding: 12px;
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 13px;
                background-color: white;
                line-height: 1.5;
            }
        """)
        chat_layout.addWidget(self.chat_display)

        # Question input section
        question_layout = QHBoxLayout()
        question_layout.setSpacing(8)

        self.question_input = QLineEdit()
        self.question_input.setPlaceholderText("Enter your question about the selected text...")
        self.question_input.setStyleSheet("""
            QLineEdit {
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 8px;
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 12px;
            }
        """)
        self.question_input.returnPressed.connect(self._send_question)
        question_layout.addWidget(self.question_input)

        self.send_btn = QPushButton("Ask")
        self.send_btn.setStyleSheet("""
            QPushButton {
                background-color: #5E81AC;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #81A1C1;
            }
            QPushButton:pressed {
                background-color: #4C6A82;
            }
        """)
        self.send_btn.clicked.connect(self._send_question)
        self.send_btn.setDefault(True)  # Make "Ask" the default button for Enter key
        question_layout.addWidget(self.send_btn)

        self.clear_chat_btn = QPushButton("Clear Chat")
        self.clear_chat_btn.setStyleSheet("""
            QPushButton {
                background-color: #f44336;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #d32f2f;
            }
        """)
        self.clear_chat_btn.clicked.connect(self._clear_chat)
        self.clear_chat_btn.setAutoDefault(False)  # Prevent this button from responding to Enter
        question_layout.addWidget(self.clear_chat_btn)

        self.copy_btn = QPushButton("Copy")
        self.copy_btn.setStyleSheet("""
            QPushButton {
                background-color: #D08770;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #EBCB8B;
            }
            QPushButton:pressed {
                background-color: #A3BE8C;
            }
        """)
        self.copy_btn.clicked.connect(self._copy_conversation)
        self.copy_btn.setAutoDefault(False)  # Prevent this button from responding to Enter
        question_layout.addWidget(self.copy_btn)

        chat_layout.addLayout(question_layout)

        main_layout.addWidget(self.chat_panel)

        # Initialize conversation history
        self.conversation_history = []
        self._first_question_asked = False
        self._streaming_message_started = False
        self._current_streaming_message = ""
        
    
    def _convert_markdown_to_html(self, markdown_text):
        """Convert markdown formatting to HTML."""
        html_text = markdown_text
        
        # Convert headers with appropriate sizing
        html_text = re.sub(r'^### (.*?)$', r'<h3 style="color: #2e7d32; margin-top: 15px; margin-bottom: 8px; font-size: 16px;">\1</h3>', html_text, flags=re.MULTILINE)
        html_text = re.sub(r'^## (.*?)$', r'<h2 style="color: #2e7d32; margin-top: 18px; margin-bottom: 10px; font-size: 18px;">\1</h2>', html_text, flags=re.MULTILINE)
        html_text = re.sub(r'^# (.*?)$', r'<h1 style="color: #2e7d32; margin-top: 20px; margin-bottom: 12px; font-size: 20px;">\1</h1>', html_text, flags=re.MULTILINE)
        
        # Convert horizontal rules
        html_text = re.sub(r'^---+$', r'<hr style="border: 1px solid #ddd; margin: 20px 0;">', html_text, flags=re.MULTILINE)
        
        # Convert **bold** to <strong>bold</strong>
        html_text = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', html_text)
        
        # Convert *italic* to <em>italic</em>
        html_text = re.sub(r'\*(.*?)\*', r'<em>\1</em>', html_text)
        
        # Convert bullet points
        html_text = re.sub(r'^\*   (.*?)$', r'<div style="margin-left: 20px;">• \1</div>', html_text, flags=re.MULTILINE)
        
        # Convert line breaks, but handle headers specially
        # Headers already have their own margins, so don't add extra breaks around them
        html_text = re.sub(r'(</h[123]>)\n+', r'\1', html_text)  # Remove breaks after headers
        html_text = re.sub(r'\n+(<h[123])', r'\1', html_text)     # Remove breaks before headers  
        html_text = re.sub(r'(</hr>)\n+', r'\1', html_text)       # Remove breaks after HR
        
        # Convert remaining double line breaks to paragraph breaks, single to <br>
        paragraphs = html_text.split('\n\n')
        formatted_paragraphs = []
        
        for paragraph in paragraphs:
            if paragraph.strip():
                # Convert single newlines to <br> within paragraphs
                paragraph_html = paragraph.replace('\n', '<br>')
                formatted_paragraphs.append(paragraph_html)
        
        # Join paragraphs with proper spacing
        html_text = '<br><br>'.join(formatted_paragraphs)
        
        return html_text
    
    def _connect_signals(self):
        """Connect UI signals."""
        pass
    
    def _load_api_key(self):
        """Load API key from file if available."""
        try:
            if os.path.exists(self.api_key_file_path):
                with open(self.api_key_file_path, "r", encoding='utf-8') as f:
                    key = f.read().strip()
                    if key:
                        self.api_key_input.setText(key)
        except Exception as e:
            print(f"Error loading API key: {e}")
    
    def _summarize_text(self):
        """Quick summarize action."""
        section_info = f" from the '{self.speech_section}' section" if self.speech_section else ""
        prompt = f'''You are about to be given an excerpt taken{section_info} from a transcript titled "{self.title}". The excerpt is as follows: "{self.selected_text}" Please provide a concise summary of this text.

IMPORTANT: Always begin your response with "Quick summary of excerpt from {self.speech_section}" in bold if there is a speech section, followed by a line break before continuing with your summary.'''
        
        # Show simple message in chat but send detailed prompt to AI
        self._add_to_chat("You", "Please summarize this text.")
        self._start_ai_processing_chat(prompt)
    
    def _get_footnotes(self):
        """Get footnotes and background information action."""
        section_info = f" from the '{self.speech_section}' section" if self.speech_section else ""
        footnotes_request = "Please provide an overall explanation of this text, necessary background and historical context, and footnotes for anything requiring greater understanding. Focus on illuminating concepts, references, or language that might be difficult for a modern reader to understand, but avoid detailed line-by-line breakdowns."
        prompt = f'''You are about to be given an excerpt taken{section_info} from a transcript titled "{self.title}". The excerpt is as follows: "{self.selected_text}" {footnotes_request}

IMPORTANT: Always begin your response with "Creating footnotes for excerpt from {self.speech_section}" in bold if there is a speech section, followed by a line break before continuing with your explanation.'''
        
        # Show simple message in chat but send detailed prompt to AI
        self._add_to_chat("You", footnotes_request)
        self._start_ai_processing_chat(prompt)
    
    def _simplify_english(self):
        """Simplify English action with comprehensive translation instructions."""
        # Create the detailed prompt directly
        detailed_prompt = '''You will be given archaic or difficult English text that you should translate into clear, modern, readable English while preserving all meaning and content. Your goal is to make the text accessible to contemporary readers without losing any of the author's intended meaning, concepts, or nuances.

TRANSLATION APPROACH:
- Break down complex, lengthy sentences into shorter, clearer sentences when needed
- Replace archaic vocabulary and phrasing with modern equivalents that convey the same meaning
- Clarify unclear pronoun references and sentence structures
- Maintain all concepts, references, and ideas - do not omit anything
- Preserve the author's tone and style as much as possible while improving clarity
- Keep theological, philosophical, or technical terms when they are important to meaning

WHAT TO MODERNIZE:
- Archaic pronouns (Thee/Thou → You, Thy → Your)
- Outdated verb forms (doth → does, hast → have)
- Inverted or complex sentence structures
- Unclear connections between clauses
- Archaic vocabulary that obscures meaning

WHAT TO PRESERVE:
- All original meaning and content
- Important concepts and references
- The author's intended emphasis and tone
- Specialized terminology that aids understanding

The text you will be given may be longer than you can translate at once. Just translate as far as you can within your token limit. The user can ask you to continue from where you left off.

Do not start by explaining what you are going to do. Simply begin the translation. Separate any non-translation content with a horizontal rule.

Do not end with summaries or explanations. Stop when you reach your limit or complete the text.

STRICT FIDELITY REQUIREMENTS:
- Stay within the provided text only
- Every sentence must correspond to original content
- No additions, expansions, or interpretive content beyond the source
- If you reach the end of provided text, stop and confirm completion

If the user starts a request with #footnote: Provide explanatory footnotes for difficult references
If the user starts a request with #intro: Write an academic introduction to provide context
If the user starts a request with #thoughtforthought: Provide interpretive, meaning-focused translation
If the user starts a request with #wordforword: Provide strictly literal translation
If the user starts a request with #help: List available commands'''

        section_info = f" from the '{self.speech_section}' section" if self.speech_section else ""
        full_prompt = f'''{detailed_prompt}

You are about to be given an excerpt taken{section_info} from a transcript titled "{self.title}". The excerpt is as follows: "#thought-for-thought: {self.selected_text}"

IMPORTANT: Always begin your response with "Modernized english excerpt from '{self.speech_section}'" in bold if there is a speech section, followed by a line break before continuing with your translation.'''

        # Show simple message in chat but send detailed prompt to AI
        simple_display = "Please translate this text into more modern, readable English while maintaining accuracy and literal meaning."
        self._add_to_chat("You", simple_display)
        
        # Send detailed prompt directly to AI
        self._start_ai_processing_chat(full_prompt)
    
    def _send_question(self):
        """Send a question (either initial or follow-up)."""
        if self._is_processing:
            return
            
        question = self.question_input.text().strip()
        if not question:
            return
        
        # Check if API key is needed for first question
        if not self._first_question_asked:
            api_key = self.api_key_input.text().strip()
            if not api_key:
                QMessageBox.warning(self, "Missing API Key", "Please enter your Gemini API key.")
                return
        
        # Add user question to chat
        self._add_to_chat("You", question)
        self.question_input.clear()
        
        if not self._first_question_asked:
            # First question - create initial prompt
            section_info = f" from the '{self.speech_section}' section" if self.speech_section else ""
            prompt = f'''You are about to be given an excerpt taken{section_info} from a transcript titled "{self.title}". The excerpt is as follows: "{self.selected_text}" The user has also provided the following question/prompt accompanying their selection: "{question}"'''
            
            self._first_question_asked = True
            # Update placeholder for future questions
            self.question_input.setPlaceholderText("Ask a follow-up question...")
        else:
            # Follow-up question - create context prompt
            prompt = self._build_conversation_context(question)
        
        self._start_ai_processing_chat(prompt)
    
    def _send_followup(self):
        """Legacy method - redirect to _send_question for compatibility."""
        self._send_question()
    
    def _build_conversation_context(self, new_question):
        """Build a prompt that includes conversation history."""
        section_info = f" from the '{self.speech_section}' section" if self.speech_section else ""
        context = f'You are continuing a conversation about text{section_info} from a transcript titled "{self.title}". '
        context += f'The original text excerpt was: "{self.selected_text}"\n\n'
        
        if self.conversation_history:
            context += "Previous conversation:\n"
            for entry in self.conversation_history:
                role = entry["role"]
                content = entry["content"]
                context += f"{role}: {content}\n"
        
        context += f"\nUser: {new_question}\n\nPlease respond to the user's latest question."
        return context
    
    def _add_to_chat(self, sender, message):
        """Add a message to the chat display."""
        # Format the message nicely with proper spacing
        formatted_message = f"<div style='margin-bottom: 15px;'>"  # Increased margin
        if sender == "You":
            formatted_message += f"<div style='background-color: #e3f2fd; padding: 10px; border-radius: 8px; margin-left: 20px; margin-bottom: 15px;'>"
            formatted_message += f"<strong style='color: #1976d2;'>You:</strong> \"{message}\""
            formatted_message += "</div><br>"
        else:  # AI or System
            formatted_message += f"<div style='background-color: #f5f5f5; padding: 10px; border-radius: 8px; margin-right: 20px; margin-bottom: 8px;'>"
            if sender == "AI":
                formatted_message += f"<strong style='color: #2e7d32;'>Scriptoria AI:</strong><br><br>"  # Added extra break
            else:
                formatted_message += f"<strong style='color: #d32f2f;'>System:</strong><br><br>"  # Added extra break
            
            # Convert markdown to HTML for AI responses, preserve as-is for system messages
            if sender == "AI":
                formatted_content = self._convert_markdown_to_html(message)
            else:
                # Convert newlines to HTML breaks for system messages
                formatted_content = message.replace('\n', '<br>')
            
            formatted_message += f"<span style='white-space: pre-wrap;'>{formatted_content}</span>"
            formatted_message += "</div><br><br>"
        
        formatted_message += "</div>"  # Close the outer div
        
        # Append to chat display
        cursor = self.chat_display.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        cursor.insertHtml(formatted_message)
        
        # Auto-scroll to bottom
        scrollbar = self.chat_display.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
        
        # Add to conversation history (unless this is a streaming message that will be added later)
        if not (sender == "AI" and self._streaming_message_started):
            self.conversation_history.append({"role": sender, "content": message})
    
    def _clear_chat(self):
        """Clear the chat history and conversation."""
        reply = QMessageBox.question(self, "Clear Chat", 
                                   "Are you sure you want to clear the chat history?",
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                   QMessageBox.StandardButton.No)
        
        if reply == QMessageBox.StandardButton.Yes:
            self.chat_display.clear()
            self.conversation_history.clear()
            self._first_question_asked = False
            self.question_input.setPlaceholderText("Enter your question about the selected text...")
    
    def _start_streaming_message(self):
        """Start a new streaming AI message in the chat display."""
        # Create the initial AI message container
        formatted_message = f"<div style='margin-bottom: 15px;'>"
        formatted_message += f"<div style='background-color: #f5f5f5; padding: 10px; border-radius: 8px; margin-right: 20px; margin-bottom: 8px;'>"
        formatted_message += f"<strong style='color: #2e7d32;'>Scriptoria AI:</strong><br><br>"
        formatted_message += f"<span id='streaming-content' style='white-space: pre-wrap;'>"
        # Note: We'll leave this span open to append content
        
        # Append to chat display
        cursor = self.chat_display.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        cursor.insertHtml(formatted_message)
        
        # Auto-scroll to bottom
        scrollbar = self.chat_display.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
    
    def _append_streaming_chunk(self, chunk_text):
        """Append a chunk of text to the current streaming message."""
        # For streaming, skip complex markdown conversion to improve speed
        # Just escape basic HTML and convert line breaks
        html_chunk = chunk_text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('\n', '<br>')
        
        # Append to the end of the chat display immediately
        cursor = self.chat_display.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        cursor.insertHtml(html_chunk)
        
        # Force immediate update
        self.chat_display.update()
        
        # Auto-scroll to bottom
        scrollbar = self.chat_display.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
    
    def _finalize_streaming_message(self):
        """Finalize the streaming message by applying markdown formatting and closing HTML tags."""
        print(f"[FINALIZE DEBUG] Starting finalize, has _current_streaming_message: {hasattr(self, '_current_streaming_message')}")
        print(f"[FINALIZE DEBUG] Message length: {len(getattr(self, '_current_streaming_message', ''))}")
        
        # Close the streaming message HTML tags first
        closing_tags = "</span></div><br><br></div>"
        cursor = self.chat_display.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        cursor.insertHtml(closing_tags)
        
        # Now replace the entire chat display content with properly formatted markdown
        if hasattr(self, '_current_streaming_message') and self._current_streaming_message:
            print(f"[FINALIZE DEBUG] Processing markdown conversion...")
            # Get current HTML and rebuild with proper markdown formatting for the last AI message
            current_html = self.chat_display.toHtml()
            print(f"[FINALIZE DEBUG] Current HTML length: {len(current_html)}")
            
            # Find where the LAST AI message content starts (after "Scriptoria AI:")
            ai_marker = "Scriptoria AI:</span><br /><br />"
            ai_content_start = current_html.rfind(ai_marker)
            
            if ai_content_start != -1:
                # Find the start of the actual content (after the marker)
                content_start = ai_content_start + len(ai_marker)
                
                # Find the end of the content (before the closing </p></body></html>)
                content_end = current_html.rfind("</p></body></html>")
                
                if content_end != -1:
                    # Extract the parts
                    before_content = current_html[:content_start]
                    after_content = current_html[content_end:]
                    
                    # Convert the accumulated message to proper markdown HTML
                    print(f"[MARKDOWN DEBUG] Converting message length: {len(self._current_streaming_message)}")
                    markdown_html = self._convert_markdown_to_html(self._current_streaming_message)
                    print(f"[MARKDOWN DEBUG] Converted to HTML length: {len(markdown_html)}")
                    
                    # Rebuild with markdown formatting, ensuring proper spacing at the end
                    # Add proper spacing after the AI response to separate from future content
                    markdown_html_with_spacing = markdown_html + "<br><br>"
                    updated_html = before_content + markdown_html_with_spacing + after_content
                    self.chat_display.setHtml(updated_html)
                    print(f"[FINALIZE DEBUG] Successfully replaced content with markdown HTML")
                    print(f"[FINALIZE DEBUG] FINAL HTML: {updated_html}")
                else:
                    print(f"[FINALIZE DEBUG] Could not find content end")
            else:
                print(f"[FINALIZE DEBUG] Could not find AI content marker")
        
        # Auto-scroll to bottom
        scrollbar = self.chat_display.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
    
    def _start_ai_processing_chat(self, prompt):
        """Start AI processing in a separate thread for chat interface."""
        try:
            api_key = self.api_key_input.text().strip()
            if not api_key:
                QMessageBox.warning(self, "Missing API Key", "Please enter your Gemini API key.")
                return
            
            model_name = self.model_combo.currentData()
            
            # Use shared cached model if same API key and model, otherwise create new one
            if (self.main_window and hasattr(self.main_window, '_cached_model')):
                if (self.main_window._cached_model is None or 
                    self.main_window._cached_api_key != api_key or 
                    self.main_window._cached_model_name != model_name):
                    
                    print(f"[API DEBUG] Creating new model instance (key changed: {self.main_window._cached_api_key != api_key}, model changed: {self.main_window._cached_model_name != model_name})")
                    
                    # Configure Gemini only when needed
                    genai.configure(api_key=api_key)
                    
                    self.main_window._cached_model = genai.GenerativeModel(
                        model_name=model_name,
                        generation_config={
                            "temperature": 0.7,
                            "top_p": 0.9,
                            "top_k": 0,
                            "max_output_tokens": 8000,
                        }
                    )
                    self.main_window._cached_api_key = api_key
                    self.main_window._cached_model_name = model_name
                else:
                    print(f"[API DEBUG] Reusing cached model instance")
                
                self.model = self.main_window._cached_model
            else:
                # Fallback: create model without caching if main_window not available
                print(f"[API DEBUG] Creating new model instance (no cache available)")
                genai.configure(api_key=api_key)
                self.model = genai.GenerativeModel(
                    model_name=model_name,
                    generation_config={
                        "temperature": 0.7,
                        "top_p": 0.9,
                        "top_k": 0,
                        "max_output_tokens": 8000,
                    }
                )
            
            # Start processing
            self._is_processing = True
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 0)  # Indeterminate progress
            
            # Start timer with initial status
            self._start_processing_timer("Connecting to Gemini API...")
            
            # Disable buttons
            self.summarize_btn.setEnabled(False)
            self.footnotes_btn.setEnabled(False)
            self.simplify_btn.setEnabled(False)
            self.send_btn.setEnabled(False)
            self.question_input.setEnabled(False)
            
            # Create worker thread
            self.thread = QThread()
            self.worker = GeminiWorker(self.model, prompt)
            self.worker.moveToThread(self.thread)
            
            # Connect signals
            self.thread.started.connect(self.worker.run)
            self.worker.finished.connect(self._on_chat_processing_finished)
            self.worker.error.connect(self._on_chat_processing_error)
            self.worker.progress.connect(self._on_progress_update)
            self.worker.streaming_chunk.connect(self._on_streaming_chunk)
            
            # Start thread
            self.thread.start()
            
        except Exception as e:
            self._on_chat_processing_error(f"Failed to start AI processing: {str(e)}")
    
    def _on_streaming_chunk(self, chunk_text):
        """Handle streaming text chunks as they arrive."""
        if not self._streaming_message_started:
            # Start a new streaming message
            self._streaming_message_started = True
            self._current_streaming_message = ""
            self._update_status_message("Receiving response...")
            self._start_streaming_message()
        
        # Append chunk to current message
        self._current_streaming_message += chunk_text
        self._append_streaming_chunk(chunk_text)
    
    def _on_chat_processing_finished(self, result):
        """Handle successful AI processing completion for chat."""
        print(f"[FINISH DEBUG] Processing finished, streaming_started: {self._streaming_message_started}")
        self._cleanup_processing()
        
        if self._streaming_message_started:
            # Streaming was used - finalize the streaming message
            print(f"[FINISH DEBUG] Calling _finalize_streaming_message")
            self._finalize_streaming_message()
            # Add to conversation history
            self.conversation_history.append({"role": "AI", "content": self._current_streaming_message})
            # Reset streaming state
            self._streaming_message_started = False
            self._current_streaming_message = ""
        else:
            # No streaming - add complete message as before
            print(f"[FINISH DEBUG] No streaming, adding result: {result[:100]}...")
            self._add_to_chat("AI", result)
    
    def _on_chat_processing_error(self, error_message):
        """Handle AI processing error for chat."""
        self._cleanup_processing()
        # Add error message to chat
        self._add_to_chat("System", f"Error: {error_message}")
        QMessageBox.critical(self, "AI Processing Error", error_message)
    
    def _on_progress_update(self, message):
        """Handle progress updates."""
        # Update status message while keeping timer running
        self._update_status_message(message)
    
    def _cleanup_processing(self):
        """Clean up after processing."""
        self._is_processing = False
        self.progress_bar.setVisible(False)
        
        # Stop timer and hide status
        self._stop_processing_timer()
        
        # Re-enable buttons
        self.summarize_btn.setEnabled(True)
        self.footnotes_btn.setEnabled(True)
        self.simplify_btn.setEnabled(True)
        self.send_btn.setEnabled(True)
        self.question_input.setEnabled(True)
        
        # Clean up thread
        if self.thread and self.thread.isRunning():
            self.thread.quit()
            self.thread.wait()
            self.thread = None
        
        self.worker = None
    
    def _copy_conversation(self):
        """Copy the entire conversation to clipboard with HTML formatting."""
        try:
            conversation_html = self.chat_display.toHtml()
            plain_text = self.chat_display.toPlainText()
            
            print("=== COPY DEBUG - Chat with AI ===")
            print("RAW PLAIN TEXT:")
            print(plain_text)
            print("=== END COPY DEBUG ===\n")
            
            # Get the clipboard
            clipboard = QApplication.clipboard()
            
            # Create a QMimeData object to set both HTML and plain text
            mime_data = QMimeData()
            
            # Set HTML format (preserves formatting when pasting into rich text editors)
            mime_data.setHtml(conversation_html)
            
            # Also set plain text version (for plain text editors)
            mime_data.setText(plain_text)
            
            # Set the data to clipboard
            clipboard.setMimeData(mime_data)
            
            # Provide visual feedback
            original_text = self.copy_btn.text()
            self.copy_btn.setText("Copied!")
            QTimer.singleShot(1500, lambda: self.copy_btn.setText(original_text))
            
        except Exception as e:
            print(f"Error copying conversation: {e}")
            # Still provide feedback even on error
            original_text = self.copy_btn.text()
            self.copy_btn.setText("Error")
            QTimer.singleShot(1500, lambda: self.copy_btn.setText(original_text))
    
    
    def closeEvent(self, event):
        """Handle dialog close event."""
        if self._is_processing and self.worker:
            self.worker.stop()
        self._cleanup_processing()
        event.accept()


class VoiceChatDialog(QDialog):
    """
    Live voice chat dialog for natural conversation about selected text.
    Uses Gemini 2.5 Flash native audio dialog for real-time voice interaction.
    """
    # Qt signals for thread-safe UI updates
    status_updated = pyqtSignal(str)
    transcription_updated = pyqtSignal(str)
    conversation_updated = pyqtSignal(str, str)  # sender, message
    audio_play_requested = pyqtSignal(str)  # file_path
    
    def __init__(self, parent=None, selected_text="", title="", speech_section="", main_window=None, expanded_context=""):
        super().__init__(parent)
        self.selected_text = selected_text
        self.title = title
        self.speech_section = speech_section
        self.main_window = main_window
        self.expanded_context = expanded_context
        
        # Setup temp voice files folder
        self.temp_voice_folder = os.path.join(os.path.dirname(os.path.abspath(__file__)), "temp_voice_files")
        self._setup_temp_folder()
        
        # Audio and recording state
        self.input_devices = []
        self.output_devices = []
        self.selected_input_index = 0
        self.selected_output_index = 0
        self.is_recording = False
        self.audio_data = []
        
        # Real-time Live API streaming state
        self.live_session = None
        self.response_task = None
        self.audio_streaming_enabled = False
        self.audio_chunk_queue = None  # Will be initialized when session connects
        
        # Toggle mode for continuous live chat
        self.live_chat_active = False
        self.live_session_persistent = False
        
        # Audio playback
        self.audio_player = None
        self.audio_output = None
        
        # Processing state
        self.is_processing = False
        self.current_processing_thread = None
        
        # Thread safety
        import threading
        self._audio_lock = threading.Lock()
        self._processing_lock = threading.Lock()
        
        # Gemini client and Live API
        self.model = None
        self._api_key = None
        self.live_client = None
        self.live_session = None
        self.websocket_session = None
        self._is_live_connected = False
        self.connection_state = "disconnected"
        self.session_lock = threading.Lock()
        
        # UI state
        self._recording_timer = QTimer()
        self._recording_timer.timeout.connect(self._update_recording_indicator)
        self._recording_animation_state = 0
        
        self.setWindowTitle("Voice Chat")
        self.setMinimumSize(300, 250)
        self.resize(350, 300)
        
        # Disable minimize button
        self.setWindowFlags(
            Qt.WindowType.Window |
            Qt.WindowType.WindowMaximizeButtonHint |
            Qt.WindowType.WindowCloseButtonHint |
            Qt.WindowType.WindowSystemMenuHint
        )
        
        self._setup_ui()
        self._connect_signals()
        self._load_api_key()
        self._setup_gemini_model()
        
        # Load audio devices in background to avoid blocking UI
        QTimer.singleShot(100, self._load_audio_devices)
    
    def _setup_temp_folder(self):
        """Create and clean temp voice files folder."""
        try:
            import shutil
            
            # Create folder if it doesn't exist
            if not os.path.exists(self.temp_voice_folder):
                os.makedirs(self.temp_voice_folder)
                print(f"Created temp voice folder: {self.temp_voice_folder}")
            
            # Clean existing files
            self._clean_temp_folder()
            
        except Exception as e:
            print(f"Error setting up temp voice folder: {e}")
            # Fallback to system temp if our folder fails
            self.temp_voice_folder = tempfile.gettempdir()
    
    def _clean_temp_folder(self):
        """Clean all files from temp voice folder."""
        try:
            if os.path.exists(self.temp_voice_folder):
                for filename in os.listdir(self.temp_voice_folder):
                    if filename.endswith(('.wav', '.mp3', '.tmp')):
                        file_path = os.path.join(self.temp_voice_folder, filename)
                        try:
                            os.remove(file_path)
                            print(f"Cleaned temp voice file: {filename}")
                        except Exception as e:
                            print(f"Could not remove {filename}: {e}")
        except Exception as e:
            print(f"Error cleaning temp voice folder: {e}")
    
    def closeEvent(self, event):
        """Clean up temp files when dialog is closed."""
        print("Voice Chat dialog closing - cleaning up temp files...")
        self._clean_temp_folder()
        super().closeEvent(event)
    
    def _create_temp_audio_file(self, suffix='.wav'):
        """Create a temp audio file in our managed temp folder."""
        import uuid
        temp_filename = f"voice_{uuid.uuid4().hex}{suffix}"
        temp_path = os.path.join(self.temp_voice_folder, temp_filename)
        return temp_path
    
    def _connect_signals(self):
        """Connect Qt signals for thread-safe UI updates."""
        self.status_updated.connect(self.status_label.setText)
        self.transcription_updated.connect(self.transcription_display.setPlainText)
        self.conversation_updated.connect(self._add_to_conversation)
        self.audio_play_requested.connect(self._play_audio_file)
        
    def _setup_ui(self):
        """Create a compact voice chat UI."""
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(8)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Compact header
        title_label = QLabel("Voice Chat")
        title_label.setStyleSheet("QLabel { font-weight: bold; font-size: 12px; }")
        main_layout.addWidget(title_label)
        
        # Audio device and TTS selection - unified layout
        device_layout = QGridLayout()
        device_layout.setSpacing(4)
        
        # TTS Selection
        device_layout.addWidget(QLabel("Voice:"), 0, 0)
        self.tts_combo = QComboBox()
        self.tts_combo.addItems([  # "Gemini Live API", - Commented out due to duplicate response issues
                                "Gemini 2.5 Flash TTS", "Edge TTS", "Google TTS"])
        self.tts_combo.setCurrentIndex(1)  # Default to Edge TTS
        self.tts_combo.setStyleSheet("QComboBox { font-size: 10px; padding: 2px; }")
        self.tts_combo.currentTextChanged.connect(self._on_tts_selection_changed)
        device_layout.addWidget(self.tts_combo, 0, 1)
        
        # Mic Selection
        device_layout.addWidget(QLabel("Mic:"), 1, 0)
        self.input_device_combo = QComboBox()
        self.input_device_combo.addItem("Loading devices...")
        self.input_device_combo.setEnabled(False)
        self.input_device_combo.setStyleSheet("QComboBox { font-size: 10px; padding: 2px; }")
        self.input_device_combo.currentIndexChanged.connect(self._on_input_device_changed)
        device_layout.addWidget(self.input_device_combo, 1, 1)
        
        # Speaker Selection
        device_layout.addWidget(QLabel("Speaker:"), 2, 0)
        self.output_device_combo = QComboBox()
        self.output_device_combo.addItem("Loading devices...")
        self.output_device_combo.setEnabled(False)
        self.output_device_combo.setStyleSheet("QComboBox { font-size: 10px; padding: 2px; }")
        self.output_device_combo.currentIndexChanged.connect(self._on_output_device_changed)
        device_layout.addWidget(self.output_device_combo, 2, 1)
        
        main_layout.addLayout(device_layout)
        
        # Compact record button - now toggle mode
        self.record_btn = QPushButton("🎤 Start Voice Chat")
        self.record_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
                min-height: 35px;
            }
            QPushButton:hover { background-color: #1976D2; }
        """)
        self.record_btn.clicked.connect(self._toggle_live_chat)
        main_layout.addWidget(self.record_btn)
        
        # Recording indicator and status
        status_layout = QHBoxLayout()
        self.recording_indicator = QLabel("⚫")
        self.recording_indicator.setStyleSheet("QLabel { color: #ccc; font-size: 16px; }")
        status_layout.addWidget(self.recording_indicator)
        
        self.status_label = QLabel("Loading audio devices...")
        self.status_label.setStyleSheet("QLabel { font-size: 10px; color: #666; }")
        status_layout.addWidget(self.status_label, 1)
        main_layout.addLayout(status_layout)
        
        # Compact conversation display
        self.conversation_display = QTextEdit()
        self.conversation_display.setStyleSheet("""
            QTextEdit {
                font-size: 10px;
                border: 1px solid #ddd;
                border-radius: 3px;
                background-color: #fafafa;
            }
        """)
        self.conversation_display.setMaximumHeight(80)
        main_layout.addWidget(self.conversation_display)
        
        # Hidden transcription display for signal compatibility
        self.transcription_display = QTextEdit()
        self.transcription_display.setVisible(False)
        
        # Add keyboard shortcut for live chat toggle (V key)
        self.ptt_shortcut = QShortcut(QKeySequence("V"), self)
        self.ptt_shortcut.activated.connect(self._toggle_recording_shortcut)
        
        # Setup audio systems
        self._setup_audio_player()
        
        # NOTE: Live API connection disabled to prevent duplicate responses
        # Live API will only connect if explicitly selected as TTS option
        # print("Initializing Live API session for real-time audio streaming...")
        # self._connect_live_session()
    
    def _toggle_recording_shortcut(self):
        """Handle V key press for live chat toggle."""
        self._toggle_live_chat()
    
    def update_context(self, selected_text, title, speech_section, expanded_context=""):
        """Update the voice chat context with new selected text."""
        self.selected_text = selected_text
        self.title = title
        self.speech_section = speech_section
        self.expanded_context = expanded_context
        
        # Update window title
        self.setWindowTitle(f"Voice Chat - {title}")
        
        # Clear conversation history for fresh context
        self.conversation_display.clear()
        
        # Reset both traditional and Live API models for new context
        if self.model:
            try:
                # Reinitialize the traditional model to clear conversation history
                import google.generativeai as genai
                self.model = genai.GenerativeModel(
                    model_name="gemini-2.5-flash-lite",
                    generation_config={
                        "temperature": 0.7,
                        "top_p": 0.8,
                        "top_k": 40,
                        "max_output_tokens": 300,
                    }
                )
                print("Gemini model reset for new context")
            except Exception as e:
                print(f"Error resetting model: {e}")
        
        # Reset Live API session for new context
        if self.live_client:
            try:
                self._disconnect_live_session()
                # Reset WebSocket error state on context update
                if self.connection_state == "websocket_error":
                    self.connection_state = "disconnected"
                    print("Live API WebSocket error state reset - will retry on next request")
                print("Live API session reset for new context")
            except Exception as e:
                print(f"Error resetting Live API session: {e}")
        
        # Reinitialize models with new context for consistency
        self._setup_gemini_model()
        self._setup_gemini_client()
        
        print(f"Voice chat context updated: {title} - {speech_section}")
    
    def _kill_current_processing(self):
        """Kill any ongoing processing and reset state (simplified like Live API)."""
        print("Interrupting current processing...")
        self.is_processing = False
        
        # Simple audio stop - no complex Qt operations
        try:
            if self.audio_player:
                self.audio_player.stop()
        except:
            pass  # Ignore any audio errors
        
        # Just set flag - let threads die naturally
        self.current_processing_thread = None
        
        # Update UI 
        self.status_updated.emit("Ready for new input")
    
    def _play_audio_file(self, file_path):
        """Play audio file on main thread (simplified like Live API)."""
        import time
        play_start = time.time()
        
        try:
            print(f"\n🔊 [AUDIO] [{play_start:.3f}] _play_audio_file called:")
            print(f"   - File path: {file_path}")
            print(f"   - Audio player exists: {self.audio_player is not None}")
            print(f"   - Audio output exists: {self.audio_output is not None}")
            
            if self.audio_player:
                # Check current player state before starting
                current_state = self.audio_player.playbackState()
                current_source = self.audio_player.source()
                current_media_status = self.audio_player.mediaStatus()
                
                print(f"🎵 [AUDIO] Current player state: {current_state}")
                print(f"🎵 [AUDIO] Current source: {current_source}")
                print(f"🎵 [AUDIO] Current media status: {current_media_status}")
                
                # Check if file exists and get size
                import os
                if os.path.exists(file_path):
                    file_size = os.path.getsize(file_path)
                    print(f"📁 [AUDIO] File exists, size: {file_size} bytes")
                else:
                    print(f"❌ [AUDIO] File does not exist: {file_path}")
                    return
                
                source_start = time.time()
                print(f"📂 [AUDIO] [{source_start:.3f}] Setting source...")
                self.audio_player.setSource(QUrl.fromLocalFile(file_path))
                source_end = time.time()
                print(f"✅ [AUDIO] Source set in {source_end - source_start:.3f}s")
                
                play_call_start = time.time()
                print(f"▶️ [AUDIO] [{play_call_start:.3f}] Calling play()...")
                self.audio_player.play()
                play_call_end = time.time()
                print(f"✅ [AUDIO] play() call completed in {play_call_end - play_call_start:.3f}s")
                
                # Check state after play call
                new_state = self.audio_player.playbackState()
                new_media_status = self.audio_player.mediaStatus()
                print(f"🎵 [AUDIO] Player state after play(): {new_state}")
                print(f"🎵 [AUDIO] Media status after play(): {new_media_status}")
                
                # Clean up temp file after playback
                QTimer.singleShot(15000, lambda: self._cleanup_temp_file(file_path))
                
                # Mark processing as complete
                self.is_processing = False
                print(f"🔄 [AUDIO] Processing marked as complete")
                
                total_time = time.time() - play_start
                print(f"⏱️ [AUDIO] Total _play_audio_file time: {total_time:.3f}s")
            else:
                print("❌ [AUDIO] No audio player available")
        except Exception as e:
            print(f"❌ [AUDIO] Audio error: {e}")
            import traceback
            traceback.print_exc()
            self.is_processing = False
    
    def _setup_gemini_model(self):
        """Setup Gemini models for both text processing and Live API."""
        try:
            if self._api_key:
                # Setup traditional text model (fallback)
                import google.generativeai as genai
                genai.configure(api_key=self._api_key)
                
                self.model = genai.GenerativeModel(
                    model_name="gemini-2.5-flash-lite",
                    generation_config={
                        "temperature": 0.7,
                        "top_p": 0.8,
                        "top_k": 40,
                        "max_output_tokens": 300,
                    },
                    system_instruction=self._build_system_instruction()
                )
                
                # Setup Live API client
                from google import genai as live_genai
                self.live_client = live_genai.Client(api_key=self._api_key)
                print("✓ Gemini Live API client initialized")
                print("✓ Gemini text model ready for voice chat (fallback)")
            else:
                print("✗ No API key available for Gemini setup")
        except Exception as e:
            print(f"✗ Error setting up Gemini model: {e}")
    
    def _load_audio_devices(self):
        """Load available audio input and output devices."""
        try:
            import pyaudio
            
            # Clear loading states
            self.input_device_combo.clear()
            self.output_device_combo.clear()
            
            p = pyaudio.PyAudio()
            self.input_devices = []
            self.output_devices = []
            
            # Get system default devices
            default_input = p.get_default_input_device_info()
            default_output = p.get_default_output_device_info()
            
            # Add system default as first option
            self.input_device_combo.addItem("System Default")
            self.output_device_combo.addItem("System Default")
            
            # Store default device info
            self.input_devices.append({
                'index': default_input['index'],
                'name': 'System Default',
                'channels': default_input['maxInputChannels'],
                'rate': int(default_input['defaultSampleRate'])
            })
            
            self.output_devices.append({
                'index': default_output['index'],
                'name': 'System Default',
                'channels': default_output['maxOutputChannels'],
                'rate': int(default_output['defaultSampleRate'])
            })
            
            # Filter out system mappers and duplicates
            seen_input_names = {default_input['name']}
            seen_output_names = {default_output['name']}
            
            for i in range(p.get_device_count()):
                device_info = p.get_device_info_by_index(i)
                device_name = device_info['name']
                
                # Skip system mappers and low-level devices
                if any(skip in device_name.lower() for skip in ['mapper', 'primary', 'communications']):
                    continue
                
                # Input devices
                if device_info['maxInputChannels'] > 0 and device_name not in seen_input_names:
                    self.input_devices.append({
                        'index': i,
                        'name': device_name,
                        'channels': device_info['maxInputChannels'],
                        'rate': int(device_info['defaultSampleRate'])
                    })
                    self.input_device_combo.addItem(f"{device_name} ({device_info['maxInputChannels']} ch)")
                    seen_input_names.add(device_name)
                
                # Output devices
                if device_info['maxOutputChannels'] > 0 and device_name not in seen_output_names:
                    self.output_devices.append({
                        'index': i,
                        'name': device_name,
                        'channels': device_info['maxOutputChannels'],
                        'rate': int(device_info['defaultSampleRate'])
                    })
                    self.output_device_combo.addItem(f"{device_name} ({device_info['maxOutputChannels']} ch)")
                    seen_output_names.add(device_name)
            
            p.terminate()
            
            # Setup audio player for output
            self._setup_audio_player()
            
            # Re-enable combo boxes after successful loading
            self.input_device_combo.setEnabled(True)
            self.output_device_combo.setEnabled(True)
            
            if self.input_devices and self.output_devices:
                self.status_label.setText(f"Found {len(self.input_devices)} input and {len(self.output_devices)} output devices")
            elif self.input_devices:
                self.status_label.setText(f"Found {len(self.input_devices)} input devices, no output devices")
            elif self.output_devices:
                self.status_label.setText(f"Found {len(self.output_devices)} output devices, no input devices")
                self.record_btn.setEnabled(False)
            else:
                self.status_label.setText("No audio devices found")
                self.record_btn.setEnabled(False)
                
        except ImportError:
            # Re-enable combo boxes even on error
            self.input_device_combo.setEnabled(True)
            self.output_device_combo.setEnabled(True)
            self.status_label.setText("PyAudio not installed - voice features disabled")
            self.record_btn.setEnabled(False)
        except Exception as e:
            # Re-enable combo boxes even on error
            self.input_device_combo.setEnabled(True)
            self.output_device_combo.setEnabled(True)
            self.status_label.setText(f"Audio system error: {str(e)}")
            self.record_btn.setEnabled(False)
    
    def _setup_audio_player(self):
        """Setup Qt audio player for output."""
        try:
            print("[DEBUG] Creating QMediaPlayer...")
            self.audio_player = QMediaPlayer()
            print("[DEBUG] Creating QAudioOutput...")
            self.audio_output = QAudioOutput()
            print("[DEBUG] Connecting player to output...")
            self.audio_player.setAudioOutput(self.audio_output)
            
            # Connect signals for debugging and auto-play
            print("[DEBUG] Connecting signals...")
            self.audio_player.playbackStateChanged.connect(self._on_playback_state_changed)
            self.audio_player.mediaStatusChanged.connect(self._on_media_status_changed)
            self.audio_player.errorOccurred.connect(self._on_audio_error)
            
            # Auto-play when media is loaded
            self._pending_play = False
            
            print(f"[DEBUG] Audio player setup complete. Default device: {self.audio_output.device()}")
        except Exception as e:
            print(f"[ERROR] Error setting up audio player: {e}")
            import traceback
            traceback.print_exc()
            self.audio_player = None
            self.audio_output = None
    
    def _on_playback_state_changed(self, state):
        """Handle playback state changes and manage audio queue."""
        states = {0: "Stopped", 1: "Playing", 2: "Paused"}
        print(f"Audio playback state changed to: {states.get(state, state)}")
        
        # When playback stops, process next audio in queue
        if state == 0:  # Stopped
            print("🔄 Audio finished - checking queue for next chunk")
            self._audio_playing = False
            # Process next audio chunk if available
            if hasattr(self, '_audio_queue') and self._audio_queue:
                print(f"📋 Queue has {len(self._audio_queue)} chunks remaining")
                # Start next chunk playback asynchronously
                import asyncio
                try:
                    # Use the current event loop if available, otherwise create task differently
                    loop = asyncio.get_event_loop()
                    if loop.is_running():
                        # Schedule the task to run soon but not immediately
                        loop.call_soon(self._schedule_next_audio_chunk)
                    else:
                        asyncio.create_task(self._process_audio_queue())
                except Exception as e:
                    print(f"Error scheduling next audio chunk: {e}")
                    # Fallback to direct call after small delay
                    QTimer.singleShot(100, self._process_next_audio_sync)
            else:
                print("📋 Audio queue is empty - playback complete")
    
    def _schedule_next_audio_chunk(self):
        """Schedule next audio chunk processing."""
        try:
            import asyncio
            asyncio.create_task(self._process_audio_queue())
        except Exception as e:
            print(f"Error in _schedule_next_audio_chunk: {e}")
            # Fallback to sync method
            self._process_next_audio_sync()
    
    def _process_next_audio_sync(self):
        """Process next audio chunk synchronously (fallback)."""
        try:
            if hasattr(self, '_audio_queue') and self._audio_queue and not self._audio_playing:
                print("🔄 Processing next audio chunk (sync fallback)")
                # Use QTimer to delay slightly for better separation
                QTimer.singleShot(50, self._start_next_audio_chunk)
        except Exception as e:
            print(f"Error in _process_next_audio_sync: {e}")
    
    def _start_next_audio_chunk(self):
        """Start the next audio chunk from queue."""
        try:
            if hasattr(self, '_audio_queue') and self._audio_queue and not self._audio_playing:
                # Take just one chunk at a time for better control
                chunk_metadata = self._audio_queue.pop(0)
                
                # Extract actual audio data from metadata
                if isinstance(chunk_metadata, dict):
                    chunk_data = chunk_metadata['data']
                    chunk_id = chunk_metadata.get('id', 'unknown')
                else:
                    # Legacy format - raw bytes
                    chunk_data = chunk_metadata
                    chunk_id = 'legacy'
                
                print(f"🎵 Starting next audio chunk {chunk_id}: {len(chunk_data)} bytes")
                
                # Verify we have valid audio data
                if not isinstance(chunk_data, bytes):
                    print(f"❌ [FALLBACK] ERROR: chunk_data is not bytes: {type(chunk_data)}")
                    self._audio_playing = False
                    return
                
                self._audio_playing = True
                
                # Process single chunk
                import asyncio
                import threading
                
                def run_async():
                    try:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)
                        loop.run_until_complete(self._play_live_audio_response([chunk_data]))
                        loop.close()
                    except Exception as e:
                        print(f"Error in async audio processing: {e}")
                        self._audio_playing = False
                
                threading.Thread(target=run_async, daemon=True).start()
                
        except Exception as e:
            print(f"Error in _start_next_audio_chunk: {e}")
            self._audio_playing = False
    
    def _on_media_status_changed(self, status):
        """Handle media status changes."""
        import time
        timestamp = time.time()
        statuses = {
            0: "NoMedia", 1: "LoadingMedia", 2: "LoadedMedia", 3: "StalledMedia",
            4: "BufferingMedia", 5: "BufferedMedia", 6: "EndOfMedia", 7: "InvalidMedia"
        }
        status_name = statuses.get(status, f"Unknown({status})")
        
        print(f"\n📺 [MEDIA] [{timestamp:.3f}] STATUS CHANGED to: {status_name}")
        print(f"   - Audio playing flag: {getattr(self, '_audio_playing', 'undefined')}")
        print(f"   - Queue size: {len(getattr(self, '_audio_queue', []))}")
        
        if self.audio_player:
            current_playback_state = self.audio_player.playbackState()
            current_source = self.audio_player.source()
            print(f"   - Current playback state: {current_playback_state}")
            print(f"   - Current source: {current_source}")
        
        # Special handling for critical status changes
        # Import the enum to compare properly
        from PyQt6.QtMultimedia import QMediaPlayer
        
        if status == QMediaPlayer.MediaStatus.EndOfMedia:  # EndOfMedia
            print(f"🏁 [MEDIA] End of media reached - checking for more audio")
            # CRITICAL FIX: Playback state change isn't firing, so trigger manually
            prev_playing = getattr(self, '_audio_playing', None)
            self._audio_playing = False
            print(f"🔓 [MEDIA] Audio playing: {prev_playing} → {self._audio_playing}")
            
            # Check for buffered audio chunks or legacy queue
            if hasattr(self, '_audio_buffer') and self._audio_buffer:
                buffer_size = len(self._audio_buffer)
                print(f"📦 [MEDIA] Buffer has {buffer_size} chunks - scheduling immediate flush")
                # Reduced delay from 10ms to 5ms for minimal gaps between segments
                QTimer.singleShot(5, lambda: asyncio.create_task(self._flush_audio_buffer()))
            elif hasattr(self, '_audio_queue') and self._audio_queue:
                queue_size = len(self._audio_queue)
                print(f"📋 [MEDIA] Legacy queue has {queue_size} chunks - scheduling next")
                QTimer.singleShot(50, self._process_next_audio_sync)
            else:
                print(f"✅ [MEDIA] All audio processed - playback complete")
                
        elif status == QMediaPlayer.MediaStatus.InvalidMedia:  # InvalidMedia
            print(f"❌ [MEDIA] Invalid media detected - potential file issue")
            self._audio_playing = False
        elif status == QMediaPlayer.MediaStatus.LoadedMedia:  # LoadedMedia
            print(f"✅ [MEDIA] Media loaded successfully")
        elif status == QMediaPlayer.MediaStatus.BufferedMedia:  # BufferedMedia
            print(f"📦 [MEDIA] Media buffered and ready")
    
    def _on_audio_error(self, error):
        """Handle audio player errors."""
        import time
        timestamp = time.time()
        errors = {
            0: "NoError", 1: "ResourceError", 2: "FormatError", 3: "NetworkError", 4: "AccessDeniedError"
        }
        error_name = errors.get(error, f"Unknown({error})")
        
        print(f"\n🚨 [ERROR] [{timestamp:.3f}] AUDIO PLAYER ERROR: {error_name}")
        print(f"   - Audio playing flag: {getattr(self, '_audio_playing', 'undefined')}")
        print(f"   - Queue size: {len(getattr(self, '_audio_queue', []))}")
        
        if self.audio_player:
            error_string = self.audio_player.errorString()
            current_state = self.audio_player.playbackState()
            current_source = self.audio_player.source()
            
            print(f"   - Error string: {error_string}")
            print(f"   - Current state: {current_state}")
            print(f"   - Current source: {current_source}")
            
            # Critical error handling
            if error != 0:  # Not NoError
                print(f"❌ [ERROR] Critical audio error - may need to reset audio_playing flag")
                self._audio_playing = False
                print(f"🔄 [ERROR] Audio playing flag reset to FALSE due to error")
    
    def _load_api_key(self):
        """Load API key from file or settings."""
        api_key_path = self._get_api_key_path()
        if api_key_path.exists():
            try:
                # Try to load as JSON first (new format)
                if api_key_path.name.endswith('.json'):
                    with open(api_key_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        self._api_key = data.get('default_key', '')
                else:
                    # Load as plain text (old format)
                    with open(api_key_path, 'r', encoding='utf-8') as f:
                        self._api_key = f.read().strip()
                
                if self._api_key:
                    self._setup_gemini_client()
                else:
                    self.status_label.setText("No API key found - please configure in API Key Manager")
                    
            except json.JSONDecodeError:
                # If JSON loading fails, try as plain text
                try:
                    with open(api_key_path, 'r', encoding='utf-8') as f:
                        self._api_key = f.read().strip()
                    if self._api_key:
                        self._setup_gemini_client()
                    else:
                        self.status_label.setText("No API key found - please configure in API Key Manager")
                except Exception as e:
                    self.status_label.setText(f"Error loading API key: {str(e)}")
            except Exception as e:
                self.status_label.setText(f"Error loading API key: {str(e)}")
        else:
            self.status_label.setText("No API key configured - please set up in API Key Manager")
    
    def _get_api_key_path(self):
        """Get the path to the API key file using the same method as other dialogs."""
        try:
            import sys
            import os
            from pathlib import Path
            
            # Get base path correctly for frozen (PyInstaller) or script execution
            if getattr(sys, 'frozen', False):
                # If the application is run as a bundle/frozen executable
                base_path = os.path.dirname(sys.executable)
            else:
                # If the application is run as a script
                base_path = os.path.dirname(os.path.abspath(__file__))

            # Check for new API key manager JSON file first
            data_folder = os.path.join(base_path, "data")
            os.makedirs(data_folder, exist_ok=True)
            
            json_key_path = os.path.join(data_folder, "gemini_api_keys.json")
            if os.path.exists(json_key_path):
                return Path(json_key_path)
            
            # Fallback to old single key file
            old_key_path = os.path.join(data_folder, "api_key.txt")
            return Path(old_key_path)
            
        except Exception as e:
            print(f"Error determining API key path: {e}")
            # Final fallback
            try:
                from pathlib import Path
                data_dir = Path.home() / "Scriptoria" / "Data"
                data_dir.mkdir(parents=True, exist_ok=True)
                return data_dir / "gemini_api_keys.json"
            except:
                return Path("gemini_api_keys.json")
    
    def _setup_gemini_client(self):
        """Setup Gemini Live API client for direct audio streaming."""
        print("=== GEMINI LIVE API DEBUGGING ===")
        try:
            import google.generativeai as genai
            print(f"✓ google.generativeai imported successfully")
            print(f"✓ genai version: {getattr(genai, '__version__', 'Unknown')}")
            print(f"✓ API key configured (length: {len(self._api_key) if self._api_key else 0})")
            
            genai.configure(api_key=self._api_key)
            
            # Debug: List all available attributes in genai module
            genai_attrs = [attr for attr in dir(genai) if not attr.startswith('_')]
            print(f"✓ Available genai attributes: {genai_attrs}")
            
            # Check for Live API related attributes
            live_api_attrs = [attr for attr in genai_attrs if 'live' in attr.lower() or 'client' in attr.lower()]
            print(f"✓ Live API related attributes: {live_api_attrs}")
            
            # Setup Live API client for direct audio streaming
            try:
                print("--- Attempting Live API client creation ---")
                
                # Method 1: Try google.genai.Client (separate package)
                try:
                    print("Method 1: Trying 'from google import genai'...")
                    from google import genai as new_genai
                    print(f"✓ google.genai imported: {type(new_genai)}")
                    new_genai_attrs = [attr for attr in dir(new_genai) if not attr.startswith('_')]
                    print(f"✓ google.genai attributes: {new_genai_attrs}")
                    
                    if hasattr(new_genai, 'Client'):
                        print("✓ Found Client in google.genai")
                        self.live_client = new_genai.Client(api_key=self._api_key)
                        print("✓ Live API client created using google.genai.Client")
                    else:
                        print("✗ No Client found in google.genai")
                        raise AttributeError("Client not in google.genai")
                        
                except ImportError as e:
                    print(f"✗ Method 1 failed - ImportError: {e}")
                    
                    # Method 2: Try google.generativeai.Client
                    try:
                        print("Method 2: Trying google.generativeai.Client...")
                        if hasattr(genai, 'Client'):
                            print("✓ Found Client in google.generativeai")
                            self.live_client = genai.Client(api_key=self._api_key)
                            print("✓ Live API client created using google.generativeai.Client")
                        else:
                            print("✗ No Client found in google.generativeai")
                            raise AttributeError("Client not in google.generativeai")
                            
                    except Exception as e2:
                        print(f"✗ Method 2 failed: {e2}")
                        
                        # Method 3: Check for other Live API classes
                        print("Method 3: Looking for alternative Live API classes...")
                        possible_classes = ['LiveAPIClient', 'LiveClient', 'LiveSession', 'live']
                        found_class = None
                        
                        for class_name in possible_classes:
                            if hasattr(genai, class_name):
                                print(f"✓ Found {class_name} in genai")
                                found_class = getattr(genai, class_name)
                                break
                        
                        if found_class:
                            try:
                                self.live_client = found_class(api_key=self._api_key)
                                print(f"✓ Live API client created using {class_name}")
                            except Exception as e3:
                                print(f"✗ Failed to create client with {class_name}: {e3}")
                                raise e3
                        else:
                            print("✗ No Live API classes found")
                            raise AttributeError("No Live API client classes available")
                
                # Also setup regular model as backup
                print("--- Setting up regular Gemini model as backup ---")
                self.model = genai.GenerativeModel(
                    model_name="gemini-2.5-flash",
                    generation_config={
                        "temperature": 0.7,
                        "top_p": 0.8,
                        "top_k": 0,
                        "max_output_tokens": 2000,
                    },
                    system_instruction=self._build_system_instruction()
                )
                print("✓ Regular Gemini model created successfully")
                
                if self.live_client:
                    print(f"✓ Live API client ready: {type(self.live_client)}")
                    print(f"✓ Live client attributes: {[attr for attr in dir(self.live_client) if not attr.startswith('_')]}")
                    self.status_label.setText("✓ Live API Ready - Direct Audio Streaming Available")
                else:
                    print("✗ Live API client is None")
                    self.status_label.setText("Live API client is None - using text fallback")
                
            except Exception as e:
                print(f"✗ LIVE API SETUP FAILED: {e}")
                print(f"✗ Exception type: {type(e)}")
                import traceback
                print(f"✗ Full traceback:\n{traceback.format_exc()}")
                
                # Fallback to regular model
                print("--- Setting up text fallback model ---")
                self.model = genai.GenerativeModel(
                    model_name="gemini-2.5-flash",
                    generation_config={
                        "temperature": 0.7,
                        "top_p": 0.8,
                        "top_k": 0,
                        "max_output_tokens": 2000,
                    },
                    system_instruction=self._build_system_instruction()
                )
                print("✓ Text fallback model created")
                self.status_label.setText(f"Live API unavailable: {str(e)} - Using text fallback")
                
        except Exception as e:
            print(f"✗ CRITICAL ERROR in Gemini setup: {e}")
            import traceback
            print(f"✗ Full traceback:\n{traceback.format_exc()}")
            self.status_label.setText(f"Error setting up Gemini: {str(e)}")
        
        print("=== END GEMINI LIVE API DEBUGGING ===\n")
    
    def _test_live_api_connection(self):
        """Test if Live API is available and working."""
        try:
            # This is a simple test - actual connection will be made during conversation
            self.status_label.setText("Live API ready - Hold mic button to start voice conversation")
        except Exception as e:
            self.status_label.setText(f"Live API test failed: {str(e)}")
    
    def _build_system_instruction(self):
        """Build system instruction with context."""
        section_info = f" from the '{self.speech_section}' section" if self.speech_section else ""
        return f"""You are an intelligent AI assistant having a voice conversation about a text{section_info} from "{self.title}".

Text: "{self.selected_text}"

CRITICAL: Get straight to the point. Cut to the chase immediately.

Voice chat rules:
- STRICTLY 1-2 complete sentences - count your sentences and STOP
- Maximum 300 tokens total (plenty of room to complete your thoughts)
- Lead with your main insight first
- No introductions, no setup, no filler words
- Skip explanations - just give the core point
- Plain text only - no formatting
- Don't ask questions back
- IMPORTANT: Complete your sentence then STOP - do not get cut off mid-thought

Examples:
BAD: "This is an interesting passage that shows Jesus putting human need above religious rules. The Pharisees see it as a direct challenge to their authority."
GOOD: "Jesus puts human need above Sabbath law. The Pharisees see this as challenging their authority."

Be conversational but smart - provide insights without asking questions back."""
    
    def _on_input_device_changed(self, index):
        """Handle input device selection change."""
        if 0 <= index < len(self.input_devices):
            self.selected_input_index = index
            device = self.input_devices[index]
            self.status_label.setText(f"Selected microphone: {device['name']}")
    
    def _on_output_device_changed(self, index):
        """Handle output device selection change."""
        if 0 <= index < len(self.output_devices):
            self.selected_output_index = index
            device = self.output_devices[index]
            self.status_label.setText(f"Selected speaker: {device['name']}")
            # Update audio output device if player is available
            self._update_audio_output_device()
    
    def _on_tts_selection_changed(self, text):
        """Handle TTS selection change."""
        print(f"TTS selection changed to: {text}")
        # Update status label to show current TTS selection
        if hasattr(self, 'status_label'):
            self.status_label.setText(f"Ready to start voice chat - Using {text}")
    
    def _test_microphone(self):
        """Test microphone input by recording a short sample."""
        if not self.input_devices:
            return
        
        try:
            import pyaudio
            import numpy as np
            
            device = self.input_devices[self.selected_input_index]
            
            p = pyaudio.PyAudio()
            
            # Record for 2 seconds to test
            stream = p.open(
                format=pyaudio.paInt16,
                channels=1,
                rate=16000,
                input=True,
                input_device_index=device['index'],
                frames_per_buffer=1024
            )
            
            self.status_label.setText("Testing microphone... speak now!")
            
            frames = []
            for _ in range(int(16000 / 1024 * 2)):  # 2 seconds
                data = stream.read(1024)
                frames.append(data)
            
            stream.stop_stream()
            stream.close()
            p.terminate()
            
            # Analyze audio level and show detailed info
            audio_data = np.frombuffer(b''.join(frames), dtype=np.int16)
            volume = np.sqrt(np.mean(audio_data**2))
            max_volume = np.max(np.abs(audio_data))
            
            if volume > 200:  # Lowered threshold for quieter mics
                self.status_label.setText(f"✅ Microphone working! Avg: {int(volume)}, Peak: {int(max_volume)}")
            elif volume > 80:
                self.status_label.setText(f"⚠️ Microphone quiet but working. Avg: {int(volume)}, Peak: {int(max_volume)} - Try speaking louder")
            else:
                self.status_label.setText(f"❌ Very low input. Avg: {int(volume)}, Peak: {int(max_volume)} - Try different device or speak during test")
                
        except Exception as e:
            self.status_label.setText(f"Microphone test failed: {str(e)}")
    
    def _test_speaker(self):
        """Test speaker output by playing a test tone."""
        if not self.output_devices:
            return
        
        try:
            import numpy as np
            import tempfile
            import wave
            
            # Generate a test tone (440 Hz for 1 second)
            sample_rate = 44100
            duration = 1.0
            frequency = 440.0
            
            t = np.linspace(0, duration, int(sample_rate * duration), False)
            wave_data = np.sin(2 * np.pi * frequency * t) * 0.3  # 30% volume
            
            # Convert to 16-bit integers
            wave_data_int = (wave_data * 32767).astype(np.int16)
            
            # Save to temporary WAV file
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                temp_path = temp_file.name
                
                with wave.open(temp_path, 'w') as wav_file:
                    wav_file.setnchannels(1)  # Mono
                    wav_file.setsampwidth(2)  # 2 bytes per sample
                    wav_file.setframerate(sample_rate)
                    wav_file.writeframes(wave_data_int.tobytes())
            
            # Play the test tone
            self.status_label.setText("Playing test tone...")
            if self.audio_player:
                self.audio_player.setSource(QUrl.fromLocalFile(temp_path))
                self.audio_player.play()
                
                # Clean up temp file after a delay
                QTimer.singleShot(2000, lambda: self._cleanup_temp_file(temp_path))
            else:
                self.status_label.setText("Audio player not available")
                
        except Exception as e:
            self.status_label.setText(f"Speaker test failed: {str(e)}")
    
    def _cleanup_temp_file(self, file_path):
        """Clean up temporary audio file."""
        try:
            import os
            if os.path.exists(file_path):
                os.remove(file_path)
        except:
            pass
    
    def _update_audio_output_device(self):
        """Update the audio output device for playback."""
        if not self.audio_output or not self.output_devices:
            return
        
        try:
            # Note: Qt's QAudioOutput doesn't directly support device selection by index
            # This is a placeholder for more advanced audio routing
            device = self.output_devices[self.selected_output_index]
            # For now, we'll use the default device and log the selection
            print(f"Audio output set to: {device['name']}")
        except Exception as e:
            print(f"Error updating audio output device: {e}")
    
    def _toggle_live_chat(self):
        """Toggle voice chat session on/off - uses TTS selection to determine mode."""
        # Check TTS selection to determine which system to use
        selected_tts = self.tts_combo.currentText()
        
        if not self.live_chat_active:
            if "Live API" in selected_tts:
                # Use Live API system (currently disabled)
                print("[VOICE CHAT] Live API is disabled - falling back to standard TTS")
                self._start_standard_voice_chat()
            else:
                # Use standard TTS system
                self._start_standard_voice_chat()
        else:
            self._stop_live_chat()
    
    def _start_standard_voice_chat(self):
        """Start standard voice chat using selected TTS (not Live API)."""
        print("[VOICE CHAT] Starting standard voice chat session...")
        
        if self.live_chat_active or not self.input_devices:
            print("[VOICE CHAT] Already active or no input devices")
            return
        
        try:
            # Kill any ongoing processing
            self._kill_current_processing()
            
            # Set voice chat state (but NOT Live API mode)
            self.live_chat_active = True
            self.live_session_persistent = False  # Don't use Live API
            self.is_recording = True
            
            # Update UI to show voice chat active
            self.record_btn.setText("🔴 Voice Chat Active - Click to Stop")
            self.record_btn.setStyleSheet("""
                QPushButton {
                    background-color: #f44336;
                    color: white;
                    border: none;
                    padding: 8px;
                    border-radius: 4px;
                    font-weight: bold;
                    font-size: 11px;
                    min-height: 35px;
                }
                QPushButton:hover { background-color: #d32f2f; }
            """)
            
            self.recording_indicator.setVisible(True)
            self._recording_timer.start(500)
            self.transcription_display.clear()
            self.status_label.setText("🎤 Voice Chat Active - Using standard TTS")
            
            # Start audio recording (but don't connect to Live API)
            self._start_audio_recording()
            
            print("[VOICE CHAT] Standard voice chat started successfully")
            
        except Exception as e:
            print(f"[VOICE CHAT] Error starting standard voice chat: {e}")
            self.live_chat_active = False
            self.is_recording = False
            self._recording_timer.stop()
            self.recording_indicator.setVisible(False)
    
    def _start_live_chat(self):
        """Start continuous live chat session."""
        print("[LIVE CHAT] Starting continuous live chat session...")
        
        if self.live_chat_active or not self.input_devices:
            print("[LIVE CHAT] Already active or no input devices")
            return
        
        try:
            # Kill any ongoing processing
            self._kill_current_processing()
            
            # Set live chat state
            self.live_chat_active = True
            self.live_session_persistent = True
            self.is_recording = True  # Keep for compatibility with audio callback
            
            # Update UI to show live state
            self.record_btn.setText("🔴 Chat Active - Click to Stop")
            self.record_btn.setStyleSheet("""
                QPushButton {
                    background-color: #f44336;
                    color: white;
                    border: none;
                    padding: 8px;
                    border-radius: 4px;
                    font-weight: bold;
                    font-size: 11px;
                    min-height: 35px;
                }
                QPushButton:hover { background-color: #d32f2f; }
            """)
            
            self.recording_indicator.setVisible(True)
            self._recording_timer.start(500)  # Slower blink for live mode
            self.transcription_display.clear()
            self.status_label.setText("🔴 Chat Active - Speak freely, AI will respond")
            
            # Connect to Live API session
            if self.connection_state != "connected":
                print("[LIVE CHAT] Connecting to Live API...")
                self._connect_live_session()
            
            # Enable continuous audio streaming
            self.audio_streaming_enabled = True
            print("✅ Live chat session started - continuous audio streaming enabled")
            
            # Start audio recording
            self._start_audio_recording()
            
        except Exception as e:
            print(f"[LIVE CHAT] Error starting live chat: {e}")
            self._stop_live_chat()
    
    def _stop_live_chat(self):
        """Stop live chat session and disconnect."""
        print("[LIVE CHAT] Stopping live chat session...")
        
        if not self.live_chat_active:
            return
        
        # Set state
        self.live_chat_active = False
        self.live_session_persistent = False
        self.is_recording = False
        
        # Update UI back to ready state
        self.record_btn.setText("🎤 Start Voice Chat")
        self.record_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 11px;
                min-height: 35px;
            }
            QPushButton:hover { background-color: #1976D2; }
        """)
        
        self.recording_indicator.setVisible(False)
        self._recording_timer.stop()
        self.status_label.setText("Ready to start voice chat")
        
        # Disable audio streaming and disconnect session
        self.audio_streaming_enabled = False
        self._stop_audio_recording()
        self._disconnect_live_session()
        
        print("✅ Live chat session stopped")
    
    def _start_audio_recording(self):
        """Start audio recording using pyaudio."""
        try:
            import pyaudio
            
            if not self.input_devices:
                return
            
            device = self.input_devices[self.selected_input_index]
            
            self.p = pyaudio.PyAudio()
            self.audio_data = []
            
            self.stream = self.p.open(
                format=pyaudio.paInt16,
                channels=1,
                rate=16000,
                input=True,
                input_device_index=device['index'],
                frames_per_buffer=1024,
                stream_callback=self._audio_callback
            )
            
            self.stream.start_stream()
            
        except Exception as e:
            self.status_label.setText(f"Recording error: {str(e)}")
            self.is_recording = False
    
    def _audio_callback(self, in_data, frame_count, time_info, status):
        """Audio stream callback - streams ALL audio to Live API for Voice Activity Detection."""
        # Always store for fallback when recording
        if self.is_recording:
            self.audio_data.append(in_data)
        
        # Only stream to Live API if it's the selected TTS option and persistent session is active
        if (self.audio_streaming_enabled and 
            self.live_session_persistent and  # Only when Live API is explicitly enabled
            self.live_session and 
            self.connection_state == "connected" and
            self.audio_chunk_queue):
            
            try:
                # Put chunk in queue for async processing (non-blocking)
                # This includes both speech and silence - Live API will detect activity
                self.audio_chunk_queue.put_nowait(in_data)
            except Exception as e:
                print(f"Error queuing audio chunk: {e}")
        
        return (in_data, pyaudio.paContinue)
    
    def _stop_audio_recording(self):
        """Stop audio recording and process the audio."""
        try:
            if hasattr(self, 'stream'):
                self.stream.stop_stream()
                self.stream.close()
            if hasattr(self, 'p'):
                self.p.terminate()
            
            # Process the recorded audio
            if self.audio_data:
                self._process_audio()
            
        except Exception as e:
            self.status_label.setText(f"Stop recording error: {str(e)}")
    
    def _process_audio(self):
        """Process recorded audio using Gemini Live API with fallback."""
        try:
            if not self.audio_data:
                self.status_label.setText("No audio data recorded")
                return
                
            # Convert audio data to the format Gemini expects (16-bit PCM, 16kHz, mono)
            audio_bytes = self._convert_audio_for_gemini()
            
            # Check selected voice option
            selected_voice = self.tts_combo.currentText()
            
            # Use Live API if selected and available
            if selected_voice == "Gemini Live API" and self.live_client and self.connection_state != "websocket_error":
                try:
                    self.status_updated.emit("Using Gemini Live API...")
                    
                    # Run Live API in background thread with asyncio
                    import threading
                    import asyncio
                    
                    def run_live_api():
                        try:
                            asyncio.run(self._process_audio_live_api(audio_bytes))
                        except Exception as e:
                            error_msg = str(e).lower()
                            print(f"Live API failed: {e}")
                            
                            # Mark WebSocket errors to avoid retry
                            if "1007" in error_msg or "invalid frame payload" in error_msg:
                                self.connection_state = "websocket_error"
                                print("Marking Live API as unavailable due to WebSocket issues")
                                # Update status indicator
                                if self.tts_combo.currentText() == "Gemini Live API":
                                    self.live_api_status.setText("🟡")
                                    self.live_api_status.setToolTip("Live API Status: WebSocket Issues (Using fallback)")
                            
                            # Fallback to traditional method
                            self.status_updated.emit("Live API failed, falling back to traditional method...")
                            self._process_audio_with_text_api(audio_bytes)
                    
                    self.current_processing_thread = threading.Thread(target=run_live_api, daemon=True)
                    self.current_processing_thread.start()
                    return
                    
                except Exception as e:
                    print(f"Live API setup failed: {e}")
                    self.status_updated.emit("Live API unavailable, using traditional method...")
            elif selected_voice == "Gemini Live API" and self.connection_state == "websocket_error":
                self.status_updated.emit("Live API disabled (WebSocket issues), using traditional method...")
            elif selected_voice == "Gemini Live API" and not self.live_client:
                self.status_updated.emit("Live API not available, using traditional method...")
            else:
                self.status_updated.emit(f"Using {selected_voice} for voice processing...")
            
            # Use traditional speech-to-text + text API approach
            self._process_audio_with_text_api(audio_bytes)
            
        except Exception as e:
            self.status_label.setText(f"Audio processing error: {str(e)}")
            print(f"Audio processing error: {e}")
    
    def _convert_audio_for_gemini(self):
        """Convert recorded audio to Gemini Live API format (16-bit PCM, 16kHz, mono)."""
        try:
            import numpy as np
            
            # Combine all audio chunks
            raw_audio = b''.join(self.audio_data)
            
            # Convert to numpy array (16-bit integers)
            audio_array = np.frombuffer(raw_audio, dtype=np.int16)
            
            # The audio is already 16kHz from our recording, so just ensure it's the right format
            # Convert to bytes in the format Gemini expects
            return audio_array.tobytes()
            
        except Exception as e:
            print(f"Audio conversion error: {e}")
            return b''
    
    def _process_audio_with_text_api(self, audio_bytes):
        """Process audio using speech-to-text then regular Gemini text API."""
        try:
            import threading
            
            self.status_updated.emit("Converting speech to text...")
            self.transcription_updated.emit("🎙️ Processing your speech...")
            
            # Run speech processing in a separate thread (simplified like Live API)
            def run_speech_processing():
                try:
                    self.is_processing = True
                    
                    # Convert audio to text using Gemini
                    text = self._convert_audio_to_text(audio_bytes)
                    
                    if not self.is_processing:  # Check if interrupted
                        return
                    
                    if text and text.strip():
                        # Update UI with transcription
                        self.transcription_updated.emit(text)
                        self.status_updated.emit("Getting AI response...")
                        
                        # Send to Gemini if still processing
                        if self.is_processing:
                            self._send_to_gemini(text)
                    else:
                        self.status_updated.emit("No speech detected")
                        
                except Exception as e:
                    print(f"Processing error: {e}")
                    self.status_updated.emit(f"Error: {str(e)}")
                finally:
                    # Let audio playback handle setting is_processing to False
                    pass
            
            # Start processing in background thread
            self.current_processing_thread = threading.Thread(target=run_speech_processing, daemon=True)
            self.current_processing_thread.start()
            
        except Exception as e:
            self.status_updated.emit(f"Audio processing error: {str(e)}")
            print(f"Audio processing error: {e}")
    
    def _convert_audio_to_text(self, audio_bytes):
        """Convert audio bytes to text using Gemini's audio processing."""
        try:
            import tempfile
            import wave
            
            # Save audio to temporary WAV file
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                temp_path = temp_file.name
                
                # Write audio data as WAV file
                with wave.open(temp_path, 'w') as wav_file:
                    wav_file.setnchannels(1)  # Mono
                    wav_file.setsampwidth(2)  # 2 bytes per sample (16-bit)
                    wav_file.setframerate(16000)  # 16kHz sample rate
                    wav_file.writeframes(audio_bytes)
            
            # Use Gemini to transcribe the audio
            import google.generativeai as genai
            
            # Upload the audio file
            audio_file = genai.upload_file(temp_path)
            
            # Create a model for audio transcription
            model = genai.GenerativeModel("gemini-2.5-flash")
            
            # Generate transcription
            response = model.generate_content([
                "Please transcribe this audio file accurately. Return only the spoken text, no additional formatting or explanation.",
                audio_file
            ])
            
            # Clean up temp file
            import os
            try:
                os.remove(temp_path)
            except:
                pass
            
            # Handle different response types
            if hasattr(response, 'text') and response.text:
                return response.text.strip()
            elif hasattr(response, 'candidates') and response.candidates:
                # Check if there are valid parts
                for candidate in response.candidates:
                    if hasattr(candidate, 'content') and candidate.content.parts:
                        for part in candidate.content.parts:
                            if hasattr(part, 'text') and part.text:
                                return part.text.strip()
            
            print(f"Speech-to-text: No valid transcription found. Response: {response}")
            return ""
            
        except Exception as e:
            print(f"Speech-to-text error: {e}")
            return ""
    
    async def _process_audio_live_api(self, audio_bytes):
        """Legacy method - now using real-time streaming instead of blob processing.
        
        This method is kept as a fallback for when real-time streaming isn't available.
        The new approach uses persistent sessions with real-time chunk streaming.
        """
        try:
            print(f"=== FALLBACK: Using blob-based Live API processing ===")
            print(f"Note: Real-time streaming is preferred for better latency")
            
            # If we have a connected session, we shouldn't be here
            if self.connection_state == "connected" and self.live_session:
                print("⚠️ Live session already connected - this fallback shouldn't be needed")
                return
            
            # This is a simplified fallback version
            self.status_updated.emit("Using fallback Live API processing...")
            print("❌ Real-time streaming not available, using traditional STT + text processing")
            
            # Fall back to regular text processing
            raise Exception("Live API real-time streaming not available - using traditional processing")
                
        except Exception as e:
            print(f"Live API fallback processing failed: {e}")
            # Re-raise to trigger traditional STT + text processing
            raise e
    
    async def _play_live_audio_response(self, audio_chunks):
        """Play audio response from Live API."""
        import time
        playback_start = time.time()
        
        try:
            print(f"\n🎬 [PLAYBACK] [{playback_start:.3f}] STARTING _play_live_audio_response:")
            print(f"   - Number of chunks: {len(audio_chunks) if audio_chunks else 0}")
            print(f"   - Chunk sizes: {[len(chunk) for chunk in audio_chunks] if audio_chunks else []}")
            print(f"   - Audio playing flag: {getattr(self, '_audio_playing', 'undefined')}")
            
            import tempfile
            import wave
            
            if not audio_chunks:
                print(f"⚠️ [PLAYBACK] No audio chunks provided - returning")
                return
            
            # Combine audio chunks
            combine_start = time.time()
            combined_audio = b''.join(audio_chunks)
            combine_end = time.time()
            
            print(f"🔗 [PLAYBACK] Audio combining took {combine_end - combine_start:.3f}s")
            print(f"   - Combined size: {len(combined_audio)} bytes")
            print(f"   - Expected duration: ~{len(combined_audio) / (24000 * 2):.2f}s (at 24kHz 16-bit)")
            
            if len(combined_audio) == 0:
                print(f"⚠️ [PLAYBACK] Combined audio is empty - returning")
                return
            
            # Save to temporary WAV file for playback (Gemini Live outputs 24kHz, 16-bit PCM)
            file_start = time.time()
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                temp_path = temp_file.name
                print(f"💾 [PLAYBACK] Creating WAV file: {temp_path}")
                
                with wave.open(temp_path, 'w') as wav_file:
                    wav_file.setnchannels(1)  # Mono
                    wav_file.setsampwidth(2)  # 2 bytes per sample (16-bit)
                    wav_file.setframerate(24000)  # Gemini Live outputs 24kHz
                    wav_file.writeframes(combined_audio)
                    
            file_end = time.time()
            print(f"✅ [PLAYBACK] WAV file creation took {file_end - file_start:.3f}s")
            
            # Check if file exists and get size
            import os
            if os.path.exists(temp_path):
                file_size = os.path.getsize(temp_path)
                print(f"📁 [PLAYBACK] WAV file size: {file_size} bytes")
            else:
                print(f"❌ [PLAYBACK] WAV file was not created!")
                return
            
            # Play through Qt audio system
            emit_start = time.time()
            print(f"📡 [PLAYBACK] [{emit_start:.3f}] Emitting audio_play_requested signal...")
            print(f"   - Current audio player state: {self.audio_player.playbackState() if self.audio_player else 'No player'}")
            print(f"   - Current media status: {self.audio_player.mediaStatus() if self.audio_player else 'No player'}")
            
            self.audio_play_requested.emit(temp_path)
            emit_end = time.time()
            
            print(f"✅ [PLAYBACK] Signal emitted in {emit_end - emit_start:.3f}s")
            print(f"⏱️ [PLAYBACK] Total _play_live_audio_response time: {emit_end - playback_start:.3f}s")
            
        except Exception as e:
            print(f"❌ [PLAYBACK] Live audio playback error: {e}")
            import traceback
            traceback.print_exc()
            # Fallback to TTS if audio playback fails
            self.status_updated.emit("Audio playback failed, using TTS")
    
    def _connect_live_session(self):
        """Establish persistent Live API session for real-time audio streaming."""
        try:
            if not self.live_client:
                print("No Live API client available")
                return False
            
            with self.session_lock:
                if self.live_session and self.connection_state == "connected":
                    print("Live session already connected")
                    return True
                
                self.connection_state = "connecting"
                print("Establishing persistent Live API session...")
                
                # Create async task to connect and maintain session
                import threading
                import asyncio
                
                def connect_session():
                    try:
                        asyncio.run(self._async_connect_session())
                    except Exception as e:
                        print(f"Session connection failed: {e}")
                        self.connection_state = "disconnected"
                
                threading.Thread(target=connect_session, daemon=True).start()
                return True
                
        except Exception as e:
            print(f"Failed to connect Live session: {e}")
            self.connection_state = "disconnected"
            return False
    
    async def _async_connect_session(self):
        """Async method to establish and maintain Live API session."""
        try:
            from google import genai
            import google.genai.types as types
            import asyncio
            
            print("=== CONNECTING PERSISTENT LIVE SESSION ===")
            
            # Use simple audio-only config that works
            config = {"response_modalities": ["AUDIO"]}
            model = "gemini-2.5-flash-preview-native-audio-dialog"
            
            print(f"Connecting to {model} with config: {config}")
            
            async with self.live_client.aio.live.connect(model=model, config=config) as session:
                print("✅ Live API session connected!")
                self.live_session = session
                self.connection_state = "connected"
                self._is_live_connected = True
                
                # Initialize audio chunk queue
                if not self.audio_chunk_queue:
                    self.audio_chunk_queue = asyncio.Queue()
                
                # Start continuous response listener
                self.response_task = asyncio.create_task(self._listen_for_responses(session))
                
                # Start audio chunk processor  
                chunk_processor_task = asyncio.create_task(self._process_audio_chunks(session))
                
                print("✅ Session ready for real-time audio streaming")
                self.status_updated.emit("Live API ready for conversation")
                
                # Keep session alive - wait for tasks to complete
                await asyncio.gather(self.response_task, chunk_processor_task)
                
        except Exception as e:
            print(f"Session connection error: {e}")
            self.connection_state = "disconnected"
            self.live_session = None
    
    def _disconnect_live_session(self):
        """Disconnect Live API session and cleanup resources."""
        try:
            # Don't disconnect if we have a persistent live chat session
            if hasattr(self, 'live_session_persistent') and self.live_session_persistent:
                print("Live session is persistent - keeping connection for continuous chat")
                return
                
            with self.session_lock:
                if self.live_session:
                    print("Disconnecting Live API session...")
                    
                    # Cancel response task
                    if self.response_task and not self.response_task.done():
                        self.response_task.cancel()
                        self.response_task = None
                    
                    # Clear audio streaming state
                    self.audio_streaming_enabled = False
                    
                    # Stop audio recording when session disconnects
                    self._stop_audio_recording()
                    
                    # Session cleanup handled by async context manager
                    self.live_session = None
                
                self.connection_state = "disconnected"
                self._is_live_connected = False
                print("Live API session disconnected")
                
        except Exception as e:
            print(f"Error disconnecting Live session: {e}")
    
    def _reconnect_if_needed(self):
        """Reconnect Live API session if connection was lost."""
        try:
            if self.connection_state == "disconnected":
                return self._connect_live_session()
            return True
        except Exception as e:
            print(f"Reconnection failed: {e}")
            return False
    
    async def _process_audio_chunks(self, session):
        """Process audio chunks from the queue and stream to Live API."""
        try:
            from google import genai
            import google.genai.types as types
            
            print("Audio chunk processor started")
            
            while True:
                try:
                    # Get audio chunk from queue (1024 bytes from audio callback)
                    chunk = await self.audio_chunk_queue.get()
                    
                    if chunk is None:  # Shutdown signal
                        break
                    
                    # Create audio blob for this chunk
                    audio_blob = types.Blob(
                        data=chunk,
                        mime_type="audio/pcm"
                    )
                    
                    # Stream chunk to Live API
                    await session.send_realtime_input(audio=audio_blob)
                    print(f"Streamed {len(chunk)} bytes to Live API")
                    
                    self.audio_chunk_queue.task_done()
                    
                except Exception as e:
                    print(f"Error processing audio chunk: {e}")
                    
        except Exception as e:
            print(f"Audio chunk processor error: {e}")
    
    async def _listen_for_responses(self, session):
        """Continuously listen for audio responses from Live API."""
        try:
            print("Response listener started")
            
            async for message in session.receive():
                print(f"Received Live API message: {type(message)}")
                
                # Check for audioStreamEnd to flush remaining chunks
                if hasattr(message, 'audioStreamEnd') or (
                    hasattr(message, 'server_content') and 
                    hasattr(message.server_content, 'audioStreamEnd') and 
                    message.server_content.audioStreamEnd
                ):
                    print("🔚 Audio stream end detected - flushing chunks")
                    await self._handle_audio_stream_end()
                    continue
                
                audio_data = None
                
                # Check for direct audio data first (preferred)
                if hasattr(message, 'data') and message.data:
                    audio_data = message.data
                    print(f"✅ NATIVE AUDIO RECEIVED: {len(audio_data)} bytes")
                
                # Only check server content if no direct audio data
                elif hasattr(message, 'server_content') and message.server_content:
                    sc = message.server_content
                    if hasattr(sc, 'model_turn') and sc.model_turn:
                        if hasattr(sc.model_turn, 'parts'):
                            for part in sc.model_turn.parts:
                                if hasattr(part, 'inline_data') and part.inline_data:
                                    if hasattr(part.inline_data, 'data'):
                                        audio_data = part.inline_data.data
                                        print(f"✅ AUDIO FROM SERVER: {len(audio_data)} bytes")
                                        break  # Only take the first audio part
                
                # Play audio if we got any
                if audio_data:
                    await self._play_live_audio_chunk(audio_data)
                
        except Exception as e:
            print(f"Response listener error: {e}")
    
    async def _play_live_audio_chunk(self, audio_chunk):
        """Add audio chunk to buffer for smooth playback."""
        import time
        timestamp = time.time()
        chunk_id = getattr(self, '_chunk_counter', 0) + 1
        setattr(self, '_chunk_counter', chunk_id)
        
        try:
            print(f"\n🔵 [CHUNK-{chunk_id}] [{timestamp:.3f}] RECEIVED: {len(audio_chunk)} bytes")
            
            # Initialize audio buffering system
            if not hasattr(self, '_audio_buffer'):
                self._audio_buffer = []
                self._audio_playing = False
                self._chunks_received = 0
                self._buffer_timer = None
                self._last_chunk_time = timestamp
                print(f"🔧 [CHUNK-{chunk_id}] Audio buffering system initialized")
            
            # Add chunk to buffer
            self._audio_buffer.append(audio_chunk)
            self._chunks_received += 1
            self._last_chunk_time = timestamp
            
            print(f"📋 [CHUNK-{chunk_id}] Buffer status:")
            print(f"   - Buffer size: {len(self._audio_buffer)} chunks")
            print(f"   - Audio playing: {self._audio_playing}")
            print(f"   - Total chunks received: {self._chunks_received}")
            
            # If this is the first chunk, update UI
            if self._chunks_received == 1:
                print(f"🎬 [CHUNK-{chunk_id}] First chunk - updating UI")
                self.conversation_updated.emit("You", "[Voice input]")
                self.conversation_updated.emit("AI", "[Live API Audio Response - Streaming]")
                self.status_updated.emit("🔊 Streaming Live API response...")
            
            # Strategy: Start playing as soon as possible with minimal buffering
            if not self._audio_playing:
                if len(self._audio_buffer) >= 2:  # Reduced from 3 to 2 chunks for faster start
                    print(f"🚀 [CHUNK-{chunk_id}] Starting buffered playback with {len(self._audio_buffer)} chunks")
                    await self._flush_audio_buffer()
                elif self._chunks_received == 1:
                    # For the very first chunk, start playback almost immediately
                    print(f"⏰ [CHUNK-{chunk_id}] Setting timer for immediate playback")
                    QTimer.singleShot(25, lambda: asyncio.create_task(self._flush_audio_buffer()))  # Reduced from 50ms to 25ms
            else:
                # If already playing, just accumulate in buffer - it will be processed when current audio ends
                print(f"📦 [CHUNK-{chunk_id}] Added to buffer (audio currently playing)")
        
        except Exception as e:
            print(f"Error in _play_live_audio_chunk: {e}")
    
    async def _flush_audio_buffer(self):
        """Flush the audio buffer by combining chunks and playing them."""
        if not hasattr(self, '_audio_buffer') or not self._audio_buffer:
            return
            
        import time
        self._last_flush_time = time.time()
        
        # Take up to 8 chunks from buffer for smooth playback (about 0.32 seconds)
        chunks_to_play = self._audio_buffer[:8]
        self._audio_buffer = self._audio_buffer[8:]  # Keep remaining chunks
        
        if chunks_to_play:
            print(f"🎵 Flushing {len(chunks_to_play)} chunks, {len(self._audio_buffer)} remaining in buffer")
            
            # Combine chunks
            combined_audio = b''.join(chunks_to_play)
            
            # Create metadata for the combined chunk
            chunk_metadata = {
                'data': combined_audio,
                'id': f"buffered-{len(chunks_to_play)}chunks",
                'timestamp': self._last_flush_time,
                'size': len(combined_audio)
            }
            
            # Play the combined audio
            self._audio_playing = True
            QTimer.singleShot(0, lambda: self._play_live_audio_response([chunk_metadata]))
    
    async def _process_audio_queue(self):
        """Process audio queue one chunk at a time to prevent overlapping."""
        try:
            if self._audio_playing or not hasattr(self, '_audio_queue') or not self._audio_queue:
                print(f"⏸️ Skipping queue process - playing: {self._audio_playing}, queue size: {len(getattr(self, '_audio_queue', []))}")
                return
            
            print(f"🎵 Processing audio queue - {len(self._audio_queue)} chunks remaining")
            self._audio_playing = True
            
            # Process only ONE chunk at a time for no overlapping
            if self._audio_queue:
                chunk_metadata = self._audio_queue.pop(0)
                
                # Extract actual audio data from metadata
                if isinstance(chunk_metadata, dict):
                    chunk_data = chunk_metadata['data']
                    chunk_id = chunk_metadata.get('id', 'unknown')
                    chunk_size = chunk_metadata.get('size', len(chunk_data))
                else:
                    # Legacy format - raw bytes
                    chunk_data = chunk_metadata
                    chunk_id = 'legacy'
                    chunk_size = len(chunk_data)
                
                print(f"🎵 Processing single audio chunk {chunk_id}: {chunk_size} bytes")
                print(f"   - Actual data type: {type(chunk_data)}")
                print(f"   - Actual data size: {len(chunk_data)} bytes")
                print(f"   - Remaining in queue: {len(self._audio_queue)}")
                
                # Verify we have valid audio data
                if not isinstance(chunk_data, bytes):
                    print(f"❌ [QUEUE] ERROR: chunk_data is not bytes: {type(chunk_data)}")
                    self._audio_playing = False
                    return
                
                await self._play_live_audio_response([chunk_data])
            else:
                self._audio_playing = False
                print("📋 No chunks to process")
                
        except Exception as e:
            print(f"Audio queue processing error: {e}")
            self._audio_playing = False
    
    async def _handle_audio_stream_end(self):
        """Handle audioStreamEnd to flush remaining audio chunks."""
        try:
            print("Audio stream ended - flushing remaining chunks")
            
            # Process all remaining chunks in queue
            if hasattr(self, '_audio_queue') and self._audio_queue:
                remaining_chunk_metadata = self._audio_queue.copy()
                self._audio_queue.clear()
                
                if remaining_chunk_metadata:
                    # Extract actual audio data from metadata
                    remaining_chunks = []
                    for chunk_metadata in remaining_chunk_metadata:
                        if isinstance(chunk_metadata, dict):
                            remaining_chunks.append(chunk_metadata['data'])
                        else:
                            remaining_chunks.append(chunk_metadata)
                    
                    print(f"Flushing {len(remaining_chunks)} remaining audio chunks")
                    await self._play_live_audio_response(remaining_chunks)
            
            # Reset response collection
            if hasattr(self, '_current_response_chunks'):
                self._current_response_chunks = []
                self._chunks_received = 0
                
        except Exception as e:
            print(f"Audio stream end handling error: {e}")
    
    def closeEvent(self, event):
        """Handle dialog close event - cleanup Live API session."""
        try:
            # Stop live chat if active
            if hasattr(self, 'live_chat_active') and self.live_chat_active:
                self._stop_live_chat()
            else:
                self._disconnect_live_session()
            super().closeEvent(event)
        except Exception as e:
            print(f"Error during close event: {e}")
            super().closeEvent(event)
    
    # Removed _test_live_api_with_text and _async_test_live_api_with_text methods
    
    # OLD CODE SECTION REMOVED - HAD INDENTATION ISSUES
    # The original debug-heavy audio conversion code was removed to prevent syntax errors
    
    def _send_to_gemini(self, text):
        """Send text to Gemini for response."""
        try:
            if not self.model:
                self.status_label.setText("Gemini not initialized")
                return
            
            self.status_label.setText("Getting AI response...")
            
            # Add user message to conversation
            self._add_to_conversation("You", text)
            
            # Build context-aware prompt
            context_prompt = self._build_context_prompt(text)
            
            # Send to Gemini with context
            response = self.model.generate_content(context_prompt)
            
            # Add AI response to conversation
            self._add_to_conversation("AI", response.text)
            
            # Try to generate and play audio response if native audio model is available
            self._generate_and_play_audio_response(response.text)
            
            self.status_label.setText("Ready for next voice input")
            
        except Exception as e:
            self.status_label.setText(f"Gemini error: {str(e)}")
            self._add_to_conversation("System", f"Error: {str(e)}")
    
    def _build_context_prompt(self, user_input):
        """Build a context-aware prompt including selected text and document context."""
        prompt_parts = []
        
        # Add document context if available
        if self.title and self.title != "Untitled Document":
            prompt_parts.append(f"Document: {self.title}")
        
        if self.speech_section:
            prompt_parts.append(f"Section: {self.speech_section}")
        
        # Add selected text context if available
        if self.selected_text and self.selected_text.strip():
            prompt_parts.append(f"Selected text for discussion:\n{self.selected_text.strip()}")
        
        # Add user's voice input
        prompt_parts.append(f"User's question/comment: {user_input}")
        
        # Add conversation style instruction to EVERY request
        style_instruction = """
CRITICAL: Respond like you're TALKING in a voice chat:
- Keep response to 1-2 sentences maximum (this is voice, not text)
- Be conversational but informative
- NO follow-up questions - just provide insights
- End naturally without prompting user to continue"""
        
        # Combine all parts
        if len(prompt_parts) > 1:
            context_prompt = "\n\n".join(prompt_parts)
            context_prompt += style_instruction
        else:
            # If no context, just use the user input with style instruction
            context_prompt = user_input + style_instruction
        
        return context_prompt
    
    async def _try_alternative_live_api(self, audio_bytes):
        """Alternative Live API approach to work around websocket issues."""
        try:
            from google import genai
            import google.genai.types as types
            
            self.status_updated.emit("Trying alternative Live API connection...")
            
            # Try using direct API calls instead of Live API
            import requests
            import base64
            
            # Convert raw PCM to WAV format for Gemini
            import tempfile
            import wave
            
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                temp_path = temp_file.name
                
                with wave.open(temp_path, 'w') as wav_file:
                    wav_file.setnchannels(1)  # Mono
                    wav_file.setsampwidth(2)  # 2 bytes per sample (16-bit)
                    wav_file.setframerate(16000)  # 16kHz
                    wav_file.writeframes(audio_bytes)
            
            # Read WAV file and convert to base64
            with open(temp_path, 'rb') as wav_file:
                wav_data = wav_file.read()
            
            audio_b64 = base64.b64encode(wav_data).decode('utf-8')
            
            # Clean up temp file
            import os
            os.unlink(temp_path)
            
            # Make direct API call to Gemini
            url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={self._api_key}"
            
            payload = {
                "contents": [
                    {
                        "parts": [
                            {
                                "text": self._build_system_instruction()
                            },
                            {
                                "inlineData": {
                                    "mimeType": "audio/wav",
                                    "data": audio_b64
                                }
                            }
                        ]
                    }
                ]
            }
            
            headers = {
                "Content-Type": "application/json"
            }
            
            response = requests.post(url, json=payload, headers=headers)
            
            if response.status_code == 200:
                result = response.json()
                if 'candidates' in result and len(result['candidates']) > 0:
                    candidate = result['candidates'][0]
                    if 'content' in candidate and 'parts' in candidate['content']:
                        for part in candidate['content']['parts']:
                            if 'text' in part:
                                full_text_response = part['text']
                                break
            else:
                raise Exception(f"API call failed: {response.status_code} - {response.text}")
            
            self.status_updated.emit("Audio processed successfully with direct API!")
            
            # Update UI and play response
            if full_text_response:
                self.conversation_updated.emit("You", "[Voice input]")
                self.conversation_updated.emit("AI", full_text_response)
                self._play_tts_response(full_text_response)
            else:
                self.conversation_updated.emit("System", "No response received")
                
            self.status_updated.emit("Alternative Live API completed successfully")
            
        except Exception as e:
            print(f"Alternative Live API error: {e}")
            raise e
    
    async def _play_gemini_audio_response(self, audio_chunks):
        """Play Gemini's native audio response through selected output device."""
        try:
            import tempfile
            import wave
            import numpy as np
            
            # Combine audio chunks
            combined_audio = b''.join(audio_chunks)
            
            # Convert audio data (Gemini outputs 24kHz, 16-bit PCM)
            audio_array = np.frombuffer(combined_audio, dtype=np.int16)
            
            # Save to temporary WAV file for playback
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                temp_path = temp_file.name
                
                with wave.open(temp_path, 'w') as wav_file:
                    wav_file.setnchannels(1)  # Mono
                    wav_file.setsampwidth(2)  # 2 bytes per sample (16-bit)
                    wav_file.setframerate(24000)  # Gemini outputs 24kHz
                    wav_file.writeframes(combined_audio)
            
            # Play through Qt audio system
            if self.audio_player:
                self.audio_player.setSource(QUrl.fromLocalFile(temp_path))
                self.audio_player.play()
                
                # Clean up temp file after playback
                QTimer.singleShot(15000, lambda: self._cleanup_temp_file(temp_path))
            
        except Exception as e:
            print(f"Audio playback error: {e}")
    
    def _play_gemini_native_audio_response(self, audio_chunks):
        """Play Gemini's native audio response through selected output device."""
        try:
            import tempfile
            import wave
            
            # Combine audio chunks
            combined_audio = b''.join(audio_chunks)
            
            # Save to temporary WAV file for playback (Gemini outputs 24kHz, 16-bit PCM)
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                temp_path = temp_file.name
                
                with wave.open(temp_path, 'w') as wav_file:
                    wav_file.setnchannels(1)  # Mono
                    wav_file.setsampwidth(2)  # 2 bytes per sample (16-bit)
                    wav_file.setframerate(24000)  # Gemini outputs 24kHz
                    wav_file.writeframes(combined_audio)
            
            # Play through Qt audio system on main thread
            if self.audio_player:
                self.audio_player.setSource(QUrl.fromLocalFile(temp_path))
                self.audio_player.play()
                
                # Clean up temp file after playback
                QTimer.singleShot(15000, lambda: self._cleanup_temp_file(temp_path))
            
        except Exception as e:
            print(f"Native audio playback error: {e}")
    
    async def _fallback_text_conversation(self):
        """Fallback to text-based conversation when Live API fails."""
        try:
            # Use regular Gemini model as fallback
            if hasattr(self, 'model') and self.model:
                self.status_updated.emit("Using text fallback...")
                self.transcription_updated.emit("Live API unavailable - using text mode")
                
                # Simulate text input (in real implementation, you'd use STT here)
                text_input = "Voice input (Live API not available)"
                response = self.model.generate_content(text_input)
                
                self.conversation_updated.emit("You", text_input)
                self.conversation_updated.emit("AI", response.text)
                
                # Use TTS for audio output
                self._play_tts_response(response.text)
                
                self.status_updated.emit("Text fallback complete - Ready for next input")
            else:
                self.status_updated.emit("No fallback available - please check API configuration")
                
        except Exception as e:
            print(f"Fallback error: {e}")
            self.status_updated.emit(f"Fallback error: {str(e)}")
    
    def _send_to_gemini(self, text):
        """Send text to Gemini for response."""
        try:
            if not self.model:
                self.status_label.setText("Gemini not initialized")
                return
            
            self.status_label.setText("Getting AI response...")
            
            # Add user message to conversation
            self._add_to_conversation("You", text)
            
            # Build context-aware prompt
            context_prompt = self._build_context_prompt(text)
            
            # Send to Gemini with context
            response = self.model.generate_content(context_prompt)
            
            # Add AI response to conversation
            self._add_to_conversation("AI", response.text)
            
            # Try to generate and play audio response if native audio model is available
            self._generate_and_play_audio_response(response.text)
            
            self.status_label.setText("Ready for next voice input")
            
        except Exception as e:
            self.status_label.setText(f"Gemini error: {str(e)}")
            self._add_to_conversation("System", f"Error: {str(e)}")
    
    def _build_context_prompt(self, user_input):
        """Build a context-aware prompt including selected text and document context."""
        prompt_parts = []
        
        # Add document context if available
        if self.title and self.title != "Untitled Document":
            prompt_parts.append(f"Document: {self.title}")
        
        if self.speech_section:
            prompt_parts.append(f"Section: {self.speech_section}")
        
        # Add selected text context if available
        if self.selected_text and self.selected_text.strip():
            prompt_parts.append(f"Selected text for discussion:\n{self.selected_text.strip()}")
        
        # Add user's voice input
        prompt_parts.append(f"User's question/comment: {user_input}")
        
        # Add conversation style instruction to EVERY request
        style_instruction = """
CRITICAL: Respond like you're TALKING in a voice chat:
- Keep response to 1-2 sentences maximum (this is voice, not text)
- Be conversational but informative
- NO follow-up questions - just provide insights
- End naturally without prompting user to continue"""
        
        # Combine all parts
        if len(prompt_parts) > 1:
            context_prompt = "\n\n".join(prompt_parts)
            context_prompt += style_instruction
        else:
            # If no context, just use the user input with style instruction
            context_prompt = user_input + style_instruction
        
        return context_prompt
    
    def _generate_and_play_audio_response(self, text):
        """Generate and play audio response using TTS or Gemini native audio."""
        try:
            # For now, use basic TTS as fallback (you can enhance this with Gemini's native audio)
            self._play_tts_response(text)
        except Exception as e:
            print(f"Audio response error: {e}")
    
    def _play_tts_response(self, text):
        """Play text-to-speech response using selected TTS option."""
        try:
            # Check if processing was killed
            if not self.is_processing:
                print("TTS cancelled - processing was stopped")
                return
                
            temp_path = None
            selected_tts = self.tts_combo.currentText()
            print(f"User selected TTS: {selected_tts}")
            
            # Handle different TTS options
            if selected_tts == "Gemini Live API":
                # Live API should have already provided audio, so this is a fallback
                print("Live API fallback - using Gemini TTS...")
                temp_path = self._try_gemini_tts(text)
            elif selected_tts == "Gemini 2.5 Flash TTS":
                print("Attempting Gemini TTS...")
                temp_path = self._try_gemini_tts(text)
            elif selected_tts == "Edge TTS":
                print("Attempting Edge TTS...")
                temp_path = self._try_edge_tts(text)
            
            # Fallback options if selected TTS fails
            if not temp_path and selected_tts not in ["Gemini Live API", "Gemini 2.5 Flash TTS"]:
                print("Falling back to Gemini TTS...")
                temp_path = self._try_gemini_tts(text)
            if not temp_path and selected_tts != "Edge TTS":
                print("Falling back to Edge TTS...")
                temp_path = self._try_edge_tts(text)
            
            # Play the generated audio using signal (thread-safe)
            if temp_path and self.audio_player:
                print(f"Generated TTS audio file: {temp_path}")
                print(f"Audio player state: {self.audio_player}")
                print(f"Audio output device: {self.audio_output}")
                
                # Use signal to play audio on main thread
                self.audio_play_requested.emit(temp_path)
            elif not temp_path:
                print("No TTS audio file generated")
                self.status_label.setText("TTS generation failed")
            elif not self.audio_player:
                print("Audio player not available")
                self.status_label.setText("Audio player not initialized")
            else:
                self.status_label.setText("No TTS options available")
                
        except Exception as e:
            print(f"TTS error: {e}")
            self.status_label.setText(f"TTS error: {str(e)}")
    
    def _actually_play_audio(self, temp_path):
        """Fallback manual play if auto-play didn't work."""
        try:
            print(f"Manual play attempt - Player state: {self.audio_player.playbackState()}")
            print(f"Media status: {self.audio_player.mediaStatus()}")
            
            # If media is loaded but not playing, force play
            if self.audio_player.mediaStatus() == 2:  # LoadedMedia
                self.audio_player.play()
                print("Manual play() called")
            
            # Clean up temp file after playback (15 seconds should be enough)
            QTimer.singleShot(15000, lambda: self._cleanup_temp_file(temp_path))
            
        except Exception as e:
            print(f"Manual playback error: {e}")
            import traceback
            traceback.print_exc()
    
    def _try_gemini_tts(self, text):
        """Try Gemini 2.5 Flash TTS (highest quality, most natural)."""
        try:
            import tempfile
            import requests
            import base64
            import time
            
            start_time = time.time()
            print(f"Starting Gemini TTS for: '{text[:50]}{'...' if len(text) > 50 else ''}'")
            
            # Use Gemini 2.5 Flash TTS API with optimized settings
            url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key={self._api_key}"
            
            payload = {
                "contents": [
                    {
                        "parts": [
                            {
                                "text": text
                            }
                        ]
                    }
                ],
                "generationConfig": {
                    "response_modalities": ["AUDIO"],
                    "speech_config": {
                        "voice_config": {
                            "prebuilt_voice_config": {
                                "voice_name": "Aoede"
                            }
                        }
                    }
                }
            }
            
            headers = {
                "Content-Type": "application/json"
            }
            
            # Optimized request with shorter timeout for faster fallback
            api_start = time.time()
            response = requests.post(url, json=payload, headers=headers, timeout=30)
            api_time = time.time() - api_start
            print(f"Gemini TTS API call took: {api_time:.2f}s")
            
            if response.status_code == 200:
                result = response.json()
                
                # Look for audio data in the response
                if 'candidates' in result and len(result['candidates']) > 0:
                    candidate = result['candidates'][0]
                    if 'content' in candidate and 'parts' in candidate['content']:
                        for part in candidate['content']['parts']:
                            if 'inlineData' in part:
                                inline_data = part['inlineData']
                                if 'mimeType' in inline_data and 'audio' in inline_data['mimeType']:
                                    # Decode base64 audio data
                                    audio_data = base64.b64decode(inline_data['data'])
                                    
                                    # Handle Gemini TTS audio format
                                    mime_type = inline_data['mimeType']
                                    print(f"Gemini TTS returned mime type: {mime_type}")
                                    
                                    if 'L16' in mime_type or 'pcm' in mime_type:
                                        # Convert raw PCM to WAV format for Qt player
                                        import wave
                                        import struct
                                        
                                        # Extract sample rate from mime type
                                        sample_rate = 24000  # default
                                        if 'rate=' in mime_type:
                                            rate_part = mime_type.split('rate=')[1]
                                            sample_rate = int(rate_part.split(';')[0])
                                        
                                        # Create WAV file with proper headers
                                        temp_path = self._create_temp_audio_file('.wav')
                                        
                                        with wave.open(temp_path, 'w') as wav_file:
                                            wav_file.setnchannels(1)  # Mono
                                            wav_file.setsampwidth(2)  # 16-bit
                                            wav_file.setframerate(sample_rate)
                                            wav_file.writeframes(audio_data)
                                    
                                    elif 'wav' in mime_type:
                                        temp_path = self._create_temp_audio_file('.wav')
                                        with open(temp_path, 'wb') as temp_file:
                                            temp_file.write(audio_data)
                                    elif 'mp3' in mime_type:
                                        temp_path = self._create_temp_audio_file('.mp3')
                                        with open(temp_path, 'wb') as temp_file:
                                            temp_file.write(audio_data)
                                    elif 'ogg' in mime_type:
                                        temp_path = self._create_temp_audio_file('.ogg')
                                        with open(temp_path, 'wb') as temp_file:
                                            temp_file.write(audio_data)
                                    else:
                                        # Fallback: assume it's raw PCM and convert to WAV
                                        import wave
                                        temp_path = self._create_temp_audio_file('.wav')
                                        
                                        with wave.open(temp_path, 'w') as wav_file:
                                            wav_file.setnchannels(1)  # Mono
                                            wav_file.setsampwidth(2)  # 16-bit
                                            wav_file.setframerate(24000)  # Default rate
                                            wav_file.writeframes(audio_data)
                                    
                                    print(f"Using Gemini 2.5 Flash TTS (highest quality) - {mime_type}")
                                    return temp_path
                
                print(f"Gemini TTS response format unexpected: {result}")
                return None
            else:
                print(f"Gemini TTS API error: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            print(f"Gemini TTS error: {e}")
            return None
    
    def _try_edge_tts(self, text):
        """Try Microsoft Edge TTS (high quality, natural voices)."""
        try:
            import edge_tts
            import asyncio
            import tempfile
            import threading
            import queue
            
            # Use a thread to handle the async operation
            result_queue = queue.Queue()
            
            def run_edge_tts():
                try:
                    async def generate_edge_tts():
                        # Use a natural voice
                        voice = "en-US-AriaNeural"  # Female voice
                        communicate = edge_tts.Communicate(text, voice)
                        
                        with tempfile.NamedTemporaryFile(suffix='.mp3', delete=False) as temp_file:
                            temp_path = temp_file.name
                            await communicate.save(temp_path)
                            return temp_path
                    
                    # Create new event loop for this thread
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    temp_path = loop.run_until_complete(generate_edge_tts())
                    loop.close()
                    
                    result_queue.put(("success", temp_path))
                except Exception as e:
                    result_queue.put(("error", str(e)))
            
            # Run in thread and wait for result
            thread = threading.Thread(target=run_edge_tts)
            thread.start()
            thread.join(timeout=10)  # 10 second timeout
            
            if not result_queue.empty():
                result_type, result_value = result_queue.get()
                if result_type == "success":
                    print("Using Edge TTS (high quality)")
                    return result_value
                else:
                    print(f"Edge TTS error: {result_value}")
                    return None
            else:
                print("Edge TTS timeout")
                return None
            
        except ImportError:
            print("Edge TTS not available - install with: pip install edge-tts")
            return None
        except Exception as e:
            print(f"Edge TTS error: {e}")
            return None
    
    def _try_bark_tts(self, text):
        """Try Bark TTS (very high quality, expressive, local)."""
        try:
            from bark import SAMPLE_RATE, generate_audio, preload_models
            from scipy.io.wavfile import write as write_wav
            import tempfile
            import threading
            import queue
            import numpy as np
            
            # Use a thread to handle TTS generation
            result_queue = queue.Queue()
            
            def run_bark_tts():
                try:
                    import torch
                    import os
                    
                    # Temporarily patch torch.load for Bark compatibility
                    original_load = torch.load
                    def patched_load(*args, **kwargs):
                        # Force weights_only=False for Bark model loading
                        if 'weights_only' not in kwargs:
                            kwargs['weights_only'] = False
                        return original_load(*args, **kwargs)
                    
                    # Apply patch
                    torch.load = patched_load
                    
                    try:
                        # Enable GPU acceleration (you have RTX 5090!)
                        if 'BARK_FORCE_CPU' in os.environ:
                            del os.environ['BARK_FORCE_CPU']
                        
                        # Check if CUDA is available and set device
                        if torch.cuda.is_available():
                            print(f"Using GPU acceleration: {torch.cuda.get_device_name()}")
                            device = "cuda"
                        else:
                            print("CUDA not available, using CPU")
                            device = "cpu"
                        
                        # Preload models on first use (this downloads models if needed)
                        print("Loading Bark models (this may take time on first use)...")
                        preload_models()
                        
                    finally:
                        # Restore original torch.load
                        torch.load = original_load
                    
                    # Generate audio with a good default voice
                    # You can experiment with different voice presets:
                    # v2/en_speaker_0 through v2/en_speaker_9 for different voices
                    voice_preset = "v2/en_speaker_1"  # Nice female voice
                    
                    print(f"Generating speech with Bark (voice: {voice_preset})...")
                    audio_array = generate_audio(text, history_prompt=voice_preset)
                    
                    # Create temporary WAV file
                    with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                        temp_path = temp_file.name
                        
                    # Convert to 16-bit integers and write WAV file
                    audio_array_16bit = (audio_array * 32767).astype(np.int16)
                    write_wav(temp_path, SAMPLE_RATE, audio_array_16bit)
                    
                    result_queue.put(("success", temp_path))
                    
                except Exception as e:
                    result_queue.put(("error", str(e)))
            
            # Run in thread and wait for result
            thread = threading.Thread(target=run_bark_tts)
            thread.start()
            thread.join(timeout=30)  # 30 second timeout (faster with GPU)
            
            if not result_queue.empty():
                result_type, result_value = result_queue.get()
                if result_type == "success":
                    print("Using Bark TTS (very expressive, local)")
                    return result_value
                else:
                    print(f"Bark TTS error: {result_value}")
                    return None
            else:
                print("Bark TTS timeout")
                return None
            
        except ImportError:
            print("Bark TTS not available - install with: pip install suno-bark")
            return None
        except Exception as e:
            print(f"Bark TTS error: {e}")
            return None
    
    def _try_windows_sapi_tts(self, text):
        """Try Windows SAPI TTS (native Windows voices)."""
        try:
            import pyttsx3
            import tempfile
            
            engine = pyttsx3.init('sapi5')  # Windows SAPI
            
            # Configure voice properties
            voices = engine.getProperty('voices')
            if voices:
                # Try to use a female voice first
                for voice in voices:
                    if 'female' in voice.name.lower() or 'zira' in voice.name.lower() or 'aria' in voice.name.lower():
                        engine.setProperty('voice', voice.id)
                        break
                else:
                    # Use first available voice
                    engine.setProperty('voice', voices[0].id)
            
            # Set speaking rate and volume
            engine.setProperty('rate', 180)  # Speed (words per minute)
            engine.setProperty('volume', 0.9)  # Volume (0.0 to 1.0)
            
            # Save to file
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                temp_path = temp_file.name
                engine.save_to_file(text, temp_path)
                engine.runAndWait()
            
            print("Using Windows SAPI TTS (native)")
            return temp_path
            
        except ImportError:
            print("pyttsx3 not available for Windows SAPI")
            return None
        except Exception as e:
            print(f"Windows SAPI TTS error: {e}")
            return None
    
    def _try_pyttsx3_tts(self, text):
        """Try pyttsx3 TTS (cross-platform offline TTS)."""
        try:
            import pyttsx3
            import tempfile
            
            engine = pyttsx3.init()
            
            # Configure voice properties
            voices = engine.getProperty('voices')
            if voices and len(voices) > 0:
                engine.setProperty('voice', voices[0].id)
            
            engine.setProperty('rate', 180)
            engine.setProperty('volume', 0.9)
            
            # Save to file
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                temp_path = temp_file.name
                engine.save_to_file(text, temp_path)
                engine.runAndWait()
            
            print("Using pyttsx3 TTS (offline)")
            return temp_path
            
        except ImportError:
            print("pyttsx3 not available - install with: pip install pyttsx3")
            return None
        except Exception as e:
            print(f"pyttsx3 TTS error: {e}")
            return None
    
    def _add_to_conversation(self, sender, message):
        """Add message to conversation display (compact format)."""
        timestamp = QTime.currentTime().toString("hh:mm")
        
        if sender == "You":
            formatted_message = f'<div style="margin: 2px 0; padding: 3px; background-color: #e3f2fd; border-radius: 3px; font-size: 9px;"><b style="color: #1976d2;">{timestamp} You:</b> {message}</div>'
        elif sender == "AI":
            formatted_message = f'<div style="margin: 2px 0; padding: 3px; background-color: #f5f5f5; border-radius: 3px; font-size: 9px;"><b style="color: #2e7d32;">{timestamp} AI:</b> {message}</div>'
        else:  # System
            formatted_message = f'<div style="margin: 2px 0; padding: 3px; background-color: #ffebee; border-radius: 3px; font-size: 9px;"><b style="color: #d32f2f;">{timestamp} Sys:</b> {message}</div>'
        
        cursor = self.conversation_display.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        cursor.insertHtml(formatted_message)
        
        # Auto-scroll to bottom
        scrollbar = self.conversation_display.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
    
    def _update_recording_indicator(self):
        """Update recording indicator animation."""
        self._recording_animation_state = (self._recording_animation_state + 1) % 2
        if self._recording_animation_state == 0:
            self.recording_indicator.setStyleSheet("QLabel { color: #f44336; font-size: 16px; }")
        else:
            self.recording_indicator.setStyleSheet("QLabel { color: #ff8a80; font-size: 16px; }")
    
    def closeEvent(self, event):
        """Handle dialog close event."""
        if self.is_recording:
            self._stop_recording()
        event.accept()


class QuickSummaryDialog(QDialog):
    """
    Quick AI summary dialog with minimal UI - optimized for speed and efficiency.
    Uses Flash Lite model for fast responses.
    """
    def __init__(self, parent=None, selected_text="", title="", api_key="", speech_section=""):
        super().__init__(parent)
        self.selected_text = selected_text
        self.title = title
        self.api_key = api_key
        self.speech_section = speech_section
        self.model = None
        self.thread = None
        self.worker = None
        self._is_processing = False
        
        # Timer for elapsed time tracking
        self._processing_timer = QTimer()
        self._processing_timer.timeout.connect(self._update_timer_display)
        self._start_time = None
        
        self.setWindowTitle("Quick AI Summary")
        self.setMinimumSize(500, 450)
        self.resize(650, 550)  # Balanced width and height
        self.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, False)
        
        self._setup_ui()
        self._start_auto_summary()
        
        # Initialize conversation history for follow-ups
        self.conversation_history = []
        
        # Initialize streaming state
        self._streaming_started = False
        self._accumulated_text = ""
    
    def _setup_ui(self):
        """Create minimal UI focused on showing the summary quickly."""
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(15, 15, 15, 15)
        
        # Compact header
        header = QWidget()
        header_layout = QHBoxLayout(header)
        header_layout.setContentsMargins(0, 0, 0, 0)
        
        title_label = QLabel("Quick Summary")
        title_label.setStyleSheet("""
            QLabel {
                font-size: 16px;
                font-weight: bold;
                color: #333;
            }
        """)
        header_layout.addWidget(title_label)
        
        header_layout.addStretch()
        
        model_label = QLabel("Flash Lite")
        model_label.setStyleSheet("""
            QLabel {
                font-size: 11px;
                color: #666;
                background-color: #f0f0f0;
                padding: 3px 6px;
                border-radius: 3px;
            }
        """)
        header_layout.addWidget(model_label)
        
        main_layout.addWidget(header)
        
        # Summary display (DOMINATES the entire space)
        self.summary_display = QTextEdit()
        self.summary_display.setReadOnly(True)
        self.summary_display.setPlaceholderText("Loading...")
        self.summary_display.setAcceptRichText(True)  # Enable rich text
        self.summary_display.setStyleSheet("""
            QTextEdit {
                border: 1px solid #ddd;
                border-radius: 6px;
                padding: 15px;
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 14px;
                background-color: white;
                line-height: 1.6;
            }
        """)
        main_layout.addWidget(self.summary_display)
        
        # Status and timer section
        status_layout = QHBoxLayout()
        status_layout.setContentsMargins(0, 0, 0, 0)
        
        self.status_label = QLabel()
        self.status_label.setStyleSheet("""
            QLabel {
                color: #666;
                font-size: 11px;
                font-style: italic;
            }
        """)
        self.status_label.setVisible(False)
        status_layout.addWidget(self.status_label)
        
        status_layout.addStretch()
        
        self.timer_label = QLabel()
        self.timer_label.setStyleSheet("""
            QLabel {
                color: #666;
                font-size: 11px;
                font-weight: bold;
            }
        """)
        self.timer_label.setVisible(False)
        status_layout.addWidget(self.timer_label)
        
        main_layout.addLayout(status_layout)
        
        # Follow-up section (compact)
        followup_layout = QHBoxLayout()
        followup_layout.setSpacing(6)
        
        self.followup_input = QLineEdit()
        self.followup_input.setPlaceholderText("Ask follow-up...")
        self.followup_input.setStyleSheet("""
            QLineEdit {
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 6px;
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 12px;
            }
        """)
        self.followup_input.returnPressed.connect(self._send_followup)
        followup_layout.addWidget(self.followup_input)
        
        self.send_btn = QPushButton("Ask")
        self.send_btn.setStyleSheet("""
            QPushButton {
                background-color: #5E81AC;
                color: white;
                border: none;
                padding: 6px 12px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 12px;
                min-width: 50px;
            }
            QPushButton:hover {
                background-color: #81A1C1;
            }
            QPushButton:pressed {
                background-color: #4C6A82;
            }
        """)
        self.send_btn.clicked.connect(self._send_followup)
        followup_layout.addWidget(self.send_btn)
        
        self.copy_btn = QPushButton("Copy")
        self.copy_btn.setStyleSheet("""
            QPushButton {
                background-color: #D08770;
                color: white;
                border: none;
                padding: 6px 12px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 12px;
                min-width: 50px;
            }
            QPushButton:hover {
                background-color: #EBCB8B;
            }
            QPushButton:pressed {
                background-color: #A3BE8C;
            }
        """)
        self.copy_btn.clicked.connect(self._copy_conversation)
        followup_layout.addWidget(self.copy_btn)
        
        main_layout.addLayout(followup_layout)
    
    def _convert_markdown_to_html(self, markdown_text):
        """Convert simple markdown formatting to HTML."""
        # Convert **bold** to <strong>bold</strong>
        html_text = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', markdown_text)
        
        # Convert *italic* to <em>italic</em>
        html_text = re.sub(r'\*(.*?)\*', r'<em>\1</em>', html_text)
        
        # Convert line breaks to HTML breaks
        html_text = html_text.replace('\n', '<br>')
        
        # Wrap in basic HTML structure with proper styling
        return f"""
        <div style="font-family: 'Segoe UI', Arial, sans-serif; font-size: 14px; line-height: 1.6; color: #333;">
            {html_text}
        </div>
        """
    
    def _start_auto_summary(self):
        """Automatically start summarizing the selected text."""
        try:
            # Configure Gemini with Flash Lite model
            genai.configure(api_key=self.api_key)
            
            self.model = genai.GenerativeModel(
                model_name="gemini-2.5-flash-lite",  # Fast model
                generation_config={
                    "temperature": 0.3,  # More focused for summaries
                    "top_p": 0.8,
                    "top_k": 0,
                    "max_output_tokens": 4000,
                }
            )
            
            # Create summary prompt
            section_info = f" from the '{self.speech_section}' section" if self.speech_section else ""
            prompt = f'''Please provide a concise summary of the following text excerpt{section_info} from a transcript titled "{self.title}":

"{self.selected_text}"

Focus on the key points and main ideas. Keep the summary clear and well-structured.'''
            
            # Start processing
            self._is_processing = True
            self.summary_display.setPlainText("Loading...")
            
            # Start timer with initial status
            self._start_processing_timer("Connecting to Gemini API...")
            
            # Disable follow-up input while processing
            self.followup_input.setEnabled(False)
            self.send_btn.setEnabled(False)
            
            # Create worker thread
            self.thread = QThread()
            self.worker = GeminiWorker(self.model, prompt)
            self.worker.moveToThread(self.thread)
            
            # Connect signals - including streaming
            self.thread.started.connect(self.worker.run)
            self.worker.finished.connect(self._on_summary_finished)
            self.worker.error.connect(self._on_summary_error)
            self.worker.progress.connect(self._on_progress_update)
            self.worker.streaming_chunk.connect(self._on_streaming_chunk)
            
            # Start thread
            self.thread.start()
            
        except Exception as e:
            self._on_summary_error(f"Failed to start summary: {str(e)}")
    
    def _on_summary_finished(self, result):
        """Handle successful summary completion."""
        self._cleanup_processing()
        
        if self._streaming_started:
            # Streaming was used - content is already displayed via chunks
            # Just add to conversation history
            self.conversation_history.append({"role": "User", "content": "Please summarize this text."})
            self.conversation_history.append({"role": "AI", "content": self._accumulated_text})
            # Reset streaming state
            self._streaming_started = False
        else:
            # Non-streaming - display the complete result
            html_result = self._convert_markdown_to_html(result)
            self.summary_display.setHtml(html_result)
            
            # Add to conversation history
            self.conversation_history.append({"role": "User", "content": "Please summarize this text."})
            self.conversation_history.append({"role": "AI", "content": result})
    
    def _on_summary_error(self, error_message):
        """Handle summary error."""
        self._cleanup_processing()
        self.summary_display.setPlainText(f"Error: {error_message}")
        QMessageBox.critical(self, "Summary Error", error_message)
    
    def _on_progress_update(self, message):
        """Handle progress updates."""
        pass  # No longer needed since we show "Loading..." in summary display
    
    def _on_streaming_chunk(self, chunk_text):
        """Handle streaming text chunks as they arrive."""
        if not self._streaming_started:
            # First chunk - clear the "Loading..." text and start streaming
            self._streaming_started = True
            self._accumulated_text = ""
            self.summary_display.clear()
        
        # Accumulate the text and update display
        self._accumulated_text += chunk_text
        
        # Convert accumulated text to HTML and display
        html_content = self._convert_markdown_to_html(self._accumulated_text)
        self.summary_display.setHtml(html_content)
        
        # Auto-scroll to bottom
        scrollbar = self.summary_display.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
    
    def _send_followup(self):
        """Send a follow-up question."""
        question = self.followup_input.text().strip()
        if not question or self._is_processing:
            return
        
        self.followup_input.clear()
        
        # Build context prompt with conversation history
        section_info = f" from the '{self.speech_section}' section" if self.speech_section else ""
        context_prompt = f'You are continuing a conversation about text{section_info} from a transcript titled "{self.title}". '
        context_prompt += f'The original text excerpt was: "{self.selected_text}"\n\n'
        
        if self.conversation_history:
            context_prompt += "Previous conversation:\n"
            for entry in self.conversation_history:
                role = entry["role"]
                content = entry["content"]
                context_prompt += f"{role}: {content}\n"
        
        context_prompt += f"\nUser: {question}\n\nPlease respond to the user's latest question."
        
        # Add user question to conversation
        self.conversation_history.append({"role": "User", "content": question})
        
        # Add user question to display
        self._add_followup_to_display("You", question)
        
        # Show loading for follow-up
        self._add_followup_to_display("AI", "Loading...")
        
        # Start processing follow-up
        self._start_followup_processing(context_prompt)
    
    def _add_followup_to_display(self, sender, message):
        """Add follow-up conversation to the summary display."""
        # Get current HTML content
        current_html = self.summary_display.toHtml()
    
        # Add separator if this is the first follow-up
        if "--- Follow-up Conversation ---" not in current_html:
            separator_html = '<hr style="margin: 5px 0; border: none; border-top: 1px solid #ddd;">'
            # Append separator using cursor
            cursor = self.summary_display.textCursor()
            cursor.movePosition(cursor.MoveOperation.End)
            cursor.insertHtml(separator_html)
    
        # Format message compactly 
        if sender == "You":
            message_html = f'<div style="margin: 5px 0;"><strong style="color: #1976d2;">You:</strong> {message}</div>'
        else:  # AI
            # Convert markdown for AI responses, but skip conversion for "Loading..."
            if sender == "AI" and message != "Loading...":
                formatted_content = self._convert_markdown_content_only(message)
            else:
                formatted_content = message
            
            message_html = f'<div style="margin: 5px 0;"><strong style="color: #2e7d32;">Scriptoria AI:</strong> {formatted_content}</div>'
    
        # Append to HTML content
        current_html_before_insert = self.summary_display.toHtml()
    
        # Find the closing </body></html> tags and insert before them
        if "</body></html>" in current_html_before_insert:
            # Insert before the closing tags
            insertion_point = current_html_before_insert.rfind("</body></html>")
            new_full_html = (current_html_before_insert[:insertion_point] + 
                           message_html + 
                           current_html_before_insert[insertion_point:])
        else:
            # Fallback: just append
            new_full_html = current_html_before_insert + message_html
    
        self.summary_display.setHtml(new_full_html)
    
        # Auto-scroll to bottom
        scrollbar = self.summary_display.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
    
    def _convert_markdown_content_only(self, text):
        """Convert markdown formatting without wrapping in div."""
        # Convert **bold** to <strong>bold</strong>
        html_text = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', text)
        
        # Convert *italic* to <em>italic</em>
        html_text = re.sub(r'\*(.*?)\*', r'<em>\1</em>', html_text)
        
        # Convert line breaks to HTML breaks
        html_text = html_text.replace('\n', '<br>')
        
        return html_text
    
    def _start_followup_processing(self, prompt):
        """Start processing a follow-up question."""
        try:
            # Start processing
            self._is_processing = True
            
            # Disable controls
            self.followup_input.setEnabled(False)
            self.send_btn.setEnabled(False)
            
            # Create worker thread
            self.thread = QThread()
            self.worker = GeminiWorker(self.model, prompt)
            self.worker.moveToThread(self.thread)
            
            # Connect signals
            self.thread.started.connect(self.worker.run)
            self.worker.finished.connect(self._on_followup_finished)
            self.worker.error.connect(self._on_followup_error)
            self.worker.progress.connect(self._on_progress_update)
            
            # Start thread
            self.thread.start()
            
        except Exception as e:
            self._on_followup_error(f"Failed to process follow-up: {str(e)}")
    
    def _on_followup_finished(self, result):
        """Handle successful follow-up completion."""
        self._cleanup_processing()
        
        # Replace the "Loading..." with actual AI response
        self._replace_last_loading_with_response(result)
        
        # Add to conversation history
        self.conversation_history.append({"role": "AI", "content": result})
    
    def _on_followup_error(self, error_message):
        """Handle follow-up error."""
        self._cleanup_processing()
        self._replace_last_loading_with_response(f"Error: {error_message}")
    
    def _replace_last_loading_with_response(self, response):
        """Replace the last 'Loading...' with the actual response."""
        current_html = self.summary_display.toHtml()
        
        print("DEBUG: === _replace_last_loading_with_response called ===")
        print(f"DEBUG: Response: {response[:100]}...")
        print(f"DEBUG: HTML contains 'Loading...': {'Loading...' in current_html}")
        print(f"DEBUG: HTML length: {len(current_html)}")
        
        if "Loading..." in current_html:
            # Format the response properly
            formatted_response = self._convert_markdown_content_only(response) if not response.startswith("Error:") else response
            print(f"DEBUG: Formatted response: {formatted_response[:100]}...")
            
            # Simple replacement of "Loading..." with the response
            new_html = current_html.replace("Loading...", formatted_response)
            self.summary_display.setHtml(new_html)
            print("DEBUG: HTML set via simple replacement")
        else:
            print("DEBUG: No Loading... found, adding new response")
            # If we can't find Loading..., just add the response
            self._add_followup_to_display("AI", response)
        
        # Auto-scroll to bottom
        scrollbar = self.summary_display.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
        print("DEBUG: === _replace_last_loading_with_response finished ===")
        print()
    
    def _cleanup_processing(self):
        """Clean up after processing."""
        self._is_processing = False
        
        # Stop timer
        self._stop_processing_timer()
        
        # Re-enable controls
        self.followup_input.setEnabled(True)
        self.send_btn.setEnabled(True)
        
        # Clean up thread
        if self.thread and self.thread.isRunning():
            self.thread.quit()
            self.thread.wait()
            self.thread = None
        
        self.worker = None
    
    def _start_processing_timer(self, status_message="Processing..."):
        """Start the processing timer with status message."""
        import time
        self._start_time = time.time()
        self._processing_timer.start(100)  # Update every 100ms
        self.status_label.setText(status_message)
        self.status_label.setVisible(True)
        self.timer_label.setVisible(True)
    
    def _stop_processing_timer(self):
        """Stop the processing timer and hide status labels."""
        self._processing_timer.stop()
        self.status_label.setVisible(False)
        self.timer_label.setVisible(False)
        self._start_time = None
    
    def _update_timer_display(self):
        """Update the timer display."""
        if self._start_time is not None:
            import time
            elapsed = time.time() - self._start_time
            minutes = int(elapsed // 60)
            seconds = int(elapsed % 60)
            if minutes > 0:
                self.timer_label.setText(f"{minutes}m {seconds}s")
            else:
                self.timer_label.setText(f"{seconds}s")
    
    def _update_status_message(self, message):
        """Update the status message while keeping timer running."""
        if self.status_label.isVisible():
            self.status_label.setText(message)
    
    def _copy_conversation(self):
        """Copy the entire conversation to clipboard with HTML formatting."""
        try:
            conversation_html = self.summary_display.toHtml()
            plain_text = self.summary_display.toPlainText()
            
            print("=== COPY DEBUG - Quick Summary ===")
            print("RAW PLAIN TEXT:")
            print(plain_text)
            print("=== END COPY DEBUG ===\n")
            
            # Get the clipboard
            clipboard = QApplication.clipboard()
            
            # Create a QMimeData object to set both HTML and plain text
            mime_data = QMimeData()
            
            # Set HTML format (preserves formatting when pasting into rich text editors)
            mime_data.setHtml(conversation_html)
            
            # Also set plain text version (for plain text editors)
            mime_data.setText(plain_text)
            
            # Set the data to clipboard
            clipboard.setMimeData(mime_data)
            
            # Provide visual feedback
            original_text = self.copy_btn.text()
            self.copy_btn.setText("Copied!")
            QTimer.singleShot(1500, lambda: self.copy_btn.setText(original_text))
            
        except Exception as e:
            print(f"Error copying conversation: {e}")
            # Still provide feedback even on error
            original_text = self.copy_btn.text()
            self.copy_btn.setText("Error")
            QTimer.singleShot(1500, lambda: self.copy_btn.setText(original_text))
    
    
    def closeEvent(self, event):
        """Handle dialog close event."""
        if self._is_processing and self.worker:
            self.worker.stop()
        self._cleanup_processing()
        event.accept()


class QuickExplainDialog(QDialog):
    """
    Quick AI explain dialog with minimal UI - optimized for speed and efficiency.
    Uses Flash Lite model for fast responses with expanded context.
    """
    def __init__(self, parent=None, selected_text="", expanded_context="", title="", api_key="", speech_section=""):
        super().__init__(parent)
        self.selected_text = selected_text
        self.expanded_context = expanded_context
        self.title = title
        self.api_key = api_key
        self.speech_section = speech_section
        self.model = None
        self.thread = None
        self.worker = None
        self._is_processing = False
        
        # Timer for elapsed time tracking
        self._processing_timer = QTimer()
        self._processing_timer.timeout.connect(self._update_timer_display)
        self._start_time = None
        
        self.setWindowTitle("Quick AI Explain")
        self.setMinimumSize(500, 450)
        self.resize(650, 550)  # Balanced width and height
        self.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, False)
        
        self._setup_ui()
        self._start_auto_explain()
        
        # Initialize conversation history for follow-ups
        self.conversation_history = []
        
        # Initialize streaming state
        self._streaming_started = False
        self._accumulated_text = ""
    
    def _setup_ui(self):
        """Create minimal UI focused on showing the explanation quickly."""
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(15, 15, 15, 15)
        
        # Compact header
        header = QWidget()
        header_layout = QHBoxLayout(header)
        header_layout.setContentsMargins(0, 0, 0, 0)
        
        title_label = QLabel("Quick Explain")
        title_label.setStyleSheet("""
            QLabel {
                font-size: 16px;
                font-weight: bold;
                color: #2E3440;
                margin-bottom: 5px;
            }
        """)
        
        # Timer display (right side)
        self.timer_label = QLabel("Processing...")
        self.timer_label.setStyleSheet("""
            QLabel {
                font-size: 11px;
                color: #5E81AC;
                margin-left: 10px;
            }
        """)
        
        header_layout.addWidget(title_label)
        header_layout.addStretch()
        header_layout.addWidget(self.timer_label)
        main_layout.addWidget(header)
        
        # Main explanation display (takes most space)
        self.explanation_display = QTextEdit()
        self.explanation_display.setReadOnly(True)
        self.explanation_display.setPlaceholderText("Loading...")
        self.explanation_display.setAcceptRichText(True)  # Enable rich text
        self.explanation_display.setStyleSheet("""
            QTextEdit {
                border: 1px solid #ddd;
                border-radius: 6px;
                padding: 15px;
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 14px;
                background-color: white;
                line-height: 1.6;
            }
        """)
        main_layout.addWidget(self.explanation_display)
        
        # Follow-up section (compact)
        followup_layout = QHBoxLayout()
        followup_layout.setSpacing(6)
        
        self.followup_input = QLineEdit()
        self.followup_input.setPlaceholderText("Ask follow-up...")
        self.followup_input.setStyleSheet("""
            QLineEdit {
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 6px;
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 12px;
            }
        """)
        self.followup_input.returnPressed.connect(self._handle_followup_question)
        followup_layout.addWidget(self.followup_input)
        
        self.ask_button = QPushButton("Ask")
        self.ask_button.setStyleSheet("""
            QPushButton {
                background-color: #5E81AC;
                color: white;
                border: none;
                padding: 6px 12px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 12px;
                min-width: 50px;
            }
            QPushButton:hover {
                background-color: #81A1C1;
            }
            QPushButton:pressed {
                background-color: #4C6A82;
            }
        """)
        
        followup_layout.addWidget(self.ask_button)
        
        self.copy_btn = QPushButton("Copy")
        self.copy_btn.setStyleSheet("""
            QPushButton {
                background-color: #D08770;
                color: white;
                border: none;
                padding: 6px 12px;
                border-radius: 4px;
                font-weight: bold;
                font-size: 12px;
                min-width: 50px;
            }
            QPushButton:hover {
                background-color: #EBCB8B;
            }
            QPushButton:pressed {
                background-color: #A3BE8C;
            }
        """)
        self.copy_btn.clicked.connect(self._copy_conversation)
        followup_layout.addWidget(self.copy_btn)
        
        main_layout.addLayout(followup_layout)
        
        # Connect events
        self.ask_button.clicked.connect(self._handle_followup_question)
        self.followup_input.returnPressed.connect(self._handle_followup_question)
    
    def _start_auto_explain(self):
        """Start automatic explanation generation."""
        if not self.api_key:
            self.explanation_display.setPlainText("Error: No API key provided.")
            return
        
        self._start_time = time.time()
        self._processing_timer.start(100)  # Update every 100ms
        self._is_processing = True
        
        # Build the prompt with expanded context
        section_info = f" from the '{self.speech_section}' section" if self.speech_section else ""
        prompt = f'''This is an excerpt from "{self.title}"{section_info}. Here is the excerpt with expanded context:

"{self.expanded_context}"

The user has specifically selected this part: "{self.selected_text}"

Provide a brief, focused explanation of this selection. Start with a **bold sentence** that gives the main point directly, then continue with more detail. Keep it concise - 2-3 short paragraphs maximum. Focus on the key meaning, important terms, and context within the passage.'''
        
        # Initialize the model and start processing
        try:
            import google.generativeai as genai
            genai.configure(api_key=self.api_key)
            self.model = genai.GenerativeModel(
                model_name="gemini-2.5-flash-lite",  # Fast model
                generation_config={
                    "temperature": 0.3,  # More focused for explanations
                    "top_p": 0.8,
                    "top_k": 40,
                    "max_output_tokens": 2048,
                }
            )
            
            # Start worker thread
            self.thread = QThread()
            self.worker = GeminiWorker(self.model, prompt)
            self.worker.moveToThread(self.thread)
            
            # Connect signals
            self.thread.started.connect(self.worker.run)
            self.worker.finished.connect(self._on_explain_finished)
            self.worker.error.connect(self._on_explain_error)
            self.worker.progress.connect(self._on_progress_update)
            self.worker.streaming_chunk.connect(self._on_streaming_chunk)
            
            # Start processing
            self.thread.start()
            
        except Exception as e:
            self._on_explain_error(str(e))
    
    def _handle_followup_question(self):
        """Handle follow-up question from user."""
        question = self.followup_input.text().strip()
        if not question or self._is_processing:
            return
        
        # Clear input
        self.followup_input.clear()
        
        # Add user question to conversation history first
        self.conversation_history.append({"role": "User", "content": question})
        
        # Add user question to display with proper formatting
        self._add_followup_to_display("You", question)
        
        # Build follow-up prompt with full context and conversation history
        section_info = f" from the '{self.speech_section}' section" if self.speech_section else ""
        
        # Get the previous AI response from conversation history
        previous_response = ""
        if self.conversation_history:
            for entry in self.conversation_history:
                if entry["role"] == "AI":
                    previous_response = entry["content"]
                    break
        
        followup_prompt = f'''This is an excerpt from "{self.title}"{section_info}. Here is the excerpt with expanded context:

"{self.expanded_context}"

The user originally selected this part: "{self.selected_text}"

I previously provided this explanation:
"{previous_response}"

Now the user has a follow-up question: {question}

Please answer their follow-up question building on my previous explanation and the full context. Keep your response brief - 2-3 short paragraphs maximum.'''
        
        self._start_time = time.time()
        self._processing_timer.start(100)
        self._is_processing = True
        
        try:
            # Start worker thread for follow-up
            self.thread = QThread()
            self.worker = GeminiWorker(self.model, followup_prompt)
            self.worker.moveToThread(self.thread)
            
            # Connect signals
            self.thread.started.connect(self.worker.run)
            self.worker.finished.connect(self._on_followup_finished)
            self.worker.error.connect(self._on_followup_error)
            
            # Start processing
            self.thread.start()
            
        except Exception as e:
            self._on_followup_error(str(e))
    
    def _add_followup_to_display(self, sender, message):
        """Add follow-up conversation to the explanation display."""
        print(f"DEBUG: _add_followup_to_display called with sender='{sender}', message='{message}'")
        
        # Get current HTML content
        current_html = self.explanation_display.toHtml()
        
        # Add clean separator if this is the first follow-up
        if "--- Follow-up Conversation ---" not in current_html:
            separator_html = '<hr style="margin: 5px 0; border: none; border-top: 1px solid #ddd;">'
            # Append using the same method as Chat with AI
            if current_html.endswith('</body></html>'):
                current_html = current_html.replace('</body></html>', separator_html + '</body></html>')
            else:
                current_html += separator_html
            print("DEBUG: Added separator line")
        
        # Format message compactly 
        if sender == "You":
            formatted_message = f'<div style="margin: 5px 0;"><strong style="color: #1976d2;">You:</strong> {message}</div>'
        else:  # AI
            # Convert markdown for AI responses, but skip conversion for "Loading..."
            if sender == "AI" and message != "Loading...":
                formatted_content = self._convert_markdown_content_only(message)
            else:
                formatted_content = message.replace('\n', '<br>')
            
            formatted_message = f'<div style="margin: 5px 0;"><strong style="color: #2e7d32;">Scriptoria AI:</strong> {formatted_content}</div>'
        
        print(f"DEBUG: Formatted message: {formatted_message[:200]}...")
        
        # Append to current HTML and set entire content (like Chat with AI does)
        if current_html.endswith('</body></html>'):
            current_html = current_html.replace('</body></html>', formatted_message + '</body></html>')
        else:
            current_html += formatted_message
            
        self.explanation_display.setHtml(current_html)
        
        # Scroll to bottom
        scrollbar = self.explanation_display.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
        print("DEBUG: HTML content updated successfully")
    
    def _convert_markdown_content_only(self, text):
        """Convert markdown to HTML, similar to QuickSummaryDialog."""
        try:
            import markdown
            return markdown.markdown(text)
        except ImportError:
            return text.replace('\n', '<br>')
    
    def _on_explain_finished(self, result):
        """Handle explanation completion."""
        self._cleanup_processing()
        
        # Convert markdown to HTML for better display
        try:
            import markdown
            html_result = markdown.markdown(result)
            self.explanation_display.setHtml(html_result)
        except ImportError:
            # Fallback to plain text if markdown isn't available
            self.explanation_display.setPlainText(result)
        
        # Add to conversation history
        self.conversation_history.append({"role": "User", "content": "Please explain this text."})
        self.conversation_history.append({"role": "AI", "content": result})
    
    def _on_followup_finished(self, result):
        """Handle follow-up question completion."""
        print(f"DEBUG: Follow-up finished with result: {result[:100]}...")
        self._cleanup_processing()
        
        # Simple approach: just add the AI response as a new message (don't try to replace Loading...)
        self._add_followup_to_display("AI", result)
        
        # Add to conversation history
        self.conversation_history.append({"role": "AI", "content": result})
    
    def _on_followup_error(self, error_message):
        """Handle follow-up error."""
        self._cleanup_processing()
        
        # Replace the "Loading..." with error message
        current_html = self.explanation_display.toHtml()
        if "Loading..." in current_html:
            new_html = current_html.replace("Loading...", f"Error: {error_message}")
            self.explanation_display.setHtml(new_html)
    
    def _on_explain_error(self, error_message):
        """Handle explanation error."""
        self._cleanup_processing()
        self.explanation_display.setPlainText(f"Error: {error_message}")
        QMessageBox.critical(self, "Explanation Error", error_message)
    
    def _on_progress_update(self, message):
        """Handle progress updates."""
        pass
    
    def _on_streaming_chunk(self, chunk_text):
        """Handle streaming text chunks as they arrive."""
        if not self._streaming_started:
            self._streaming_started = True
            self.explanation_display.clear()
            self._accumulated_text = ""
        
        self._accumulated_text += chunk_text
        
        try:
            import markdown
            html_result = markdown.markdown(self._accumulated_text)
            self.explanation_display.setHtml(html_result)
        except ImportError:
            self.explanation_display.setPlainText(self._accumulated_text)
        
        # Scroll to bottom
        cursor = self.explanation_display.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        self.explanation_display.setTextCursor(cursor)
    
    def _update_timer_display(self):
        """Update the timer display."""
        if self._start_time:
            elapsed = time.time() - self._start_time
            self.timer_label.setText(f"Processing... {elapsed:.1f}s")
    
    def _cleanup_processing(self):
        """Clean up processing resources."""
        self._is_processing = False
        self._processing_timer.stop()
        self.timer_label.setText("Completed")
        
        # Clean up thread properly
        if self.thread and self.thread.isRunning():
            self.thread.quit()
            self.thread.wait()  # Wait for thread to finish
            self.thread = None
        
        self.worker = None
    
    def _copy_conversation(self):
        """Copy the entire conversation to clipboard with HTML formatting."""
        try:
            conversation_html = self.explanation_display.toHtml()
            plain_text = self.explanation_display.toPlainText()
            
            print("=== COPY DEBUG - Quick Explain ===")
            print("RAW PLAIN TEXT:")
            print(plain_text)
            print("\nFULL RAW HTML:")
            print(conversation_html)
            
            # Get the clipboard
            clipboard = QApplication.clipboard()
            
            # Create a QMimeData object to set both HTML and plain text
            mime_data = QMimeData()
            
            # Set HTML format (preserves formatting when pasting into rich text editors)
            mime_data.setHtml(conversation_html)
            
            # Also set plain text version (for plain text editors)
            mime_data.setText(plain_text)
            
            # Set the data to clipboard
            clipboard.setMimeData(mime_data)
            
            # Debug: Check what formats are available after setting
            print("\nCLIPBOARD FORMATS AVAILABLE:")
            for format_name in clipboard.mimeData().formats():
                print(f"- {format_name}")
            
            print("=== END COPY DEBUG ===\n")
            
            # Provide visual feedback
            original_text = self.copy_btn.text()
            self.copy_btn.setText("Copied!")
            QTimer.singleShot(1500, lambda: self.copy_btn.setText(original_text))
            
        except Exception as e:
            print(f"Error copying conversation: {e}")
            # Still provide feedback even on error
            original_text = self.copy_btn.text()
            self.copy_btn.setText("Error")
            QTimer.singleShot(1500, lambda: self.copy_btn.setText(original_text))
    
    def closeEvent(self, event):
        """Handle dialog close event."""
        if self._is_processing and self.worker:
            self.worker.stop()
        self._cleanup_processing()
        event.accept()


class QuickCustomDialog(QDialog):
    """
    Quick AI custom query dialog with user-definable question.
    Allows users to save and reuse custom prompts across sessions.
    """
    def __init__(self, parent=None, selected_text="", expanded_context="", title="", api_key="", speech_section=""):
        super().__init__(parent)
        self.selected_text = selected_text
        self.expanded_context = expanded_context
        self.title = title
        self.api_key = api_key
        self.speech_section = speech_section
        self.model = None
        self.thread = None
        self.worker = None
        self._is_processing = False
        self.parent_window = parent
        
        # Timer for elapsed time tracking
        self._processing_timer = QTimer()
        self._processing_timer.timeout.connect(self._update_timer_display)
        self._start_time = None
        
        self.setWindowTitle("Preset Prompt")
        self.setMinimumSize(500, 500)
        self.resize(650, 600)
        self.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, False)
        
        # Load saved custom question
        self.custom_question = self._load_custom_question()
        
        self._setup_ui()
        
        # Initialize conversation history for follow-ups
        self.conversation_history = []
        
        # Initialize streaming state
        self._streaming_started = False
        self._accumulated_text = ""
        
        # If we have a saved question, auto-start, otherwise show question input
        if self.custom_question:
            self._start_auto_custom()
        else:
            self._show_question_input()
    
    def _load_custom_question(self):
        """Load the saved custom question from settings."""
        if hasattr(self.parent_window, 'app_settings') and self.parent_window.app_settings:
            return self.parent_window.app_settings.value("quick_custom_question", "")
        return ""
    
    def _save_custom_question(self, question):
        """Save the custom question to settings."""
        if hasattr(self.parent_window, 'app_settings') and self.parent_window.app_settings:
            self.parent_window.app_settings.setValue("quick_custom_question", question)
            self.parent_window.app_settings.sync()
    
    def _setup_ui(self):
        """Create UI for custom question input and AI response."""
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(5)
        main_layout.setContentsMargins(15, 15, 15, 15)
        
        # Compact header with modify button and model selection
        header = QWidget()
        header_layout = QHBoxLayout(header)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(8)
        
        title_label = QLabel("Preset Prompt")
        title_label.setStyleSheet("""
            QLabel {
                font-size: 16px;
                font-weight: bold;
                color: #2E3440;
            }
        """)
        
        # Compact modify question button (shown when question exists)
        self.modify_question_btn = QPushButton("Modify Prompt")
        self.modify_question_btn.clicked.connect(self._show_question_input)
        self.modify_question_btn.setStyleSheet("""
            QPushButton {
                background-color: #D08770;
                color: white;
                border: none;
                padding: 4px 8px;
                border-radius: 3px;
                font-size: 10px;
                font-weight: bold;
                max-height: 24px;
            }
            QPushButton:hover {
                background-color: #C07060;
            }
        """)
        
        # Model selection dropdown
        model_label = QLabel("Model:")
        model_label.setStyleSheet("""
            QLabel {
                font-size: 10px;
                color: #2E3440;
            }
        """)
        
        self.model_combo = QComboBox()
        self.model_combo.addItem("Gemini 2.5 Flash", "gemini-2.5-flash")
        self.model_combo.addItem("Gemini 2.5 Flash Lite", "gemini-2.5-flash-lite")
        self.model_combo.setStyleSheet("""
            QComboBox {
                font-size: 10px;
                padding: 2px 4px;
                max-height: 24px;
                min-width: 120px;
            }
        """)
        
        # Timer display (right side)
        self.timer_label = QLabel("")
        self.timer_label.setStyleSheet("""
            QLabel {
                font-size: 11px;
                color: #5E81AC;
            }
        """)
        
        header_layout.addWidget(title_label)
        header_layout.addWidget(self.modify_question_btn)
        header_layout.addWidget(model_label)
        header_layout.addWidget(self.model_combo)
        header_layout.addStretch()
        header_layout.addWidget(self.timer_label)
        main_layout.addWidget(header)
        
        # Question input section (compact, hidden if we have a saved question)
        self.question_widget = QWidget()
        question_layout = QVBoxLayout(self.question_widget)
        question_layout.setContentsMargins(0, 0, 0, 0)
        question_layout.setSpacing(3)
        
        question_label = QLabel("Preset Prompt:")
        question_label.setStyleSheet("""
            QLabel {
                font-size: 11px;
                font-weight: bold;
                color: #2E3440;
            }
        """)
        question_layout.addWidget(question_label)
        
        self.question_input = QTextEdit()
        self.question_input.setMaximumHeight(80)
        self.question_input.setPlaceholderText("Enter your preset prompt here...")
        if self.custom_question:
            self.question_input.setPlainText(self.custom_question)
        question_layout.addWidget(self.question_input)
        
        # Compact buttons for question management
        button_layout = QHBoxLayout()
        button_layout.setSpacing(5)
        
        self.save_question_btn = QPushButton("Save and Apply")
        self.save_question_btn.clicked.connect(self._save_and_apply_question)
        self.save_question_btn.setStyleSheet("""
            QPushButton {
                background-color: #5E81AC;
                color: white;
                border: none;
                padding: 4px 8px;
                border-radius: 3px;
                font-size: 10px;
                font-weight: bold;
                max-height: 24px;
            }
            QPushButton:hover {
                background-color: #4C7A9C;
            }
        """)
        
        button_layout.addWidget(self.save_question_btn)
        button_layout.addStretch()
        
        question_layout.addLayout(button_layout)
        main_layout.addWidget(self.question_widget)
        
        # Response display - gets maximum space
        self.response_browser = QTextBrowser()
        self.response_browser.setStyleSheet("""
            QTextBrowser {
                border: 1px solid #D8DEE9;
                border-radius: 8px;
                padding: 12px;
                background-color: white;
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 13px;
                font-weight: normal;
                line-height: 1.4;
            }
        """)
        main_layout.addWidget(self.response_browser, 1)  # Give maximum space to response
        
        # Follow-up section (compact)
        followup_layout = QHBoxLayout()
        followup_layout.setSpacing(5)
        
        self.followup_input = QLineEdit()
        self.followup_input.setPlaceholderText("Ask follow-up...")
        self.followup_input.setStyleSheet("""
            QLineEdit {
                border: 1px solid #ccc;
                border-radius: 3px;
                padding: 4px;
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 10px;
                max-height: 24px;
            }
        """)
        self.followup_input.returnPressed.connect(self._handle_followup_question)
        followup_layout.addWidget(self.followup_input)
        
        self.ask_button = QPushButton("Ask")
        self.ask_button.clicked.connect(self._handle_followup_question)
        self.ask_button.setStyleSheet("""
            QPushButton {
                background-color: #5E81AC;
                color: white;
                border: none;
                padding: 4px 8px;
                border-radius: 3px;
                font-weight: bold;
                font-size: 10px;
                max-height: 24px;
                min-width: 40px;
            }
            QPushButton:hover {
                background-color: #81A1C1;
            }
            QPushButton:pressed {
                background-color: #4C6A82;
            }
        """)
        followup_layout.addWidget(self.ask_button)
        
        # Copy button
        self.copy_btn = QPushButton("Copy")
        self.copy_btn.clicked.connect(self._copy_response)
        self.copy_btn.setStyleSheet("""
            QPushButton {
                background-color: #D08770;
                color: white;
                border: none;
                padding: 4px 8px;
                border-radius: 3px;
                font-weight: bold;
                font-size: 10px;
                max-height: 24px;
                min-width: 40px;
            }
            QPushButton:hover {
                background-color: #C07060;
            }
        """)
        followup_layout.addWidget(self.copy_btn)
        
        # Compact close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: #4C566A;
                color: white;
                border: none;
                padding: 4px 8px;
                border-radius: 3px;
                font-size: 10px;
                font-weight: bold;
                max-height: 24px;
                min-width: 40px;
            }
            QPushButton:hover {
                background-color: #5E81AC;
            }
        """)
        followup_layout.addWidget(close_btn)
        
        main_layout.addLayout(followup_layout)
        
        # Set initial visibility based on saved question
        if self.custom_question:
            self.question_widget.setVisible(False)
            self.modify_question_btn.setVisible(True)
        else:
            self.question_widget.setVisible(True)
            self.modify_question_btn.setVisible(False)
    
    def _show_question_input(self):
        """Show the question input section."""
        self.question_widget.setVisible(True)
        self.modify_question_btn.setVisible(False)
        self.timer_label.setText("")
    
    def _hide_question_input(self):
        """Hide the question input section after saving."""
        self.question_widget.setVisible(False)
        self.modify_question_btn.setVisible(True)
    
    def _save_and_apply_question(self):
        """Save the custom question and apply it to the selected text."""
        question = self.question_input.toPlainText().strip()
        if not question:
            self.response_browser.setHtml("""
                <div style='color: #BF616A; font-weight: bold; padding: 10px; border: 1px solid #BF616A; border-radius: 4px; background-color: #FDF2F2;'>
                    Please enter a preset prompt before saving.
                </div>
            """)
            return
        
        # Check if question is the same as before
        if question == self.custom_question:
            # Just hide the input without re-prompting Gemini
            self._hide_question_input()
            return
        
        self.custom_question = question
        self._save_custom_question(question)
        self._hide_question_input()
        self._start_auto_custom()
    
    def _start_auto_custom(self):
        """Start the custom AI query automatically."""
        if not self.custom_question:
            self._show_question_input()
            return
            
        if not self.api_key:
            self.response_browser.setHtml("""
                <div style='color: #BF616A; font-weight: bold; padding: 10px; border: 1px solid #BF616A; border-radius: 4px; background-color: #FDF2F2;'>
                    <strong>No API Key Found</strong><br>
                    Please set up your Gemini API key in the settings to use Preset Prompt.
                </div>
            """)
            return
        
        self._is_processing = True
        self.timer_label.setText("Processing...")
        self._start_time = QTime.currentTime()
        self._processing_timer.start(100)
        
        # Build the custom prompt with embedded instruction for quick summary
        prompt = f"Please provide a quick summarized answer at the top of your response, then give your full analysis below.\n\n{self.custom_question}\n\nText to analyze:\n{self.selected_text}"
        if self.expanded_context:
            prompt += f"\n\nAdditional context:\n{self.expanded_context}"
        
        # Initialize and start worker
        try:
            import google.generativeai as genai
            genai.configure(api_key=self.api_key)
            
            # Get selected model from dropdown
            selected_model = self.model_combo.currentData()
            self.model = genai.GenerativeModel(selected_model)
            
            self.thread = QThread()
            self.worker = GeminiWorker(self.model, prompt, enable_streaming=True)
            self.worker.moveToThread(self.thread)
            
            # Connect signals
            self.worker.streaming_chunk.connect(self._handle_chunk)
            self.worker.finished.connect(self._handle_completion)
            self.worker.error.connect(self._handle_error)
            
            self.thread.started.connect(self.worker.run)
            self.thread.start()
            
        except Exception as e:
            self._handle_error(f"Failed to initialize AI model: {str(e)}")
    
    def _handle_chunk(self, chunk):
        """Handle streaming chunk from AI response."""
        if not self._streaming_started:
            self.response_browser.clear()
            self._streaming_started = True
            self._accumulated_text = ""
        
        self._accumulated_text += chunk
        
        # Convert markdown formatting to HTML
        html_chunk = self._accumulated_text.replace('\n', '<br>')
        # Handle **bold** markdown properly  
        import re
        html_chunk = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', html_chunk)
        
        formatted_html = f"""
        <div style='font-family: "Segoe UI", Arial, sans-serif; font-size: 13px; font-weight: normal; line-height: 1.5; color: #2E3440;'>
            {html_chunk}
        </div>
        """
        
        self.response_browser.setHtml(formatted_html)
    
    def _handle_completion(self):
        """Handle completion of AI response."""
        self._cleanup_processing()
        self.timer_label.setText("Complete!")
    
    def _handle_error(self, error_message):
        """Handle errors from AI processing."""
        self._cleanup_processing()
        self.timer_label.setText("Error occurred")
        
        error_html = f"""
        <div style='color: #BF616A; font-weight: bold; padding: 10px; border: 1px solid #BF616A; border-radius: 4px; background-color: #FDF2F2;'>
            <strong>Error:</strong><br>
            {error_message}
        </div>
        """
        self.response_browser.setHtml(error_html)
    
    def _cleanup_processing(self):
        """Clean up processing resources."""
        self._is_processing = False
        self._processing_timer.stop()
        
        if self.worker:
            self.worker.stop()
            self.worker = None
        
        if self.thread and self.thread.isRunning():
            self.thread.quit()
            self.thread.wait()
            self.thread = None
    
    def _update_timer_display(self):
        """Update the timer display during processing."""
        if self._start_time:
            elapsed = self._start_time.msecsTo(QTime.currentTime())
            seconds = elapsed / 1000.0
            self.timer_label.setText(f"Processing... {seconds:.1f}s")
    
    def _handle_followup_question(self):
        """Handle follow-up question from user."""
        question = self.followup_input.text().strip()
        if not question or self._is_processing:
            return
        
        # Add user question to display
        self._add_followup_to_display("You", question)
        
        # Clear input and show loading
        self.followup_input.clear()
        self._add_followup_to_display("AI", "Loading...")
        
        # Add to conversation history
        self.conversation_history.append({"role": "User", "content": question})
        
        # Build follow-up prompt with conversation context
        context_prompt = "Previous conversation:\n"
        for entry in self.conversation_history[-6:]:  # Last 6 messages for context
            role = "User" if entry["role"] == "User" else "AI"
            context_prompt += f"{role}: {entry['content']}\n"
        
        prompt = f"{context_prompt}\nUser: {question}\n\nPlease respond to this follow-up question about the text."
        
        # Start processing
        self._start_followup_processing(prompt)
    
    def _add_followup_to_display(self, sender, message):
        """Add follow-up conversation to the response display."""
        # Get current HTML content
        current_html = self.response_browser.toHtml()
        
        # Add separator if this is the first follow-up
        if "--- Follow-up Conversation ---" not in current_html:
            separator_html = '<hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">'
            if current_html.endswith('</body></html>'):
                current_html = current_html.replace('</body></html>', separator_html + '</body></html>')
            else:
                current_html += separator_html
        
        # Format message
        if sender == "You":
            formatted_message = f'<div style="margin: 5px 0;"><strong style="color: #1976d2;">You:</strong> {message}</div>'
        else:  # AI
            if sender == "AI" and message != "Loading...":
                # Handle markdown formatting
                import re
                formatted_content = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', message)
                formatted_content = formatted_content.replace('\n', '<br>')
            else:
                formatted_content = message.replace('\n', '<br>')
            
            formatted_message = f'<div style="margin: 5px 0;"><strong style="color: #2e7d32;">Scriptoria AI:</strong> {formatted_content}</div>'
        
        # Append to current HTML
        if current_html.endswith('</body></html>'):
            current_html = current_html.replace('</body></html>', formatted_message + '</body></html>')
        else:
            current_html += formatted_message
            
        self.response_browser.setHtml(current_html)
    
    def _start_followup_processing(self, prompt):
        """Start processing follow-up question."""
        if not self.api_key:
            self._handle_followup_error("No API key available")
            return
        
        self._is_processing = True
        self.timer_label.setText("Processing follow-up...")
        self._start_time = QTime.currentTime()
        self._processing_timer.start(100)
        
        # Initialize and start worker
        try:
            import google.generativeai as genai
            genai.configure(api_key=self.api_key)
            
            # Get selected model from dropdown
            selected_model = self.model_combo.currentData()
            self.model = genai.GenerativeModel(selected_model)
            
            self.thread = QThread()
            self.worker = GeminiWorker(self.model, prompt, enable_streaming=True)
            self.worker.moveToThread(self.thread)
            
            # Connect signals for follow-up
            self.worker.streaming_chunk.connect(self._handle_followup_chunk)
            self.worker.finished.connect(self._handle_followup_completion)
            self.worker.error.connect(self._handle_followup_error)
            
            self.thread.started.connect(self.worker.run)
            self.thread.start()
            
        except Exception as e:
            self._handle_followup_error(f"Failed to initialize AI model: {str(e)}")
    
    def _handle_followup_chunk(self, chunk):
        """Handle streaming chunk from follow-up response."""
        # Initialize followup accumulator if needed
        if not hasattr(self, '_followup_accumulated'):
            self._followup_accumulated = ""
        
        # Replace "Loading..." with the actual response
        current_html = self.response_browser.toHtml()
        if "Loading..." in current_html:
            # Initialize follow-up response
            self._followup_accumulated = chunk
            new_content = f'<div style="margin: 5px 0;"><strong style="color: #2e7d32;">Scriptoria AI:</strong> {chunk}</div>'
            new_html = current_html.replace('<div style="margin: 5px 0;"><strong style="color: #2e7d32;">Scriptoria AI:</strong> Loading...</div>', new_content)
            self.response_browser.setHtml(new_html)
        else:
            # Continue accumulating chunks
            self._followup_accumulated += chunk
            # Update the last AI message
            import re
            # Handle markdown formatting
            formatted_content = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', self._followup_accumulated)
            formatted_content = formatted_content.replace('\n', '<br>')
            
            pattern = r'(<div style="margin: 5px 0;"><strong style="color: #2e7d32;">Scriptoria AI:</strong> )([^<]*)(</div>)(?!.*<div style="margin: 5px 0;"><strong style="color: #2e7d32;">Scriptoria AI:</strong>)'
            
            def replace_last_ai_message(match):
                return match.group(1) + formatted_content + match.group(3)
            
            new_html = re.sub(pattern, replace_last_ai_message, current_html)
            self.response_browser.setHtml(new_html)
    
    def _handle_followup_completion(self, result):
        """Handle completion of follow-up response."""
        self._cleanup_processing()
        self.timer_label.setText("Complete!")
        
        # Add to conversation history
        self.conversation_history.append({"role": "AI", "content": result})
    
    def _handle_followup_error(self, error_message):
        """Handle follow-up processing error."""
        self._cleanup_processing()
        self.timer_label.setText("Error occurred")
        
        # Replace "Loading..." with error message
        current_html = self.response_browser.toHtml()
        if "Loading..." in current_html:
            error_content = f'<div style="margin: 5px 0;"><strong style="color: #2e7d32;">Scriptoria AI:</strong> <span style="color: #BF616A;">Error: {error_message}</span></div>'
            new_html = current_html.replace('<div style="margin: 5px 0;"><strong style="color: #2e7d32;">Scriptoria AI:</strong> Loading...</div>', error_content)
            self.response_browser.setHtml(new_html)
    
    def _copy_response(self):
        """Copy the current response to clipboard."""
        # Get the plain text content from the response browser
        text_content = self.response_browser.toPlainText()
        
        if text_content.strip():
            # Copy to clipboard
            clipboard = QApplication.clipboard()
            clipboard.setText(text_content)
            
            # Show brief feedback by temporarily changing button text
            original_text = self.copy_btn.text()
            self.copy_btn.setText("Copied!")
            QTimer.singleShot(1000, lambda: self.copy_btn.setText(original_text))
        else:
            # No content to copy
            original_text = self.copy_btn.text()
            self.copy_btn.setText("Nothing to copy")
            QTimer.singleShot(1000, lambda: self.copy_btn.setText(original_text))

    def closeEvent(self, event):
        """Handle dialog close event."""
        if self._is_processing and self.worker:
            self.worker.stop()
        self._cleanup_processing()
        event.accept()


class PasteFormatDialog(QDialog):
    def __init__(self, parent=None, detected_content_type="Plain/other", detected_info=None):
        super().__init__(parent)
        self.setWindowTitle("Paste Formatting Options")
        self.setMinimumWidth(400)
    
        # Set fixed size constraints to prevent dialog from growing too large
        self.setMinimumHeight(150)
        self.setMaximumHeight(500)  # Limit maximum height
    
        # Store the detected content type and info
        self.detected_content_type = detected_content_type
        self.detected_info = detected_info or {}
    
        # Store initial size for resetting
        self.initial_width = 400
        self.initial_height = 200  # Approximate initial height
        
        # Store the detected content type
        self.detected_content_type = detected_content_type
        
        # Initialize the selected content type (will be set by user selection)
        self.selected_content_type = detected_content_type
        
        self.settings = QSettings("TranscriptCreator", "PasteFormatSettings")
        
        # Default values for custom formatting options
        self.default_format_values = {
            'bold_as_header': True,
            'h1_treatment': 'header',  # Options: 'header', 'section', 'plain'
            'h2_treatment': 'header',
            'h3_treatment': 'header',
            'h4_treatment': 'header',
            'h5_treatment': 'header',
            'h6_treatment': 'header',
            'global_header_treatment': '',  # When set, overrides individual h1-h6 treatments
        }
        
        # Initialize formatting options with saved values or defaults
        self.format_options = self.default_format_values.copy()
        
        # Load saved settings if available
        self.load_settings()
        
        # Create the UI
        self.init_ui()

        self.update_preview()
        
        # Force proper layout initialization
        QTimer.singleShot(0, self.force_layout_update)
        
    def init_ui(self):
        # Main layout
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # ===== CONTENT TYPE SELECTION SECTION =====
        content_type_frame = QFrame()
        content_type_frame.setFrameShape(QFrame.Shape.StyledPanel)
        content_type_layout = QVBoxLayout(content_type_frame)
        content_type_layout.setSpacing(8)
        content_type_layout.setContentsMargins(10, 10, 10, 10)
        
        # Add a label for the content type section
        content_type_label = QLabel("<b>Content Type</b>")
        
        # Add a label showing the detected type
        detected_label = QLabel(f"Detected as: <span style='color: #0066cc;'>{self.detected_content_type}</span>")
        
        # Create radio buttons for content type selection
        content_type_radio_layout = QHBoxLayout()
        
        self.html_radio = QRadioButton("HTML")
        self.markdown_radio = QRadioButton("Markdown")
        self.plain_radio = QRadioButton("Plain/other")
        
        # Set the radio button based on detected content type
        if self.detected_content_type == "HTML":
            self.html_radio.setChecked(True)
        elif self.detected_content_type == "Markdown":
            self.markdown_radio.setChecked(True)
        else:
            self.plain_radio.setChecked(True)
        
        # Connect radio buttons to update the selected content type
        self.html_radio.toggled.connect(self.update_content_type)
        self.markdown_radio.toggled.connect(self.update_content_type)
        self.plain_radio.toggled.connect(self.update_content_type)
   
        
        # Add radio buttons to layout
        content_type_radio_layout.addWidget(self.html_radio)
        content_type_radio_layout.addWidget(self.markdown_radio)
        content_type_radio_layout.addWidget(self.plain_radio)
        content_type_radio_layout.addStretch()
        
        # Add all elements to the content type frame
        content_type_layout.addWidget(content_type_label)
        content_type_layout.addWidget(detected_label)
        content_type_layout.addLayout(content_type_radio_layout)
        
        # Add the content type frame to the main layout
        main_layout.addWidget(content_type_frame)

        # ===== DETECTED TAGS PREVIEW SECTION =====
        preview_frame = QFrame()
        preview_frame.setFrameShape(QFrame.Shape.StyledPanel)
        preview_layout = QVBoxLayout(preview_frame)
        preview_layout.setSpacing(8)
        preview_layout.setContentsMargins(10, 10, 10, 10)

        # Header with toggle button
        preview_header_layout = QHBoxLayout()
        preview_label = QLabel("<b>Content Preview</b>")
        self.preview_toggle_btn = QPushButton("Show")
        self.preview_toggle_btn.setCheckable(True)
        self.preview_toggle_btn.setChecked(False)
        self.preview_toggle_btn.setMaximumWidth(80)
        self.preview_toggle_btn.clicked.connect(self.toggle_preview)

        preview_header_layout.addWidget(preview_label)
        preview_header_layout.addStretch()
        preview_header_layout.addWidget(self.preview_toggle_btn)
        preview_layout.addLayout(preview_header_layout)

        # Preview content area (scrollable)
        self.preview_scroll = QScrollArea()
        self.preview_scroll.setWidgetResizable(True)
        self.preview_scroll.setFrameShape(QFrame.Shape.NoFrame)
        self.preview_scroll.setMaximumHeight(150)  # Limit height
        self.preview_scroll.setVisible(False)  # Hidden by default

        # Container for preview items
        self.preview_container = QWidget()
        self.preview_layout = QVBoxLayout(self.preview_container)
        self.preview_layout.setSpacing(5)
        self.preview_layout.setContentsMargins(5, 5, 5, 5)
    
        # We'll populate this in update_preview() - no content added here
    
        # Set the container as the scroll area widget
        self.preview_scroll.setWidget(self.preview_container)
        preview_layout.addWidget(self.preview_scroll)

        # Add the preview frame to the main layout
        main_layout.addWidget(preview_frame)

        # ===== FORMATTING STYLE SECTION =====
        # This section should be visible for HTML and Markdown, but hidden for Plain Text
        self.format_section_widget = QWidget()
        format_section_layout = QVBoxLayout(self.format_section_widget)
        format_section_layout.setSpacing(10)
        format_section_layout.setContentsMargins(0, 0, 0, 0)
        
        format_choice_frame = QFrame()
        format_choice_frame.setFrameShape(QFrame.Shape.StyledPanel)
        format_choice_layout = QVBoxLayout(format_choice_frame)
        format_choice_layout.setSpacing(8)
        format_choice_layout.setContentsMargins(10, 10, 10, 10)
    
        format_label = QLabel("<b>Formatting Options</b>")
        self.default_format_radio = QRadioButton("Default")
        self.custom_format_radio = QRadioButton("Advanced Options")
    
        # Always start with the choices visible - don't save the use_default choice
        self.default_format_radio.setChecked(True)
        
        format_choice_layout.addWidget(format_label)
        format_choice_layout.addWidget(self.default_format_radio)
        format_choice_layout.addWidget(self.custom_format_radio)
        format_section_layout.addWidget(format_choice_frame)
    
        # Create scrollable area for all custom options
        self.custom_options_scroll = QScrollArea()
        self.custom_options_scroll.setWidgetResizable(True)
        self.custom_options_scroll.setFrameShape(QFrame.Shape.NoFrame)
        
        # Container widget for all custom options
        self.custom_options_container = QWidget()
        custom_container_layout = QVBoxLayout(self.custom_options_container)
        custom_container_layout.setSpacing(10)
        custom_container_layout.setContentsMargins(0, 0, 0, 0)
        
        # Bold text handling - more compact
        bold_frame = QFrame()
        bold_frame.setFrameShape(QFrame.Shape.StyledPanel)
        bold_layout = QHBoxLayout(bold_frame)
        bold_layout.setContentsMargins(10, 10, 10, 10)
        
        bold_label = QLabel("<b>Bold Text:</b>")
        bold_label.setMinimumWidth(80)
        
        self.bold_as_header_radio = QRadioButton("Treat as Header")
        self.bold_as_plain_radio = QRadioButton("No Formatting")
        
        if self.format_options['bold_as_header']:
            self.bold_as_header_radio.setChecked(True)
        else:
            self.bold_as_plain_radio.setChecked(True)
        
        bold_layout.addWidget(bold_label)
        bold_layout.addWidget(self.bold_as_header_radio)
        bold_layout.addWidget(self.bold_as_plain_radio)
        bold_layout.addStretch()
        custom_container_layout.addWidget(bold_frame)
    
        # Global header handling - more compact
        global_header_frame = QFrame()
        global_header_frame.setFrameShape(QFrame.Shape.StyledPanel)
        global_header_layout = QVBoxLayout(global_header_frame)
        global_header_layout.setContentsMargins(10, 10, 10, 10)
        global_header_layout.setSpacing(8)
        
        global_header_title = QLabel("<b>Header Tags (H1-H6)</b>")
        
        self.global_header_check = QCheckBox("Apply the same formatting to all header tags")
        self.global_header_check.setChecked(bool(self.format_options['global_header_treatment']))
        
        global_header_combo_layout = QHBoxLayout()
        global_header_combo_layout.setContentsMargins(20, 0, 0, 0)
        
        global_header_combo_label = QLabel("Format as:")
        self.global_header_combo = QComboBox()
        self.global_header_combo.addItem("Header", "header")
        self.global_header_combo.addItem("Section Divider", "section")
        self.global_header_combo.addItem("Plain Text", "plain")
        
        # Set the combo box to the saved value
        if self.format_options['global_header_treatment']:
            index = self.global_header_combo.findData(self.format_options['global_header_treatment'])
            if index >= 0:
                self.global_header_combo.setCurrentIndex(index)
        
        global_header_combo_layout.addWidget(global_header_combo_label)
        global_header_combo_layout.addWidget(self.global_header_combo)
        global_header_combo_layout.addStretch()
        
        global_header_layout.addWidget(global_header_title)
        global_header_layout.addWidget(self.global_header_check)
        global_header_layout.addLayout(global_header_combo_layout)
        custom_container_layout.addWidget(global_header_frame)
    
        # Individual header handling - grid layout for compactness
        individual_header_frame = QFrame()
        individual_header_frame.setFrameShape(QFrame.Shape.StyledPanel)
        individual_header_layout = QVBoxLayout(individual_header_frame)
        individual_header_layout.setContentsMargins(10, 10, 10, 10)
        individual_header_layout.setSpacing(8)
        
        individual_header_title = QLabel("<b>Individual Header Tags</b>")
        individual_header_layout.addWidget(individual_header_title)
        
        # Create a grid layout for header options
        header_grid = QGridLayout()
        header_grid.setHorizontalSpacing(15)
        header_grid.setVerticalSpacing(8)
        header_grid.setContentsMargins(20, 0, 0, 0)
        
        # Create headers for the grid
        header_grid.addWidget(QLabel("Tag"), 0, 0)
        header_grid.addWidget(QLabel("Format as"), 0, 1)
        
        # Create options for each header tag
        self.header_combos = {}
        
        for h_level in range(1, 7):
            row = h_level
            h_label = QLabel(f"H{h_level}:")
            
            h_combo = QComboBox()
            h_combo.addItem("Header", "header")
            h_combo.addItem("Section Divider", "section")
            h_combo.addItem("Plain Text", "plain")
            
            # Set the combo box to the saved value
            option_key = f'h{h_level}_treatment'
            index = h_combo.findData(self.format_options[option_key])
            if index >= 0:
                h_combo.setCurrentIndex(index)
            
            self.header_combos[f'h{h_level}'] = h_combo
            
            header_grid.addWidget(h_label, row, 0)
            header_grid.addWidget(h_combo, row, 1)
        
        individual_header_layout.addLayout(header_grid)
        custom_container_layout.addWidget(individual_header_frame)
    
        # Connect the global header checkbox to enable/disable individual header options
        self.global_header_check.toggled.connect(self.toggle_individual_headers)
        
        # Initial state of individual headers based on global setting
        self.toggle_individual_headers(self.global_header_check.isChecked())
        
        # Add reset button to custom options
        reset_layout = QHBoxLayout()
        self.reset_button = QPushButton("Reset to Defaults")
        self.reset_button.setToolTip("Restore all formatting options to their default values")
        self.reset_button.clicked.connect(self.reset_to_defaults)
        reset_layout.addStretch()
        reset_layout.addWidget(self.reset_button)
        custom_container_layout.addLayout(reset_layout)
        
        # Add spacing at the bottom
        custom_container_layout.addStretch()
        
        # Set the custom options container as the widget for the scroll area
        self.custom_options_scroll.setWidget(self.custom_options_container)
        
        # Add the scroll area to the format section layout
        format_section_layout.addWidget(self.custom_options_scroll)
        
        # Connect radio buttons to handle visibility toggling
        self.default_format_radio.toggled.connect(self.on_format_radio_toggled)
        
        # Initial state - hide custom options at startup
        self.custom_options_scroll.setVisible(False)
        
        # Add save as default checkbox
        self.save_default_check = QCheckBox("Save these custom formatting options as default")
        self.save_default_check.setToolTip("Your custom formatting preferences will be saved for future use")
        format_section_layout.addWidget(self.save_default_check)
        
        # Add the format section to the main layout
        main_layout.addWidget(self.format_section_widget)
        
        # Plain text message (shown when Plain/other is selected)
        self.plain_text_message = QLabel("Content will be pasted as plain text without formatting.")
        self.plain_text_message.setWordWrap(True)
        self.plain_text_message.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.plain_text_message.setStyleSheet("color: #666; margin: 20px;")
        main_layout.addWidget(self.plain_text_message)
        
        # Buttons layout - standard dialog buttons
        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()
        
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        self.ok_button = QPushButton("OK")
        self.ok_button.clicked.connect(self.accept)
        self.ok_button.setDefault(True)
        
        buttons_layout.addWidget(self.cancel_button)
        buttons_layout.addWidget(self.ok_button)
        
        main_layout.addLayout(buttons_layout)

        # Also connect these to update_preview
        self.html_radio.toggled.connect(self.update_preview)
        self.markdown_radio.toggled.connect(self.update_preview)
        self.plain_radio.toggled.connect(self.update_preview)
        
        # Set initial visibility based on content type
        self.update_content_type()

    def update_preview(self):
        """Update the preview content based on the selected content type"""
        # Clear all existing preview content
        while self.preview_layout.count():
            item = self.preview_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
    
        import re
        has_content = False
    
        if self.html_radio.isChecked():
            # HTML preview logic - show detected HTML tags
            if self.detected_info and 'original_html' in self.detected_info:
                # Process header tags
                header_tags = self.detected_info.get('header_tags', [])
                if header_tags:
                    for match in header_tags[:4]:  # Show max 4 headers
                        h_level = match.group(1)
                        content = match.group(2).strip()
                    
                        # Clean content (remove HTML)
                        content = re.sub(r'<[^>]+>', '', content)
                    
                        if len(content) > 25:
                            content = content[:25] + "..."
                    
                        tag_label = QLabel(f"<b>h{h_level}:</b> {content}")
                        tag_label.setWordWrap(True)
                        self.preview_layout.addWidget(tag_label)
                        has_content = True
            
                # Process bold tags
                bold_tags = self.detected_info.get('bold_tags', [])
                if bold_tags:
                    for match in bold_tags[:3]:  # Show max 3
                        tag_name = match.group(1)
                        content = match.group(2).strip()
                    
                        # Clean content (remove HTML)
                        content = re.sub(r'<[^>]+>', '', content)
                    
                        if len(content) > 25:
                            content = content[:25] + "..."
                    
                        tag_label = QLabel(f"<b>{tag_name}:</b> {content}")
                        tag_label.setWordWrap(True)
                        self.preview_layout.addWidget(tag_label)
                        has_content = True
            
                if not has_content:
                    no_tags_label = QLabel("No HTML tags detected in content.")
                    no_tags_label.setStyleSheet("color: gray; font-style: italic;")
                    self.preview_layout.addWidget(no_tags_label)
            else:
                no_preview_label = QLabel("No HTML content available.")
                no_preview_label.setStyleSheet("color: gray; font-style: italic;")
                self.preview_layout.addWidget(no_preview_label)
    
        elif self.markdown_radio.isChecked():
            # Markdown preview logic
            if self.detected_info and 'plain_text' in self.detected_info:
                text = self.detected_info.get('plain_text', '')
            
                # Check for Markdown formatting
                has_content = False
            
                # Look for headers (# Header)
                header_pattern = r'^#{1,6}\s+(.+?)$'
                header_matches = list(re.finditer(header_pattern, text, re.MULTILINE))
            
                if header_matches:
                    for match in header_matches[:3]:  # Show max 3
                        content = match.group(1).strip()
                        header_level = match.group(0).count('#')
                    
                        if len(content) > 25:
                            content = content[:25] + "..."
                    
                        tag_label = QLabel(f"<b>Header {header_level}:</b> {content}")
                        tag_label.setWordWrap(True)
                        self.preview_layout.addWidget(tag_label)
                        has_content = True
            
                # Look for bold text (**bold**)
                bold_pattern = r'\*\*([^\*\n]+)\*\*'
                bold_matches = list(re.finditer(bold_pattern, text))
            
                if bold_matches:
                    for match in bold_matches[:3]:  # Show max 3
                        content = match.group(1).strip()
                    
                        if len(content) > 25:
                            content = content[:25] + "..."
                    
                        tag_label = QLabel(f"<b>Bold:</b> {content}")
                        tag_label.setWordWrap(True)
                        self.preview_layout.addWidget(tag_label)
                        has_content = True
            
                if not has_content:
                    no_md_label = QLabel("No Markdown formatting detected in content.")
                    no_md_label.setStyleSheet("color: gray; font-style: italic;")
                    self.preview_layout.addWidget(no_md_label)
            else:
                no_preview_label = QLabel("No Markdown content available.")
                no_preview_label.setStyleSheet("color: gray; font-style: italic;")
                self.preview_layout.addWidget(no_preview_label)
    
        elif self.plain_radio.isChecked():
            # Plain text preview logic - just show the first few lines
            if self.detected_info and 'plain_text' in self.detected_info:
                text = self.detected_info.get('plain_text', '')
            
                # Get the first 3 lines or 100 characters, whichever is shorter
                lines = text.splitlines()
                preview_lines = lines[:3]
                preview_text = '\n'.join(preview_lines)
            
                if len(preview_text) > 100:
                    preview_text = preview_text[:100] + "..."
            
                # Replace line breaks with <br> for QLabel
                preview_text = preview_text.replace('\n', '<br>')
            
                text_preview = QLabel(f"<b>Text preview:</b><br>{preview_text}")
                text_preview.setWordWrap(True)
                self.preview_layout.addWidget(text_preview)
            else:
                no_preview_label = QLabel("No text content available.")
                no_preview_label.setStyleSheet("color: gray; font-style: italic;")
                self.preview_layout.addWidget(no_preview_label)
    
        # Add a stretcher at the end
        self.preview_layout.addStretch()

    def update_content_type(self):
        """Update the selected content type and UI based on radio button selection"""
        if self.html_radio.isChecked():
            self.selected_content_type = "HTML"
            self.format_section_widget.setVisible(True)
            self.plain_text_message.setVisible(False)
        elif self.markdown_radio.isChecked():
            self.selected_content_type = "Markdown"
            self.format_section_widget.setVisible(True)
            self.plain_text_message.setVisible(False)
        else:
            self.selected_content_type = "Plain/other"
            self.format_section_widget.setVisible(False)
            self.plain_text_message.setVisible(True)
        
        # Update the layout
        self.adjust_dialog_size()

    def adjust_dialog_size(self):
        """Adjust the dialog size after visibility changes"""
        self.adjustSize()
        self.center_dialog()

    def force_layout_update(self):
        """Force proper layout initialization after dialog is shown"""
        # Manually trigger our toggle handler to ensure proper visibility and spacing
        self.on_format_radio_toggled(True)
    
        # Update the layout
        self.layout().update()
        self.adjustSize()
    
        # Store the initial size after adjustment
        self.initial_width = self.width()
        self.initial_height = self.height()
    
        # Initial centering
        self.center_dialog()
        
    def center_dialog(self):
        """Center the dialog on the screen"""
        # Get the available screen geometry
        screen = QApplication.primaryScreen().availableGeometry()
        
        # Get the dialog size
        size = self.geometry()
        
        # Calculate the new position
        x = (screen.width() - size.width()) // 2
        y = (screen.height() - size.height()) // 2
        
        # Move the dialog
        self.move(x, y)

    def toggle_preview(self):
        """Toggle the visibility of the preview section"""
        is_visible = self.preview_toggle_btn.isChecked()
        self.preview_scroll.setVisible(is_visible)
        self.preview_toggle_btn.setText("Hide" if is_visible else "Show")
    
        # Adjust dialog size based on both preview visibility and format option
        use_custom = self.custom_format_radio.isChecked()
    
        # If hiding preview and using default formatting, reset to initial size
        if not is_visible and not use_custom:
            self.resize(self.initial_width, self.initial_height)
        else:
            # Otherwise adjust to fit content
            self.adjustSize()
    
        # Recenter the dialog
        self.center_dialog()

    def on_format_radio_toggled(self, checked):
        """Handle radio button toggle to properly show/hide custom options and recenter the dialog"""
        use_custom = self.custom_format_radio.isChecked()
        self.custom_options_scroll.setVisible(use_custom)
        self.save_default_check.setVisible(use_custom)
    
        # Check if preview is visible
        preview_visible = self.preview_toggle_btn.isChecked()
    
        # Reset size if returning to default format option and preview is hidden
        if not use_custom and not preview_visible:
            # Reset to original compact size
            self.resize(self.initial_width, self.initial_height)
        else:
            # Expand as needed for custom options and/or preview
            self.adjustSize()
    
        # Recenter the dialog on the screen
        self.center_dialog()
        
    def toggle_individual_headers(self, use_global):
        """Enable or disable individual header options based on global checkbox"""
        # Enable/disable individual header options
        for combo in self.header_combos.values():
            combo.setEnabled(not use_global)
            
        # Enable/disable the global header combo
        self.global_header_combo.setEnabled(use_global)
    
    def reset_to_defaults(self):
        """Reset all custom formatting options to their defaults"""
        # Reset Bold Text options
        self.bold_as_header_radio.setChecked(self.default_format_values['bold_as_header'])
        
        # Reset Global Header options
        self.global_header_check.setChecked(bool(self.default_format_values['global_header_treatment']))
        
        if self.default_format_values['global_header_treatment']:
            index = self.global_header_combo.findData(self.default_format_values['global_header_treatment'])
            if index >= 0:
                self.global_header_combo.setCurrentIndex(index)
        
        # Reset Individual Header options
        for h_level in range(1, 7):
            h_key = f'h{h_level}'
            option_key = f'{h_key}_treatment'
            index = self.header_combos[h_key].findData(self.default_format_values[option_key])
            if index >= 0:
                self.header_combos[h_key].setCurrentIndex(index)
        
        # Also remove any saved settings
        self.settings.clear()
        
    def get_formatting_options(self):
        """Gather all options from the UI"""
        options = {
            'content_type': self.selected_content_type,  # Add the selected content type
        }
        
        # Only add other formatting options if not in Plain/other mode
        if self.selected_content_type != "Plain/other":
            options.update({
                'use_default': self.default_format_radio.isChecked(),
                'bold_as_header': self.bold_as_header_radio.isChecked(),
                'global_header_treatment': self.global_header_combo.currentData() if self.global_header_check.isChecked() else '',
            })
            
            # Get individual header treatments
            for h_level in range(1, 7):
                h_key = f'h{h_level}'
                options[f'{h_key}_treatment'] = self.header_combos[h_key].currentData()
            
            # If saving as default, store ONLY the custom formatting settings
            if self.save_default_check.isChecked() and self.save_default_check.isVisible():
                custom_settings = {k: v for k, v in options.items() if k != 'use_default'}
                self.save_settings(custom_settings)
        
        return options
        
    def save_settings(self, options=None):
        """Save the custom formatting options only"""
        if options is None:
            # Get all options except 'use_default'
            options = {k: v for k, v in self.get_formatting_options().items() if k != 'use_default'}
            
        for key, value in options.items():
            self.settings.setValue(key, value)
            
    def load_settings(self):
        """Load saved custom formatting settings if they exist"""
        for key in self.format_options.keys():
            if self.settings.contains(key):
                value = self.settings.value(key)
                
                # Convert string 'true'/'false' to actual boolean for checkbox states
                if isinstance(value, str) and value.lower() in ('true', 'false'):
                    value = value.lower() == 'true'
                    
                self.format_options[key] = value

class AutoWrapHeadersDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Auto Wrap Headers")
        self.setFixedWidth(650)  # Widened to accommodate horizontal layout
        self.setFixedHeight(450)
        self.document_text = ""
    
        # Get document text from parent if available
        if parent and hasattr(parent, 'input_text'):
            self.document_text = parent.input_text.toPlainText()
            print(f"[DEBUG] Loaded document text, length: {len(self.document_text)} chars")
    
        # Apply the same stylesheet as before
        self.setStyleSheet("""
            QDialog {
                background-color: #F9FAFB;
            }
            QLabel {
                font-size: 13px;
                color: #333333;
            }
            QLineEdit {
                border: 1px solid #dee2e6;
                border-radius: 4px;
                padding: 8px;
                background-color: white;
                font-size: 13px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 5px;
                font-size: 13px;
                min-width: 100px;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
            QPushButton:pressed {
                background-color: #1A5E5C;
            }
            QPushButton#cancelButton {
                background-color: #F5F5F5;
                color: #333333;
                border: 1px solid #CCCCCC;
            }
            QPushButton#cancelButton:hover {
                background-color: #E0E0E0;
            }
            QTextEdit {
                border: 1px solid #dee2e6;
                border-radius: 4px;
                background-color: white;
                font-size: 12px;
                padding: 5px;
            }
            QGroupBox {
                font-size: 13px;
                font-weight: bold;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                margin-top: 12px;
                background-color: #FAFAFA;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px;
            }
            QRadioButton {
                font-size: 13px;
                margin: 5px;
            }
            QRadioButton::indicator {
                width: 15px;
                height: 15px;
            }
            /* Custom styling for radio buttons */
            QRadioButton#headerRadio {
                color: #2196F3; /* Blue color for header format */
                font-weight: bold;
            }
            QRadioButton#sectionRadio {
                color: #e6aa00; /* Gold color for section divider format */
                font-weight: bold;
            }
            QCheckBox {
                font-size: 13px;
                margin: 5px;
            }
        """)
    
        # Main layout
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(12)
    
        # Search term input (remains at the top)
        search_layout = QVBoxLayout()
        search_label = QLabel("Text that starts the line (e.g., \"Chapter\"):")
        self.search_term = QLineEdit()
        self.search_term.setPlaceholderText("Enter starting text...")
        self.search_term.textChanged.connect(self.update_preview)
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.search_term)
        main_layout.addLayout(search_layout)
    
        # Two-column layout for options and preview
        horizontal_layout = QHBoxLayout()
        horizontal_layout.setSpacing(15)
    
        # LEFT COLUMN - Options
        left_column = QVBoxLayout()
        left_column.setContentsMargins(0, 0, 0, 0)
    
        # Format style group
        format_group = QGroupBox("Format style:")
        format_layout = QVBoxLayout(format_group)
    
        # Create radio buttons with colored text
        self.header_radio = QRadioButton("Make Header")
        self.header_radio.setObjectName("headerRadio")  # For CSS styling
    
        self.section_radio = QRadioButton("Make Section Divider")
        self.section_radio.setObjectName("sectionRadio")  # For CSS styling
    
        # Set the first option as default
        self.header_radio.setChecked(True)
    
        # Connect signals
        self.header_radio.toggled.connect(self.update_preview)
        self.section_radio.toggled.connect(self.update_preview)
    
        # Add to layout
        format_layout.addWidget(self.header_radio)
        format_layout.addWidget(self.section_radio)
        format_layout.setContentsMargins(10, 15, 10, 10)
    
        left_column.addWidget(format_group)
    
        # Options group
        options_group = QGroupBox("Format Options:")
        options_layout = QVBoxLayout(options_group)
    
        # Case sensitivity option
        self.case_sensitive = QCheckBox("Case sensitive")
        self.case_sensitive.stateChanged.connect(self.update_preview)
        options_layout.addWidget(self.case_sensitive)
    
        # Format scope radio buttons (mutually exclusive options)
        scope_group_box = QGroupBox("Format Scope:")
        scope_layout = QVBoxLayout(scope_group_box)
    
        # Create a button group to ensure only one option is selected
        self.scope_button_group = QButtonGroup(self)
    
        self.whole_line_radio = QRadioButton("Format whole line")
        self.sentence_only_radio = QRadioButton("Format to first sentence end")
        self.word_only_radio = QRadioButton("Format word only")
    
        # Add buttons to the button group
        self.scope_button_group.addButton(self.whole_line_radio)
        self.scope_button_group.addButton(self.sentence_only_radio)
        self.scope_button_group.addButton(self.word_only_radio)
    
        # Set whole line as default
        self.whole_line_radio.setChecked(True)
    
        # Connect a single signal from the button group
        self.scope_button_group.buttonClicked.connect(self.update_preview)
    
        scope_layout.addWidget(self.whole_line_radio)
        scope_layout.addWidget(self.sentence_only_radio)
        scope_layout.addWidget(self.word_only_radio)
    
        options_layout.addWidget(scope_group_box)
        options_layout.setContentsMargins(10, 15, 10, 10)
    
        left_column.addWidget(options_group)
    
        # Add stretch to push everything to the top
        left_column.addStretch()
    
        # RIGHT COLUMN - Match count and Preview
        right_column = QVBoxLayout()
        right_column.setContentsMargins(0, 0, 0, 0)
    
        # Match count label
        self.match_count_label = QLabel("No matches found")
        self.match_count_label.setStyleSheet("""
            QLabel {
                color: #1976D2;
                font-weight: bold;
                margin-top: 4px;
            }
        """)
        right_column.addWidget(self.match_count_label)
    
        # Preview section - now expanded to fill available space
        preview_group = QGroupBox("Preview")
        preview_layout = QVBoxLayout(preview_group)
    
        # Expanded preview boxes
        self.preview_before = QTextEdit()
        self.preview_before.setMinimumHeight(60)  # Increased from fixed 40
        self.preview_before.setReadOnly(True)
    
        self.preview_after = QTextEdit()
        self.preview_after.setMinimumHeight(80)  # Increased from fixed 40
        self.preview_after.setReadOnly(True)
    
        preview_layout.addWidget(QLabel("Before:"))
        preview_layout.addWidget(self.preview_before)
        preview_layout.addWidget(QLabel("After:"))
        preview_layout.addWidget(self.preview_after)
    
        right_column.addWidget(preview_group, 1)  # Give the preview group a stretch factor
    
        # Add columns to horizontal layout with proper width ratio
        horizontal_layout.addLayout(left_column, 1)  # 50% of width
        horizontal_layout.addLayout(right_column, 1)  # 50% of width
    
        # Add horizontal layout to main layout
        main_layout.addLayout(horizontal_layout, 1)  # Give the horizontal layout a stretch factor
    
        # DEBUG option
        self.debug_checkbox = QCheckBox("Enable Debug Output")
        self.debug_checkbox.setChecked(False)
        #main_layout.addWidget(self.debug_checkbox)
    
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
    
        cancel_button = QPushButton("Cancel")
        cancel_button.setObjectName("cancelButton")
        cancel_button.clicked.connect(self.reject)
    
        apply_button = QPushButton("Apply")
        apply_button.clicked.connect(self.accept)
    
        button_layout.addWidget(cancel_button)
        button_layout.addWidget(apply_button)
        main_layout.addLayout(button_layout)
    
        # Set focus to search term input
        self.search_term.setFocus()
    
        # Initialize preview
        self.update_preview()
    
        # Also colorize the preview output based on format
        self.update_preview_colors()

    def keyPressEvent(self, event):
        """Handle key press events to make Enter accept the dialog"""
        if event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter:
            # Check if the key press didn't come from a text field with multi-line editing enabled
            focused_widget = QApplication.focusWidget()
            if not (isinstance(focused_widget, QTextEdit) and focused_widget.acceptRichText()):
                # Accept the dialog (same as clicking Apply)
                self.accept()
                return
    
        # For all other keys, pass to the parent handler
        super().keyPressEvent(event)

    def accept(self):
        """Override the standard accept method to trigger orphaned text check after dialog closes"""
        # Call the parent class's accept method first
        super().accept()
    
        # Schedule the orphaned text check in the parent window with a small delay
        # This ensures the check happens after changes are applied
        if self.parent() and hasattr(self.parent(), 'input_text'):
            if hasattr(self.parent().input_text, 'header_highlighter'):
                highlighter = self.parent().input_text.header_highlighter
            
                # Use the force_orphaned_recheck method if available (preferred)
                if hasattr(highlighter, 'force_orphaned_recheck'):
                    QTimer.singleShot(300, highlighter.force_orphaned_recheck)
                    self.debug_print("Forced orphaned text recheck scheduled after formatting")
                # Otherwise fall back to regular orphaned text check
                elif hasattr(highlighter, 'check_for_orphaned_text'):
                    QTimer.singleShot(300, highlighter.check_for_orphaned_text)
                    self.debug_print("Orphaned text check scheduled via highlighter after formatting")
                # Last resort - try the input text's perform_orphaned_check
                elif hasattr(self.parent().input_text, '_perform_orphaned_check'):
                    QTimer.singleShot(300, self.parent().input_text._perform_orphaned_check)
                    self.debug_print("Orphaned text check scheduled after formatting")
        
    def debug_print(self, message):
        """Print debug message if debug is enabled"""
        if hasattr(self, 'debug_checkbox') and self.debug_checkbox.isChecked():
            print(f"[DEBUG] {message}")
    
    def find_next_period(self, text, start_pos=0):
        """
        Find the next period in the text, starting from start_pos.
        Returns the position of the period or -1 if not found.
        """
        for i in range(start_pos, len(text)):
            if text[i] == '.':
                self.debug_print(f"Found period at position {i}: '{text[max(0, i-10):i+10]}'")
                return i
        return -1
        
    def is_abbreviation_period(self, text, period_pos):
        """
        Determine if a period at the given position is likely part of an abbreviation.
        Returns True if it's likely an abbreviation period, False otherwise.
        """
        if period_pos <= 0 or period_pos >= len(text) - 1:
            return False
            
        # Common abbreviations to check for
        common_abbrevs = ["mr.", "mrs.", "dr.", "prof.", "etc.", "e.g.", "i.e.", "vs."]
        
        # Check for the pattern of an abbreviation (lowercase + period)
        for abbrev in common_abbrevs:
            if period_pos >= len(abbrev) - 1:
                text_segment = text[period_pos - len(abbrev) + 1:period_pos + 1].lower()
                if text_segment == abbrev:
                    self.debug_print(f"Period at {period_pos} is part of abbreviation: '{abbrev}'")
                    return True
        
        # Check for initials (single letter followed by period)
        if period_pos > 0 and text[period_pos-1].isalpha():
            # Check if it's just a single letter
            if period_pos == 1 or not text[period_pos-2].isalpha():
                # If next char is uppercase, likely an initial
                if period_pos < len(text)-1 and text[period_pos+1].isupper():
                    self.debug_print(f"Period at {period_pos} is likely an initial")
                    return True
        
        # Check for decimal numbers (like 3.14)
        if period_pos > 0 and period_pos < len(text) - 1:
            if text[period_pos-1].isdigit() and text[period_pos+1].isdigit():
                self.debug_print(f"Period at {period_pos} is part of a decimal number")
                return True
        
        # Check for numbering schemes (like 1. or I.)
        if period_pos > 0:
            prev_char = text[period_pos-1]
            if prev_char.isdigit() or prev_char in "IVXLCDMivxlcdm":
                # Check if this is an isolated number/roman numeral followed by period
                if period_pos == 1 or text[period_pos-2].isspace():
                    self.debug_print(f"Period at {period_pos} is part of numbering scheme")
                    return True
        
        self.debug_print(f"Period at {period_pos} is NOT an abbreviation")
        return False
    
    def find_sentence_end(self, text, start_pos=0, search_term=None):
        """
        Find the first real sentence ending period.
        If search_term contains a period, starts looking after that initial period.
        """
        self.debug_print(f"Finding sentence end in: '{text[:50]}...' starting at pos {start_pos}")
        self.debug_print(f"Search term: '{search_term}'")
        
        # If search term ends with a period, adjust start position
        if search_term and '.' in search_term:
            self.debug_print(f"Search term contains period(s), checking if need to adjust start pos")
            case_sensitive = self.case_sensitive.isChecked()
            
            # Find where the search term appears in text
            if case_sensitive:
                if text.startswith(search_term):
                    last_period_in_term = search_term.rfind('.')
                    start_pos = max(start_pos, last_period_in_term + 1)
                    self.debug_print(f"Adjusted start_pos to {start_pos} (after period in search term)")
            else:
                if text.lower().startswith(search_term.lower()):
                    last_period_in_term = search_term.rfind('.')
                    start_pos = max(start_pos, last_period_in_term + 1)
                    self.debug_print(f"Adjusted start_pos to {start_pos} (after period in search term, case insensitive)")
        
        # Look for periods in the text after start_pos
        current_pos = start_pos
        while current_pos < len(text):
            # Find the next period
            period_pos = self.find_next_period(text, current_pos)
            if period_pos == -1:
                # No more periods found
                self.debug_print("No more periods found in text")
                return -1
                
            # Check if this period is part of an abbreviation
            if not self.is_abbreviation_period(text, period_pos):
                # This is a real sentence ending period
                self.debug_print(f"Found true sentence end at pos {period_pos}: '{text[max(0, period_pos-20):period_pos+1]}'")
                return period_pos
            
            # Move past this period and continue searching
            current_pos = period_pos + 1
            
        self.debug_print("No sentence end found after checking all periods")
        return -1  # No sentence end found
    
    def find_matches(self, search_term, case_sensitive):
        """
        Find and count every line that starts with the given search term –
        even if that line is already wrapped in the *opposite* style, so the
        user can re‑wrap it.  
        Lines that are already wrapped in the **requested** style are skipped.
        """
        if not search_term or not self.document_text:
            self.debug_print("No search term or document text")
            return [], 0

        matches = []
        lines = self.document_text.split('\n')
        target_section = self.section_radio.isChecked()   # True == [[…]]  mode

        for i, line in enumerate(lines):
            stripped = line.strip()
            if not stripped:
                continue

            # Detect current wrapper (if any)
            is_section = stripped.startswith("[[") and "]]" in stripped
            is_header  = stripped.startswith("**") and stripped.count("**") >= 2

            # Unwrap so the search‑term check uses plain text
            candidate = stripped
            if is_section:
                end = candidate.find("]]", 2)
                if end != -1:
                    candidate = candidate[2:end] + candidate[end+2:].lstrip()
            elif is_header:
                end = candidate.find("**", 2)
                if end != -1:
                    candidate = candidate[2:end] + candidate[end+2:].lstrip()

            # Does the (possibly unwrapped) line begin with our term?
            starts = candidate.startswith(search_term) if case_sensitive \
                     else candidate.lower().startswith(search_term.lower())
            if not starts:
                continue

            # Skip if it’s *already* in the desired wrapper style
            if (is_section and target_section) or (is_header and not target_section):
                self.debug_print(f"Line {i+1} already in desired style, skipping")
                continue

            # Otherwise we need to re‑wrap it
            self.debug_print(f"Match (needs re‑wrap) on line {i+1}: '{stripped[:50]}…'")
            matches.append({"line": stripped, "original_line": line})

        self.debug_print(f"Total matches found: {len(matches)}")
        return matches, len(matches)
    
    def get_text_to_format(self, line, search_term):
        """
        Extract the text that should be formatted based on current settings.
        Returns a tuple (text_to_format, remaining_text)
        """
        self.debug_print(f"Getting text to format from: '{line[:50]}...'")
        self.debug_print(f"With search term: '{search_term}'")
        
        if self.whole_line_radio.isChecked():
            # Format the whole line
            self.debug_print("Mode: Format whole line")
            return line, ""
            
        elif self.sentence_only_radio.isChecked():
            # Format up to the first real sentence end
            self.debug_print("Mode: Format to first sentence end")
            
            # First find the right starting point
            start_index = 0
            
            # Find the real sentence end, passing the search term
            period_index = self.find_sentence_end(line, start_index, search_term)
            self.debug_print(f"Sentence end found at position: {period_index}")
            
            if period_index > 0:
                text_to_format = line[:period_index + 1]  # Include the period
                remaining_text = line[period_index + 1:].lstrip()
                self.debug_print(f"Text to format: '{text_to_format}'")
                self.debug_print(f"Remaining text: '{remaining_text}'")
                return text_to_format, remaining_text
            else:
                # No sentence end found, format the whole line
                self.debug_print("No sentence end found, formatting whole line")
                return line, ""
                
        elif self.word_only_radio.isChecked():
            # Format only the matched word
            self.debug_print("Mode: Format word only")
            case_sensitive = self.case_sensitive.isChecked()
            
            if case_sensitive:
                start_index = line.find(search_term)
                self.debug_print(f"Found search term at position {start_index} (case sensitive)")
            else:
                line_lower = line.lower()
                search_term_lower = search_term.lower()
                start_index = line_lower.find(search_term_lower)
                self.debug_print(f"Found search term at position {start_index} (case insensitive)")
                
                # Get the actual case from the original text
                if start_index >= 0:
                    search_term = line[start_index:start_index + len(search_term)]
                    self.debug_print(f"Actual term in text: '{search_term}'")
            
            if start_index >= 0:
                # Extract parts
                before_word = line[:start_index]
                after_word = line[start_index + len(search_term):]
                
                self.debug_print(f"Before word: '{before_word}'")
                self.debug_print(f"Word to format: '{search_term}'")
                self.debug_print(f"After word: '{after_word}'")
                
                return search_term, before_word + after_word
            else:
                # Shouldn't happen as we already checked for match
                self.debug_print("ERROR: Couldn't find search term in line!")
                return search_term, line.replace(search_term, "")
        
        # Default fallback
        self.debug_print("WARNING: Using default fallback (whole line)")
        return line, ""
    
    def update_preview(self):
        """Update the preview based on current settings and show match count"""
        search_term = self.search_term.text().strip()
        case_sensitive = self.case_sensitive.isChecked()
    
        self.debug_print(f"\n--- Updating Preview ---")
        self.debug_print(f"Search term: '{search_term}'")
        self.debug_print(f"Case sensitive: {case_sensitive}")
        self.debug_print(f"Format whole line: {self.whole_line_radio.isChecked()}")
        self.debug_print(f"Format to sentence end: {self.sentence_only_radio.isChecked()}")
        self.debug_print(f"Format word only: {self.word_only_radio.isChecked()}")
    
        # Find matches in the document
        matches, count = self.find_matches(search_term, case_sensitive)
    
        # Update match count label
        if search_term:
            if count == 0:
                self.match_count_label.setText("No matches found")
                self.match_count_label.setStyleSheet("QLabel { color: #dc3545; font-weight: bold; }")
            elif count == 1:
                self.match_count_label.setText(f"1 match found")
                self.match_count_label.setStyleSheet("QLabel { color: #28a745; font-weight: bold; }")
            else:
                self.match_count_label.setText(f"{count} matches found")
                self.match_count_label.setStyleSheet("QLabel { color: #28a745; font-weight: bold; }")
        else:
            self.match_count_label.setText("Enter text to find matches")
            self.match_count_label.setStyleSheet("QLabel { color: #6c757d; font-weight: bold; }")
    
        # Get example text for preview
        if matches and count > 0:
            # Use the first actual match
            example_line = matches[0]["line"]
            self.debug_print(f"Using actual match for preview: '{example_line[:50]}...'")
        
            # Extract the part that would be formatted
            text_to_format, _ = self.get_text_to_format(example_line, search_term)
        
            # Truncate if too long
            if len(text_to_format) > 40:
                text_to_format = text_to_format[:37] + "..."
            
            example_text = text_to_format
        
        elif search_term:
            # No matches but we have a search term, create example
            if self.word_only_radio.isChecked():
                example_text = search_term
                #self.debug_print(f"Using search term as example: '{example_text}'")
            elif self.sentence_only_radio.isChecked():
                if '.' in search_term:
                    # If search term has a period, make an example with another element after it
                    parts = search_term.split('.')
                    if len(parts) > 1 and parts[0] and parts[1]:
                        example_text = f"{parts[0]}. {parts[1].strip()}"
                    else:
                        example_text = f"{search_term}"
                else:
                    example_text = f"{search_term}"
                self.debug_print(f"Using sample sentence as example: '{example_text}'")
            else:
                example_text = f"{search_term}"
                #self.debug_print(f"Using sample line as example: '{example_text}'")
        else:
            # Fallback example
            if self.word_only_radio.isChecked():
                example_text = "Word"
            elif self.sentence_only_radio.isChecked():
                example_text = "Placeholder header text"
            else:
                example_text = "Placeholder header text"
            self.debug_print(f"Using fallback example: '{example_text}'")
    
        # Show example in before preview
        self.preview_before.setText(example_text)
    
        # Show formatted example in after preview
        if self.header_radio.isChecked():
            # Header format - Rich text with proper styling
            header_color = "#2196F3"  # Blue for headers
        
            if not self.word_only_radio.isChecked():
                # Format with header in blue and following text in black
                formatted_html = f"<span style='color: {header_color}'>**{example_text}**</span><br>The rest continues here..."
            else:
                # Just the formatted word/text
                formatted_html = f"<span style='color: {header_color}'>**{example_text}**</span>"
        else:
            # Section divider format
            section_color = "#e6aa00"  # Gold for section dividers
        
            if not self.word_only_radio.isChecked():
                # Format with section divider in gold and following text in black
                formatted_html = f"<span style='color: {section_color}'>[[{example_text}]]</span><br>The rest continues here..."
            else:
                # Just the formatted word/text
                formatted_html = f"<span style='color: {section_color}'>[[{example_text}]]</span>"
    
        # Set the formatted HTML content
        self.preview_after.setHtml(formatted_html)
        self.debug_print(f"Preview after (HTML): '{formatted_html}'")

    def update_preview_colors(self):
        """Update the colors in the preview based on format selection"""
        # This method is no longer needed as we're using HTML formatting
        # in update_preview(), but keeping it for compatibility
        # The actual color updates happen in update_preview()
        self.update_preview()
    
    def is_section_format(self):
        """Return whether section divider format is selected"""
        return self.section_radio.isChecked()
        
    def get_formatted_text(self, original_text):
        """
        Apply the chosen wrapper style to every matching line.
        If a line is already wrapped in the *other* style it is first un‑wrapped,
        then re‑wrapped with the requested one.
        """
        search_term   = self.search_term.text().strip()
        case_sensitive = self.case_sensitive.isChecked()
        target_section = self.is_section_format()      # True == [[…]]

        if not search_term:
            return original_text

        self.debug_print("\n=== Formatting Document Text ===")
        lines_out = []

        for idx, raw in enumerate(original_text.split('\n')):
            stripped = raw.strip()
            if not stripped:
                lines_out.append(raw)
                continue

            # Identify existing wrapper
            is_section = stripped.startswith("[[") and "]]" in stripped
            is_header  = stripped.startswith("**") and stripped.count("**") >= 2

            # Build an unwrapped copy for all further checks
            work = stripped
            if is_section:
                end = work.find("]]", 2)
                if end != -1:
                    work = work[2:end] + work[end+2:].lstrip()
            elif is_header:
                end = work.find("**", 2)
                if end != -1:
                    work = work[2:end] + work[end+2:].lstrip()

            # Does it start with the term?
            if case_sensitive:
                starts = work.startswith(search_term)
            else:
                starts = work.lower().startswith(search_term.lower())

            if not starts:
                lines_out.append(raw)
                continue

            # Keep untouched if it already has the correct wrapper
            if (is_section and target_section) or (is_header and not target_section):
                lines_out.append(raw)
                continue

            self.debug_print(f"\nRe‑wrapping line {idx+1}: '{work[:50]}…'")

            # Collect leading whitespace to restore indentation
            leading_ws = re.match(r'^\s*', raw).group(0)

            # ---- figure out WHAT part to wrap (existing helper does that) ----
            text_to_wrap, remaining = self.get_text_to_format(work, search_term)

            # ---- apply the requested wrapper style --------------------------
            if target_section:          # → [[  ]]
                if self.word_only_radio.isChecked():
                    wrapped = work.replace(text_to_wrap, f"[[{text_to_wrap}]]", 1)
                    final   = leading_ws + wrapped
                else:
                    core = f"[[{text_to_wrap}]]"
                    if remaining:
                        lines_out.append(leading_ws + core)
                        final = leading_ws + remaining
                    else:
                        final = leading_ws + core
            else:                       # → **  **
                if self.word_only_radio.isChecked():
                    wrapped = work.replace(text_to_wrap, f"**{text_to_wrap}**", 1)
                    final   = leading_ws + wrapped
                else:
                    core = f"**{text_to_wrap}**"
                    if remaining:
                        lines_out.append(leading_ws + core)
                        final = leading_ws + remaining
                    else:
                        final = leading_ws + core

            self.debug_print(f"  Final line: '{final[:50]}…'")
            lines_out.append(final)

        self.debug_print("=== Formatting Complete ===\n")
        return '\n'.join(lines_out)

class ClickableLabel(QLabel):
    """
    A QLabel subclass that emits a clicked signal.
    """
    clicked = pyqtSignal()

    def mousePressEvent(self, event):
        self.clicked.emit()
        super().mousePressEvent(event)

class InstanceItemWidget(QWidget):
    """
    A selectable widget that displays the instance's context with highlighted text.
    """
    clicked = pyqtSignal()
    
    def __init__(self, rich_text, parent=None):
        super().__init__(parent)
        self.selected = False
        
        # Create a label to display the rich text
        self.label = ClickableLabel()
        self.label.setText(rich_text)
        self.label.setTextFormat(Qt.TextFormat.RichText)
        self.label.setStyleSheet("""
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 12px;
            color: #333333;
            line-height: 1.3;
        """)
        self.label.setWordWrap(True)
        self.label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Connect label's click signal to this widget's click signal
        self.label.clicked.connect(self.clicked.emit)
        
        # Arrange label in a layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(0)
        layout.addWidget(self.label)
        
        # Make the widget clickable
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        
        # Initialize styling
        self.update_selected_state(False)
        
    def mousePressEvent(self, event):
        self.clicked.emit()
        super().mousePressEvent(event)

    def set_selected(self, selected):
        self.selected = selected
        self.update_selected_state(selected)

    def update_selected_state(self, selected):
        if selected:
            self.setStyleSheet("""
                QWidget {
                    border: 2px solid #203740;
                    border-radius: 4px;
                    background-color: #f0f7ff;
                    padding: 0px;
                }
            """)
        else:
            self.setStyleSheet("""
                QWidget {
                    border: 1px solid #dddddd;
                    border-radius: 4px;
                    background-color: white;
                    padding: 0px;
                }
                QWidget:hover {
                    background-color: #f5f5f5;
                    border: 1px solid #cccccc;
                }
            """)

class InstanceSelectionDialog(QDialog):
    """
    A dialog that lists text instances as selectable items.
    """
    def __init__(self, instances, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Instance")
        self.instances = instances
        self.selected_index = None
        self.item_widgets = []
        
        # Set dialog-wide stylesheet
        self.setStyleSheet("""
            QDialog {
                background-color: white;
                color: #333333;
                font-family: 'Segoe UI', Arial, sans-serif;
            }
            QScrollBar:vertical {
                border: none;
                background: #f0f0f0;
                width: 8px;
                margin: 0px;
            }
            QScrollBar::handle:vertical {
                background: #c0c0c0;
                min-height: 20px;
                border-radius: 4px;
            }
            QScrollBar::handle:vertical:hover {
                background: #a0a0a0;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)
        
        self.setup_ui()

    def pre_select_instance(self, instance):
        """Pre-select the given instance in the dialog."""
        if instance in self.instances:
            index = self.instances.index(instance)
            self.select_item(index)

    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(12, 12, 12, 12)
        main_layout.setSpacing(10)

        # Header label
        header = QLabel("Multiple instances detected. Select one:")
        header.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #333333;
            margin-bottom: 4px;
        """)
        header.setAlignment(Qt.AlignmentFlag.AlignCenter)
        main_layout.addWidget(header)

        # Scroll area
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.Shape.NoFrame)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        
        container = QWidget()
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(6)

        # Create instance widgets
        for i, inst in enumerate(self.instances):
            # Create rich text with highlight styling
            rich_text = (
                f"{inst['context_before']}"
                f"<span style='font-weight: 600; background-color: #ffeb3b; padding: 1px 2px; border-radius: 2px;'>{inst['text']}</span>"
                f"{inst['context_after']}"
            )
            item = InstanceItemWidget(rich_text)
            item.clicked.connect(lambda idx=i: self.select_item(idx))
            self.item_widgets.append(item)
            container_layout.addWidget(item)

        container_layout.addStretch()  # Push items to the top
        scroll_area.setWidget(container)
        main_layout.addWidget(scroll_area)

        # Button layout
        button_layout = QHBoxLayout()
        button_layout.setSpacing(8)
        
        # Create buttons with custom styling
        cancel_button = QPushButton("Cancel")
        cancel_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #666666;
                border: 1px solid #cccccc;
                padding: 6px 12px;
                border-radius: 4px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #f5f5f5;
                border-color: #999999;
                color: #333333;
            }
            QPushButton:pressed {
                background-color: #eeeeee;
            }
        """)
        
        select_button = QPushButton("Select")
        select_button.setStyleSheet("""
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 6px 12px;
                border-radius: 4px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
        """)
        
        button_layout.addStretch()
        button_layout.addWidget(cancel_button)
        button_layout.addWidget(select_button)
        
        select_button.clicked.connect(self.accept_selection)
        cancel_button.clicked.connect(self.reject)
        
        main_layout.addLayout(button_layout)

        # Set dialog size
        screen_size = QApplication.primaryScreen().size()
        dialog_width = min(max(320, screen_size.width() // 4), 480)
        dialog_height = min(self.sizeHint().height(), screen_size.height() * 2 // 3)
        self.resize(dialog_width, dialog_height)
        
    def select_item(self, index):
        # Update the selected index and visual state
        self.selected_index = index
        
        # Update all items to show the correct selection state
        for i, item in enumerate(self.item_widgets):
            item.set_selected(i == index)

    def accept_selection(self):
        if self.selected_index is not None:
            self.accept()
        else:
            # Show a message if nothing is selected
            msg_box = QMessageBox(self)
            msg_box.setIcon(QMessageBox.Icon.Information)
            msg_box.setWindowTitle("No Selection")
            msg_box.setText("Please select an instance or cancel.")
            msg_box.setStandardButtons(QMessageBox.StandardButton.Ok)
            msg_box.exec()

    def get_selected_instance(self):
        if self.selected_index is not None:
            return self.instances[self.selected_index]
        return None

class XMarkCheckBox(QCheckBox):
    """Modern custom checkbox that shows an X mark when unchecked and a checkmark when checked"""
    def __init__(self, text, parent=None):
        super().__init__(text, parent)

        # Apply modern styling with clean lines and good contrast
        self.setStyleSheet("""
            QCheckBox {
                spacing: 8px;
            }
    
            QCheckBox::indicator {
                width: 14px;
                height: 14px;
                border: 1px solid #b0b0b0;
                border-radius: 2px;
                background-color: white;
            }
    
            QCheckBox::indicator:checked {
                background-color: #2E7D32;
                border-color: #2E7D32;
            }
    
            QCheckBox::indicator:hover {
                border-color: #2E7D32;
            }
    
            QCheckBox:disabled {
                color: #a0a0a0;
            }
    
            QCheckBox::indicator:disabled {
                border-color: #d0d0d0;
                background-color: #f0f0f0;
            }
    
            QCheckBox::indicator:checked:disabled {
                background-color: #a5d6a7;
                border-color: #a5d6a7;
            }
        """)

    def paintEvent(self, event):
        # Let the standard paint event handle base rendering
        super().paintEvent(event)

        # Get the indicator rect using proper styling options
        option = QStyleOptionButton()
        option.initFrom(self)
        rect = self.style().subElementRect(QStyle.SubElement.SE_CheckBoxIndicator, option, self)

        # Create painter with antialiasing for smooth rendering
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)

        # Calculate base center point
        width = rect.width()
        height = rect.height()
        base_center_x = rect.center().x()
        base_center_y = rect.center().y()

        # Draw X when unchecked
        if not self.isChecked():
            # Specific adjustment for X mark - shift more to the right
            center_x = base_center_x + 0.8  # Adjusted horizontal offset to 0.8
            center_y = base_center_y + 0.5
    
            # Setup for X drawing with proper color based on enabled state
            x_color = "#D32F2F" if self.isEnabled() else "#BDBDBD"  # Red when enabled, grey when disabled
            pen = QPen(QColor(x_color), 2.5, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin)
            painter.setPen(pen)
    
            # Smaller X with perfect centering
            offset = min(width, height) * 0.23
    
            # Draw the X with precise center alignment
            painter.drawLine(
                QPointF(center_x - offset, center_y - offset),
                QPointF(center_x + offset, center_y + offset)
            )
            painter.drawLine(
                QPointF(center_x - offset, center_y + offset),
                QPointF(center_x + offset, center_y - offset)
            )

        # Draw checkmark when checked
        elif self.isChecked():
            # Use the standard offset for checkmark that already looks good
            center_x = base_center_x + 0.5
            center_y = base_center_y + 0.5
    
            # Setup for checkmark drawing - white on green background
            # Use slightly different white shade when disabled
            check_color = "white" if self.isEnabled() else "#F5F5F5"
            pen = QPen(QColor(check_color), 2, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin)
            painter.setPen(pen)
    
            # Calculate checkmark size based on box dimensions
            checkmark_width = width * 0.65
            checkmark_height = height * 0.45
    
            # Precisely adjusted points for perfect centering
            # Left point of checkmark (start)
            left_x = center_x - checkmark_width/2.8
            left_y = center_y + checkmark_height/6
    
            # Bottom point of checkmark (middle)
            bottom_x = center_x - checkmark_width/15
            bottom_y = center_y + checkmark_height/2.2
    
            # Right point of checkmark (end)
            right_x = center_x + checkmark_width/2.2
            right_y = center_y - checkmark_height/2.5
    
            # Create and draw the checkmark path
            path = QPainterPath()
            path.moveTo(left_x, left_y)
            path.lineTo(bottom_x, bottom_y)
            path.lineTo(right_x, right_y)
    
            painter.drawPath(path)

        painter.end()

class HeaderSyntaxHighlighter(QSyntaxHighlighter):
    """Syntax highlighter for headers with cancellation support, progress dialog, and debug timestamps"""
    
    def __init__(self, document):
        super().__init__(document)
        
        # Format for main headers [[Section Divider]]
        self.main_header_format = QTextCharFormat()
        self.main_header_format.setForeground(QColor("#E6AA00"))  # Yellow
        self.main_header_format.setFontWeight(700)  # Bold
        self._major_formatting_active = False # New flag
        
        # Format for normal headers **Header**
        self.normal_header_format = QTextCharFormat()
        self.normal_header_format.setForeground(QColor("#2196F3"))  # Blue
        self.normal_header_format.setFontWeight(700)  # Bold
        
        # Format for orphaned text (text not under any header)
        self.orphaned_text_format = QTextCharFormat()
        self.orphaned_text_format.setForeground(QColor("#FF3333"))  # Red color
        # Optional: Ensure orphaned text is also not bold
        self.orphaned_text_format.setFontWeight(QFont.Weight.Normal)

        # Format for regular text - EXPLICIT BLACK COLOR AND NORMAL WEIGHT
        self.default_text_format = QTextCharFormat()
        self.default_text_format.setForeground(QColor("#000000"))  # Black
        self.default_text_format.setFontWeight(QFont.Weight.Normal) # <<< ADD THIS LINE
        
        # Pattern for main headers: [[...]]
        self.main_header_pattern = QRegularExpression(r"\[\[(.*?)\]\]")
        
        # Pattern for normal headers: **...**
        self.normal_header_pattern = QRegularExpression(r"\*\*(.*?)\*\*")
        
        # Track header positions and orphaned blocks
        self.header_blocks = set()
        self.orphaned_blocks = set()
        self.previous_orphaned_blocks = set()  # NEW: Track previous state of orphaned blocks
        
        # Flag to control when to check for orphaned text - disabled by default
        self.check_orphaned = False
        
        # Flag to temporarily pause highlighting for large operations
        self._highlighting_paused = False
        
        # Store last processed text to avoid redundant processing
        self._last_processed_text = ""
        
        # Add timestamp for last rehighlight to prevent too-frequent updates
        self._last_rehighlight_time = time.time()
        
        # Flag to prevent recursive rehighlights
        self._rehighlighting = False
        
        # Add cancellation support
        self._highlighting_active = False
        self._highlighting_cancelled = False
        self._cancel_check_func = None  # Will store a function to check for cancellation
        
        # Progress dialog reference
        self._progress_dialog = None
        self._progress_value = 0
        self._progress_max = 100
        
        # Debug mode for timestamps
        self._debug_enabled = True
        
        # NEW: Flag for header refresh coordination
        self._header_refresh_in_progress = False


    def force_orphaned_recheck(self):
        """
        Force a complete reanalysis of orphaned text status after headers have changed.
        Shows a progress dialog for the operation. Skips if formatting is in progress.
        Includes improved progress updates and error handling during rehighlighting.
        """
        # # --- Add Lock Check ---

        if getattr(self, '_major_formatting_active', False):
            print(f"{self._debug_timestamp()} [force_orphaned_recheck] Skipped: Major formatting operation active.")
            return

        main_window = None
        editor_instance = getattr(self, 'editor', None)
        if editor_instance and hasattr(editor_instance, 'window'):
             main_window = editor_instance.window()
             # Check if editor is CreateTranscriptTextEdit and has the flag
             if isinstance(editor_instance, CreateTranscriptTextEdit):
                 if getattr(editor_instance, '_formatting_in_progress', False):
                     print(f"{self._debug_timestamp()} [force_orphaned_recheck] Skipped: Formatting operation in progress (checked via editor).")
                     return
             # Fallback to checking main window if editor doesn't have it
             elif main_window and getattr(main_window, '_formatting_in_progress', False):
                 print(f"{self._debug_timestamp()} [force_orphaned_recheck] Skipped: Formatting operation in progress (checked via main window).")
                 return
        # --- End Lock Check ---

        print(f"{self._debug_timestamp()} [force_orphaned_recheck] Forcing complete orphaned text reanalysis")

        # Find parent widget for progress dialog more robustly
        parent_widget = None
        if editor_instance and isinstance(editor_instance, QWidget):
            parent_widget = editor_instance
        else:
            # Try to find parent through document (less reliable for QWidget parent)
            doc = self.document()
            if hasattr(doc, 'parent') and callable(doc.parent):
                doc_parent = doc.parent()
                if isinstance(doc_parent, QWidget):
                    parent_widget = doc_parent
                elif hasattr(doc_parent, 'view') and isinstance(doc_parent.view(), QWidget): # e.g., QPlainTextEdit
                    parent_widget = doc_parent.view()

        # Create progress dialog
        progress = QProgressDialog("Checking orphaned text status...", "Cancel", 0, 100, parent_widget)
        progress.setWindowTitle("Updating Text Format")
        try:
            progress.setWindowModality(Qt.WindowModality.WindowModal)
        except AttributeError:
            try: progress.setWindowModality(Qt.WindowModal) # Qt5 fallback
            except AttributeError: pass # Ignore if modality cannot be set
        progress.setMinimumDuration(1000)  # Only show if operation takes more than 1 second
        progress.setValue(0)
        QApplication.processEvents() # Show it briefly

        # Initialize state variables used in finally block
        old_rehighlighting = self._rehighlighting
        old_highlighting_paused = self._highlighting_paused

        try:
            # Save previous state (moved inside try)
            # old_rehighlighting = self._rehighlighting # Moved initialization up
            # old_highlighting_paused = self._highlighting_paused # Moved initialization up

            # Temporarily set states to allow analysis
            self._rehighlighting = False
            self._highlighting_paused = False
            self._highlighting_active = True
            self._highlighting_cancelled = False # Reset flag

            # Connect cancel button
            progress.canceled.connect(lambda: setattr(self, '_highlighting_cancelled', True))

            # Update progress
            progress.setValue(10)
            progress.setLabelText("Analyzing document structure...")
            QApplication.processEvents()

            # Check for early cancellation
            if self._highlighting_cancelled:
                 print(f"{self._debug_timestamp()} [force_orphaned_recheck] Cancelled before analysis start")
                 # No return here, let finally block handle cleanup
                 raise OperationCanceledError("Cancelled before analysis")


            # Save current orphaned blocks for comparison
            previous_orphaned = self.orphaned_blocks.copy() if hasattr(self, 'orphaned_blocks') else set()

            # Analyze the document with fresh state
            print(f"{self._debug_timestamp()} [force_orphaned_recheck] Running document analysis")

            doc = self.document() # Get document reference once
            doc_text = doc.toPlainText()
            doc_length = len(doc_text)
            max_blocks = doc.blockCount()

            # Skip analysis for very short documents
            if doc_length < 10:
                progress.setValue(100)
                return # Use return here as it's not an error/cancellation

            # Update progress
            progress.setValue(20)
            progress.setLabelText("Finding headers...")
            QApplication.processEvents()

            # Find all headers first
            block_count = 0
            header_blocks_indices = [] # Store indices
            block = doc.begin()
            while block.isValid():
                # Check for cancellation
                if self._highlighting_cancelled:
                    raise OperationCanceledError("Cancelled during header finding")

                # Update progress periodically
                if block_count % 100 == 0:
                    progress_value = 20 + int((block_count / max_blocks) * 30) if max_blocks > 0 else 50 # 20-50% progress
                    progress.setValue(progress_value)
                    progress.setLabelText(f"Finding headers ({block_count}/{max_blocks})...")
                    QApplication.processEvents() # Allow UI updates and cancel check

                text = block.text().strip()
                # Use match for efficiency
                if self.normal_header_pattern.match(text).hasMatch() or self.main_header_pattern.match(text).hasMatch():
                    header_blocks_indices.append(block.blockNumber())

                block = block.next()
                block_count += 1

            # Check for cancellation after loop
            if self._highlighting_cancelled:
                raise OperationCanceledError("Cancelled after header finding")

            # Update progress - clearly indicate the header analysis is complete
            progress.setValue(50)
            progress.setLabelText("Header analysis complete. Identifying orphaned text...")
            QApplication.processEvents()

            # Clear orphaned blocks and update internal header set
            self.orphaned_blocks.clear()
            self.header_blocks = set(header_blocks_indices) # Update the internal set

            # If no headers, all non-empty non-header blocks are orphaned
            if not header_blocks_indices:
                block = doc.begin()
                block_count = 0
                while block.isValid():
                     # Check for cancellation
                    if self._highlighting_cancelled:
                        raise OperationCanceledError("Cancelled during orphaned text identification (no headers)")
                    # Update progress periodically
                    if block_count % 100 == 0:
                        progress_value = 50 + int((block_count / max_blocks) * 25) if max_blocks > 0 else 75 # 50-75% progress
                        progress.setValue(progress_value)
                        progress.setLabelText(f"Checking text blocks ({block_count}/{max_blocks})...")
                        QApplication.processEvents()

                    text = block.text().strip()
                    # A block is orphaned if it has text AND is not a header
                    # (We already know there are no headers here, so just check for text)
                    if text:
                        self.orphaned_blocks.add(block.blockNumber())

                    block = block.next()
                    block_count += 1
            else:
                # Process blocks to identify orphaned text
                block = doc.begin()
                block_count = 0
                first_header_found = False # Track if *any* header has been encountered

                while block.isValid():
                    # Check for cancellation
                    if self._highlighting_cancelled:
                        raise OperationCanceledError("Cancelled during orphaned text identification (with headers)")
                    # Update progress periodically
                    if block_count % 100 == 0:
                        progress_value = 50 + int((block_count / max_blocks) * 25) if max_blocks > 0 else 75 # 50-75% progress
                        progress.setValue(progress_value)
                        progress.setLabelText(f"Identifying orphaned text ({block_count}/{max_blocks})...")
                        QApplication.processEvents()

                    block_num = block.blockNumber()
                    text = block.text().strip()

                    # Skip empty blocks
                    if not text:
                        block = block.next()
                        block_count += 1
                        continue

                    # Check if this is a header using the pre-calculated set
                    is_header = block_num in self.header_blocks

                    if is_header:
                        first_header_found = True # Mark that we've seen at least one header
                    elif not first_header_found:
                        # If it's not a header AND we haven't seen any header yet, it's orphaned
                        self.orphaned_blocks.add(block_num)

                    block = block.next()
                    block_count += 1

            # Check for cancellation before final steps
            if self._highlighting_cancelled:
                raise OperationCanceledError("Cancelled before final updates")

            # Calculate changed blocks
            newly_orphaned = self.orphaned_blocks - previous_orphaned
            no_longer_orphaned = previous_orphaned - self.orphaned_blocks
            changed_blocks = newly_orphaned | no_longer_orphaned

            print(f"{self._debug_timestamp()} [force_orphaned_recheck] Analysis complete. {len(newly_orphaned)} newly orphaned, {len(no_longer_orphaned)} no longer orphaned")

            # Enable orphaned checking
            self.check_orphaned = True

            # Update progress
            progress.setValue(75)
            if changed_blocks:
                 progress.setLabelText(f"Updating {len(changed_blocks)} changed blocks...")
            else:
                 progress.setLabelText("No formatting changes needed.")
            QApplication.processEvents()

            # Only update changed blocks to improve performance
            if changed_blocks:
                # doc reference already available
                processed = 0
                total_changed = len(changed_blocks) # Get total count once
                # --- CHANGE: Update progress less frequently ---
                update_interval = max(100, total_changed // 100) if total_changed > 0 else 100 # Avoid division by zero
                next_update_count = update_interval # First update after 'update_interval' blocks
                print(f"{self._debug_timestamp()} [force_orphaned_recheck] Update interval set to {update_interval} blocks")
                # --- END CHANGE ---

                for block_num in changed_blocks:
                    # Check for cancellation FIRST
                    if self._highlighting_cancelled:
                        raise OperationCanceledError(f"Cancelled during block update (block {block_num})")

                    # --- CHANGE: Update progress based on interval ---
                    if processed >= next_update_count or processed == total_changed -1 : # Update on interval or last block
                        progress_value = 75 + int((processed / total_changed) * 25) if total_changed > 0 else 100 # 75-100% progress
                        progress.setValue(progress_value)
                        # Limit processEvents calls significantly
                        QApplication.processEvents(QEventLoop.ProcessEventsFlag.ExcludeUserInputEvents)
                        print(f"{self._debug_timestamp()} [force_orphaned_recheck] Progress update at block {processed}/{total_changed} -> {progress_value}%")
                        next_update_count += update_interval # Set next update point

                        # Check cancellation *after* processEvents
                        if self._highlighting_cancelled:
                            raise OperationCanceledError(f"Cancelled during block update after processEvents (block {block_num})")
                    # --- END CHANGE ---

                    # Get block and rehighlight with error handling
                    try:
                        block = doc.findBlockByNumber(block_num)
                        if block.isValid():
                            # print(f"{self._debug_timestamp()} [force_orphaned_recheck] Rehighlighting block {block_num}") # Uncomment for deep debug
                            self.rehighlightBlock(block)
                            # print(f"{self._debug_timestamp()} [force_orphaned_recheck] Finished rehighlighting block {block_num}") # Uncomment for deep debug
                        else:
                            print(f"{self._debug_timestamp()} [force_orphaned_recheck] Warning: Block {block_num} is invalid, skipping.")

                    # --- CHANGE: Add specific error handling ---
                    except Exception as highlight_error:
                        print(f"{self._debug_timestamp()} [force_orphaned_recheck] ***** ERROR rehighlighting block {block_num} *****")
                        print(f"{self._debug_timestamp()} [force_orphaned_recheck] Error details: {highlight_error}")
                        import traceback
                        traceback.print_exc() # Print full traceback for errors
                        # Option 1: Continue processing other blocks (might leave some unstyled)
                        print(f"{self._debug_timestamp()} [force_orphaned_recheck] Skipping block {block_num} due to error and continuing.")
                        # Option 2: Abort the entire process (comment out the 'continue' above if you want this)
                        # raise Exception(f"Error highlighting block {block_num}") from highlight_error
                    # --- END CHANGE ---

                    processed += 1

                # Ensure final progress is 100 if not cancelled
                if not self._highlighting_cancelled:
                     progress.setValue(100)
                     print(f"{self._debug_timestamp()} [force_orphaned_recheck] Final update: {processed}/{total_changed} changed blocks")
                # else: # Logging for cancellation already happened inside the loop

            else:
                print(f"{self._debug_timestamp()} [force_orphaned_recheck] No blocks changed orphaned status")
                progress.setValue(100) # Ensure progress completes if no blocks changed

            # Complete progress (if not cancelled)
            if not self._highlighting_cancelled:
                progress.setLabelText("Update complete")
                QApplication.processEvents()

        except OperationCanceledError as cancel_err:
             print(f"{self._debug_timestamp()} [force_orphaned_recheck] Operation Cancelled: {cancel_err}")
             # Progress dialog closed in finally block

        except Exception as e:
            print(f"{self._debug_timestamp()} [force_orphaned_recheck] Error: {e}")
            import traceback
            traceback.print_exc()
            # Progress dialog closed in finally block

        finally:
            # Restore previous states
            self._rehighlighting = old_rehighlighting
            self._highlighting_paused = old_highlighting_paused
            self._highlighting_active = False # Always reset active flag

            # Close progress dialog safely
            if progress and progress.isVisible():
                # If cancelled, ensure value is updated before closing
                if self._highlighting_cancelled:
                     progress.setValue(progress.value()) # Keep current value on cancel
                     progress.setLabelText("Operation Cancelled.")
                     QTimer.singleShot(50, progress.close) # Close quickly on cancel
                else:
                     # Ensure it shows 100% on success
                     progress.setValue(100)
                     progress.setLabelText("Update complete")
                     QTimer.singleShot(200, progress.close) # Slightly longer delay on success

            print(f"{self._debug_timestamp()} [force_orphaned_recheck] Reanalysis complete")
    
    def _debug_timestamp(self):
        """Generate timestamp for debug messages"""
        if not hasattr(self, '_debug_enabled') or not self._debug_enabled:
            return ""
            
        # Format: [HH:MM:SS.mmm]
        current_time = QTime.currentTime()
        return f"[{current_time.toString('HH:mm:ss.zzz')}]"
        
    def set_cancellation_flag(self, cancel_check_func):
        """Set a function to check whether operation should be cancelled"""
        print(f"{self._debug_timestamp()} [set_cancellation_flag] Setting cancellation function")
        #traceback.print_stack()
        self._cancel_check_func = cancel_check_func
    
    def should_cancel(self):
        """Check if current operation should be cancelled"""
        result = (hasattr(self, '_cancel_check_func') and 
                self._cancel_check_func is not None and 
                self._cancel_check_func())
                
        if result:
            print(f"{self._debug_timestamp()} [should_cancel] Cancellation requested")
            
        return result
        
    def pause_highlighting(self):
        """Temporarily pause highlighting to improve performance during large text operations"""
        print(f"{self._debug_timestamp()} [pause_highlighting] Pausing highlighting")
        self._highlighting_paused = True

    def rehighlight_header_blocks(self):
        """Directly rehighlight all known header blocks"""
        print(f"{self._debug_timestamp()} [rehighlight_header_blocks] Starting selective header rehighlight")
    
        try:
            # Skip if rehighlighting is already in progress
            if self._rehighlighting:
                print(f"{self._debug_timestamp()} [rehighlight_header_blocks] Already rehighlighting, skipping")
                return
            
            # Set flag to prevent recursive rehighlighting
            self._rehighlighting = True
        
            # Get document
            doc = self.document()
        
            # Get block count for logging
            total_headers = len(self.header_blocks)
            print(f"{self._debug_timestamp()} [rehighlight_header_blocks] Found {total_headers} header blocks to rehighlight")
        
            # If no header blocks, nothing to do
            if not self.header_blocks:
                print(f"{self._debug_timestamp()} [rehighlight_header_blocks] No header blocks found, nothing to do")
                return
            
            # Process each header block
            processed = 0
            for block_num in self.header_blocks:
                block = doc.findBlockByNumber(block_num)
                if block.isValid():
                    # Directly rehighlight this block
                    self.rehighlightBlock(block)
                    processed += 1
                
            print(f"{self._debug_timestamp()} [rehighlight_header_blocks] Successfully rehighlighted {processed}/{total_headers} header blocks")
        
        finally:
            # Clear rehighlighting flag
            self._rehighlighting = False
            print(f"{self._debug_timestamp()} [rehighlight_header_blocks] Completed")

    # This should be a separate method in the HeaderSyntaxHighlighter class:
    def force_header_formatting_consistency(self):
        """Ensure text patterns and visual formatting are consistent"""
        print(f"{self._debug_timestamp()} [force_header_formatting_consistency] Ensuring pattern consistency")
    
        # Get document
        doc = self.document()
        if not doc:
            return False
    
        # First identify all header blocks and their formatting status
        header_blocks = {}  # {block_num: {'text': text, 'type': 'main'|'regular', 'formatted': bool}}
        misformatted_count = 0
    
        block = doc.begin()
        while block.isValid():
            text = block.text().strip()
            block_num = block.blockNumber()
        
            # Check for section dividers [[...]]
            if '[[' in text and ']]' in text:
                # Check visual formatting
                format = block.charFormat()
                color = format.foreground().color()
                is_yellow = color.red() > 200 and color.green() > 150 and color.blue() < 100
                correctly_formatted = is_yellow and format.fontWeight() >= QFont.Weight.Bold
            
                if not correctly_formatted:
                    misformatted_count += 1
                
                header_blocks[block_num] = {
                    'text': text,
                    'type': 'main',
                    'formatted': correctly_formatted
                }
        
            # Check for regular headers **...**
            elif '**' in text and '**' in text[2:]:
                # Check visual formatting
                format = block.charFormat()
                color = format.foreground().color()
                is_blue = color.blue() > 200 and color.red() < 100
                correctly_formatted = is_blue and format.fontWeight() >= QFont.Weight.Bold
            
                if not correctly_formatted:
                    misformatted_count += 1
                
                header_blocks[block_num] = {
                    'text': text,
                    'type': 'regular',
                    'formatted': correctly_formatted
                }
        
            block = block.next()
    
        # Exit if everything is properly formatted
        if misformatted_count == 0:
            print(f"{self._debug_timestamp()} [force_header_formatting_consistency] All {len(header_blocks)} headers correctly formatted")
            return False
    
        print(f"{self._debug_timestamp()} [force_header_formatting_consistency] Found {misformatted_count} misformatted headers out of {len(header_blocks)} total")
    
        # Apply formatting to all misformatted headers
        saved_states = {
            'rehighlighting': getattr(self, '_rehighlighting', False),
            'highlighting_paused': getattr(self, '_highlighting_paused', False)
        }
    
        try:
            # Temporarily block other operations
            self._rehighlighting = True
        
            # Create strong formatting
            main_format = QTextCharFormat()
            main_format.setForeground(QColor("#E6AA00"))  # Yellow/gold
            main_format.setFontWeight(QFont.Weight.Bold)
        
            normal_format = QTextCharFormat()
            normal_format.setForeground(QColor("#2196F3"))  # Blue
            normal_format.setFontWeight(QFont.Weight.Bold)
        
            # Direct formatting with cursor
            cursor = QTextCursor(doc)
            cursor.beginEditBlock()
        
            # Format each misformatted header
            for block_num, info in header_blocks.items():
                if not info['formatted']:
                    block = doc.findBlockByNumber(block_num)
                    if not block.isValid():
                        continue
                
                    # Select entire block text
                    cursor.setPosition(block.position())
                    cursor.movePosition(QTextCursor.MoveOperation.EndOfBlock, QTextCursor.MoveMode.KeepAnchor)
                
                    # Apply appropriate format
                    if info['type'] == 'main':
                        cursor.setCharFormat(main_format)  # Replace format completely
                    else:  # regular
                        cursor.setCharFormat(normal_format)  # Replace format completely
        
            cursor.endEditBlock()
        
            # Make sure our header_blocks set is up to date
            if hasattr(self, 'header_blocks'):
                self.header_blocks = set(header_blocks.keys())
        
            # Force document update
            doc.markContentsDirty(0, doc.characterCount())
        
            print(f"{self._debug_timestamp()} [force_header_formatting_consistency] Corrected formatting for {misformatted_count} headers")
            return True
        
        finally:
            # Restore original states
            self._rehighlighting = saved_states['rehighlighting']
            self._highlighting_paused = saved_states['highlighting_paused']    

    # 3. Replace the resume_highlighting method with this modified version
    def resume_highlighting(self):
        """Resume highlighting after it was paused"""
        print(f"{self._debug_timestamp()} [resume_highlighting] Resuming highlighting")

        # --- CALL CONSISTENCY CHECK HERE ---
        # CRITICAL: Force consistent formatting BEFORE resuming the main highlight cycle
        # if hasattr(self, 'force_header_formatting_consistency'):
        #     print(f"{self._debug_timestamp()} [resume_highlighting] Calling force_header_formatting_consistency.")
        #     self.force_header_formatting_consistency()
        # --- END CALL ---

        # Optionally call force_style_headers if still needed, but consistency check might be enough
        # if hasattr(self, 'force_style_headers'):
        #     self.force_style_headers()

        # IMPORTANT: Reset the header refresh in progress flag if it was set
        if hasattr(self, '_header_refresh_in_progress') and self._header_refresh_in_progress:
            self._header_refresh_in_progress = False
            print(f"{self._debug_timestamp()} [resume_highlighting] Cleared header refresh in progress flag")

        # If we weren't paused, do nothing EXCEPT we already ran consistency check
        if not self._highlighting_paused:
            print(f"{self._debug_timestamp()} [resume_highlighting] Highlighting wasn't paused, only consistency checked.")
            # Maybe trigger a throttled rehighlight anyway if consistency check made changes?
            # self._throttled_rehighlight() # Uncomment if needed
            return

        # Reset the paused flag but don't immediately rehighlight
        self._highlighting_paused = False
        print(f"{self._debug_timestamp()} [resume_highlighting] Set _highlighting_paused = False")

        # Check if enough time has passed since last rehighlight
        current_time = time.time()
        # Use a slightly longer delay to ensure consistency check effects are rendered
        if current_time - self._last_rehighlight_time > 0.5: # 0.5 second minimum
            print(f"{self._debug_timestamp()} [resume_highlighting] Time threshold met, scheduling throttled rehighlight")
            self._throttled_rehighlight()
            # self._last_rehighlight_time = current_time # Throttled rehighlight updates this
        else:
            print(f"{self._debug_timestamp()} [resume_highlighting] Too soon after last highlight ({current_time - self._last_rehighlight_time:.1f}s), skipping throttled rehighlight")

    def force_style_headers(self):
        """Force style application to headers without interference from other processes"""
        print(f"{self._debug_timestamp()} [force_style_headers] Applying critical style to headers")
    
        # Get document
        doc = self.document()
        if not doc:
            return
        
        # Store header state
        was_rehighlighting = getattr(self, '_rehighlighting', False)
        was_highlighting_paused = getattr(self, '_highlighting_paused', False)
        was_header_refresh = getattr(self, '_header_refresh_in_progress', False)
    
        try:
            # Block all highlighting processes temporarily
            self._rehighlighting = True
            self._highlighting_paused = True
            self._header_refresh_in_progress = True
        
            # Create special persistent formats
            main_format = QTextCharFormat()
            main_format.setForeground(QColor("#E6AA00"))  # Yellow
            main_format.setFontWeight(QFont.Weight.Bold)
            main_format.setFontPointSize(doc.defaultFont().pointSizeF())  # Maintain font size
        
            normal_format = QTextCharFormat()
            normal_format.setForeground(QColor("#2196F3"))  # Blue
            normal_format.setFontWeight(QFont.Weight.Bold)
            normal_format.setFontPointSize(doc.defaultFont().pointSizeF())  # Maintain font size
        
            # Process all header blocks with direct styling
            with QSignalBlocker(doc):  # Block signals during formatting
                cursor = QTextCursor(doc)
                cursor.beginEditBlock()
            
                # Look for headers directly in document
                block = doc.begin()
                while block.isValid():
                    text = block.text().strip()
                
                    # Apply section divider formatting
                    if '[[' in text and ']]' in text:
                        cursor.setPosition(block.position())
                        cursor.setPosition(block.position() + block.length() - 1, QTextCursor.MoveMode.KeepAnchor)
                        cursor.mergeCharFormat(main_format)
                        # Also explicitly add to header blocks
                        if hasattr(self, 'header_blocks'):
                            self.header_blocks.add(block.blockNumber())
                
                    # Apply chapter header formatting
                    elif '**' in text and '**' in text[2:]:
                        cursor.setPosition(block.position())
                        cursor.setPosition(block.position() + block.length() - 1, QTextCursor.MoveMode.KeepAnchor)
                        cursor.mergeCharFormat(normal_format)
                        # Also explicitly add to header blocks
                        if hasattr(self, 'header_blocks'):
                            self.header_blocks.add(block.blockNumber())
                
                    block = block.next()
                
                cursor.endEditBlock()
            
            # Force document update
            doc.markContentsDirty(0, doc.characterCount())
        
        finally:
            # Restore previous state
            self._rehighlighting = was_rehighlighting
            self._highlighting_paused = was_highlighting_paused
            self._header_refresh_in_progress = was_header_refresh
        
            print(f"{self._debug_timestamp()} [force_style_headers] Header styling completed")

    def apply_header_formatting(self):
        """Enhanced apply formatting to ALL headers with persistence guarantee"""
        print(f"{self._debug_timestamp()} [apply_header_formatting] Starting enhanced header formatting")
    
        try:
            # Get the document
            doc = self.document()
            if not doc:
                print(f"{self._debug_timestamp()} [apply_header_formatting] No document available")
                return
            
            # Check if there's text content
            if doc.isEmpty():
                print(f"{self._debug_timestamp()} [apply_header_formatting] Document is empty")
                return
            
            # Define the expected format colors
            expected_main_color = QColor("#E6AA00")  # Yellow/gold 
            expected_normal_color = QColor("#2196F3")  # Blue
        
            # Create strong formatting objects
            main_format = QTextCharFormat()
            main_format.setForeground(expected_main_color)
            main_format.setFontWeight(QFont.Weight.Bold)
            # Add persistence property
            main_format.setProperty(QTextFormat.UserProperty, "main_header_persistent")
        
            normal_format = QTextCharFormat()
            normal_format.setForeground(expected_normal_color)
            normal_format.setFontWeight(QFont.Weight.Bold)
            # Add persistence property
            normal_format.setProperty(QTextFormat.UserProperty, "normal_header_persistent")
        
            # Scan document for all headers - use string detection first for speed
            section_dividers = []  # [[section dividers]]
            chapter_headers = []   # **chapter headers**
            header_blocks = set()  # Track all header blocks
        
            block = doc.begin()
            while block.isValid():
                text = block.text().strip()
                block_num = block.blockNumber()
            
                # Detect section dividers [[...]]
                if '[[' in text and ']]' in text:
                    section_dividers.append((block_num, text))
                    header_blocks.add(block_num)
                
                # Detect chapter headers **...**
                elif '**' in text and '**' in text[2:]:  # Look for second ** after the first pair
                    chapter_headers.append((block_num, text))
                    header_blocks.add(block_num)
                
                block = block.next()
            
            # Log header count
            print(f"{self._debug_timestamp()} [apply_header_formatting] Found {len(section_dividers)} section dividers and {len(chapter_headers)} chapter headers")
        
            # Update header blocks tracking
            if hasattr(self, 'header_blocks'):
                self.header_blocks = header_blocks
            
            # Apply formatting directly with text cursor - with retries
            for attempt in range(2):  # Try up to twice for persistence
                cursor = QTextCursor(doc)
                cursor.beginEditBlock()
            
                # Format section dividers
                for block_num, text in section_dividers:
                    block = doc.findBlockByNumber(block_num)
                    if not block.isValid():
                        continue
                    
                    # Format entire block as main header
                    cursor.setPosition(block.position())
                    cursor.setPosition(block.position() + len(text), QTextCursor.MoveMode.KeepAnchor)
                    cursor.mergeCharFormat(main_format)
                
                # Format chapter headers
                for block_num, text in chapter_headers:
                    block = doc.findBlockByNumber(block_num)
                    if not block.isValid():
                        continue
                    
                    # Format entire block as normal header
                    cursor.setPosition(block.position())
                    cursor.setPosition(block.position() + len(text), QTextCursor.MoveMode.KeepAnchor)
                    cursor.mergeCharFormat(normal_format)
                
                cursor.endEditBlock()
            
                # Force document update
                doc.markContentsDirty(0, doc.characterCount())
            
                # Process minimal events to allow updates without triggering other processes
                QCoreApplication.processEvents(QEventLoop.ProcessEventsFlag.ExcludeSocketNotifiers | 
                                              QEventLoop.ProcessEventsFlag.ExcludeUserInputEvents)
        
            # Return header count for verification
            return len(section_dividers) + len(chapter_headers)
        
        except Exception as e:
            print(f"{self._debug_timestamp()} [apply_header_formatting] Error: {str(e)}")
            import traceback
            traceback.print_exc()
            return 0

    def _fallback_rehighlight_all_headers(self):
        """Extra fallback method to ensure all headers get highlighted"""
        print(f"{self._debug_timestamp()} [_fallback_rehighlight_all_headers] Starting fallback rehighlighting")
    
        # Always force color and format application regardless of previous state
        if hasattr(self, 'header_blocks') and self.header_blocks:
            doc = self.document()
        
            # Create stronger formatting objects with increased priority
            main_format = QTextCharFormat()
            main_format.setForeground(QColor("#E6AA00"))  # Yellow
            main_format.setFontWeight(QFont.Weight.Bold)
            main_format.setProperty(QTextFormat.UserProperty, "main_header")  # Add property to prevent override
        
            normal_format = QTextCharFormat()
            normal_format.setForeground(QColor("#2196F3"))  # Blue
            normal_format.setFontWeight(QFont.Weight.Bold)
            normal_format.setProperty(QTextFormat.UserProperty, "normal_header")  # Add property to prevent override
        
            # Apply formatting directly
            cursor = QTextCursor(doc)
            cursor.beginEditBlock()
        
            for block_num in self.header_blocks:
                block = doc.findBlockByNumber(block_num)
                if block.isValid():
                    text = block.text()
                    if '[[' in text and ']]' in text:
                        # Apply main header format with direct cursor
                        cursor.setPosition(block.position())
                        cursor.setPosition(block.position() + len(text), QTextCursor.MoveMode.KeepAnchor)
                        cursor.mergeCharFormat(main_format)
                    elif '**' in text:
                        # Apply normal header format with direct cursor
                        cursor.setPosition(block.position())
                        cursor.setPosition(block.position() + len(text), QTextCursor.MoveMode.KeepAnchor)
                        cursor.mergeCharFormat(normal_format)
                    
            cursor.endEditBlock()
        
            # Force document update
            doc.markContentsDirty(0, doc.characterCount())
    
    # NEW: Method to cancel scheduled rehighlights
    def cancel_scheduled_rehighlights(self):
        """Cancel any scheduled rehighlights"""
        print(f"{self._debug_timestamp()} [cancel_scheduled_rehighlights] Checking for pending rehighlights")
    
        if hasattr(self, '_rehighlight_timer') and self._rehighlight_timer.isActive():
            self._rehighlight_timer.stop()
            print(f"{self._debug_timestamp()} [cancel_scheduled_rehighlights] Cancelled active rehighlight timer")
    
        # Set a flag that will be checked by _safe_rehighlight
        self._header_refresh_in_progress = True
    
        # Store the time when we set this flag for timeout detection
        self._header_refresh_set_time = time.time()
    
        # Schedule the removal of this flag after a reasonable amount of time
        if not hasattr(self, '_header_refresh_timer'):
            self._header_refresh_timer = QTimer()
            self._header_refresh_timer.setSingleShot(True)
            self._header_refresh_timer.timeout.connect(self._clear_header_refresh_flag)
        
        # Set a 3-second timeout - longer than most header refresh operations
        self._header_refresh_timer.start(3000)
    
        print(f"{self._debug_timestamp()} [cancel_scheduled_rehighlights] Set header refresh flag for 3s")

    # NEW: Method to clear header refresh flag
    def _clear_header_refresh_flag(self):
        """Clear the header refresh in progress flag"""
        if hasattr(self, '_header_refresh_in_progress'):
            self._header_refresh_in_progress = False
            print(f"{self._debug_timestamp()} [_clear_header_refresh_flag] Cleared header refresh flag")
    
    # Fix for _throttled_rehighlight
    def _throttled_rehighlight(self):
        """Extremely throttled rehighlight to prevent stuttering"""
        print(f"{self._debug_timestamp()} [_throttled_rehighlight] Called")
    
        # NEW: Check for header refresh in progress - skip if active
        if hasattr(self, '_header_refresh_in_progress') and self._header_refresh_in_progress:
            print(f"{self._debug_timestamp()} [_throttled_rehighlight] Header refresh in progress, skipping")
            return
    
        # Skip if we're already rehighlighting or if it's paused
        if self._rehighlighting or self._highlighting_paused:
            print(f"{self._debug_timestamp()} [_throttled_rehighlight] Skipped: already rehighlighting={self._rehighlighting}, paused={self._highlighting_paused}")
            return
        
        # Check for cancellation
        if self.should_cancel():
            print(f"{self._debug_timestamp()} [_throttled_rehighlight] Cancelled due to typing")
            return
        
        # Check if a rehighlight is already scheduled
        if hasattr(self, '_rehighlight_timer') and self._rehighlight_timer.isActive():
            print(f"{self._debug_timestamp()} [_throttled_rehighlight] Rehighlight already scheduled")
            return  # Don't schedule another one
        
        # Create timer if needed
        if not hasattr(self, '_rehighlight_timer'):
            print(f"{self._debug_timestamp()} [_throttled_rehighlight] Creating rehighlight timer")
            self._rehighlight_timer = QTimer()
            self._rehighlight_timer.setSingleShot(True)
            self._rehighlight_timer.timeout.connect(self._safe_rehighlight)
    
        # Schedule with original delay from your code
        print(f"{self._debug_timestamp()} [_throttled_rehighlight] Starting rehighlight timer with 50ms delay")
        self._rehighlight_timer.start(50)  # Use your original 50ms delay
        

    def _safe_rehighlight(self):
        """Run rehighlight with safety measures against recursion and cancellation"""
        # --- Check NEW flag ---
        if getattr(self, '_major_formatting_active', False):
            print(f"{self._debug_timestamp()} [_safe_rehighlight] Skipped: Major formatting operation active.")
            return
        # --- End Check ---
        print(f"{self._debug_timestamp()} [_safe_rehighlight] Called")
    
        # Make a local copy of header refresh flag for more reliable checking
        header_refresh_active = hasattr(self, '_header_refresh_in_progress') and self._header_refresh_in_progress
    
        # NEW: If header refresh has been active for more than 10 seconds, forcibly clear it
        # This prevents a stuck flag from permanently disabling highlighting
        if header_refresh_active and hasattr(self, '_header_refresh_set_time'):
            current_time = time.time()
            if current_time - self._header_refresh_set_time > 10.0:  # 10 second timeout
                self._header_refresh_in_progress = False
                print(f"{self._debug_timestamp()} [_safe_rehighlight] Forcibly cleared stale header refresh flag")
                header_refresh_active = False
    
        # Check if headers refresh is in progress - skip rehighlight completely if so
        if header_refresh_active:
            print(f"{self._debug_timestamp()} [_safe_rehighlight] Header refresh in progress, SKIPPING rehighlight")
            return
            
        try:
            # Skip if already rehighlighting or paused
            if self._rehighlighting or self._highlighting_paused:
                print(f"{self._debug_timestamp()} [_safe_rehighlight] Skipped: already rehighlighting={self._rehighlighting}, paused={self._highlighting_paused}")
                return
        
            # IMPORTANT: Check for active modal dialogs - COMPLETELY SKIP REHIGHLIGHTING when a modal dialog is open
            app = QApplication.instance()
            if app:
                active_modal_widgets = [w for w in app.topLevelWidgets() if w.isVisible() and w.isModal()]
                if active_modal_widgets:
                    print(f"{self._debug_timestamp()} [_safe_rehighlight] Modal dialog active, SKIPPING rehighlight completely")
                    return
    
            # Check for cancellation before starting
            if self.should_cancel():
                print(f"{self._debug_timestamp()} [_safe_rehighlight] Cancelled due to typing")
                return
    
            # Set the rehighlighting flag to prevent recursion
            self._rehighlighting = True

            # Set the active flag to allow progress tracking
            self._highlighting_active = True
            self._highlighting_cancelled = False

            # Get document information for progress estimation
            doc = self.document()
            block_count = doc.blockCount()

            # Determine if progress dialog should be shown
            show_progress = block_count > 500  # Adjust threshold as needed
    
            # CRITICAL: Check if session is loading - don't show progress dialog during session load
            if hasattr(self, 'is_loading_session') and self.is_loading_session:
                print(f"{self._debug_timestamp()} [_safe_rehighlight] Session loading in progress, suppressing progress dialog")
                show_progress = False
            
            if show_progress:
                # Find a widget to use as parent - QSyntaxHighlighter.parent() returns a QTextDocument, not a widget
                # Try to find the document's parent widget if possible
                parent_widget = None
    
                # First check if we've stored a reference to the editor
                if hasattr(self, 'editor') and self.editor is not None:
                    parent_widget = self.editor
                # Try to find a widget through associated QTextEdit/QPlainTextEdit
                elif hasattr(doc, 'parent') and callable(doc.parent):
                    doc_parent = doc.parent()
                    if doc_parent is not None and hasattr(doc_parent, 'viewport'):
                        parent_widget = doc_parent
    
                # Create progress dialog with appropriate parent
                progress = QProgressDialog("Rehighlighting document...", "Cancel", 0, 100, parent_widget)
                progress.setWindowTitle("Rehighlighting")
                progress.setWindowModality(Qt.WindowModality.WindowModal)
                progress.setMinimumDuration(1000)  # Only show if operation takes more than 3 seconds
                progress.show()
    
                # Connect cancel button to highlighting cancelled flag
                progress.canceled.connect(lambda: setattr(self, '_highlighting_cancelled', True))
    
                # Store progress dialog for access in highlightBlock
                self._rehighlight_progress = progress
    
                # Initial progress update
                progress.setValue(0)
                QApplication.processEvents()

            # Do the actual rehighlight with cancellation protection
            if not self.should_cancel():
                # Disable auto rehighlighting temporarily
                print(f"{self._debug_timestamp()} [_safe_rehighlight] Disabling auto rehighlighting")
                old_auto_rehighlight = self.document().metaObject().userProperty().read(self.document())
                self.document().metaObject().userProperty().write(self.document(), False)
    
                if show_progress:
                    progress.setLabelText("Preparing document...")
                    progress.setValue(10)
                    QApplication.processEvents()
    
                # Store the total blocks for progress tracking
                if show_progress:
                    self._total_blocks = block_count
                    self._processed_blocks = 0
    
                # Do the rehighlight
                print(f"{self._debug_timestamp()} [_safe_rehighlight] Performing rehighlight")
    
                if show_progress:
                    progress.setLabelText("Analyzing text formatting...")
                    progress.setValue(20)
                    QApplication.processEvents()
    
                # IMPORTANT: Check for header blocks first and prioritize them
                if hasattr(self, 'header_blocks') and self.header_blocks:
                    print(f"{self._debug_timestamp()} [_safe_rehighlight] Prioritizing {len(self.header_blocks)} header blocks")
                    for block_num in self.header_blocks:
                        block = doc.findBlockByNumber(block_num)
                        if block.isValid():
                            self.rehighlightBlock(block)
    
                # Then do the normal rehighlight
                self.rehighlight()
    
                # Restore auto rehighlighting
                print(f"{self._debug_timestamp()} [_safe_rehighlight] Restoring auto rehighlighting")
                self.document().metaObject().userProperty().write(self.document(), old_auto_rehighlight)

            # Clean up progress dialog
            if show_progress:
                progress.setValue(100)
                QTimer.singleShot(100, progress.close)
                delattr(self, '_rehighlight_progress')
    
                if hasattr(self, '_total_blocks'):
                    delattr(self, '_total_blocks')
                if hasattr(self, '_processed_blocks'):
                    delattr(self, '_processed_blocks')

            # Update the timestamp
            self._last_rehighlight_time = time.time()
            print(f"{self._debug_timestamp()} [_safe_rehighlight] Rehighlight completed")

        finally:
            # Always clear the flags
            self._rehighlighting = False
            self._highlighting_active = False
        
            # Also check and clear header refresh flag if it's been more than 5 seconds
            if hasattr(self, '_header_refresh_in_progress') and self._header_refresh_in_progress:
                if hasattr(self, '_header_refresh_set_time'):
                    current_time = time.time()
                    if current_time - self._header_refresh_set_time > 5.0:
                        self._header_refresh_in_progress = False
                        print(f"{self._debug_timestamp()} [_safe_rehighlight] Cleared stale header refresh flag in finally block")



    def highlightBlock(self, text):
        """
        Apply highlighting to the given block of text with explicit logic
        and whole-block formatting for headers/orphans/default.
        """
        # --- Initial Checks ---
        if self._highlighting_paused or self._highlighting_cancelled:
            return
        if self.should_cancel():
            self._highlighting_cancelled = True
            print(f"{self._debug_timestamp()} [highlightBlock] Cancelled highlighting due to typing")
            return

        # --- Progress Update Code (Keep if used) ---
        if hasattr(self, '_rehighlight_progress') and hasattr(self, '_total_blocks') and hasattr(self, '_processed_blocks'):
            self._processed_blocks += 1
            if self._processed_blocks % 50 == 0 or self._processed_blocks == self._total_blocks:
                if self._total_blocks > 0: # Avoid division by zero
                     progress_percent = 20 + int(75.0 * self._processed_blocks / self._total_blocks)
                     self._rehighlight_progress.setValue(progress_percent)
                if self._processed_blocks % 200 == 0:
                    self._rehighlight_progress.setLabelText(f"Processing text ({self._processed_blocks}/{self._total_blocks} blocks)...")
                QApplication.processEvents()
        # --- End Progress Update ---

        # --- Get Block Info ---
        current_block = self.currentBlock()
        block_number = current_block.blockNumber()
        block_length = current_block.length() # Use block length for formatting

        # --- Skip Empty Blocks ---
        # Check the raw text length; strip() can be slow in a loop
        if block_length <= 1 and not text.strip():
             # Optionally apply default format to empty lines if needed for background etc.
             # self.setFormat(0, 0, self.default_text_format)
             self.setCurrentBlockState(0) # Reset state even for empty blocks
             return

        # --- Determine Correct Format ---
        determined_format = None

        # 1. Check for Main Header (using strict regex)
        if self.main_header_pattern.match(text).hasMatch():
            determined_format = self.main_header_format
            if hasattr(self, 'header_blocks'): self.header_blocks.add(block_number)
            # print(f"Block {block_number}: Applying MAIN Header") # Debug

        # 2. Else, check for Normal Header (using strict regex)
        elif self.normal_header_pattern.match(text).hasMatch():
            determined_format = self.normal_header_format
            if hasattr(self, 'header_blocks'): self.header_blocks.add(block_number)
            # print(f"Block {block_number}: Applying NORMAL Header") # Debug

        # 3. Else, check if Orphaned
        elif getattr(self, 'check_orphaned', False) and \
             hasattr(self, 'orphaned_blocks') and \
             block_number in self.orphaned_blocks:
            determined_format = self.orphaned_text_format
            # print(f"Block {block_number}: Applying ORPHANED") # Debug

        # --- Apply Determined Format or Default ---
        if determined_format is not None:
            # Apply Header or Orphaned format to the entire block length
            # Using block_length - 1 ensures we don't format the newline character itself
            self.setFormat(0, block_length -1 if block_length > 0 else 0, determined_format)
        else:
            # Apply Default format (Black, Normal Weight) to the entire block length
            # print(f"Block {block_number}: Applying DEFAULT") # Debug
            self.setFormat(0, block_length -1 if block_length > 0 else 0, self.default_text_format)

        # --- Reset Block State ---
        # Explicitly reset the state for the next block's processing.
        self.setCurrentBlockState(0)
    
    def _show_progress_dialog(self, title, text, max_value):
        """Show a progress dialog for long-running operations with proper parent widget"""
        print(f"{self._debug_timestamp()} [_show_progress_dialog] Creating progress dialog: {title}")
    
        # Find valid parent widget for the dialog
        parent = None
        doc = self.document()
    
        # Try to find a parent widget by traversing up the hierarchy
        if hasattr(doc, 'parent'):
            obj = doc.parent()
            # Check if it's a widget or find a widget parent
            while obj and not isinstance(obj, QWidget):
                if hasattr(obj, 'parent'):
                    obj = obj.parent()
                else:
                    obj = None
            parent = obj
    
        # Debug output for troubleshooting
        if parent:
            print(f"{self._debug_timestamp()} [_show_progress_dialog] Found parent widget: {type(parent).__name__}")
        else:
            print(f"{self._debug_timestamp()} [_show_progress_dialog] No suitable parent widget found, using None")
    
        # Create progress dialog with safer initialization
        try:
            self._progress_dialog = QProgressDialog(text, "Cancel", 0, max_value, parent)
            self._progress_dialog.setWindowTitle(title)
            self._progress_dialog.setMinimumDuration(3000)  # Only show if operation takes more than 3 seconds
            self._progress_dialog.setCancelButton(None)  # Hide cancel button since we handle cancellation separately
            self._progress_dialog.setWindowModality(Qt.WindowModality.WindowModal)
            self._progress_dialog.setMinimumWidth(300)

            # Store progress values
            self._progress_value = 0
            self._progress_max = max_value

            return self._progress_dialog
        except Exception as e:
            print(f"{self._debug_timestamp()} [_show_progress_dialog] Error creating progress dialog: {e}")
            # Create a fallback version with minimal arguments
            try:
                if parent and isinstance(parent, QWidget):
                    self._progress_dialog = QProgressDialog(parent)
                else:
                    self._progress_dialog = QProgressDialog()
                self._progress_dialog.setLabelText(text)
                self._progress_dialog.setCancelButtonText("Cancel")
                self._progress_dialog.setMinimum(0)
                self._progress_dialog.setMaximum(max_value)
                self._progress_dialog.setWindowTitle(title)
                return self._progress_dialog
            except Exception as e2:
                print(f"{self._debug_timestamp()} [_show_progress_dialog] Fallback dialog also failed: {e2}")
                # Disable progress dialog functionality completely
                self._progress_dialog = None
                return None 
    
    def _update_progress(self, value, text=None):
        """Update the progress dialog"""
        if self._progress_dialog and not self._progress_dialog.wasCanceled():
            # Update progress value
            self._progress_value = min(value, self._progress_max)
            self._progress_dialog.setValue(self._progress_value)
            
            # Update text if provided
            if text:
                self._progress_dialog.setLabelText(text)
                
            # Process events to ensure UI updates
            QApplication.processEvents()
            
            # Check if user cancelled
            if self._progress_dialog.wasCanceled():
                print(f"{self._debug_timestamp()} [_update_progress] Progress dialog cancelled by user")
                return True
                
        return False
                
    def analyze_document(self):
        """Unified document analysis with correct orphaned text detection
           where ONLY **Normal Headers** prevent preceding text from being orphaned."""
        print(f"{self._debug_timestamp()} [analyze_document] Starting document analysis (Corrected Logic)")

        # Check for header refresh in progress
        if hasattr(self, '_header_refresh_in_progress') and self._header_refresh_in_progress:
            print(f"{self._debug_timestamp()} [analyze_document] Header refresh in progress, deferring analysis")
            return

        # --- Initialize progress variables ---
        progress = None
        using_shared_dialog = False # Track if using a shared dialog
        if hasattr(self, '_shared_progress_dialog') and self._shared_progress_dialog:
             progress = self._shared_progress_dialog
             progress_min = getattr(self, '_shared_progress_min', 0)
             progress_max = getattr(self, '_shared_progress_max', 100)
             using_shared_dialog = True
             print(f"{self._debug_timestamp()} [analyze_document] Using shared progress dialog ({progress_min}-{progress_max})")
        else:
             progress_min = 0
             progress_max = 100
             print(f"{self._debug_timestamp()} [analyze_document] No shared progress dialog found.")
        # --- End Initialize progress ---

        try:
            # Set active flag to allow cancellation
            self._highlighting_active = True
            self._highlighting_cancelled = False

            # Get the document text
            doc = self.document()
            doc_text = doc.toPlainText()
            doc_length = len(doc_text)
            max_blocks = doc.blockCount()

            print(f"{self._debug_timestamp()} [analyze_document] Document length: {doc_length} characters, {max_blocks} blocks")

            # Store text for future comparisons
            self._last_processed_text = doc_text

            # Save previous orphaned blocks for comparison
            if hasattr(self, 'orphaned_blocks'):
                self.previous_orphaned_blocks = self.orphaned_blocks.copy()
            else:
                self.previous_orphaned_blocks = set()
                self.orphaned_blocks = set()

            # Check for progress dialog needs only if not using shared
            show_progress_dialog_locally = (not using_shared_dialog) and (doc_length > 20000)
            if show_progress_dialog_locally:
                print(f"{self._debug_timestamp()} [analyze_document] Using own progress dialog for large document")
                # Phase 1: Header Finding (0% - 40%)
                self._show_progress_dialog("Analyzing Document", "Finding headers...", 100)
                progress = self._progress_dialog # Use the created dialog
                # Ensure range is set correctly for the _update_progress helper
                self._progress_min_value = 0
                self._progress_max_value = 100
            elif progress:
                # Update shared dialog state
                self._progress_dialog = progress
                self._progress_min_value = progress_min
                self._progress_max_value = progress_max


            # Cancellation checkpoint
            if self.should_cancel():
                print(f"{self._debug_timestamp()} [analyze_document] Cancelled at checkpoint 1")
                self._highlighting_cancelled = True
                return

            # ===== PHASE 1: FIND ALL HEADERS (Separately) =====
            normal_header_indices = set()
            main_header_indices = set()
            all_header_indices = set() # Combined set for quick lookups later

            phase_1_start = progress_min
            phase_1_end = progress_min + int((progress_max - progress_min) * 0.4) # Allocate 40% of range

            # Use text splitting for very large documents
            large_doc_threshold = 10000
            is_large_doc = doc_length > large_doc_threshold

            # --- Progress Update Helper ---
            def update_analysis_progress(current, total, phase_start, phase_end, label):
                if progress:
                     phase_progress = (current / total) if total > 0 else 1.0
                     # Calculate overall progress value based on the min/max of THIS instance
                     overall_progress = self._progress_min_value + int(phase_progress * (self._progress_max_value - self._progress_min_value) * ( (phase_end - phase_start)/100.0 ) )
                     # Apply the phase start offset relative to the instance's min value
                     overall_progress += int( (phase_start / 100.0) * (self._progress_max_value - self._progress_min_value) )

                     self._update_progress(overall_progress, f"{label} ({current}/{total})...")

            if is_large_doc:
                lines = doc_text.split('\n')
                line_count = len(lines)
                print(f"{self._debug_timestamp()} [analyze_document] Large doc detected, using line-based analysis ({line_count} lines)")
                for i, line in enumerate(lines):
                    if i % max(1, line_count // 20) == 0:
                        update_analysis_progress(i, line_count, phase_1_start, phase_1_end, "Finding headers")
                    if i % 100 == 0 and self.should_cancel():
                         print(f"{self._debug_timestamp()} [analyze_document] Cancelled during header scan (lines)")
                         self._highlighting_cancelled = True; return

                    line_text = line.strip()
                    is_main = '[[' in line_text and ']]' in line_text
                    is_normal = '**' in line_text and '**' in line_text[2:]
                    if is_main:
                        main_header_indices.add(i)
                        all_header_indices.add(i)
                    elif is_normal:
                        normal_header_indices.add(i)
                        all_header_indices.add(i)
            else:
                block = doc.begin()
                block_count = 0
                print(f"{self._debug_timestamp()} [analyze_document] Using block-based analysis ({max_blocks} blocks)")
                while block.isValid():
                    if block_count % max(1, max_blocks // 20) == 0:
                        update_analysis_progress(block_count, max_blocks, phase_1_start, phase_1_end, "Finding headers")
                    if block_count % 50 == 0 and self.should_cancel():
                         print(f"{self._debug_timestamp()} [analyze_document] Cancelled during header scan (blocks)")
                         self._highlighting_cancelled = True; return

                    block_text = block.text().strip()
                    block_num = block.blockNumber()
                    is_main = '[[' in block_text and ']]' in block_text
                    is_normal = '**' in block_text and '**' in block_text[2:]
                    if is_main:
                        main_header_indices.add(block_num)
                        all_header_indices.add(block_num)
                    elif is_normal:
                        normal_header_indices.add(block_num)
                        all_header_indices.add(block_num)

                    block = block.next()
                    block_count += 1

            print(f"{self._debug_timestamp()} [analyze_document] Found {len(normal_header_indices)} Normal Headers and {len(main_header_indices)} Section Dividers")

            # Update the main header_blocks attribute with ALL headers
            if hasattr(self, 'header_blocks'):
                self.header_blocks = all_header_indices.copy()

            # ===== PHASE 2: DETERMINE ORPHANED TEXT (Based *only* on Normal Headers) =====
            self.orphaned_blocks.clear()
            phase_2_start = phase_1_end # Start where phase 1 ended
            phase_2_end = progress_min + int((progress_max - progress_min) * 0.95) # Allocate up to 95% overall

            if progress:
                 # Use instance update method
                 self._update_progress(phase_2_start, "Identifying orphaned text...")

            # CRITICAL FIX: Check if NORMAL headers exist
            if not normal_header_indices:
                print(f"{self._debug_timestamp()} [analyze_document] No NORMAL headers found, all non-header text is orphaned")

                if is_large_doc:
                    for i, line in enumerate(lines):
                        if i % max(1, line_count // 20) == 0:
                            update_analysis_progress(i, line_count, phase_2_start, phase_2_end, "Marking orphaned lines")
                        if i % 100 == 0 and self.should_cancel():
                            print(f"{self._debug_timestamp()} [analyze_document] Cancelled during orphaned text ID (no normal headers, lines)")
                            self._highlighting_cancelled = True; return
                        # Mark as orphaned if non-empty AND not ANY type of header
                        if line.strip() and i not in all_header_indices:
                            self.orphaned_blocks.add(i)
                else:
                    block = doc.begin()
                    block_count = 0
                    while block.isValid():
                        if block_count % max(1, max_blocks // 20) == 0:
                            update_analysis_progress(block_count, max_blocks, phase_2_start, phase_2_end, "Marking orphaned blocks")
                        if block_count % 50 == 0 and self.should_cancel():
                             print(f"{self._debug_timestamp()} [analyze_document] Cancelled during orphaned text ID (no normal headers, blocks)")
                             self._highlighting_cancelled = True; return
                        block_num = block.blockNumber()
                        # Mark as orphaned if non-empty AND not ANY type of header
                        if block.text().strip() and block_num not in all_header_indices:
                            self.orphaned_blocks.add(block_num)
                        block = block.next()
                        block_count += 1
            else:
                # NORMAL headers exist, find the first one
                first_normal_header_pos = min(normal_header_indices)
                print(f"{self._debug_timestamp()} [analyze_document] First NORMAL header found at position {first_normal_header_pos}")

                # Mark blocks/lines before the first NORMAL header as orphaned
                if is_large_doc:
                    for i in range(first_normal_header_pos):
                        if i % max(1, first_normal_header_pos // 20) == 0:
                            update_analysis_progress(i, first_normal_header_pos, phase_2_start, phase_2_end, "Checking initial lines")
                        if i % 100 == 0 and self.should_cancel():
                             print(f"{self._debug_timestamp()} [analyze_document] Cancelled during orphaned text ID (before first normal header, lines)")
                             self._highlighting_cancelled = True; return
                        # Mark as orphaned if non-empty AND not ANY type of header
                        if lines[i].strip() and i not in all_header_indices:
                            self.orphaned_blocks.add(i)
                else:
                    block = doc.begin()
                    block_count = 0
                    while block.isValid() and block_count < first_normal_header_pos:
                        if block_count % max(1, first_normal_header_pos // 20) == 0:
                            update_analysis_progress(block_count, first_normal_header_pos, phase_2_start, phase_2_end, "Checking initial blocks")
                        if block_count % 50 == 0 and self.should_cancel():
                             print(f"{self._debug_timestamp()} [analyze_document] Cancelled during orphaned text ID (before first normal header, blocks)")
                             self._highlighting_cancelled = True; return
                        block_num = block.blockNumber()
                        # Mark as orphaned if non-empty AND not ANY type of header
                        if block.text().strip() and block_num not in all_header_indices:
                            self.orphaned_blocks.add(block_num)
                        block = block.next()
                        block_count += 1

            # Enable orphaned checking in highlightBlock
            self.check_orphaned = True

            # Summarize results
            print(f"{self._debug_timestamp()} [analyze_document] Analysis complete. Found {len(self.orphaned_blocks)} orphaned blocks")
            if progress:
                # Use instance update method, reach end of phase range
                self._update_progress(phase_2_end, "Analysis complete")

        except OperationCanceledError:
             print(f"{self._debug_timestamp()} [analyze_document] Operation Cancelled during analysis")

        except Exception as e:
            print(f"{self._debug_timestamp()} [analyze_document] Error: {e}")
            import traceback
            traceback.print_exc()

        finally:
            # Always clear active flag
            self._highlighting_active = False

            # Cleanup progress dialog if it was created here
            if show_progress_dialog_locally and hasattr(self, '_progress_dialog') and self._progress_dialog:
                if self._highlighting_cancelled:
                    self._progress_dialog.setValue(self._progress_dialog.value())
                    self._progress_dialog.setLabelText("Analysis Cancelled.")
                    QTimer.singleShot(50, self._progress_dialog.close)
                else:
                    # Ensure 100% if successful completion of analysis
                    final_progress = progress_min + (progress_max - progress_min) # Should be 100 if min=0, max=100
                    self._update_progress(final_progress, "Analysis complete")
                    QTimer.singleShot(200, self._progress_dialog.close)
                self._progress_dialog = None # Clear local reference
                # Reset instance range vars if we created the dialog here
                self._progress_min_value = 0
                self._progress_max_value = 100


            # Clear shared dialog reference IF IT WAS NOT PASSED IN
            # (This prevents analyze_document from closing a dialog managed by check_for_orphaned_text)
            if not using_shared_dialog and hasattr(self, '_shared_progress_dialog'):
                 self._shared_progress_dialog = None
                 if hasattr(self, '_shared_progress_min'): delattr(self, '_shared_progress_min')
                 if hasattr(self, '_shared_progress_max'): delattr(self, '_shared_progress_max')

            print(f"{self._debug_timestamp()} [analyze_document] Document analysis completed")
        
    def has_header(self, text):
        """Fast header detection"""
        # Quick string check before regex
        if '[[' in text:
            return self.is_main_header(text)
        elif '**' in text:
            return self.is_normal_header(text)
        return False

    def is_main_header(self, text):
        """Optimized check for main headers"""
        match = self.main_header_pattern.match(text)
        return match.hasMatch() if match else False
        
    def is_normal_header(self, text):
        """Optimized check for normal headers"""
        match = self.normal_header_pattern.match(text)
        return match.hasMatch() if match else False
        
    def get_orphaned_blocks(self):
        """Return the set of block numbers with orphaned text"""
        return self.orphaned_blocks.copy() if hasattr(self, 'orphaned_blocks') else set()
        
    # NEW: Method for selective rehighlighting of orphaned blocks
    def selective_rehighlight_orphaned(self):
        """Selectively rehighlight orphaned blocks and changed blocks"""
        print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Starting selective rehighlight")

        # --- REMOVE THIS CALL ---
        # Ensure header formatting is consistent first
        # if hasattr(self, 'force_header_formatting_consistency'):
        #     self.force_header_formatting_consistency()
        # --- END REMOVAL ---

        # Initialize progress variables safely
        progress = None
        using_shared_dialog = False
        progress_min = 0
        progress_max = 100
        local_progress_created = False # Track if *this* call creates the dialog

        try:
            # Skip if highlighting is paused or already rehighlighting
            if self._highlighting_paused or self._rehighlighting:
                print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Skipped: highlighting paused={self._highlighting_paused}, rehighlighting={self._rehighlighting}")
                return

            # Set flags to prevent recursion and enable cancellation
            self._rehighlighting = True
            self._highlighting_active = True
            # Reset cancellation flag for this operation (important!)
            self._highlighting_cancelled = False

            # CANCELLATION CHECKPOINT at entry
            if self.should_cancel():
                print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Cancelled at entry point due to typing")
                # Don't set self._highlighting_cancelled = True here, let the check handle it
                raise OperationCanceledError("Cancelled at entry point") # Use exception

            # Ensure previous_orphaned_blocks exists
            if not hasattr(self, 'previous_orphaned_blocks'): self.previous_orphaned_blocks = set()
            if not hasattr(self, 'orphaned_blocks'): self.orphaned_blocks = set()

            # Calculate blocks that changed status
            newly_orphaned = self.orphaned_blocks - self.previous_orphaned_blocks
            no_longer_orphaned = self.previous_orphaned_blocks - self.orphaned_blocks

            # Include ALL currently orphaned blocks + those that are no longer orphaned
            blocks_to_rehighlight = self.orphaned_blocks | no_longer_orphaned

            if not blocks_to_rehighlight:
                print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] No blocks need rehighlighting.")
                # Ensure flags are reset even on early exit (handled in finally)
                return

            print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] {len(newly_orphaned)} newly orphaned, {len(no_longer_orphaned)} no longer orphaned, {len(self.orphaned_blocks)} total orphaned")
            print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Will rehighlight {len(blocks_to_rehighlight)} blocks in total")

            # --- DIALOG HANDLING ---
            # Check for shared progress dialog first
            if hasattr(self, '_shared_progress_dialog') and self._shared_progress_dialog:
                progress = self._shared_progress_dialog
                progress_min = getattr(self, '_shared_progress_min', 0)
                progress_max = getattr(self, '_shared_progress_max', 100)
                using_shared_dialog = True
                print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Using shared progress dialog (Range: {progress_min}-{progress_max})")
            # Create own progress dialog ONLY if needed and NOT using shared
            elif len(blocks_to_rehighlight) > 100: # Threshold for showing dialog
                print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Creating own progress dialog.")
                parent_widget = None # Find parent logic... (keep your existing logic)
                doc = self.document()
                if hasattr(self, 'editor') and self.editor is not None: parent_widget = self.editor
                elif hasattr(doc, 'parent') and callable(doc.parent):
                    doc_parent = doc.parent()
                    if doc_parent is not None and isinstance(doc_parent, QWidget): parent_widget = doc_parent
                    elif doc_parent is not None and hasattr(doc_parent, 'view') and isinstance(doc_parent.view(), QWidget): parent_widget = doc_parent.view()

                progress = QProgressDialog("Updating text formatting...", "Cancel", 0, len(blocks_to_rehighlight), parent_widget)
                progress.setWindowTitle("Updating Formatting")
                try: progress.setWindowModality(Qt.WindowModality.WindowModal)
                except AttributeError:
                    try: progress.setWindowModality(Qt.WindowModal)
                    except AttributeError: print("Warning: Could not set progress dialog modality.")
                progress.setMinimumDuration(1000)
                progress.show()
                # Connect cancel button TO THE INSTANCE FLAG
                progress.canceled.connect(lambda: setattr(self, '_highlighting_cancelled', True))
                progress.setValue(0)
                QApplication.processEvents()
                local_progress_created = True
                progress_min = 0
                progress_max = len(blocks_to_rehighlight)
            # --- END DIALOG HANDLING ---

            doc = self.document()
            processed_count = 0
            block_count = len(blocks_to_rehighlight)
            sorted_blocks = sorted(list(blocks_to_rehighlight))

            # Determine update interval for progress
            update_interval = max(20, block_count // 20) if block_count > 0 else 20
            next_update_count = update_interval

            for block_num in sorted_blocks:
                # CANCELLATION CHECK: Check instance flag *before* processing
                if self._highlighting_cancelled:
                    raise OperationCanceledError("Cancelled during block processing loop")

                # Update progress
                if progress and (processed_count >= next_update_count or processed_count == block_count - 1):
                    # Calculate progress value
                    if using_shared_dialog:
                        percent_complete = (processed_count + 1) / block_count if block_count > 0 else 1.0
                        progress_value = progress_min + int(percent_complete * (progress_max - progress_min))
                        progress.setLabelText(f"Formatting orphaned blocks ({processed_count + 1}/{block_count})...")
                    else:
                        progress_value = processed_count + 1
                        progress.setLabelText(f"Updating orphaned blocks {processed_count + 1}/{block_count}...")

                    progress.setValue(progress_value)
                    QApplication.processEvents() # Allow UI to update & check cancel button

                    # Check for cancellation via dialog *after* updating UI
                    if progress.wasCanceled(): # This might implicitly check the flag too
                        self._highlighting_cancelled = True # Ensure instance flag is set
                        raise OperationCanceledError("Cancelled via progress dialog")

                    next_update_count += update_interval

                # Check for cancellation via should_cancel method periodically
                if processed_count % 50 == 0 and self.should_cancel(): # Check every 50 blocks
                    raise OperationCanceledError("Cancelled during processing via should_cancel()")

                # --- Rehighlight Block with Error Handling ---
                try:
                    block = doc.findBlockByNumber(block_num)
                    if not block.isValid():
                        print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Warning: Block {block_num} is invalid, skipping.")
                        continue
                    # print(f"Rehighlighting block {block_num}") # Debug
                    self.rehighlightBlock(block) # Call the highlighter's core function
                except Exception as e_rehighlight:
                    print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] ***** ERROR rehighlighting block {block_num} *****")
                    print(f"Error details: {e_rehighlight}")
                    traceback.print_exc()
                    print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Skipping block {block_num} due to error and continuing.")
                # --- End Rehighlight ---

                processed_count += 1

            # --- Final Progress Update ---
            if progress and local_progress_created and not self._highlighting_cancelled:
                 progress.setValue(progress_max)
                 progress.setLabelText("Update complete.")
                 QTimer.singleShot(200, progress.close)
            elif progress and local_progress_created and self._highlighting_cancelled:
                 progress.setValue(progress.value()) # Keep current value
                 progress.setLabelText("Update cancelled.")
                 QTimer.singleShot(50, progress.close) # Close quicker on cancel
            # --- End Final Progress Update ---

            if not self._highlighting_cancelled:
                self._last_rehighlight_time = time.time()
                print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Selective rehighlight completed for {processed_count}/{block_count} blocks")

        except OperationCanceledError as op_cancel:
             # Log cancellation cleanly
             print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Operation Cancelled: {op_cancel}")
             # Ensure progress dialog is closed if created locally
             if progress and local_progress_created:
                  progress.setValue(progress.value())
                  progress.setLabelText("Update cancelled.")
                  QTimer.singleShot(50, progress.close)

        except Exception as e:
            print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Error: {e}")
            traceback.print_exc()
            # Ensure progress dialog is closed on error if created locally
            if progress and local_progress_created:
                 progress.close()

        finally:
            # Always clear flags
            self._rehighlighting = False
            self._highlighting_active = False
            # Don't reset _highlighting_cancelled here automatically,
            # let the caller handle it if needed, but log its final state.
            print(f"{self._debug_timestamp()} [selective_rehighlight_orphaned] Final state: cancelled={getattr(self, '_highlighting_cancelled', 'N/A')}")

    def _update_progress(self, value, text=None):
        """Update the progress dialog with optional range scaling"""
        if self._progress_dialog and not self._progress_dialog.wasCanceled():
            # Check if we have min/max range values
            min_value = getattr(self, '_progress_min_value', 0) 
            max_value = getattr(self, '_progress_max_value', 100)
        
            # Scale the value to our range if needed
            if min_value > 0 or max_value < 100:
                scaled_value = min_value + int((value / 100.0) * (max_value - min_value))
                self._progress_value = min(scaled_value, max_value)
            else:
                # Normal operation
                self._progress_value = min(value, self._progress_max)
        
            # Update progress dialog
            self._progress_dialog.setValue(self._progress_value)
        
            # Update text if provided
            if text:
                self._progress_dialog.setLabelText(text)
            
            # Process events to ensure UI updates
            QApplication.processEvents()
        
            # Check if user cancelled
            if self._progress_dialog.wasCanceled():
                print(f"{self._debug_timestamp()} [_update_progress] Progress dialog cancelled by user")
                return True
            
        return False

    def _create_orphaned_analysis_dialog(self, parent_widget):
        """Create progress dialog for long-running orphaned text analysis after delay"""
        # Check if we already have a dialog or if the operation was cancelled
        if hasattr(self, '_progress_dialog') and self._progress_dialog:
            return  # Dialog already exists
    
        if not self._highlighting_active or self._highlighting_cancelled:
            return  # Operation already completed or cancelled
    
        print(f"{self._debug_timestamp()} [_create_orphaned_analysis_dialog] Creating dialog for long-running analysis")
    
        # Create progress dialog
        progress = QProgressDialog("Analyzing document structure...", "Cancel", 0, 100, parent_widget)
        progress.setWindowTitle("Orphaned Text Analysis")
    
        # Configure dialog
        try:
            progress.setWindowModality(Qt.WindowModality.WindowModal)
        except AttributeError:
            try:
                progress.setWindowModality(Qt.WindowModal)  # Qt5 fallback
            except AttributeError:
                print("Warning: Could not set window modality for progress dialog.")
    
        # Show immediately with some progress already indicated
        progress.setValue(40)  # Show with some progress already
        progress.show()
    
        # Connect cancel button
        progress.canceled.connect(lambda: setattr(self, '_highlighting_cancelled', True))
    
        # Store references
        self._progress_dialog = progress
        self._shared_progress_dialog = progress
        self._shared_progress_min = 0
        self._shared_progress_max = 100
    
        return progress
        
    def check_for_orphaned_text(self, use_shared_dialog=False):
        """Ultra-throttled orphaned text check with sequential processing guarantee and improved dialog timing."""
        print(f"{self._debug_timestamp()} [check_for_orphaned_text] Called")

        # Initialize variables before the try block
        progress = None
        local_progress_created = False  # Flag to track if *this* call created the dialog
        progress_min = 0
        progress_max = 100
        dialog_timer = None
        parent_widget = None
    
        # Check if we are already part of a coordinated process OR if a shared dialog exists
        using_shared_dialog = use_shared_dialog or hasattr(self, '_in_coordinated_process') or \
                              (hasattr(self, '_shared_progress_dialog') and self._shared_progress_dialog is not None)

        try:
            # Skip if highlighting is paused or already rehighlighting
            if self._highlighting_paused or self._rehighlighting:
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] Skipped: highlighting paused={self._highlighting_paused}, rehighlighting={self._rehighlighting}")
                return

            # Abort if header refresh is in progress and we're not in a coordinated process
            if not using_shared_dialog and hasattr(self, '_header_refresh_in_progress') and self._header_refresh_in_progress:
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] Header refresh in progress, aborting")
                return

            # Check parent's suppression flag
            parent = self.document().parent()
            if hasattr(parent, '_suppress_orphaned_check') and parent._suppress_orphaned_check:
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] Orphaned check suppressed by parent, skipping")
                return

            # Get shared progress dialog if available *first*
            if hasattr(self, '_shared_progress_dialog') and self._shared_progress_dialog:
                progress = self._shared_progress_dialog
                progress_min = getattr(self, '_shared_progress_min', 0)
                progress_max = getattr(self, '_shared_progress_max', 100)
                using_shared_dialog = True  # Mark as using shared even if not explicitly passed
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] Using existing shared progress dialog ({progress_min}-{progress_max})")

            # Set active flag
            self._highlighting_active = True
            self._highlighting_cancelled = False

            # CANCELLATION CHECKPOINT 1
            if self.should_cancel():
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] Cancelled at entry point due to typing")
                self._highlighting_cancelled = True
                return

            # Save current state of orphaned blocks for comparison
            # Ensure previous_orphaned_blocks exists
            if not hasattr(self, 'previous_orphaned_blocks'):
                self.previous_orphaned_blocks = set()
            if hasattr(self, 'orphaned_blocks'):
                self.previous_orphaned_blocks = self.orphaned_blocks.copy()
            else:
                self.orphaned_blocks = set()  # Initialize if it doesn't exist
                self.previous_orphaned_blocks = set()

            # Analyze the document
            doc_text = self.document().toPlainText()
            doc_length = len(doc_text)
            print(f"{self._debug_timestamp()} [check_for_orphaned_text] Analyzing document: {doc_length} characters")

            # Check if we should show dialog - ONLY SHOW DIALOG IF EDITOR IS ON ACTIVE TAB
            show_dialog = True
            if hasattr(self, 'editor') and self.editor and hasattr(self.editor, 'is_on_active_tab'):
                show_dialog = self.editor.is_on_active_tab()
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] Editor on active tab: {show_dialog}")

            # --- DIALOG CREATION LOGIC ---
            # Find parent widget for potential dialog
            if show_dialog and not progress and doc_length > 20000 and not using_shared_dialog:
                if hasattr(self, 'editor') and self.editor is not None:
                    parent_widget = self.editor
                else:
                    doc = self.document()
                    if hasattr(doc, 'parent') and callable(doc.parent):
                        doc_parent = doc.parent()
                        if doc_parent is not None and hasattr(doc_parent, 'viewport'):
                            parent_widget = doc_parent

                # Start a timer to show dialog only if operation takes more than 1 second
                analysis_start_time = time.time()
                dialog_timer = QTimer()
                dialog_timer.setSingleShot(True)
            
                # Use a lambda to create and configure the dialog after delay
                dialog_timer.timeout.connect(lambda: self._create_orphaned_analysis_dialog(parent_widget))
                dialog_timer.start(1000)  # 1 second delay before showing dialog
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] Started timer for delayed dialog creation")

            # Start document analysis immediately
            if progress:
                # Use the shared/local progress dialog for analyze_document
                self._progress_dialog = progress  # Ensure analyze_document uses the right dialog
                self._progress_min_value = progress_min  # Pass range info
                self._progress_max_value = progress_max
            
                # Update progress
                current_value = progress_min + int((progress_max - progress_min) * 0.2)  # 20% of our range
                progress.setValue(current_value)
                progress.setLabelText("Analyzing document structure...")
                QApplication.processEvents()
            
                # Do the analysis
                self.analyze_document()
            else:
                # Standard analysis without progress dialog
                self.analyze_document()
            
                # If we had a timer and analysis completed quickly, cancel the timer
                if dialog_timer and dialog_timer.isActive():
                    elapsed_ms = (time.time() - analysis_start_time) * 1000
                    dialog_timer.stop()
                    print(f"{self._debug_timestamp()} [check_for_orphaned_text] Analysis completed in {elapsed_ms:.1f}ms, cancelling dialog timer")

            # Check if a dialog was created during analysis
            if not progress and hasattr(self, '_progress_dialog') and self._progress_dialog:
                progress = self._progress_dialog
                local_progress_created = True
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] Using dialog created during analysis")

            # Exit if cancelled during analysis
            if self._highlighting_cancelled:
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] Analysis was cancelled, exiting")
                # No return here, let finally block handle cleanup
                raise OperationCanceledError("Analysis cancelled")  # Use exception for cleaner exit

            # Enable orphaned text checking
            print(f"{self._debug_timestamp()} [check_for_orphaned_text] Enabling orphaned text checking")
            self.check_orphaned = True

            # Update rehighlighting
            newly_orphaned = self.orphaned_blocks - self.previous_orphaned_blocks
            no_longer_orphaned = self.previous_orphaned_blocks - self.orphaned_blocks
            changed_blocks = newly_orphaned | no_longer_orphaned

            # Use selective rehighlight if there are specific changes
            if changed_blocks:
                # Update progress before calling selective_rehighlight
                if progress:
                    final_stage_start = progress_min + int((progress_max - progress_min) * 0.7)  # Start at 70%
                    progress.setValue(final_stage_start)
                    progress.setLabelText(f"Updating {len(changed_blocks)} text blocks...")
                    QApplication.processEvents()
                    # Set the range for the selective rehighlight part
                    self._shared_progress_min = final_stage_start
                    self._shared_progress_max = progress_max  # End at 100%

                print(f"{self._debug_timestamp()} [check_for_orphaned_text] {len(changed_blocks)} blocks changed status, using selective rehighlight")
                # selective_rehighlight_orphaned will now use the shared dialog if set
                self.selective_rehighlight_orphaned()

                # Check for cancellation after selective rehighlight returns
                if self._highlighting_cancelled:
                    print(f"{self._debug_timestamp()} [check_for_orphaned_text] Selective rehighlight was cancelled, exiting")
                    raise OperationCanceledError("Selective rehighlight cancelled")

            else:
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] No blocks changed status, skipping selective rehighlight")
                # Update progress to completion if no rehighlight needed
                if progress:
                    progress.setValue(progress_max)

            # Final progress update (only if we created the dialog locally)
            if progress and local_progress_created:
                progress.setValue(progress_max)  # Ensure it reaches 100%
                progress.setLabelText("Analysis complete")
                QApplication.processEvents()

            # Ensure headers are properly formatted after orphaned text processing
            if hasattr(self, 'force_header_formatting_consistency'):
                self.force_header_formatting_consistency()

        except OperationCanceledError:
            print(f"{self._debug_timestamp()} [check_for_orphaned_text] Operation cancelled.")
            # Let finally block handle cleanup

        except Exception as e:
            print(f"{self._debug_timestamp()} [check_for_orphaned_text] Error: {e}")
            import traceback
            traceback.print_exc()  # Print full traceback for debugging
            # Let finally block handle cleanup

        finally:
            # Always clear active flag
            self._highlighting_active = False

            # Cancel timer if it's still active
            if dialog_timer and dialog_timer.isActive():
                dialog_timer.stop()

            # --- DIALOG CLEANUP ---
            # Clear the shared dialog reference ONLY IF this call created it
            if local_progress_created and hasattr(self, '_shared_progress_dialog') and self._shared_progress_dialog == getattr(self, '_progress_dialog', None):
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] Clearing shared progress dialog reference (was created locally)")
                self._shared_progress_dialog = None
                # Clear shared range attributes too
                if hasattr(self, '_shared_progress_min'): delattr(self, '_shared_progress_min')
                if hasattr(self, '_shared_progress_max'): delattr(self, '_shared_progress_max')

            # Close the local progress dialog reference if it exists
            # Use getattr to safely access _progress_dialog
            local_dialog_ref = getattr(self, '_progress_dialog', None)
            if local_dialog_ref and local_progress_created:  # Only close if created locally
                print(f"{self._debug_timestamp()} [check_for_orphaned_text] Closing locally created progress dialog")
                QTimer.singleShot(200, local_dialog_ref.close)
                self._progress_dialog = None  # Clear local reference

            print(f"{self._debug_timestamp()} [check_for_orphaned_text] Completed")
        
    def disable_orphaned_check(self):
        """Disable orphaned text checking to improve performance"""
        print(f"{self._debug_timestamp()} [disable_orphaned_check] Called")
        
        # Save the previous state for selective rehighlighting
        if self.check_orphaned and self.orphaned_blocks:
            self.previous_orphaned_blocks = self.orphaned_blocks.copy()
        
        # Disable checking
        self.check_orphaned = False
        self.orphaned_blocks.clear()
        
        # Determine what blocks need updating (all previously orphaned blocks)
        blocks_to_update = self.previous_orphaned_blocks
        
        # If there were previously orphaned blocks, update them
        if blocks_to_update:
            print(f"{self._debug_timestamp()} [disable_orphaned_check] {len(blocks_to_update)} blocks need updating")
            
            # If small number of blocks, update selectively
            if len(blocks_to_update) < 500:
                # Get document
                doc = self.document()
                
                # Update each block that was previously orphaned
                for block_num in blocks_to_update:
                    block = doc.findBlockByNumber(block_num)
                    if block.isValid():
                        self.rehighlightBlock(block)
                
                print(f"{self._debug_timestamp()} [disable_orphaned_check] Selectively updated {len(blocks_to_update)} blocks")
            else:
                # Too many blocks, use throttled rehighlight
                print(f"{self._debug_timestamp()} [disable_orphaned_check] Too many blocks to update selectively, scheduling throttled rehighlight")
                self._throttled_rehighlight()
        else:
            print(f"{self._debug_timestamp()} [disable_orphaned_check] No blocks were orphaned, nothing to update")

class LoadingDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)

        # Block signals during initialization
        self.blockSignals(True)
        
        # Pre-create widgets before layout
        self.progress_bar = QProgressBar(self)
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setMinimumHeight(25)
        self.progress_bar.setValue(0)

        self.status_label = QLabel("Loading session...", self)
        self.detail_label = QLabel(self)
        
        # Base window setup
        self.setWindowTitle("Loading")
        self.setFixedSize(400, 150)
        self.setModal(True)  # Make dialog modal to prevent interaction with parent
        self.setWindowFlags(
            Qt.WindowType.Dialog | 
            Qt.WindowType.CustomizeWindowHint |
            Qt.WindowType.WindowTitleHint |
            Qt.WindowType.WindowStaysOnTopHint
        )

        # Setup layout first
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(25, 20, 25, 20)

        # Pre-configure all widgets before adding to layout
        self.status_label.setAlignment(Qt.AlignmentFlag.AlignLeft)
        self.detail_label.setWordWrap(True)
        self.detail_label.setAlignment(Qt.AlignmentFlag.AlignLeft)
        
        # Add widgets to layout
        layout.addWidget(self.status_label)
        layout.addWidget(self.progress_bar)
        layout.addWidget(self.detail_label)
        layout.addStretch()
        
        # Apply all styles at once
        self.setStyleSheet("""
            QDialog {
                background-color: white;
                border: 1px solid #e0e0e0;
                border-radius: 0px;
            }
            QLabel {
                color: #666666;
                font-size: 12px;
                font-style: italic;
                padding: 2px;
                min-height: 20px;
            }
            QLabel#status_label {
                color: #1a1a1a;
                font-size: 14px;
                font-weight: 600;
                padding: 0px;
                font-style: normal;
            }
            QProgressBar {
                border: none;
                border-radius: 6px;
                background-color: #f0f0f0;
                text-align: center;
                margin: 0px;
                font-size: 12px;
                font-weight: 500;
                color: white;
            }
            QProgressBar::chunk {
                background-color: #203740;
                border-radius: 6px;
            }
        """)

        # Set object names for specific styling
        self.status_label.setObjectName("status_label")
        
        # Add shadow effect
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(20)
        shadow.setColor(QColor(0, 0, 0, 50))
        shadow.setOffset(0, 4)
        self.setGraphicsEffect(shadow)

        # Position the dialog
        self.adjust_to_parent_monitor()
        
        # Force layout update and initial draw
        self.layout().activate()
        self.updateGeometry()
        
        # Ensure widgets are painted
        self.ensurePolished()
        
        # Initialize timeout timer
        self.timeout_timer = QTimer(self)
        self.timeout_timer.setSingleShot(True)
        self.timeout_timer.timeout.connect(self.handle_timeout)
        self.timeout_ms = 30000  # Default 30 second timeout
        
        # Unblock signals
        self.blockSignals(False)

    def showEvent(self, event):
        """Ensure immediate visual update on show and start timeout timer"""
        super().showEvent(event)
        self.raise_()
        self.activateWindow()
        
        # Start the timeout timer when the dialog is shown
        self.timeout_timer.start(self.timeout_ms)
        
        QApplication.processEvents()

    def closeEvent(self, event):
        """Handle dialog closing by stopping timeout timer"""
        self.timeout_timer.stop()
        super().closeEvent(event)

    def set_timeout(self, timeout_ms):
        """Set the timeout duration in milliseconds"""
        self.timeout_ms = timeout_ms
        # If dialog is already visible, restart timer with new duration
        if self.isVisible() and self.timeout_timer:
            self.timeout_timer.stop()
            self.timeout_timer.start(timeout_ms)

    def handle_timeout(self):
        """Handle timeout by closing dialog and showing warning"""
        print("Loading dialog timeout reached")
        self.update_detail("Operation timed out. Closing dialog...")
        
        # Show warning in status bar if parent has one
        parent = self.parent()
        if parent and hasattr(parent, 'status_bar'):
            parent.status_bar.showMessage("Loading operation timed out", 5000)
        
        # Close the dialog after a brief delay to allow reading the message
        QTimer.singleShot(1000, self.close)

    def adjust_to_parent_monitor(self):
        """Center the dialog on the parent window, not just the monitor."""
        parent_window = self.parent()
        if parent_window:
            parent_geometry = parent_window.geometry()
            # Center dialog on parent window
            self.move(
                parent_geometry.center().x() - self.width() // 2,
                parent_geometry.center().y() - self.height() // 2
            )
        else:
            # If no parent, center on primary screen
            primary_screen = QApplication.primaryScreen()
            if primary_screen:
                screen_geometry = primary_screen.geometry()
                self.move(
                    screen_geometry.center().x() - self.width() // 2,
                    screen_geometry.center().y() - self.height() // 2
                )

    def update_status(self, text):
        """Update the status text."""
        self.status_label.setText(text)
        QApplication.processEvents()

    def update_detail(self, text):
        """Update the detail text."""
        self.detail_label.setText(text)
        QApplication.processEvents()

class FlowLayout(QLayout):
    """A flow layout that arranges widgets in rows, wrapping to new rows as needed."""
    def __init__(self, parent=None, margin=10, h_spacing=6, v_spacing=6):
        super().__init__(parent)
        self.h_spacing = h_spacing
        self.v_spacing = v_spacing
        self.item_list = []
        self.setContentsMargins(margin, margin, margin, margin)

    def addItem(self, item):
        self.item_list.append(item)

    def count(self):
        return len(self.item_list)

    def itemAt(self, index):
        if 0 <= index < len(self.item_list):
            return self.item_list[index]
        return None

    def takeAt(self, index):
        if 0 <= index < len(self.item_list):
            return self.item_list.pop(index)
        return None

    def expandingDirections(self):
        return Qt.Orientation(0)

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        height = self.doLayout(QRect(0, 0, width, 0), True)
        return height

    def setGeometry(self, rect):
        super().setGeometry(rect)
        self.doLayout(rect, False)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QSize()
        for item in self.item_list:
            size = size.expandedTo(item.minimumSize())
        margins = self.contentsMargins()
        size += QSize(margins.left() + margins.right(), margins.top() + margins.bottom())
        return size

    def doLayout(self, rect, test_only):
        x = rect.x()
        y = rect.y()
        line_height = 0
        
        for item in self.item_list:
            widget = item.widget()
            space_x = self.h_spacing
            space_y = self.v_spacing
            
            next_x = x + item.sizeHint().width() + space_x
            if next_x - space_x > rect.right() and line_height > 0:
                x = rect.x()
                y = y + line_height + space_y
                next_x = x + item.sizeHint().width() + space_x
                line_height = 0

            if not test_only:
                item.setGeometry(QRect(QPoint(x, y), item.sizeHint()))
            
            x = next_x
            line_height = max(line_height, item.sizeHint().height())
        
        return y + line_height - rect.y()

class CompactTagGridWidget(QScrollArea):
    itemChanged = pyqtSignal(object)  # Emit when an item is edited
    layoutChanged = pyqtSignal()  # Emit when items are reordered
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # Store tags and widgets
        self.tag_widgets = []
        self.drag_start_pos = None
        self.dragged_widget = None
        self.currently_editing = None  # Track which widget is being edited
        
        # Setup scroll area
        self.setWidgetResizable(True)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        # Create container widget with flow layout
        self.container = QWidget()
        self.container.mousePressEvent = self.containerClicked  # Override to handle clicks
        # Add inner padding so tags aren't tight against the border
        self.container.setStyleSheet("padding: 8px;")
        self.flow_layout = FlowLayout(self.container, margin=10, h_spacing=8, v_spacing=6)
        self.container.setLayout(self.flow_layout)
        # Enable accepting drops on the container so drops between tags are recognized
        self.container.setAcceptDrops(True)
        # Bind DnD handlers to the container to allow in-between drops
        self.container.dragEnterEvent = self._containerDragEnterEvent
        self.container.dragMoveEvent = self._containerDragMoveEvent
        self.container.dropEvent = self._containerDropEvent
        self.container.dragLeaveEvent = self._containerDragLeaveEvent
        self.setWidget(self.container)

        # Visual drop indicator (thin vertical bar)
        self._drop_indicator = None
        
        # Modern styling
        self.setStyleSheet("""
            QScrollArea {
                border: 1px solid #d0d0d0;
                border-radius: 6px;
                background-color: #ffffff;
            }
            QScrollBar:vertical {
                width: 10px;
                border: none;
                background: #f3f4f6;
                border-radius: 5px;
            }
            QScrollBar::handle:vertical {
                background: #9ca3af;
                border-radius: 5px;
                min-height: 20px;
            }
            QScrollBar::handle:vertical:hover {
                background: #6b7280;
            }
        """)
    
    def containerClicked(self, event):
        """Handle clicks on empty container space"""
        if event.button() == Qt.MouseButton.LeftButton and self.currently_editing:
            self.currently_editing.finishEditing()
        
    def addTagItem(self, text):
        """Add a new tag widget to the flow layout"""
        tag_widget = TagItemWidget(text, self.container)
        tag_widget.edited.connect(lambda w: self.itemChanged.emit(w))
        tag_widget.deleteRequested.connect(self.removeTagWidget)
        # Store reference to the grid widget in the tag widget
        tag_widget.grid_widget = self
        
        self.flow_layout.addWidget(tag_widget)
        self.tag_widgets.append(tag_widget)
        return tag_widget
    
    def removeTagWidget(self, widget):
        """Remove a tag widget"""
        if widget in self.tag_widgets:
            # Get the tag text before removing the widget
            tag_to_delete = widget.text()
            
            # Find the parent TagListDialog to handle the proper delete
            parent_dialog = self.parent()
            while parent_dialog and not isinstance(parent_dialog, TagListDialog):
                parent_dialog = parent_dialog.parent()
            
            if parent_dialog:
                # Use the same delete logic as the list view context menu
                if parent_dialog._confirm_and_delete_tag(tag_to_delete):
                    # Only remove from UI if the deletion was confirmed and successful
                    self.tag_widgets.remove(widget)
                    self.flow_layout.removeWidget(widget)
                    widget.deleteLater()
                    
                    # Update the tags list and notify of changes
                    parent_dialog.update_tags_list()
                    parent_dialog.notify_changes()
                    
                    # Rebuild layout to maintain proper spacing
                    self.rebuildLayout()
            else:
                # Fallback: just remove from UI if we can't find the parent dialog
                self.tag_widgets.remove(widget)
                self.flow_layout.removeWidget(widget)
                widget.deleteLater()
    
    def clear(self):
        """Clear all tag widgets"""
        for widget in self.tag_widgets:
            widget.deleteLater()
        self.tag_widgets.clear()
        
        # Clear the layout
        while self.flow_layout.count():
            item = self.flow_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
    
    def count(self):
        """Return the number of tags"""
        return len(self.tag_widgets)
    
    def item(self, index):
        """Get tag widget at index"""
        if 0 <= index < len(self.tag_widgets):
            return self.tag_widgets[index]
        return None
        
    def takeItem(self, index):
        """Remove and return tag widget at index"""
        if 0 <= index < len(self.tag_widgets):
            widget = self.tag_widgets.pop(index)
            self.flow_layout.removeWidget(widget)
            widget.deleteLater()
            return widget
        return None
    
    def row(self, widget):
        """Get the index of a widget"""
        if widget in self.tag_widgets:
            return self.tag_widgets.index(widget)
        return -1
    
    def scrollToBottom(self):
        """Scroll to the bottom of the widget"""
        self.verticalScrollBar().setValue(self.verticalScrollBar().maximum())
    
    def rebuildLayout(self):
        """Rebuild the layout after drag-and-drop reordering"""
        print(f"[DEBUG] rebuildLayout: Reordering {len(self.tag_widgets)} widgets")
        
        # Clear the layout
        while self.flow_layout.count():
            item = self.flow_layout.takeAt(0)
            # Don't delete the widget - just remove from layout
        
        # Re-add widgets in the new order
        for i, widget in enumerate(self.tag_widgets):
            print(f"[DEBUG] Adding widget {i}: {widget.text()}")
            self.flow_layout.addWidget(widget)
            # Ensure widget is visible and has correct parent
            widget.setVisible(True)
            widget.setParent(self.container)
        
        # Force comprehensive layout update
        self.flow_layout.invalidate()
        self.container.updateGeometry()
        self.container.adjustSize()
        self.container.update()
        self.update()
        
        # Process any pending events to ensure layout is applied
        QCoreApplication.processEvents()
        
        print("[DEBUG] rebuildLayout: Layout rebuild complete")
        
        # Emit signal that layout changed
        self.layoutChanged.emit()

    # --------------------
    # Container DnD support
    # --------------------
    def _containerDragEnterEvent(self, event):
        if event.mimeData().hasFormat("application/x-tag-widget"):
            event.acceptProposedAction()
        else:
            event.ignore()

    def _containerDragMoveEvent(self, event):
        if not event.mimeData().hasFormat("application/x-tag-widget"):
            event.ignore()
            return
        event.acceptProposedAction()
        # Compute insertion index for indicator
        pos = event.position().toPoint()
        insert_index = self._compute_insert_index(pos)
        self._show_drop_indicator(insert_index, pos)

    def _containerDropEvent(self, event):
        if not event.mimeData().hasFormat("application/x-tag-widget"):
            event.ignore()
            return
        try:
            source_id = int(event.mimeData().data("application/x-tag-widget").data().decode())
        except Exception:
            event.ignore()
            return

        # Find source widget
        source_widget = None
        for w in self.tag_widgets:
            if id(w) == source_id:
                source_widget = w
                break
        if not source_widget:
            event.ignore()
            return

        pos = event.position().toPoint()
        insert_index = self._compute_insert_index(pos)

        # Clamp and adjust if dropping after itself
        if source_widget in self.tag_widgets:
            current_index = self.tag_widgets.index(source_widget)
            # If moving forward past itself, removing first shifts target left by 1
            if insert_index > current_index:
                insert_index -= 1
            # Remove and insert at new index
            self.tag_widgets.insert(insert_index, self.tag_widgets.pop(current_index))
            self.rebuildLayout()

            # Notify parent dialog of change
            parent_dialog = self.parent()
            while parent_dialog and not isinstance(parent_dialog, TagListDialog):
                parent_dialog = parent_dialog.parent()
            if parent_dialog:
                parent_dialog.on_rows_moved()

        self._hide_drop_indicator()
        event.acceptProposedAction()

    def _containerDragLeaveEvent(self, event):
        self._hide_drop_indicator()
        event.accept()

    def _compute_insert_index(self, pos):
        """Compute insert index based on cursor position within the flow layout."""
        if not self.tag_widgets:
            return 0
        # If above first row, before first
        first_rect = self.tag_widgets[0].geometry()
        if pos.y() < first_rect.top():
            return 0
        # If after last, append
        last_rect = self.tag_widgets[-1].geometry()
        if pos.y() > last_rect.bottom():
            return len(self.tag_widgets)

        # Find the row closest to pos.y by scanning widgets
        row_widgets = []
        row_y = None
        row_h = None
        for w in self.tag_widgets:
            r = w.geometry()
            if r.top() <= pos.y() <= r.bottom():
                # Found target row
                row_y = r.top()
                row_h = r.height()
                break
        if row_y is None:
            # Choose nearest row by minimal vertical distance
            min_dist = 10**9
            for w in self.tag_widgets:
                r = w.geometry()
                cy = (r.top() + r.bottom()) // 2
                d = abs(pos.y() - cy)
                if d < min_dist:
                    min_dist = d
                    row_y = r.top()
                    row_h = r.height()

        # Collect widgets on that row
        for i, w in enumerate(self.tag_widgets):
            r = w.geometry()
            if abs(r.top() - row_y) <= (row_h // 2):
                row_widgets.append((i, w))

        if not row_widgets:
            return len(self.tag_widgets)

        # Determine insert index by x against centers of row widgets
        for i, w in row_widgets:
            c = w.geometry().center().x()
            if pos.x() < c:
                return i
        # After last in row
        return row_widgets[-1][0] + 1

    def _show_drop_indicator(self, index, pos):
        """Show a vertical bar indicating insertion point."""
        if self._drop_indicator is None:
            from PyQt6.QtWidgets import QFrame
            self._drop_indicator = QFrame(self.container)
            self._drop_indicator.setFrameShape(QFrame.Shape.VLine)
            self._drop_indicator.setStyleSheet("color: #1a73e8; background-color: #1a73e8;")
            self._drop_indicator.resize(2, 24)

        # Determine geometry for indicator based on index
        if self.tag_widgets:
            if index <= 0:
                ref = self.tag_widgets[0].geometry()
                x = max(0, ref.x() - 3)
                y = ref.y()
                h = ref.height()
            elif index >= len(self.tag_widgets):
                ref = self.tag_widgets[-1].geometry()
                x = ref.right() + 3
                y = ref.y()
                h = ref.height()
            else:
                ref = self.tag_widgets[index].geometry()
                x = max(0, ref.x() - 3)
                y = ref.y()
                h = ref.height()
        else:
            x = pos.x()
            y = pos.y()
            h = 24
        self._drop_indicator.setGeometry(x, y, 2, h)
        self._drop_indicator.show()
        self._drop_indicator.raise_()

    def _hide_drop_indicator(self):
        if self._drop_indicator is not None:
            self._drop_indicator.hide()

class TagItemWidget(QLineEdit):
    """Individual tag widget that looks like a pill/badge and supports inline editing"""
    edited = pyqtSignal(object)
    deleteRequested = pyqtSignal(object)
    dragStarted = pyqtSignal(object)
    
    def __init__(self, text, parent=None):
        super().__init__(text, parent)
        self._original_text = text
        self.setReadOnly(True)
        self.setFrame(False)
        self.setFixedHeight(26)
        self.setMaximumWidth(200)
        self.setMinimumWidth(80)
        self.setMaxLength(35)  # Set 35 character limit
        
        # Disable text cursor and selection when read-only
        self.setCursorPosition(0)
        self.deselect()
        
        # Drag and drop setup
        self.setAcceptDrops(True)
        self.drag_start_pos = None
        self.is_dragging = False
        
        # Adjust width based on text
        font_metrics = self.fontMetrics()
        text_width = font_metrics.horizontalAdvance(text) + 30
        self.setFixedWidth(min(200, max(80, text_width)))
        
        # Style as a pill/badge
        self.setStyleSheet("""
            QLineEdit {
                background-color: #f0f4f8;
                border: 1px solid #d0d7de;
                border-radius: 12px;
                padding: 3px 12px;
                color: #24292f;
                font-size: 12px;
                font-weight: 500;
            }
            QLineEdit:hover {
                background-color: #e5e7eb;
                border: 1px solid #9ca3af;
            }
            QLineEdit:focus {
                background-color: #dbeafe;
                color: #1e40af;
                border: 1px solid #93c5fd;
            }
            QLineEdit:read-only {
                background-color: #f0f4f8;
            }
            QLineEdit:!read-only {
                background-color: #ffffff;
                border: 2px solid #3b82f6;
            }
        """)
        
        # Enable editing on double-click
        self.editingFinished.connect(self.finishEditing)
        
    def text(self):
        """Override to match ListWidgetItem interface"""
        return super().text()
        
    def setText(self, text):
        """Override to match ListWidgetItem interface"""
        super().setText(text)
        # Adjust width
        font_metrics = self.fontMetrics()
        text_width = font_metrics.horizontalAdvance(text) + 30
        self.setFixedWidth(min(200, max(80, text_width)))
    
    def mousePressEvent(self, event):
        """Handle single click - finish any other editing and prepare for drag"""
        if event.button() == Qt.MouseButton.LeftButton:
            grid_widget = getattr(self, 'grid_widget', None)
            # If another widget is being edited, finish it
            if grid_widget and hasattr(grid_widget, 'currently_editing') and grid_widget.currently_editing and grid_widget.currently_editing != self:
                grid_widget.currently_editing.finishEditing()
            
            # Store drag start position
            if self.isReadOnly():  # Only allow dragging when not editing
                self.drag_start_pos = event.pos()
                # Prevent text selection in read-only mode - don't call super()
                return
        super().mousePressEvent(event)
    
    def mouseDoubleClickEvent(self, event):
        """Start editing on double-click"""
        if event.button() == Qt.MouseButton.LeftButton:
            # Check if another widget is being edited and finish it first
            grid_widget = getattr(self, 'grid_widget', None)
            if grid_widget and hasattr(grid_widget, 'currently_editing') and grid_widget.currently_editing and grid_widget.currently_editing != self:
                grid_widget.currently_editing.finishEditing()
            
            self.setReadOnly(False)
            self.selectAll()
            self.setFocus()
            
            # Mark this widget as currently editing
            if grid_widget and hasattr(grid_widget, 'currently_editing'):
                grid_widget.currently_editing = self
        super().mouseDoubleClickEvent(event)
    
    def mouseMoveEvent(self, event):
        """Handle drag start and prevent text selection when read-only"""
        if self.isReadOnly():
            # In read-only mode, check for drag start
            if (event.buttons() & Qt.MouseButton.LeftButton and 
                self.drag_start_pos and 
                (event.pos() - self.drag_start_pos).manhattanLength() > QApplication.startDragDistance()):
                
                self.startDrag()
            # Don't call super() to prevent text selection
            return
        super().mouseMoveEvent(event)
    
    def startDrag(self):
        """Start drag operation"""
        self.is_dragging = True
        drag = QDrag(self)
        mimeData = QMimeData()
        mimeData.setText(self.text())
        mimeData.setData("application/x-tag-widget", str(id(self)).encode())
        
        # Create drag pixmap
        pixmap = self.grab()
        
        drag.setMimeData(mimeData)
        drag.setPixmap(pixmap)
        # Place pixmap to the top-right of the cursor so it doesn't obscure drop indicators
        # Anchor the bottom-left corner of the pixmap at the cursor position
        drag.setHotSpot(QPoint(0, pixmap.height()))
        
        # Execute drag
        dropAction = drag.exec(Qt.DropAction.MoveAction)
        self.is_dragging = False
    
    def dragEnterEvent(self, event):
        """Accept drag if it's from another tag widget"""
        if event.mimeData().hasFormat("application/x-tag-widget"):
            event.acceptProposedAction()
        else:
            event.ignore()
    
    def dragMoveEvent(self, event):
        """Accept drag move"""
        if event.mimeData().hasFormat("application/x-tag-widget"):
            event.acceptProposedAction()
        else:
            event.ignore()
    
    def dropEvent(self, event):
        """Handle drop event - reorder tags"""
        if event.mimeData().hasFormat("application/x-tag-widget"):
            source_id = int(event.mimeData().data("application/x-tag-widget").data().decode())
            
            # Find the source widget by ID
            grid_widget = getattr(self, 'grid_widget', None)
            if not grid_widget:
                event.ignore()
                return
                
            source_widget = None
            for widget in grid_widget.tag_widgets:
                if id(widget) == source_id:
                    source_widget = widget
                    break
            
            if source_widget and source_widget != self:
                # Get positions in the list
                source_index = grid_widget.tag_widgets.index(source_widget)
                target_index = grid_widget.tag_widgets.index(self)
                
                # Reorder the list
                grid_widget.tag_widgets.insert(target_index, grid_widget.tag_widgets.pop(source_index))
                
                # Rebuild the layout
                grid_widget.rebuildLayout()
                
                # Find the parent TagListDialog and trigger the update
                parent_dialog = grid_widget.parent()
                while parent_dialog and not isinstance(parent_dialog, TagListDialog):
                    parent_dialog = parent_dialog.parent()
                
                if parent_dialog:
                    # Call the same update methods that handle reordering
                    parent_dialog.on_rows_moved()
                
                event.acceptProposedAction()
            else:
                event.ignore()
        else:
            event.ignore()
    
    def contextMenuEvent(self, event):
        """Show context menu for delete"""
        menu = QMenu(self)
        delete_action = menu.addAction("Delete Tag")
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                padding: 4px 0px;
            }
            QMenu::item {
                padding: 8px 24px;
            }
            QMenu::item:selected {
                background-color: #e3f2fd;
                color: #1a73e8;
            }
        """)
        action = menu.exec(event.globalPos())
        if action == delete_action:
            self.deleteRequested.emit(self)
    
    def focusOutEvent(self, event):
        """Accept edit when focus is lost"""
        if not self.isReadOnly():
            self.finishEditing()
        super().focusOutEvent(event)
    
    def finishEditing(self):
        """Finish editing and emit signal with validation"""
        new_text = self.text().strip()
        
        # Validate for duplicate tags if text changed
        if new_text != self._original_text:
            # Find the parent dialog to get the tag list
            widget = self.parent()
            while widget and not isinstance(widget, TagListDialog):
                widget = widget.parent()
            
            if widget:  # Found TagListDialog
                # Skip validation if text hasn't actually changed
                new_text_clean = new_text.lstrip('#').lower()
                original_text_clean = self._original_text.lstrip('#').lower()
                
                if new_text_clean != original_text_clean:
                    # Only check for duplicates if the text actually changed
                    # Get all other tags (exclude the current tag being edited)
                    other_tags = []
                    if widget.current_view == "grid":
                        # In grid view, get tags from other widgets
                        for tag_widget in widget.list_widget.tag_widgets:
                            if tag_widget != self:  # Exclude the current widget being edited
                                other_tags.append(tag_widget.text().lstrip('#').lower())
                    else:
                        # In list view, get tags from list items
                        for i in range(widget.list_widget.count()):
                            item = widget.list_widget.item(i)
                            if item and item.text().lstrip('#').lower() != original_text_clean:
                                other_tags.append(item.text().lstrip('#').lower())
                    
                    if new_text_clean in other_tags:
                        # Show error message
                        from PyQt6.QtWidgets import QMessageBox
                        QMessageBox.warning(widget, "Duplicate Tag", f"A tag named '{new_text_clean}' already exists. Please choose a different name.")
                        # Reset to original text
                        self.setText(self._original_text)
                        self.setReadOnly(True)
                        # Clear selection on validation failure
                        self.deselect()
                        return
        
        self.setReadOnly(True)
        # Clear selection when exiting edit mode
        self.deselect()
        if new_text != self._original_text:
            self.edited.emit(self)
            self._original_text = new_text
        
        # Clear the currently editing reference
        grid_widget = getattr(self, 'grid_widget', None)
        if grid_widget and hasattr(grid_widget, 'currently_editing') and grid_widget.currently_editing == self:
            grid_widget.currently_editing = None
    
    def keyPressEvent(self, event):
        """Handle key events"""
        if event.key() == Qt.Key.Key_Escape:
            self.setText(self._original_text)
            self.setReadOnly(True)
            self.clearFocus()
        elif event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            self.clearFocus()  # This will trigger editingFinished
        else:
            super().keyPressEvent(event)

class TagListWidget(QListWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        # Enable drag and drop with smooth reordering
        self.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)
        self.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)  # Multi-select with Shift/Ctrl
        self.setVerticalScrollMode(QAbstractItemView.ScrollMode.ScrollPerPixel)
        self.verticalScrollBar().setSingleStep(150)  # Lightning fast scrolling
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.setAutoScroll(True)  # Enable autoscroll during drag operations
        self.setAutoScrollMargin(100)  # Maximum autoscroll margin for instant response
        
        # Enable context menu
        self.setContextMenuPolicy(Qt.ContextMenuPolicy.DefaultContextMenu)
        
        # Auto-scroll will be initialized when first needed
        
        # View settings
        self.setViewMode(QListView.ViewMode.ListMode)
        self.setMovement(QListView.Movement.Snap)  # Changed from Free to Snap for better drop positioning
        self.setResizeMode(QListView.ResizeMode.Fixed)
        self.setDefaultDropAction(Qt.DropAction.MoveAction)
        
        # Size settings - more compact, stretch to full width
        self.setSpacing(2)  # Tighter spacing
        self.setWordWrap(True)
        self.setUniformItemSizes(True)
        
        # Center text alignment for all items
        self.setItemAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Modern styling with subtle shadows and transitions
        self.setStyleSheet("""
            QListWidget {
                outline: none;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                padding: 8px;
                background-color: #ffffff;
            }
            QListWidget::item {
                background-color: #f8f9fa;
                border: 1px solid #e9ecef;
                border-radius: 8px;
                padding: 2px 8px;
                margin: 1px;
                min-height: 22px;
                text-align: center;
                font-size: 11px;
                selection-background-color: #e3f2fd;
                selection-color: #1a73e8;
            }
            QListWidget::item:selected {
                background-color: #e3f2fd;
                color: #1a73e8;
                border: 1px solid #90caf9;
            }
            QListWidget::item:hover:!selected {
                background-color: #f5f5f5;
                border: 1px solid #dadce0;
            }
            QListWidget::item:focus {
                outline: none;
                border: 1px solid #90caf9;
            }
        """)
        
        # Scrollbar policies
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        # Selection behavior for multi-select
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        
        # Use our custom delegate for editing items
        self.setItemDelegate(TagItemDelegate())

    def mousePressEvent(self, event):
        """Handle mouse press for proper selection behavior"""
        # Handle right-clicks by manually calling contextMenuEvent
        if event.button() == Qt.MouseButton.RightButton:
            from PyQt6.QtGui import QContextMenuEvent
            global_pos = self.mapToGlobal(event.pos())
            context_event = QContextMenuEvent(QContextMenuEvent.Reason.Mouse, event.pos(), global_pos)
            self.contextMenuEvent(context_event)
            return
            
        index = self.indexAt(event.pos())
        if not index.isValid():
            # If an editor (QLineEdit) is currently active, clear its focus to commit any edits.
            focus_widget = QApplication.focusWidget()
            if isinstance(focus_widget, QLineEdit):
                focus_widget.clearFocus()
            # Also clear any selection so that the tag item is deselected.
            self.clearSelection()
        else:
            # Handle the selection properly - don't clear automatically
            if event.button() == Qt.MouseButton.LeftButton:
                if event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                    # Toggle selection on Ctrl+click
                    item = self.itemFromIndex(index)
                    item.setSelected(not item.isSelected())
                elif event.modifiers() == Qt.KeyboardModifier.ShiftModifier:
                    # Range selection on Shift+click
                    super().mousePressEvent(event)
                else:
                    # Clear other selections and select this item
                    super().mousePressEvent(event)
            else:
                super().mousePressEvent(event)
    
    def contextMenuEvent(self, event):
        """Same context menu as TagItemWidget but with batch delete support"""
        item = self.itemAt(event.pos())
        selected_items = self.selectedItems()
        
        # If we right-clicked on an item, make sure it's selected
        if item and item not in selected_items:
            self.clearSelection()
            item.setSelected(True)
            selected_items = [item]
        
        if item and len(selected_items) > 0:
            menu = QMenu(self)
            if len(selected_items) == 1:
                delete_action = menu.addAction("Delete Tag")
            else:
                delete_action = menu.addAction(f"Delete {len(selected_items)} Tags")
                
            # Use the same styling as TagItemWidget
            menu.setStyleSheet("""
                QMenu {
                    background-color: #ffffff;
                    border: 1px solid #dee2e6;
                    border-radius: 4px;
                    padding: 4px 0px;
                }
                QMenu::item {
                    padding: 8px 24px;
                }
                QMenu::item:selected {
                    background-color: #e3f2fd;
                    color: #1a73e8;
                }
            """)
            action = menu.exec(event.globalPos())
            if action == delete_action:
                # Find the parent TagListDialog to handle the delete
                parent_dialog = self.parent()
                while parent_dialog and not isinstance(parent_dialog, TagListDialog):
                    parent_dialog = parent_dialog.parent()
                
                if parent_dialog:
                    if len(selected_items) == 1:
                        # Single delete - same as TagItemWidget
                        tag_to_delete = selected_items[0].text()
                        if parent_dialog._confirm_and_delete_tag(tag_to_delete):
                            self.takeItem(self.row(selected_items[0]))
                            parent_dialog.update_tags_list()
                            parent_dialog.notify_changes()
                            if self.count() == 0:
                                parent_dialog.populate_tags()
                            parent_dialog.update_count()
                    else:
                        # Batch delete
                        tags_to_delete = [item.text() for item in selected_items]
                        if parent_dialog._confirm_and_delete_multiple_tags(tags_to_delete):
                            for item in reversed(selected_items):
                                self.takeItem(self.row(item))
                            parent_dialog.update_tags_list()
                            parent_dialog.notify_changes()
                            if self.count() == 0:
                                parent_dialog.populate_tags()
                            parent_dialog.update_count()

    def resizeEvent(self, event):
        """Update item sizes when widget is resized"""
        super().resizeEvent(event)
        # Temporarily disconnect itemChanged signal to prevent triggering tag processing during resize
        parent_dialog = self.parent()
        while parent_dialog and not isinstance(parent_dialog, TagListDialog):
            parent_dialog = parent_dialog.parent()
        
        if parent_dialog:
            # Disconnect signal temporarily
            try:
                parent_dialog.list_widget.itemChanged.disconnect()
            except:
                pass  # Signal might not be connected
        
        # Update all item widths to match new widget width
        for i in range(self.count()):
            item = self.item(i)
            if item:
                item.setSizeHint(QSize(self.width() - 20, 26))
        
        # Reconnect signal
        if parent_dialog:
            try:
                parent_dialog.list_widget.itemChanged.connect(parent_dialog.on_item_changed)
            except:
                pass

class TagItemDelegate(QStyledItemDelegate):
    def createEditor(self, parent, option, index):
        editor = QLineEdit(parent)
        editor.setMaxLength(35)
        editor.setFixedHeight(option.rect.height())  # Ensure the editor fits the tag item
        editor.setAlignment(Qt.AlignmentFlag.AlignCenter)
        editor.setStyleSheet("""
            QLineEdit {
                border: 1px solid #90caf9;
                border-radius: 16px;
                padding: 0px 12px;
                background-color: #ffffff;
                font-size: 13px;
                text-align: center;
            }
            QLineEdit:focus {
                border-color: #1a73e8;
            }
        """)
        return editor

    def updateEditorGeometry(self, editor, option, index):
        editor.setGeometry(option.rect)

    def setModelData(self, editor, model, index):
        """Validate tag name before saving"""
        new_text = editor.text().strip()
        original_text = index.data(Qt.ItemDataRole.DisplayRole)
        
        # Don't validate if text hasn't changed
        if new_text == original_text:
            return super().setModelData(editor, model, index)
        
        # Find the parent dialog to get the tag list
        widget = editor.parent()
        while widget and not isinstance(widget, TagListDialog):
            widget = widget.parent()
        
        if widget:  # Found TagListDialog
            # Normalize by removing # prefix for comparison
            new_text_clean = new_text.lstrip('#').lower()
            original_text_clean = original_text.lstrip('#').lower()
            
            if new_text_clean != original_text_clean:
                # Only check for duplicates if the text actually changed
                # Get all other tags from the actual list widget items (exclude current item)
                other_tags = []
                for i in range(widget.list_widget.count()):
                    item = widget.list_widget.item(i)
                    if item and item != model.itemFromIndex(index):  # Exclude the current item being edited
                        other_tags.append(item.text().lstrip('#').lower())
                
                if new_text_clean in other_tags:
                    # Show error message
                    from PyQt6.QtWidgets import QMessageBox
                    QMessageBox.warning(widget, "Duplicate Tag", f"A tag named '{new_text_clean}' already exists. Please choose a different name.")
                    # Reset to original text
                    editor.setText(original_text)
                    return
        
        # If validation passes, save the data
        super().setModelData(editor, model, index)

    def paint(self, painter, option, index):
        option.displayAlignment = Qt.AlignmentFlag.AlignCenter
        super().paint(painter, option, index) #Taglist
    
    def mousePressEvent(self, event):
        """Debug selection behavior and handle mouse events"""
        print(f"DEBUG: Mouse press event - button: {event.button()}, modifiers: {event.modifiers()}, pos: {event.pos()}")
        if event.button() == Qt.MouseButton.RightButton:
            print(f"DEBUG: Right mouse button pressed!")
        super().mousePressEvent(event)
        print(f"DEBUG: After mouse press - selected items: {len(self.selectedItems())}")
    
    def __init_auto_scroll(self):
        """Initialize auto-scroll after parent is set"""
        self.auto_scroll_timer = QTimer()
        self.auto_scroll_timer.timeout.connect(self.performFastAutoScroll)
        self.auto_scroll_direction = 0  # -1 for up, 1 for down, 0 for stop
    
    def performFastAutoScroll(self):
        """Custom fast auto-scroll implementation"""
        if hasattr(self, 'auto_scroll_direction') and self.auto_scroll_direction != 0:
            scroll_bar = self.verticalScrollBar()
            current_value = scroll_bar.value()
            # Scroll by large chunks for speed - 150px per tick
            scroll_amount = self.auto_scroll_direction * 150
            new_value = current_value + scroll_amount
            scroll_bar.setValue(new_value)
    
    def dragMoveEvent(self, event):
        """Override to implement fast auto-scroll"""
        super().dragMoveEvent(event)
        
        if not hasattr(self, 'auto_scroll_timer'):
            self.__init_auto_scroll()
        
        # Get the position relative to the widget
        pos = event.position().toPoint()
        widget_height = self.height()
        margin = 100  # Same as setAutoScrollMargin
        
        # Check if we need to auto-scroll
        if pos.y() < margin:
            # Scroll up
            if self.auto_scroll_direction != -1:
                self.auto_scroll_direction = -1
                self.auto_scroll_timer.start(30)  # Super fast timer - 30ms intervals
        elif pos.y() > widget_height - margin:
            # Scroll down  
            if self.auto_scroll_direction != 1:
                self.auto_scroll_direction = 1
                self.auto_scroll_timer.start(30)  # Super fast timer - 30ms intervals
        else:
            # Stop auto-scroll
            self.auto_scroll_direction = 0
            self.auto_scroll_timer.stop()
    
    def dragLeaveEvent(self, event):
        """Stop auto-scroll when drag leaves widget"""
        super().dragLeaveEvent(event)
        if hasattr(self, 'auto_scroll_timer'):
            self.auto_scroll_direction = 0
            self.auto_scroll_timer.stop()
    
    def dropEvent(self, event):
        """Stop auto-scroll when drop completes"""
        super().dropEvent(event)
        if hasattr(self, 'auto_scroll_timer'):
            self.auto_scroll_direction = 0
            self.auto_scroll_timer.stop()
    
class PresetNameDialog(QDialog):
    """Dialog for naming tag presets"""
    
    def __init__(self, parent=None, existing_names=None, current_name=""):
        super().__init__(parent)
        self.setWindowTitle("Save Tag Preset")
        self.setFixedSize(400, 150)
        self.existing_names = existing_names or []
        
        layout = QVBoxLayout(self)
        layout.setSpacing(12)
        layout.setContentsMargins(16, 16, 16, 16)
        
        # Instruction label
        instruction = QLabel("Enter a name for this tag preset:")
        instruction.setStyleSheet("font-size: 12px; color: #495057;")
        layout.addWidget(instruction)
        
        # Name input
        self.name_input = QLineEdit()
        self.name_input.setText(current_name)
        self.name_input.setPlaceholderText("Preset name...")
        self.name_input.setMinimumHeight(35)  # Increased by 5px from default ~30px
        self.name_input.setStyleSheet("""
            QLineEdit {
                padding: 8px 12px;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                font-size: 12px;
                background-color: #ffffff;
            }
            QLineEdit:focus {
                border-color: #007bff;
                outline: none;
            }
        """)
        self.name_input.textChanged.connect(self.validate_name)
        layout.addWidget(self.name_input)
        
        # Error label
        self.error_label = QLabel()
        self.error_label.setStyleSheet("color: #dc3545; font-size: 11px;")
        self.error_label.hide()
        layout.addWidget(self.error_label)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        # Overwrite Existing button (left side)
        self.overwrite_button = QPushButton("Overwrite Existing")
        self.overwrite_button.setStyleSheet("""
            QPushButton {
                background-color: #ffc107;
                border: 1px solid #ffc107;
                border-radius: 4px;
                padding: 6px 16px;
                font-size: 12px;
                color: #212529;
            }
            QPushButton:hover {
                background-color: #e0a800;
                border-color: #d39e00;
            }
        """)
        self.overwrite_button.clicked.connect(self.overwrite_existing_preset)
        button_layout.addWidget(self.overwrite_button)
        
        button_layout.addStretch()
        
        cancel_button = QPushButton("Cancel")
        cancel_button.setStyleSheet("""
            QPushButton {
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                padding: 6px 16px;
                font-size: 12px;
                color: #495057;
            }
            QPushButton:hover {
                background-color: #e9ecef;
            }
        """)
        cancel_button.clicked.connect(self.reject)
        
        self.save_button = QPushButton("Save")
        self.save_button.setStyleSheet("""
            QPushButton {
                background-color: #007bff;
                border: 1px solid #007bff;
                border-radius: 4px;
                padding: 6px 16px;
                font-size: 12px;
                color: white;
            }
            QPushButton:hover {
                background-color: #0056b3;
                border-color: #0056b3;
            }
            QPushButton:disabled {
                background-color: #6c757d;
                border-color: #6c757d;
            }
        """)
        self.save_button.clicked.connect(self.accept)
        self.save_button.setDefault(True)
        
        button_layout.addWidget(cancel_button)
        button_layout.addWidget(self.save_button)
        layout.addLayout(button_layout)
        
        # Initial validation
        self.validate_name()
        self.name_input.setFocus()
        if current_name:
            self.name_input.selectAll()
    
    def validate_name(self):
        """Validate the preset name"""
        name = self.name_input.text().strip()
        
        if not name:
            self.error_label.setText("Preset name cannot be empty")
            self.error_label.show()
            self.save_button.setEnabled(False)
            return False
        
        # Check for invalid characters
        invalid_chars = ['<', '>', ':', '"', '/', '\\', '|', '?', '*']
        if any(char in name for char in invalid_chars):
            self.error_label.setText("Preset name contains invalid characters")
            self.error_label.show()
            self.save_button.setEnabled(False)
            return False
        
        # Check length
        if len(name) > 50:
            self.error_label.setText("Preset name too long (max 50 characters)")
            self.error_label.show()
            self.save_button.setEnabled(False)
            return False
        
        self.error_label.hide()
        self.save_button.setEnabled(True)
        return True
    
    def get_preset_name(self):
        """Get the validated preset name"""
        return self.name_input.text().strip()
    
    def check_overwrite_needed(self):
        """Check if this preset name already exists"""
        return self.get_preset_name() in self.existing_names
    
    def overwrite_existing_preset(self):
        """Open file dialog to select existing preset file to overwrite"""
        from PyQt6.QtWidgets import QFileDialog
        import os
        
        # Get the tag presets directory
        tag_presets_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Data", "tag_presets")
        
        # Ensure the directory exists
        os.makedirs(tag_presets_dir, exist_ok=True)
        
        # Open file dialog to select existing JSON file
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Preset File to Overwrite",
            tag_presets_dir,
            "JSON Files (*.json);;All Files (*)"
        )
        
        if file_path:
            # Extract the filename without path and extension
            filename = os.path.basename(file_path)
            preset_name = os.path.splitext(filename)[0]
            
            # Set the selected filename (without extension) as the preset name
            self.name_input.setText(preset_name)
            
            # Store the file path for overwriting
            self.overwrite_file_path = file_path
            
            # Accept the dialog to proceed with overwrite
            self.accept()
    
    def get_overwrite_file_path(self):
        """Get the file path to overwrite (if overwrite was selected)"""
        return getattr(self, 'overwrite_file_path', None)


class TagListDialog(QDialog):
    tagsChanged = pyqtSignal()  # Signal to notify when tags are modified
    
    def __init__(self, parent=None, tags=None):
        super().__init__(parent)
        self.setWindowTitle("Tag Manager")
        self.resize(600, 500)  # Default size: minimum width + 100px height
        self.setMinimumSize(600, 400)  # Set minimum size
        self.setSizeGripEnabled(True)
        
        # Initialize tags list
        self.tags = tags if tags else []
        
        # Preset management state
        self.current_preset_name = None
        self.current_preset_file = None
        
        # Create tag_presets directory if it doesn't exist
        self.tag_presets_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Data", "tag_presets")
        os.makedirs(self.tag_presets_dir, exist_ok=True)
        
        # Enable context menu for the dialog
        self.setContextMenuPolicy(Qt.ContextMenuPolicy.DefaultContextMenu)
        
        # Set up the UI layout
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(12)
        main_layout.setContentsMargins(16, 16, 16, 16)

        # Header section with title and buttons
        header_layout = QHBoxLayout()
        header_layout.setSpacing(8)

        # Title and count
        title_layout = QVBoxLayout()
        title_label = QLabel("Tags")
        title_label.setStyleSheet("font-size: 16px; font-weight: bold; color: #202124;")
        
        # View toggle button
        self.view_toggle_btn = QPushButton("List View")
        self.view_toggle_btn.setCheckable(True)
        self.view_toggle_btn.setStyleSheet("""
            QPushButton {
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                padding: 4px 12px;
                font-size: 11px;
                color: #495057;
            }
            QPushButton:hover {
                background-color: #e9ecef;
                border-color: #adb5bd;
            }
            QPushButton:checked {
                background-color: #007bff;
                border-color: #007bff;
                color: white;
            }
        """)
        self.view_toggle_btn.clicked.connect(self.toggle_view)
        
        self.count_label = QLabel(f"{len(self.tags)} tags")
        self.count_label.setStyleSheet("font-size: 12px; color: #5f6368;")
        title_layout.addWidget(title_label)
        title_layout.addWidget(self.count_label)
        
        # Create a horizontal layout for the buttons
        buttons_layout = QHBoxLayout()
        buttons_layout.setSpacing(6)  # Small space between buttons
        buttons_layout.addWidget(self.view_toggle_btn)
        
        # Sort button
        self.sort_button = QPushButton("Sort A-Z")
        self.sort_button.setStyleSheet("""
            QPushButton {
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                padding: 4px 12px;
                font-size: 11px;
                color: #495057;
            }
            QPushButton:hover {
                background-color: #e9ecef;
                border-color: #adb5bd;
            }
        """)
        self.sort_button.clicked.connect(self.sort_tags_alphabetically)
        buttons_layout.addWidget(self.sort_button)
        
        # Manage Presets dropdown button
        self.presets_button = QPushButton("Manage Presets")
        self.presets_button.setStyleSheet("""
            QPushButton {
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                padding: 4px 12px;
                font-size: 11px;
                color: #495057;
            }
            QPushButton:hover {
                background-color: #e9ecef;
                border-color: #adb5bd;
            }
        """)
        
        # Create dropdown menu for presets
        self.presets_menu = QMenu(self)
        self.presets_menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 6px 12px;
                font-size: 12px;
                color: #495057;
            }
            QMenu::item:hover {
                background-color: #f8f9fa;
            }
            QMenu::item:disabled {
                color: #adb5bd;
            }
        """)
        
        # Add menu actions
        self.load_preset_action = self.presets_menu.addAction("Load Preset")
        self.load_preset_action.triggered.connect(self.load_preset)
        
        self.save_preset_action = self.presets_menu.addAction("Save")
        self.save_preset_action.triggered.connect(self.save_preset)
        self.save_preset_action.setEnabled(False)  # Initially disabled
        
        self.save_as_preset_action = self.presets_menu.addAction("Save As Preset")
        self.save_as_preset_action.triggered.connect(self.save_as_preset)
        
        self.presets_menu.addSeparator()
        
        self.unload_clear_action = self.presets_menu.addAction("Unload and Clear")
        self.unload_clear_action.triggered.connect(self.unload_and_clear)
        
        self.presets_button.setMenu(self.presets_menu)
        buttons_layout.addWidget(self.presets_button)
        
        title_layout.addLayout(buttons_layout)
        
        header_layout.addLayout(title_layout)
        header_layout.addStretch()

        self.add_button = QPushButton()
        self.add_button.setIcon(QIcon("Img/add-tag.png"))
        self.add_button.setIconSize(QSize(34, 34))
        self.add_button.setFixedSize(48, 48)  # Make button slightly larger to account for the transform
        self.add_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.add_button.setToolTip("Add Tag")
        self.add_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                padding: 7px;  /* Increased padding for better centering */
            }
            QPushButton:hover {
                background-color: #f0f0f0;
                border-radius: 4px;
            }
            QToolTip {
                background-color: #f8f9fa;
                color: #202124;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 12px;
            }
        """)

        # Keep your normal/hover icon implementation for the icon change on hover
        self.normal_icon = QIcon("Img/add-tag.png")
        self.hover_icon = QIcon("Img/add-tag-hover.png")

        class IconHoverFilter(QObject):
            def __init__(self, button, normal_icon, hover_icon):
                super().__init__()
                self.button = button
                self.normal_icon = normal_icon
                self.hover_icon = hover_icon
    
            def eventFilter(self, obj, event):
                if event.type() == QEvent.Type.Enter:
                    self.button.setIcon(self.hover_icon)
                elif event.type() == QEvent.Type.Leave:
                    self.button.setIcon(self.normal_icon)
                return False

        self.add_button.installEventFilter(
            IconHoverFilter(self.add_button, self.normal_icon, self.hover_icon)
        )

        
        header_layout.addWidget(self.add_button)
        main_layout.addLayout(header_layout)
        

        # Search bar with a clear button
        search_layout = QHBoxLayout()
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search tags...")
        self.search_input.setStyleSheet("""
            QLineEdit {
                padding: 8px 12px;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                background: #ffffff;
                font-size: 13px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
        """)
        # Clear button for search field
        clear_button = QPushButton("✕")
        clear_button.setFixedSize(20, 20)
        clear_button.setStyleSheet("""
            QPushButton {
                background: transparent;
                border: none;
                color: #a0a0a0;
            }
            QPushButton:hover {
                color: #666666;
            }
        """)
        clear_button.clicked.connect(lambda: self.search_input.clear())
        search_layout.addWidget(self.search_input)
        search_layout.addWidget(clear_button)
        main_layout.addLayout(search_layout)

        # Create both widget views
        self.grid_widget = CompactTagGridWidget()
        self.traditional_list = TagListWidget()
        
        # Create a container that will hold the current view
        self.view_container = QWidget()
        self.view_layout = QVBoxLayout(self.view_container)
        self.view_layout.setContentsMargins(0, 0, 0, 0)
        
        # Start with grid view (default)
        self.list_widget = self.grid_widget  # Keep reference for existing code
        self.current_view = "grid"
        self.view_layout.addWidget(self.grid_widget)
        
        main_layout.addWidget(self.view_container)
        
        # Connect signals for changes and filtering
        self.add_button.clicked.connect(self.add_tag)
        self.grid_widget.itemChanged.connect(self.on_item_changed)
        self.grid_widget.layoutChanged.connect(self.on_rows_moved)
        self.traditional_list.itemChanged.connect(self.on_item_changed)  
        self.traditional_list.model().layoutChanged.connect(self.on_rows_moved)
        self.traditional_list.model().rowsMoved.connect(self.on_rows_moved)
        self.search_input.textChanged.connect(self.filter_tags)
        
        # Populate existing tags
        self.populate_tags()

    def setup_button_hover(self):
        self.normal_icon = QIcon("Img/add-tag.png")
        self.hover_icon = QIcon("Img/add-tag-hover.png")
    
        # Define normal and hover sizes
        self.normal_size = QSize(32, 32)
        self.hover_size = QSize(36, 36)
    
        class HoverEventFilter(QObject):
            def __init__(self, button, normal_icon, hover_icon, normal_size, hover_size):
                super().__init__()
                self.button = button
                self.normal_icon = normal_icon
                self.hover_icon = hover_icon
                self.normal_size = normal_size
                self.hover_size = hover_size
        
            def eventFilter(self, obj, event):
                if event.type() == QEvent.Type.Enter:
                    self.button.setIcon(self.hover_icon)
                    self.button.setIconSize(QSize(28, 28))  # Slightly larger icon
                    self.button.setFixedSize(self.hover_size)
                    # Center the button so it grows from the center
                    self.button.setContentsMargins(0, 0, 0, 0)
                elif event.type() == QEvent.Type.Leave:
                    self.button.setIcon(self.normal_icon)
                    self.button.setIconSize(QSize(24, 24))  # Original icon size
                    self.button.setFixedSize(self.normal_size)
                    self.button.setContentsMargins(0, 0, 0, 0)
                return False
    
        self.add_button.installEventFilter(
            HoverEventFilter(
                self.add_button, 
                self.normal_icon, 
                self.hover_icon,
                self.normal_size,
                self.hover_size
            )
        )


    # ========== TAG PRESET MANAGEMENT METHODS ==========
    
    def update_window_title(self):
        """Update window title to show current preset if any"""
        if self.current_preset_name:
            self.setWindowTitle(f"Tag Manager - [Preset: {self.current_preset_name}]")
        else:
            self.setWindowTitle("Tag Manager")
    
    def get_existing_preset_names(self):
        """Get list of existing preset names"""
        try:
            preset_files = [f for f in os.listdir(self.tag_presets_dir) if f.endswith('.json')]
            return [os.path.splitext(f)[0] for f in preset_files]
        except OSError:
            return []
    
    def load_preset(self):
        """Load a tag preset from file"""
        file_dialog = QFileDialog(self)
        file_dialog.setWindowTitle("Load Tag Preset")
        file_dialog.setNameFilter("JSON Files (*.json)")
        file_dialog.setFileMode(QFileDialog.FileMode.ExistingFile)
        file_dialog.setDirectory(self.tag_presets_dir)
        
        if file_dialog.exec() == QDialog.DialogCode.Accepted:
            selected_files = file_dialog.selectedFiles()
            if selected_files:
                file_path = selected_files[0]
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        preset_data = json.load(f)
                    
                    # Validate preset data
                    if 'tags' not in preset_data:
                        QMessageBox.warning(self, "Invalid Preset", "This file does not contain valid tag preset data.")
                        return
                    
                    # Load the tags
                    self.tags = preset_data.get('tags', [])
                    self.current_preset_name = preset_data.get('name', os.path.splitext(os.path.basename(file_path))[0])
                    self.current_preset_file = file_path
                    
                    # Update UI
                    self.populate_tags()
                    self.update_count()
                    self.update_window_title()
                    self.save_preset_action.setEnabled(True)
                    
                    # Notify parent of changes
                    self.notify_changes()
                    
                    print(f"Loaded preset '{self.current_preset_name}' with {len(self.tags)} tags")
                    
                except Exception as e:
                    QMessageBox.critical(self, "Error Loading Preset", f"Failed to load preset:\n{str(e)}")
    
    def save_preset(self):
        """Save current tags to the current preset file"""
        if not self.current_preset_file or not self.current_preset_name:
            self.save_as_preset()
            return
        
        try:
            self.update_tags_list()  # Ensure tags list is current
            
            preset_data = {
                "name": self.current_preset_name,
                "tags": self.tags.copy(),
                "created": datetime.datetime.now().isoformat(),
                "modified": datetime.datetime.now().isoformat()
            }
            
            with open(self.current_preset_file, 'w', encoding='utf-8') as f:
                json.dump(preset_data, f, indent=2, ensure_ascii=False)
            
            print(f"Saved preset '{self.current_preset_name}' with {len(self.tags)} tags")
            
        except Exception as e:
            QMessageBox.critical(self, "Error Saving Preset", f"Failed to save preset:\n{str(e)}")
    
    def save_as_preset(self):
        """Save current tags as a new preset with user-specified name"""
        existing_names = self.get_existing_preset_names()
        
        dialog = PresetNameDialog(self, existing_names)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            preset_name = dialog.get_preset_name()
            
            # Check for overwrite
            if dialog.check_overwrite_needed():
                reply = QMessageBox.question(
                    self,
                    "Overwrite Preset",
                    f"A preset named '{preset_name}' already exists.\n\nDo you want to overwrite it?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No
                )
                if reply != QMessageBox.StandardButton.Yes:
                    return
            
            try:
                self.update_tags_list()  # Ensure tags list is current
                
                preset_data = {
                    "name": preset_name,
                    "tags": self.tags.copy(),
                    "created": datetime.datetime.now().isoformat(),
                    "modified": datetime.datetime.now().isoformat()
                }
                
                file_path = os.path.join(self.tag_presets_dir, f"{preset_name}.json")
                
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(preset_data, f, indent=2, ensure_ascii=False)
                
                # Update current preset info
                self.current_preset_name = preset_name
                self.current_preset_file = file_path
                self.update_window_title()
                self.save_preset_action.setEnabled(True)
                
                print(f"Saved new preset '{preset_name}' with {len(self.tags)} tags")
                
            except Exception as e:
                QMessageBox.critical(self, "Error Saving Preset", f"Failed to save preset:\n{str(e)}")
    
    def unload_and_clear(self):
        """Unload current preset and clear all tags"""
        if self.tags:
            reply = QMessageBox.question(
                self,
                "Clear All Tags",
                "This will remove all tags and unload the current preset.\n\nAre you sure?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply != QMessageBox.StandardButton.Yes:
                return
        
        # Clear everything
        self.tags.clear()
        self.current_preset_name = None
        self.current_preset_file = None
        
        # Update UI
        self.populate_tags()
        self.update_count()
        self.update_window_title()
        self.save_preset_action.setEnabled(False)
        
        # Notify parent of changes
        self.notify_changes()
        
        print("Cleared all tags and unloaded preset")

    def filter_tags(self, text):
        search_text = text.lower()
        if self.current_view == "grid":
            for widget in self.list_widget.tag_widgets:
                matches = search_text in widget.text().lower()
                widget.setVisible(matches)
        else:
            # Traditional list filtering
            for i in range(self.list_widget.count()):
                item = self.list_widget.item(i)
                if isinstance(item, QListWidgetItem):
                    matches = search_text in item.text().lower()
                    item.setHidden(not matches)

        
    def populate_tags(self):
        self.list_widget.clear()
    
        if not self.tags:
            # Show placeholder label in the center
            placeholder = QLabel("No tags added yet - Click 'Add Tag' to create one")
            placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
            placeholder.setStyleSheet("""
                QLabel {
                    color: #666666;
                    font-size: 14px;
                    font-style: italic;
                    padding: 40px;
                }
            """)
            # Note: placeholder will be removed when first tag is added
            self.list_widget.flow_layout.addWidget(placeholder)
        else:
            for tag in self.tags:
                self.add_tag_item(tag)
        self.update_count()

    def add_tag_item(self, tag_text=""):
        if self.current_view == "grid":
            item = self.list_widget.addTagItem(tag_text)
            # Store original text for change detection
            item._original_text = tag_text
        else:
            # Traditional list widget - compact size, full width
            item = QListWidgetItem(tag_text)
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
            item.setSizeHint(QSize(self.list_widget.width() - 20, 26))  # Full width minus margins, slightly taller
            item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)  # Center the text
            item._original_text = tag_text
            self.list_widget.addItem(item)
        return item
    
    def add_tag(self):
        if not self.tags:
            self.list_widget.clear()
        item = self.add_tag_item()
        # Start editing the new tag
        if self.current_view == "grid":
            item.mouseDoubleClickEvent(QMouseEvent(
                QEvent.Type.MouseButtonDblClick,
                QPointF(0, 0),
                Qt.MouseButton.LeftButton,
                Qt.MouseButton.LeftButton,
                Qt.KeyboardModifier.NoModifier
            ))
        else:
            # Traditional list editing
            self.list_widget.editItem(item)
        self.notify_changes()
        self.update_count()
        
        # Auto-scroll to bottom to show the new tag
        self.list_widget.scrollToBottom()
        
    def on_item_changed(self, item):
        print(f"\n=== TAG RENAME DEBUG START ===")
        
        # Store original text before processing to detect actual changes  
        old_text = getattr(item, '_original_text', item.text())
        print(f"DEBUG: Original text: '{old_text}'")
        print(f"DEBUG: Current item text: '{item.text()}'")
        
        # Process the new text according to existing rules
        text = item.text().strip().replace(" ", "")
        print(f"DEBUG: After strip and space removal: '{text}'")
        
        import string
        # Allow certain characters: # (for prefix), - (dashes), _ (underscores), & (ampersands)
        allowed_chars = "#-_&"
        punctuation_to_remove = ''.join(c for c in string.punctuation if c not in allowed_chars)
        for char in punctuation_to_remove:
            text = text.replace(char, "")
        print(f"DEBUG: After punctuation removal: '{text}'")
        
        if not text.startswith("#"):
            text = f"#{text}"
        print(f"DEBUG: After # prefix: '{text}'")
        
        if len(text) > 35:  # Increased character limit
            text = text[:35]
        print(f"DEBUG: After length limit: '{text}'")
        
        while '##' in text:
            text = text.replace('##', '#')
        print(f"DEBUG: Final processed text: '{text}'")
        
        item.setText(text)
        
        # If the tag actually changed, update across entire system
        print(f"DEBUG: Comparing old_text='{old_text}' with new text='{text}'")
        print(f"DEBUG: old_text != text: {old_text != text}")
        print(f"DEBUG: old_text.strip(): '{old_text.strip()}'")
        print(f"DEBUG: text.strip(): '{text.strip()}'")
        
        # Normalize both texts for comparison (ensure both have # prefix for fair comparison)
        old_text_normalized = old_text if old_text.startswith('#') else '#' + old_text
        text_normalized = text if text.startswith('#') else '#' + text
        
        if old_text_normalized != text_normalized and old_text.strip() and text.strip():
            print(f"DEBUG: Tag actually changed! Checking for confirmation before calling _rename_tag_across_system('{old_text}', '{text}')")
            # Check if rename should proceed (with confirmation dialog)
            if self._confirm_and_rename_tag(old_text, text, item):
                print(f"DEBUG: User confirmed rename - proceeding")
            else:
                print(f"DEBUG: User canceled rename - reverting to original")
        else:
            print(f"DEBUG: No tag change detected or empty tags - skipping system update")
        
        # Store the current text for future comparisons
        item._original_text = text
        print(f"DEBUG: Stored new original text: '{text}'")
        
        self.update_tags_list()
        self.notify_changes()
        self.update_count()
        
        print(f"=== TAG RENAME DEBUG END ===\n")
    
    def toggle_view(self):
        """Toggle between grid view and traditional list view"""
        if self.current_view == "grid":
            # Switch to list view
            self.current_view = "list"
            self.view_toggle_btn.setText("Grid View")
            self.view_toggle_btn.setChecked(True)
            
            # Remove grid widget and add list widget
            self.view_layout.removeWidget(self.grid_widget)
            self.grid_widget.hide()
            self.view_layout.addWidget(self.traditional_list)
            self.traditional_list.show()
            self.list_widget = self.traditional_list
        else:
            # Switch to grid view
            self.current_view = "grid"
            self.view_toggle_btn.setText("List View") 
            self.view_toggle_btn.setChecked(False)
            
            # Remove list widget and add grid widget
            self.view_layout.removeWidget(self.traditional_list)
            self.traditional_list.hide()
            self.view_layout.addWidget(self.grid_widget)
            self.grid_widget.show()
            self.list_widget = self.grid_widget
        
        # Repopulate the new view with current tags
        self.populate_tags()
        
    def on_rows_moved(self):
        # Not needed with new flow layout
        self.update_tags_list()
        self.notify_changes()
        self.update_count()
        
    def update_tags_list(self):
        if self.current_view == "grid":
            self.tags = [widget.text() for widget in self.list_widget.tag_widgets]
        else:
            self.tags = [self.list_widget.item(i).text() for i in range(self.list_widget.count())]
            
    # Context menu is now handled by individual tag widgets in each view
                
    def notify_changes(self):
        if self.parent():
            self.parent().mark_changes_pending()
        self.tagsChanged.emit()
        
    def update_count(self):
        self.count_label.setText(f"{len(self.tags)} tags")
        
    def get_tags(self):
        return self.tags #Taglist
        
    def sort_tags_alphabetically(self):
        """Sort all tags alphabetically with confirmation dialog"""
        if not self.tags or len(self.tags) <= 1:
            QMessageBox.information(self, "Sort Tags", "Not enough tags to sort (need at least 2 tags).")
            return
            
        # Show confirmation dialog
        reply = QMessageBox.question(
            self, 
            "Sort Tags Alphabetically",
            f"This will sort all {len(self.tags)} tags in alphabetical order.\n\n"
            "This action cannot be undone. Are you sure you want to continue?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # Store original order for undo (in case we want to add that later)
            original_order = self.tags.copy()
            
            # Sort tags alphabetically (case-insensitive)
            self.tags.sort(key=str.lower)
            
            # Refresh the UI
            self.populate_tags()
            self.update_count()
            self.notify_changes()
            
            QMessageBox.information(self, "Sort Complete", f"Successfully sorted {len(self.tags)} tags alphabetically!")
    
    def _rename_tag_across_system(self, old_tag, new_tag):
        """Rename a tag across all annotations and DOM elements with progress dialog"""
        import json
        print(f"\n=== _RENAME_TAG_ACROSS_SYSTEM DEBUG START ===")
        print(f"DEBUG: old_tag='{old_tag}', new_tag='{new_tag}'")
        
        if not old_tag or not new_tag or old_tag == new_tag:
            print(f"DEBUG: Skipping rename - invalid parameters")
            return
            
        # Get main window to access annotations
        print(f"DEBUG: Searching for main window...")
        main_window = self.parent()
        parent_count = 0
        while main_window and not hasattr(main_window, 'web_view'):
            parent_count += 1
            print(f"DEBUG: Parent {parent_count}: {type(main_window).__name__}")
            main_window = main_window.parent()
            if parent_count > 10:  # Prevent infinite loop
                print(f"DEBUG: Too many parent levels, stopping search")
                break
            
        if not main_window or not hasattr(main_window, 'web_view'):
            print("ERROR: Could not find main window for tag rename")
            print(f"DEBUG: Final main_window: {main_window}")
            print(f"DEBUG: Has web_view: {hasattr(main_window, 'web_view') if main_window else 'N/A'}")
            return
            
        print(f"DEBUG: Found main window: {type(main_window).__name__}")
        print(f"DEBUG: web_view exists: {hasattr(main_window, 'web_view')}")
        print(f"DEBUG: annotations exist: {hasattr(main_window.web_view, 'annotations') if hasattr(main_window, 'web_view') else 'N/A'}")
        
        if not hasattr(main_window.web_view, 'annotations'):
            print(f"ERROR: web_view has no annotations attribute")
            return
            
        annotations = main_window.web_view.annotations
        print(f"DEBUG: Total annotations in system: {len(annotations)}")
        affected_annotations = []
        
        # Find annotations that contain the old tag (remove # prefix for comparison)
        old_tag_clean = old_tag.lstrip('#')
        new_tag_clean = new_tag.lstrip('#')
        print(f"DEBUG: Searching for clean old_tag: '{old_tag_clean}'")
        
        # OPTIMIZED: Fast filter - only check annotations that have tags (major performance improvement)
        affected_annotations = [a for a in annotations if a.get('tags') and old_tag_clean in a.get('tags', [])]
        print(f"DEBUG: Found {len(affected_annotations)} affected annotations in optimized search")
        for annotation in affected_annotations:
            print(f"DEBUG: Will update annotation {annotation.get('id', 'NO_ID')} - Tags: {annotation.get('tags', [])}")
                
        if not affected_annotations:
            print(f"DEBUG: No annotations to update - returning")
            print(f"=== _RENAME_TAG_ACROSS_SYSTEM DEBUG END ===\n")
            return  # No annotations to update
            
        # ENHANCED: Always show progress dialog (no cancel once operation starts)
        print(f"DEBUG: Creating progress dialog for {len(affected_annotations)} annotations")
        progress = QProgressDialog(f"Renaming tag '{old_tag}' to '{new_tag}'...", None, 0, len(affected_annotations), self)
        progress.setWindowTitle("Updating Tags")
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setMinimumDuration(0)  # Always show immediately
        progress.setCancelButton(None)  # Remove cancel button - user already confirmed
        progress.setValue(0)
        progress.show()  # Force show
        QApplication.processEvents()  # Ensure it appears
        
        try:
            print(f"DEBUG: Starting OPTIMIZED batch annotation updates for {len(affected_annotations)} annotations...")
            updated_annotations = []
            affected_annotation_ids = []
            
            # OPTIMIZED: Batch update annotations (much faster than one-by-one)
            for i, annotation in enumerate(affected_annotations):
                    
                # Update the annotation's tags
                tags = annotation.get('tags', [])
                if old_tag_clean in tags:
                    # Replace old tag with new tag (both without # prefix)
                    tag_index = tags.index(old_tag_clean)
                    tags[tag_index] = new_tag_clean
                    annotation['tags'] = tags
                    updated_annotations.append(annotation)
                    affected_annotation_ids.append(annotation.get('id'))
                    print(f"DEBUG: Updated annotation {annotation.get('id', 'NO_ID')}: {old_tag_clean} -> {new_tag_clean}")
                
                # OPTIMIZED: Update progress less frequently (every 10 annotations) for better visibility
                if i > 0 and i % 10 == 0:
                    progress.setValue(i + 1)
                    progress.setLabelText(f"Updated {i + 1} of {len(affected_annotations)} annotations...")
                    QApplication.processEvents()  # Keep UI responsive
                
            # OPTIMIZED: Batch emit signals and refresh UI components
            if updated_annotations:
                print(f"DEBUG: Emitting batch updates for {len(updated_annotations)} annotations")
                
                # OPTIMIZED: Emit signals for all updated annotations in batch
                for annotation in updated_annotations:
                    main_window.web_view.annotation_updated.emit(json.dumps(annotation))
                
                # ENHANCED: Refresh theme view and storyboard if open
                print(f"DEBUG: Refreshing UI components with affected annotation IDs: {affected_annotation_ids[:5]}...")
                self._refresh_ui_components_for_tag_change(main_window, affected_annotation_ids)
                
                # ENHANCED: Refresh active tag filters if they exist
                self._refresh_tag_filtering_after_bulk_operation(main_window, old_tag_clean, new_tag_clean, is_rename=True)
                
                # Mark changes as pending
                print(f"DEBUG: Marking changes as pending")
                main_window.mark_changes_pending()
                
                progress.setValue(len(affected_annotations))
                print(f"DEBUG: OPTIMIZED tag rename completed successfully - updated {len(updated_annotations)} annotations")
            elif not updated_annotations:
                print(f"DEBUG: No annotations were actually updated (this shouldn't happen)")
                
        except Exception as e:
            print(f"DEBUG: Exception occurred: {str(e)}")
            import traceback
            print(f"DEBUG: Full traceback: {traceback.format_exc()}")
            QMessageBox.critical(self, "Error", f"Error renaming tag: {str(e)}")
        finally:
            progress.close()
            print(f"=== _RENAME_TAG_ACROSS_SYSTEM DEBUG END ===\n")
    
    def _refresh_ui_components_for_tag_change(self, main_window, affected_annotation_ids):
        """Refresh theme view and storyboard for annotations with updated tags"""
        try:
            # FIXED: Refresh the affected annotations in theme view regardless of visibility
            if hasattr(main_window, 'scene_tabs') and main_window.scene_tabs:
                print(f"DEBUG: Refreshing theme view for {len(affected_annotation_ids)} annotations")
                # Iterate through all scene tabs and refresh each annotation
                for i in range(main_window.scene_tabs.count()):
                    list_widget = main_window.scene_tabs.widget(i)
                    if hasattr(list_widget, 'refresh_annotation_display'):
                        for annotation_id in affected_annotation_ids:
                            list_widget.refresh_annotation_display(annotation_id)
                print(f"DEBUG: Refreshed all theme view tabs for tag changes")
            else:
                print(f"DEBUG: Scene tabs not available")
            
            # Refresh storyboard if it's open - use the correct targeted refresh method
            if hasattr(main_window, 'storyboard_dialog') and main_window.storyboard_dialog and main_window.storyboard_dialog.isVisible():
                print(f"DEBUG: Refreshing storyboard for {len(affected_annotation_ids)} annotations")
                # Use the order list's refresh method for individual annotations
                if hasattr(main_window.storyboard_dialog, 'order_list') and hasattr(main_window.storyboard_dialog.order_list, 'refresh_annotation_display'):
                    for annotation_id in affected_annotation_ids:
                        main_window.storyboard_dialog.order_list.refresh_annotation_display(annotation_id)
                        print(f"DEBUG: Refreshed annotation {annotation_id} in storyboard")
                else:
                    print(f"DEBUG: Storyboard targeted refresh not available - using fallback")
                    # Fallback to full refresh if targeted method not available
                    if hasattr(main_window.storyboard_dialog, 'populate_order_list_and_improve_strikethroughs'):
                        main_window.storyboard_dialog.populate_order_list_and_improve_strikethroughs()
                    else:
                        print(f"DEBUG: No storyboard refresh method available")
                    
        except Exception as e:
            print(f"DEBUG: Error refreshing UI components: {str(e)}")
            import traceback
            print(f"DEBUG: Full traceback: {traceback.format_exc()}")
    
    def _refresh_tag_filtering_after_bulk_operation(self, main_window, old_tag, new_tag, is_rename=True):
        """
        Refresh tag filtering system after bulk tag operations.
        For renames: updates active filters to use new tag name
        For deletions: removes deleted tag from active filters and refreshes
        """
        print(f"[DEBUG] Refreshing tag filtering after bulk operation: old_tag='{old_tag}', new_tag='{new_tag}', is_rename={is_rename}")
        
        try:
            # Check if tag filtering is active and update accordingly
            js_code = f"""
            (function() {{
                const oldTag = "{old_tag}";
                const newTag = "{new_tag}";
                const isRename = {str(is_rename).lower()};
                
                console.log(`[DEBUG] Checking tag filtering state for bulk operation: old=${{oldTag}}, new=${{newTag}}, isRename=${{isRename}}`);
                
                // Check if tag filtering is active
                if (!window.stickyHeaderTagState || !window.stickyHeaderTagState.isActive) {{
                    console.log('[DEBUG] No active tag filters - no refresh needed');
                    return {{ hasActiveFilters: false, updated: false }};
                }}
                
                const tagStates = window.stickyHeaderTagState.tagStates;
                const oldTagWithHash = '#' + oldTag;
                const newTagWithHash = newTag ? '#' + newTag : null;
                
                let filterWasUpdated = false;
                
                if (isRename && newTag) {{
                    // RENAME: Update the tag in active filters
                    if (tagStates[oldTagWithHash]) {{
                        console.log(`[DEBUG] Renaming tag in active filters: ${{oldTagWithHash}} -> ${{newTagWithHash}}`);
                        const oldState = tagStates[oldTagWithHash];
                        delete tagStates[oldTagWithHash];
                        tagStates[newTagWithHash] = oldState;
                        filterWasUpdated = true;
                    }}
                }} else {{
                    // DELETE: Remove the tag from active filters
                    if (tagStates[oldTagWithHash]) {{
                        console.log(`[DEBUG] Removing deleted tag from active filters: ${{oldTagWithHash}}`);
                        delete tagStates[oldTagWithHash];
                        filterWasUpdated = true;
                        
                        // Check if any filters are left
                        if (Object.keys(tagStates).length === 0) {{
                            console.log('[DEBUG] No tag filters left - triggering clear tag filters action');
                            
                            // Trigger the specific "clear tag filters" action (not global clear all)
                            if (window.clearTagFilters) {{
                                window.clearTagFilters();
                            }} else {{
                                // Fallback: manually clear tag filtering state
                                window.stickyHeaderTagState.isActive = false;
                                window.stickyHeaderTagState.tagStates = {{}};
                                window.stickyHeaderTagState.strictMode = true;
                                
                                // Hide tag filter UI elements if they exist
                                const tagFilterBtn = document.getElementById('tag-filter-btn');
                                if (tagFilterBtn) {{
                                    tagFilterBtn.classList.remove('active');
                                    tagFilterBtn.style.display = '';
                                }}
                                
                                // Clear any tag filter indicators
                                const tagFilterIndicators = document.querySelectorAll('.tag-filter-indicator');
                                tagFilterIndicators.forEach(indicator => indicator.remove());
                            }}
                        }}
                    }}
                }}
                
                if (filterWasUpdated) {{
                    console.log('[DEBUG] Tag filters updated - triggering full filter refresh');
                    // Trigger a full filter refresh since multiple annotations were affected
                    if (window.applyStickyHeaderFilters) {{
                        window.applyStickyHeaderFilters();
                    }}
                }}
                
                return {{ 
                    hasActiveFilters: true, 
                    updated: filterWasUpdated,
                    remainingTags: Object.keys(tagStates).length
                }};
            }})();
            """
            
            def handle_filter_result(result):
                if isinstance(result, dict):
                    has_active_filters = result.get('hasActiveFilters', False)
                    was_updated = result.get('updated', False)
                    remaining_tags = result.get('remainingTags', 0)
                    
                    if has_active_filters:
                        if was_updated:
                            operation = "rename" if is_rename else "deletion"
                            print(f"[DEBUG] Tag filters updated after {operation}. Remaining active tags: {remaining_tags}")
                        else:
                            print(f"[DEBUG] Tag filters were active but no update was needed")
                    else:
                        print(f"[DEBUG] No active tag filters found")
                else:
                    print(f"[DEBUG] Unexpected result from filter check: {result}")
            
            main_window.web_view.page().runJavaScript(js_code, handle_filter_result)
            
        except Exception as e:
            print(f"[DEBUG] Error refreshing tag filtering: {str(e)}")
    
    def _confirm_and_rename_tag(self, old_tag, new_tag, item):
        """Show confirmation dialog before renaming tag and handle user response"""
        # Get main window to access annotations
        main_window = self.parent()
        while main_window and not hasattr(main_window, 'web_view'):
            main_window = main_window.parent()
            
        if not main_window or not hasattr(main_window, 'web_view'):
            print("ERROR: Could not find main window for tag rename confirmation")
            return False
            
        # OPTIMIZED: Check if ANY annotations would be affected (stop at first match)
        old_tag_clean = old_tag.lstrip('#')
        annotations = main_window.web_view.annotations
        
        # Fast check - stop at first match
        has_affected_annotations = any(a.get('tags') and old_tag_clean in a.get('tags', []) for a in annotations)
        
        print(f"DEBUG: Has affected annotations: {has_affected_annotations}")
        
        if has_affected_annotations:
            # Show confirmation dialog (no count for performance)
            reply = QMessageBox.question(
                self,
                "Rename Tag",
                f"Existing annotations with this tag will be updated.\n\n"
                "Are you sure you want to continue?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                # User confirmed - proceed with rename
                self._rename_tag_across_system(old_tag, new_tag)
                return True
            else:
                # User canceled - revert the item text
                print(f"DEBUG: User canceled - reverting item text from '{new_tag}' to '{old_tag}'")
                item.setText(old_tag)
                item._original_text = old_tag
                return False
        else:
            # No annotations affected - just proceed silently
            print(f"DEBUG: No annotations affected - proceeding with rename")
            return True
    
    def _confirm_and_delete_tag(self, tag_to_delete):
        """Show confirmation dialog before deleting tag and handle user response"""
        # Get main window to access annotations
        main_window = self.parent()
        while main_window and not hasattr(main_window, 'web_view'):
            main_window = main_window.parent()
            
        if not main_window or not hasattr(main_window, 'web_view'):
            print("ERROR: Could not find main window for tag delete confirmation")
            return False
            
        # OPTIMIZED: Check if ANY annotations would be affected (stop at first match)
        tag_clean = tag_to_delete.lstrip('#')
        annotations = main_window.web_view.annotations
        
        # Fast check - stop at first match
        has_affected_annotations = any(a.get('tags') and tag_clean in a.get('tags', []) for a in annotations)
        
        print(f"DEBUG: Has affected annotations: {has_affected_annotations}")
        
        if has_affected_annotations:
            # Show confirmation dialog (no count for performance)
            reply = QMessageBox.question(
                self,
                "Delete Tag",
                f"Existing annotations with this tag will be updated.\n\n"
                "Are you sure you want to continue?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                # User confirmed - proceed with delete
                self._delete_tag_across_system(tag_to_delete)
                return True
            else:
                # User canceled
                print(f"DEBUG: User canceled delete operation")
                return False
        else:
            # No annotations affected - just proceed silently
            print(f"DEBUG: No annotations affected - proceeding with delete")
            return True
    
    def _confirm_and_delete_multiple_tags(self, tags_to_delete):
        """Show confirmation dialog for batch tag deletion"""
        tag_list = "\n".join([f"  • {tag}" for tag in tags_to_delete])
        reply = QMessageBox.question(
            self, 
            "Delete Multiple Tags",
            f"Are you sure you want to delete these {len(tags_to_delete)} tags?\n\n"
            f"{tag_list}\n\n"
            "This will remove them from all annotations and cannot be undone.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            for tag in tags_to_delete:
                self._delete_tag_across_system(tag)
            return True
        return False
    
    def _delete_tag_across_system(self, tag_to_delete):
        """Delete a tag from all annotations and DOM elements with progress dialog"""
        import json
        print(f"\n=== _DELETE_TAG_ACROSS_SYSTEM DEBUG START ===")
        print(f"DEBUG: tag_to_delete='{tag_to_delete}'")
        
        if not tag_to_delete:
            print(f"DEBUG: No tag to delete - returning")
            return
            
        # Get main window to access annotations
        main_window = self.parent()
        while main_window and not hasattr(main_window, 'web_view'):
            main_window = main_window.parent()
            
        if not main_window or not hasattr(main_window, 'web_view'):
            print("ERROR: Could not find main window for tag deletion")
            return
            
        annotations = main_window.web_view.annotations
        
        # OPTIMIZED: Find annotations that contain the tag to delete (remove # prefix for comparison)
        tag_to_delete_clean = tag_to_delete.lstrip('#')
        print(f"DEBUG: Searching for clean tag_to_delete: '{tag_to_delete_clean}'")
        
        # OPTIMIZED: Fast filter - only check annotations that have tags
        affected_annotations = [a for a in annotations if a.get('tags') and tag_to_delete_clean in a.get('tags', [])]
        print(f"DEBUG: Found {len(affected_annotations)} affected annotations for deletion")
        for annotation in affected_annotations:
            print(f"DEBUG: Will delete tag from annotation {annotation.get('id', 'NO_ID')} - Tags: {annotation.get('tags', [])}")
                
        if not affected_annotations:
            print(f"DEBUG: No annotations to update - returning")
            print(f"=== _DELETE_TAG_ACROSS_SYSTEM DEBUG END ===\n")
            return  # No annotations to update
            
        # ENHANCED: Always show progress dialog (no cancel once operation starts)
        print(f"DEBUG: Creating progress dialog for {len(affected_annotations)} annotations")
        progress = QProgressDialog(f"Removing tag '{tag_to_delete}' from document...", None, 0, len(affected_annotations), self)
        progress.setWindowTitle("Removing Tags")
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setMinimumDuration(0)  # Always show immediately
        progress.setCancelButton(None)  # Remove cancel button - user already confirmed
        progress.setValue(0)
        progress.show()  # Force show
        QApplication.processEvents()  # Ensure it appears
        
        try:
            print(f"DEBUG: Starting OPTIMIZED batch annotation deletions for {len(affected_annotations)} annotations...")
            updated_annotations = []
            affected_annotation_ids = []
            
            # OPTIMIZED: Batch delete tag from annotations (much faster than one-by-one)
            for i, annotation in enumerate(affected_annotations):
                    
                # Update the annotation's tags
                tags = annotation.get('tags', [])
                if tag_to_delete_clean in tags:
                    # Remove the tag (without # prefix)
                    tags.remove(tag_to_delete_clean)
                    annotation['tags'] = tags
                    updated_annotations.append(annotation)
                    affected_annotation_ids.append(annotation.get('id'))
                    print(f"DEBUG: Removed tag from annotation {annotation.get('id', 'NO_ID')}: {tag_to_delete_clean}")
                
                # OPTIMIZED: Update progress less frequently (every 10 annotations) for better visibility
                if i > 0 and i % 10 == 0:
                    progress.setValue(i + 1)
                    progress.setLabelText(f"Updated {i + 1} of {len(affected_annotations)} annotations...")
                    QApplication.processEvents()  # Keep UI responsive
                
            # OPTIMIZED: Batch emit signals and refresh UI components
            if updated_annotations:
                print(f"DEBUG: Emitting batch updates for {len(updated_annotations)} annotations")
                
                # OPTIMIZED: Emit signals for all updated annotations in batch
                for annotation in updated_annotations:
                    main_window.web_view.annotation_updated.emit(json.dumps(annotation))
                
                # ENHANCED: Refresh theme view and storyboard if open
                print(f"DEBUG: Refreshing UI components with affected annotation IDs: {affected_annotation_ids[:5]}...")
                self._refresh_ui_components_for_tag_change(main_window, affected_annotation_ids)
                
                # ENHANCED: Refresh active tag filters if they exist (clear deleted tag from active filters)
                self._refresh_tag_filtering_after_bulk_operation(main_window, tag_to_delete_clean, None, is_rename=False)
                
                # Mark changes as pending
                print(f"DEBUG: Marking changes as pending")
                main_window.mark_changes_pending()
                
                progress.setValue(len(affected_annotations))
                print(f"DEBUG: OPTIMIZED tag deletion completed successfully - updated {len(updated_annotations)} annotations")
            elif not updated_annotations:
                print(f"DEBUG: No annotations were actually updated (this shouldn't happen)")
                
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error deleting tag: {str(e)}")
        finally:
            progress.close()
            print(f"=== _DELETE_TAG_ACROSS_SYSTEM DEBUG END ===\n")
    
    def contextMenuEvent(self, event):
        """Handle right-click context menu in empty areas of the dialog"""
        # Create context menu
        menu = QMenu(self)
        add_tag_action = menu.addAction("Add Tag")
        add_tag_action.setIcon(QIcon("Img/add-tag.png"))
        
        # Use the same styling as other context menus
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                padding: 4px 0px;
            }
            QMenu::item {
                padding: 8px 24px;
            }
            QMenu::item:selected {
                background-color: #e3f2fd;
                color: #1a73e8;
            }
        """)
        
        # Show menu and handle action
        action = menu.exec(event.globalPos())
        if action == add_tag_action:
            self.add_tag()

class ThemeChipButton(QPushButton):
    """Custom painted theme chip button with pastel yellow chip"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.has_filters = False
        
    def paintEvent(self, event):
        # Call parent paint first for button base
        super().paintEvent(event)
        
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Draw pastel yellow chip in center
        rect = self.rect()
        chip_size = 10
        chip_x = (rect.width() - chip_size) // 2 - 2  # Move left 1px more
        chip_y = (rect.height() - chip_size) // 2 + 1  # Center the chip better
        
        # Set chip color based on filter state
        if self.has_filters:
            chip_color = QColor("#FFE082")  # Brighter pastel yellow when active
        else:
            chip_color = QColor("#FFF8B3")  # Softer pastel yellow when inactive
        
        painter.setBrush(QBrush(chip_color))
        painter.setPen(QPen(QColor("#E0C547"), 1))  # Golden border
        painter.drawEllipse(chip_x, chip_y, chip_size, chip_size)
        
    def set_has_filters(self, has_filters):
        """Update filter state and repaint"""
        self.has_filters = has_filters
        self.update()  # Trigger repaint

class ClearFiltersButton(QWidget):
    """Custom painted clear filters button with hover states"""
    
    clicked = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.is_hovered = False
        self.setAttribute(Qt.WidgetAttribute.WA_Hover, True)
        
    def enterEvent(self, event):
        self.is_hovered = True
        self.update()
        super().enterEvent(event)
        
    def leaveEvent(self, event):
        self.is_hovered = False
        self.update()
        super().leaveEvent(event)
        
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.clicked.emit()
        super().mousePressEvent(event)
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Get widget rect
        rect = self.rect()
        
        # No background fill - keep container transparent
        
        # Draw the X with size effect on hover (only the X changes)
        pen_color = QColor(183, 28, 28) if self.is_hovered else QColor(211, 47, 47)
        font_size = 18 if self.is_hovered else 16  # Larger on hover for "pop" effect
        
        painter.setPen(QPen(pen_color, 3))
        painter.setFont(QFont("Arial", font_size, QFont.Weight.Bold))
        
        # Center the X in the widget
        painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, "×")


class ThemeViewSearch(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        print("\n=== ThemeViewSearch Initialized ===")
        # Initialize core attributes
        self.current_list_widget = None
        self.current_search_text = ""
        self.global_search_enabled = False  # Track global search state
        self.favorites_only = False  # Track favorites filter state
        self.hide_used = False  # Track hide used state
        self.search_confirmed = False  # New flag to track if search was confirmed with enter
        
        # Tag filtering state
        self.selected_tags = set()  # Currently selected tags for filtering
        self.strict_tag_filtering = True  # True = AND (strict), False = OR (loose)
        self.available_tags = set()  # All available tags in the system
        
        # Header filtering state
        self.selected_headers = set()  # Currently selected headers for filtering
        self.session_headers = []  # All available headers from DOM scan
        self.available_headers = set()  # All available headers in the system
        
        # Theme filtering state
        self.selected_themes = set()  # Currently selected themes for filtering
        
        # Debounce timer for search
        self.search_timer = QTimer()
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self.perform_debounced_search)
        
        # Set up the UI after initializing attributes
        self.setup_ui()
        # Set minimum height to prevent layout issues
        self.setMinimumHeight(36)  # Account for padding and borders
        
        # Initialize clear button visibility
        self._update_clear_button_visibility()

    def setup_ui(self):
        # Main layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(8, 4, 8, 4)
        layout.setSpacing(4)

        # Search bar container for proper clear button positioning
        search_container = QWidget()
        search_container.setLayout(QHBoxLayout())
        search_container.layout().setContentsMargins(0, 0, 0, 0)
        search_container.layout().setSpacing(0)
        search_container.setMinimumWidth(100)

        # Create buttons and inputs
        icon_size = QSize(16, 16)

        # Create Refresh button
        self.refresh_btn = QPushButton()
        self.refresh_btn.setFixedSize(28, 28)
        self.refresh_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.refresh_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: #f5f5f5;
                margin-right: 4px;
                padding: 2px;
            }
            QPushButton:checked {
                background: #e3f2fd;
                border-color: #2196F3;
            }
            QPushButton:hover {
                background: #eeeeee;
            }
        """)
        self.refresh_btn.setIconSize(icon_size)
        self.refresh_btn.setText("⟳")  # Start with refresh search icon

        # Create global search toggle button
        self.global_search_btn = QPushButton()
        self.global_search_btn.setCheckable(True)
        self.global_search_btn.setFixedSize(28, 28)
        self.global_search_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.global_search_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: #f5f5f5;
                margin-right: 4px;
                padding: 2px;
            }
            QPushButton:checked {
                background: #e3f2fd;
                border-color: #2196F3;
            }
            QPushButton:hover {
                background: #eeeeee;
            }
        """)
        self.global_search_btn.setIconSize(icon_size)
        self.global_search_btn.setText("🌐")  # Start with global search icon
        self.global_search_btn.setChecked(True)  # Start checked
        self.global_search_enabled = True  # Set initial state

        # Create hide used toggle button
        self.hide_used_btn = QPushButton()
        self.hide_used_btn.setCheckable(True)
        self.hide_used_btn.setFixedSize(28, 28)
        self.hide_used_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        # In ThemeViewSearch.__init__:
        self.hide_used = 0  # 0 = show all, 1 = hide used, 2 = show only used

        # In ThemeViewSearch.setup_ui(), update the button style:
        self.hide_used_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: #f5f5f5;
                margin-right: 4px;
                padding: 2px;
                padding-left: 3px;
                padding-bottom: 5px;
                font-size: 24px;
                color: #4CAF50;  /* Default gray color for empty square */
            }
            QPushButton[state="1"] {  /* Hide used - red X */
                background: rgba(244, 67, 54, 0.1);
                border: 1px solid #f44336;
                color: #f44336;  /* Red color for crossed box */
                font-size: 16px;
                padding-left: 2.5px;
                padding-top: 3px;
                padding-bottom: 4px;
            }
            QPushButton[state="2"] {  /* Show only used - green fill */
                background: rgba(76, 175, 80, 0.15);
                border: 1px solid #4CAF50;
                color: #4CAF50;  /* Green color for filled square */
                font-size: 16px;
                padding-left: 2.5px;
                padding-top: 3px;
                padding-bottom: 5px;
            }
            QPushButton:hover {
                background: #eeeeee;
            }
        """)
        self.hide_used_btn.setText("◪")
        self.hide_used_btn.setIconSize(icon_size)
        self.hide_used_btn.setToolTip("Filter Used (Showing All Used and Unused)")
        
        # Create favorites filter toggle button
        self.favorites_btn = QPushButton()
        self.favorites_btn.setCheckable(True)
        self.favorites_btn.setFixedSize(28, 28)
        self.favorites_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.favorites_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: #f5f5f5;
                margin-right: 4px;
                padding: 2px;
                padding-right: 1px;
                font-size: 14px;
                color: #FFD700;
            }
            QPushButton:checked {
                background: #fff3e0;
                border-color: #ffa726;
            }
            QPushButton:hover {
                background: #eeeeee;
            }
        """)
        self.favorites_btn.setText("★")
        self.favorites_btn.setIconSize(icon_size)
        self.favorites_btn.setToolTip("Toggle Favorites Filter (Showing All)")

        # Create Filter Tags button
        self.filter_tags_btn = QPushButton()
        self.filter_tags_btn.setFixedSize(28, 28)
        self.filter_tags_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.filter_tags_btn.setText("🏷")  # Tag emoji
        self.filter_tags_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: #f5f5f5;
                margin-right: 4px;
                padding: 2px 1px 5px 3px;
                font-size: 14px;
            }
            QPushButton:hover {
                background: #eeeeee;
            }
            QPushButton[has_filters="true"] {
                background: #e3f2fd;
                border-color: #2196F3;
            }
        """)
        self.filter_tags_btn.clicked.connect(self.show_tag_filter_dialog)
        self._update_filter_tags_button_text()

        # Create Filter Headers button
        self.filter_headers_btn = QPushButton()
        self.filter_headers_btn.setFixedSize(28, 28)
        self.filter_headers_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.filter_headers_btn.setText("𝕋")  # Double-struck T
        self.filter_headers_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: #f5f5f5;
                margin-right: 4px;
                padding: 2px 3px 3px 2px;
                font-size: 14px;
            }
            QPushButton:hover {
                background: #eeeeee;
            }
            QPushButton[has_filters="true"] {
                background: #e3f2fd;
                border-color: #2196F3;
            }
        """)
        self.filter_headers_btn.clicked.connect(self.show_header_filter_dialog)
        self._update_filter_headers_button_text()

        # Create Filter Themes button (custom painted chip)
        self.filter_themes_btn = ThemeChipButton()
        self.filter_themes_btn.setFixedSize(28, 28)
        self.filter_themes_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.filter_themes_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: #f5f5f5;
                margin-right: 4px;
                padding: 2px;
            }
            QPushButton:hover {
                background: #eeeeee;
            }
            QPushButton[has_filters="true"] {
                background: #e3f2fd;
                border-color: #2196F3;
            }
        """)
        self.filter_themes_btn.clicked.connect(self.show_theme_filter_dialog)
        self._update_filter_themes_button_text()

        # Create Clear Filters button (custom painted X)
        self.clear_filters_btn = ClearFiltersButton()
        self.clear_filters_btn.setFixedSize(20, 28)  # Reduced width for less spacing
        self.clear_filters_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.clear_filters_btn.setToolTip("Clear all filters")
        self.clear_filters_btn.clicked.connect(self.clear_all_filters)
        self.clear_filters_btn.setVisible(False)  # Initially hidden

        # Create search bar
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Type and press enter to search in current tab...")
        self.search_input.setFixedHeight(28)
        self.search_input.setMinimumWidth(150)
        self.search_input.setStyleSheet("""
            QLineEdit {
                padding: 4px 8px;
                padding-right: 24px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: #f5f5f5;
                font-size: 12px;
            }
            QLineEdit:focus {
                background: white;
                border-color: #2196F3;
            }
        """)

        # Create clear button
        self.clear_button = QPushButton("×")
        self.clear_button.setFixedSize(20, 20)
        self.clear_button.setStyleSheet("""
            QPushButton {
                background: transparent;
                color: #b04040;
                padding: 0px;
                border: none;
                font-size: 18px;
                font-weight: bold;
                margin-right: 4px;
                margin-bottom: 6px;
            }
            QPushButton:hover {
                color: #666;
            }
        """)
        self.clear_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.clear_button.clicked.connect(self.clear_search)
        self.clear_button.hide()  # Initially hidden

        # Setup tooltips and connect signals
        self.update_global_search_tooltip()
        self.global_search_btn.clicked.connect(self.toggle_global_search)
        self.refresh_btn.clicked.connect(self.refresh_theme_view_button)
        self.favorites_btn.clicked.connect(self.toggle_favorites)
        self.hide_used_btn.clicked.connect(self.toggle_hide_used)

        # Add widgets to layout
        #layout.addWidget(self.refresh_btn)
        layout.addWidget(self.global_search_btn)
        layout.addWidget(self.hide_used_btn)
        layout.addWidget(self.favorites_btn)
        search_container.layout().addWidget(self.search_input)
        layout.addWidget(self.filter_tags_btn)
        layout.addWidget(self.filter_headers_btn)
        layout.addWidget(self.filter_themes_btn)
        layout.addWidget(self.clear_filters_btn)
        # Set up context menu for search input
        self.search_input.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.search_input.customContextMenuRequested.connect(self.show_search_context_menu)
        layout.addWidget(search_container)

        # Set up clear button as overlay
        clear_container = QWidget(self.search_input)
        clear_container.setFixedSize(20, 20)
        clear_layout = QVBoxLayout(clear_container)
        clear_layout.setContentsMargins(0, 0, 0, 0)
        clear_layout.addWidget(self.clear_button, 0, Qt.AlignmentFlag.AlignCenter)
        
        # Position the clear button
        clear_container.move(
            self.search_input.width() - clear_container.width() - 4,
            (self.search_input.height() - clear_container.height()) // 2
        )

        # Connect search signals
        self.search_input.returnPressed.connect(self.force_search)
        self.search_input.textChanged.connect(self.on_text_changed)

    def add_sort_chronologically_button(self):
        """Add a 'Sort Chronologically' button to the search toolbar as the first button."""
    
        # Create the sort button with styling consistent with other buttons
        self.sort_btn = QPushButton()
        self.sort_btn.setFixedSize(28, 28)
        self.sort_btn.setCursor(Qt.CursorShape.PointingHandCursor)
    
        # Get the application's directory path and look for images in the img folder
        import os
        app_dir = os.path.dirname(os.path.abspath(__file__))
        # Look for img folder in the root directory
        root_dir = os.path.dirname(app_dir)  # Go up one level to the root
        img_dir = os.path.join(root_dir, "img")
    
        # Try different possible locations for the images
        possible_paths = [
            # Primary location in img folder
            os.path.join(img_dir, "numerical-sorting-12_hires.png"),
            os.path.join(img_dir, "numerical-sorting-12_hires_hover.png"),
        
            # Alternative - direct in root directory
            os.path.join(root_dir, "numerical-sorting-12_hires.png"),
            os.path.join(root_dir, "numerical-sorting-12_hires_hover.png"),
        
            # Alternative - in the current directory
            os.path.join(app_dir, "numerical-sorting-12_hires.png"),
            os.path.join(app_dir, "numerical-sorting-12_hires_hover.png"),
        
            # Alternative - in 'img' subdirectory of current directory
            os.path.join(app_dir, "img", "numerical-sorting-12_hires.png"),
            os.path.join(app_dir, "img", "numerical-sorting-12_hires_hover.png"),
        
            # Hardcoded full path - edit these if needed
            r"I:\Programs\Program Backend\Video Transcript Manager - backend\img\numerical-sorting-12_hires.png",
            r"I:\Programs\Program Backend\Video Transcript Manager - backend\img\numerical-sorting-12_hires_hover.png"
        ]
    
        # Find the first existing normal and hover icon paths
        normal_icon_path = None
        hover_icon_path = None
    
        for path in possible_paths:
            if os.path.isfile(path):
                if "hover" in path and not hover_icon_path:
                    hover_icon_path = path
                elif "hover" not in path and not normal_icon_path:
                    normal_icon_path = path
    
        # Fallback to img dir paths for reporting
        if not normal_icon_path:
            normal_icon_path = os.path.join(img_dir, "numerical-sorting-12_hires.png")
        if not hover_icon_path:
            hover_icon_path = os.path.join(img_dir, "numerical-sorting-12_hires_hover.png")
    
        # Check if image files exist
        normal_icon_exists = os.path.isfile(normal_icon_path)
        hover_icon_exists = os.path.isfile(hover_icon_path)
    
        # Log image path status for debugging
        print(f"\n=== Sort Button Images ===")
        print(f"Application directory: {app_dir}")
        print(f"Root directory: {root_dir}")
        print(f"Image directory: {img_dir}")
        print(f"Image directory exists: {os.path.exists(img_dir)}")
    
        # Check for normal icon
        normal_icon_exists = normal_icon_path and os.path.isfile(normal_icon_path)
        print(f"Looking for normal icon at: {normal_icon_path}")
        print(f"Normal icon exists: {normal_icon_exists}")
    
        # Check for hover icon
        hover_icon_exists = hover_icon_path and os.path.isfile(hover_icon_path)
        print(f"Looking for hover icon at: {hover_icon_path}")
        print(f"Hover icon exists: {hover_icon_exists}")
    
        # If image directory exists but icons not found, list contents
        if os.path.exists(img_dir) and not (normal_icon_exists and hover_icon_exists):
            print(f"\nListing contents of {img_dir}:")
            for file in os.listdir(img_dir):
                print(f"  - {file}")
    
        # Fall back to text if images don't exist
        if not normal_icon_exists:
            # Fallback to text-based button
            self.sort_btn.setText("⇅")
            print("Using text fallback for sort button: ⇅")
        
            self.sort_btn.setStyleSheet("""
                QPushButton {
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    background: #f5f5f5;
                    margin-right: 4px;
                    padding: 2px;
                    font-size: 14px;
                }
                QPushButton:hover {
                    background: #eeeeee;
                }
                QPushButton:pressed {
                    background: #e3f2fd;
                    border-color: #2196F3;
                }
                QPushButton:disabled {
                    background: #f0f0f0;
                    border: 1px solid #e0e0e0;
                    color: #aaa;
                }
            """)
        else:
            # Style for icon-based button
            self.sort_btn.setStyleSheet("""
                QPushButton {
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    background: #f5f5f5;
                    margin-right: 4px;
                    padding: 4px;
                }
                QPushButton:hover {
                    background: #eeeeee;
                }
                QPushButton:pressed {
                    background: #e3f2fd;
                    border-color: #2196F3;
                }
                QPushButton:disabled {
                    background: #f0f0f0;
                    border: 1px solid #e0e0e0;
                    opacity: 0.7;
                }
            """)
        
            # Set up the icon with the image
            normal_icon = QIcon(normal_icon_path)
            self.sort_btn.setIcon(normal_icon)
            self.sort_btn.setIconSize(QSize(16, 16))
        
            # Set up icon hover state if hover image exists
            if hover_icon_exists:
                hover_icon = QIcon(hover_icon_path)
            
                class IconHoverHandler(QObject):
                    def __init__(self, parent, normal_icon, hover_icon):
                        super().__init__(parent)
                        self.normal_icon = normal_icon
                        self.hover_icon = hover_icon
                
                    def eventFilter(self, obj, event):
                        if event.type() == QEvent.Type.Enter:
                            obj.setIcon(self.hover_icon)
                            return True
                        elif event.type() == QEvent.Type.Leave:
                            obj.setIcon(self.normal_icon)
                            return True
                        return False
            
                # Install the event filter to handle hover
                hover_handler = IconHoverHandler(self.sort_btn, normal_icon, hover_icon)
                self.sort_btn.installEventFilter(hover_handler)
                self.sort_btn._hover_handler = hover_handler  # Keep reference to prevent garbage collection
    
        self.sort_btn.setToolTip("Sort Annotations Chronologically")

        # Connect the button to sort function
        self.sort_btn.clicked.connect(self.sort_annotations_chronologically)

        # Insert the button at the beginning of the layout (first from the left)
        layout = self.layout()
        layout.insertWidget(0, self.sort_btn)

        # Check initial state of filters
        self.update_sort_button_state()

        # Connect signals to update button state
        self.search_input.textChanged.connect(self.update_sort_button_state)
        self.favorites_btn.clicked.connect(self.update_sort_button_state)
        self.hide_used_btn.clicked.connect(self.update_sort_button_state)

    # Add this new method to the ThemeViewSearch class
    def update_sort_button_state(self):
        """Update the enabled state of the sort button based on filters."""
        if not hasattr(self, 'sort_btn'):
            return
    
        # Check if any filters are active
        has_search = bool(self.current_search_text)
        favorites_filtered = self.favorites_only
        hide_used_filtered = self.hide_used != 0  # 0 = show all, 1 = hide used, 2 = show only used
        has_tag_filters = bool(self.selected_tags)  # Tag filters active
        has_header_filters = bool(self.selected_headers)  # Header filters active
    
        # Disable sort button if ANY filters are active (including tag and header filters)
        if has_search or favorites_filtered or hide_used_filtered or has_tag_filters or has_header_filters:
            self.sort_btn.setEnabled(False)
            self.sort_btn.setToolTip("Sorting disabled because search/filters are active.")
        else:
            self.sort_btn.setEnabled(True)
            self.sort_btn.setToolTip("Sort Annotations Chronologically")


    def sort_annotations_chronologically(self):
        """Sort annotations based on their order in the document."""
        
        # Get the main window and scene tabs
        main_window = self.window()
        if not isinstance(main_window, ScriptoriaMain):
            return
            
        # Show choice dialog for sort scope
        self._show_sort_scope_dialog()
    
    def _show_sort_scope_dialog(self):
        """Show dialog to choose between sorting current tab or all tabs."""
        main_window = self.window()
        
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QLabel
        from PyQt6.QtCore import Qt
        
        dialog = QDialog(main_window)
        dialog.setWindowTitle("Sort Scope")
        dialog.setModal(True)
        dialog.setFixedSize(300, 150)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        
        # Title label
        title_label = QLabel("Choose sorting scope:")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title_label)
        
        # Button layout
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        
        # Current tab button
        current_tab_btn = QPushButton("Sort Current Tab")
        current_tab_btn.setStyleSheet("""
            QPushButton {
                background-color: #4a90e2;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #357abd;
            }
        """)
        current_tab_btn.clicked.connect(lambda: self._handle_sort_choice(dialog, "current"))
        
        # All tabs button
        all_tabs_btn = QPushButton("Sort All Tabs")
        all_tabs_btn.setStyleSheet("""
            QPushButton {
                background-color: #5cb85c;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #449d44;
            }
        """)
        all_tabs_btn.clicked.connect(lambda: self._handle_sort_choice(dialog, "all"))
        
        button_layout.addWidget(current_tab_btn)
        button_layout.addWidget(all_tabs_btn)
        layout.addLayout(button_layout)
        
        dialog.exec()
    
    def _handle_sort_choice(self, dialog, choice):
        """Handle the sort choice selection."""
        dialog.accept()
        
        if choice == "current":
            self._sort_current_tab()
        elif choice == "all":
            self._sort_all_tabs()
    
    def _sort_current_tab(self):
        """Sort annotations in the current tab based on their order in the document."""
        
        # Get the main window and scene tabs
        main_window = self.window()
        if not isinstance(main_window, ScriptoriaMain):
            return
    
        # Get the current tab and ensure it's an AnnotationListWidget
        scene_tabs = main_window.scene_tabs
        current_index = scene_tabs.currentIndex()
        if current_index < 0:
            main_window.status_bar.showMessage("No tab selected to sort", 3000)
            return
    
        list_widget = scene_tabs.widget(current_index)
        if not isinstance(list_widget, AnnotationListWidget):
            main_window.status_bar.showMessage("Current tab cannot be sorted", 3000)
            return
    
        # Get the current scene from the tab
        current_scene = scene_tabs.tabText(current_index)
        print(f"\n=== SORTING ANNOTATIONS FOR SCENE: {current_scene} ===")
    
        # Show progress dialog for better UX
        from PyQt6.QtWidgets import QProgressDialog
        progress = QProgressDialog("Sorting annotations chronologically...", None, 0, 3, main_window)
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setAutoClose(True)
        progress.setAutoReset(False)
        progress.setValue(0)
        progress.show()
        QApplication.processEvents()
        
        # Show loading state on button as well
        original_text = self.sort_btn.text()
        self.sort_btn.setText("⏳")
        self.sort_btn.setDisabled(True)
    
        # Get all annotation IDs for this scene
        scene_annotation_ids = []
        annotation_texts = {}  # For debugging
    
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item and not item.isHidden():
                anno_id = item.data(Qt.ItemDataRole.UserRole)
                if anno_id:
                    scene_annotation_ids.append(anno_id)
                
                    # Get the text for debugging
                    widget = list_widget.itemWidget(item)
                    if widget:
                        label = widget.findChild(QLabel)
                        if label:
                            annotation_texts[anno_id] = label.text()
    
        print(f"Found {len(scene_annotation_ids)} annotations to sort")
        print(f"Reassigning Script Editor Entry: {scene_annotation_ids}")
    
        # Optimized JavaScript with reduced DOM queries and minimal logging
        js_code = '''
        (function() {
            var annotationIds = %s;
            var targetIds = new Set(annotationIds);  // Use Set for O(1) lookup
            
            // Optimized single query with CSS selector
            var spans = document.querySelectorAll('span[data-annotation-id]');
            
            if (spans.length === 0) {
                return {
                    sortedIds: [],
                    positionDetails: [],
                    totalSpans: 0,
                    matchedCount: 0,
                    error: "No annotation spans found in document"
                };
            }

            var spanPositions = [];
            var processedIds = new Set();
            var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            // Single pass through spans with optimized processing
            for (var i = 0; i < spans.length; i++) {
                var span = spans[i];
                var id = span.getAttribute('data-annotation-id');
                
                // Skip if not in target set or already processed
                if (!targetIds.has(id) || processedIds.has(id)) continue;
                
                try {
                    var rect = span.getBoundingClientRect();
                    
                    // Skip invalid positions more efficiently
                    if (!rect || (rect.width === 0 && rect.height === 0)) continue;
                    
                    spanPositions.push({
                        id: id,
                        position: rect.top + scrollTop
                    });
                    
                    processedIds.add(id);
                    
                    // Early exit if we found all target annotations
                    if (processedIds.size === annotationIds.length) break;
                    
                } catch (e) {
                    // Silent error handling for performance
                    continue;
                }
            }

            if (spanPositions.length === 0) {
                return {
                    sortedIds: [],
                    positionDetails: [],
                    totalSpans: spans.length,
                    matchedCount: 0,
                    error: "No matching spans found"
                };
            }

            // Sort by position (top to bottom)
            spanPositions.sort(function(a, b) {
                return a.position - b.position;
            });

            return {
                sortedIds: spanPositions.map(function(span) { return span.id; }),
                positionDetails: spanPositions,
                totalSpans: spans.length,
                matchedCount: spanPositions.length
            };
        })();
        ''' % json.dumps(scene_annotation_ids)
    
        def handle_position_results(result):
            try:
                progress.setValue(1)
                progress.setLabelText("Processing annotation positions...")
                QApplication.processEvents()
                
                print("\n=== RECEIVED POSITION RESULTS ===")
            
                if not result:
                    print("No result received from JavaScript")
                    main_window.status_bar.showMessage("Could not determine annotation positions", 3000)
                    progress.close()
                    self.sort_btn.setText(original_text)
                    self.sort_btn.setEnabled(True)
                    return
            
                print(f"JavaScript found {result.get('totalSpans', 0)} total spans")
                print(f"Matched {result.get('matchedCount', 0)} annotations")
            
                if not result.get('sortedIds'):
                    print("No sorted IDs in result")
                    main_window.status_bar.showMessage("Could not determine annotation positions", 3000)
                    progress.close()
                    self.sort_btn.setText(original_text)
                    self.sort_btn.setEnabled(True)
                    return
            
                sorted_ids = result.get('sortedIds', [])
                position_details = result.get('positionDetails', [])
            
                print(f"Original order: {scene_annotation_ids}")
                print(f"Sorted order: {sorted_ids}")
            
                # Check if order has actually changed
                if scene_annotation_ids == sorted_ids:
                    print("Order is already correct, no changes needed")
                    main_window.status_bar.showMessage("Annotations already in chronological order", 3000)
                    progress.close()
                    self.sort_btn.setText(original_text)
                    self.sort_btn.setEnabled(True)
                    return
            
                # Print detailed position info
                print("\nDetailed position information:")
                for detail in position_details:
                    print(f"ID: {detail['id']}, Position: {detail['position']}")
            
                # First get all annotations for this scene
                scene_annotations = []
                used_ids = set()
            
                # Create a map of annotations for quick lookup
                annotation_map = {anno.get('id'): anno for anno in main_window.web_view.annotations 
                                 if anno.get('scene') == current_scene}
            
                print(f"\nFound {len(annotation_map)} annotations in the map")
            
                # Get the scene annotations in the sorted order
                for anno_id in sorted_ids:
                    if anno_id in annotation_map and anno_id not in used_ids:
                        scene_annotations.append(annotation_map[anno_id])
                        used_ids.add(anno_id)
                        print(f"Added sorted annotation ID={anno_id}")
            
                # Find any remaining annotations for this scene not in the sorted list
                for anno_id, anno in annotation_map.items():
                    if anno_id not in used_ids:
                        scene_annotations.append(anno)
                        used_ids.add(anno_id)
                        print(f"Added remaining annotation ID={anno_id}")
            
                print(f"\nReorganized {len(scene_annotations)} annotations")
            
                # Create a new list with non-scene annotations first
                new_annotations = []
                for anno in main_window.web_view.annotations:
                    if anno.get('scene') != current_scene:
                        new_annotations.append(anno)
            
                # Then add scene annotations in the sorted order
                new_annotations.extend(scene_annotations)
            
                print(f"Final annotations list has {len(new_annotations)} items")
                print(f"Original had {len(main_window.web_view.annotations)} items")
            
                if len(new_annotations) != len(main_window.web_view.annotations):
                    print("WARNING: Annotation count mismatch!")
                    main_window.status_bar.showMessage("Error sorting: Annotation count mismatch", 3000)
                    progress.close()
                    self.sort_btn.setText(original_text)
                    self.sort_btn.setEnabled(True)
                    return
                    
                progress.setValue(2)
                progress.setLabelText("Updating theme view...")
                QApplication.processEvents()
            
                # Save current selections and scroll positions before updating
                current_scroll = list_widget.verticalScrollBar().value()
                selected_ids = [item.data(Qt.ItemDataRole.UserRole) for item in list_widget.selectedItems()]
            
                # Update the annotations in the main_window and mark changes pending
                main_window.web_view.annotations = new_annotations
                main_window.mark_changes_pending()
            
                # Force a redraw of the webview to ensure changes are visible
                main_window.web_view.handle_content_change()
            
                print("\nUpdating theme view...")
            
                # Use the existing update_theme_view function to rebuild the tabs
                main_window.update_theme_view()
            
                def restore_state():
                    progress.setValue(3)
                    progress.setLabelText("Finalizing...")
                    QApplication.processEvents()
                    
                    # Find the tab index again as it might have changed
                    for i in range(scene_tabs.count()):
                        if scene_tabs.tabText(i) == current_scene:
                            scene_tabs.setCurrentIndex(i)
                            tab_widget = scene_tabs.widget(i)
                            if isinstance(tab_widget, AnnotationListWidget):
                                # Restore selections
                                for j in range(tab_widget.count()):
                                    item = tab_widget.item(j)
                                    if item and item.data(Qt.ItemDataRole.UserRole) in selected_ids:
                                        item.setSelected(True)
                            
                                # Restore scroll position
                                tab_widget.verticalScrollBar().setValue(current_scroll)
                            break
                
                    # Close progress dialog
                    progress.close()
                    
                    # Show success message
                    main_window.status_bar.showMessage(f"Annotations sorted chronologically for '{current_scene}'", 3000)
                
                    # Restore button state
                    self.sort_btn.setText(original_text)
                    self.sort_btn.setEnabled(True)
                
                    print("=== SORTING COMPLETE ===\n")
            
                # Delay state restoration to ensure update_theme_view has completed
                QTimer.singleShot(500, restore_state)
            
            except Exception as e:
                # Ensure progress dialog is closed on error
                progress.close()
                import traceback
                print(f"Error sorting annotations: {e}")
                print(traceback.format_exc())
                main_window.status_bar.showMessage(f"Error sorting: {str(e)}", 3000)
                self.sort_btn.setText(original_text)
                self.sort_btn.setEnabled(True)
    
        # Run JavaScript to get positions, then handle the results
        main_window.web_view.page().runJavaScript(js_code, handle_position_results)

    def _sort_all_tabs(self):
        """Sort annotations in all tabs based on their order in the document."""
        
        # Get the main window and scene tabs
        main_window = self.window()
        if not isinstance(main_window, ScriptoriaMain):
            return
            
        scene_tabs = main_window.scene_tabs
        
        if scene_tabs.count() == 0:
            main_window.status_bar.showMessage("No tabs to sort", 3000)
            return
        
        # Show progress dialog for better UX
        from PyQt6.QtWidgets import QProgressDialog
        total_tabs = scene_tabs.count()
        progress = QProgressDialog("Sorting all tabs chronologically...", "Cancel", 0, total_tabs, main_window)
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setAutoClose(True)
        progress.setAutoReset(False)
        progress.setValue(0)
        progress.show()
        QApplication.processEvents()
        
        # Show loading state on button as well
        original_text = self.sort_btn.text()
        self.sort_btn.setText("⏳")
        self.sort_btn.setDisabled(True)
        
        # Store current tab to restore after sorting
        current_tab_index = scene_tabs.currentIndex()
        
        # Track which tabs we've processed
        processed_tabs = 0
        tabs_to_process = []
        
        # Collect all valid tabs first
        for i in range(total_tabs):
            list_widget = scene_tabs.widget(i)
            if isinstance(list_widget, AnnotationListWidget):
                scene_name = scene_tabs.tabText(i)
                tabs_to_process.append((i, scene_name, list_widget))
        
        if not tabs_to_process:
            progress.close()
            self.sort_btn.setText(original_text)
            self.sort_btn.setEnabled(True)
            main_window.status_bar.showMessage("No sortable tabs found", 3000)
            return
        
        # Function to process the next tab
        def process_next_tab():
            nonlocal processed_tabs
            
            if progress.wasCanceled() or processed_tabs >= len(tabs_to_process):
                # All tabs processed or cancelled
                progress.close()
                self.sort_btn.setText(original_text)
                self.sort_btn.setEnabled(True)
                
                # If we processed any tabs, refresh the theme view
                if processed_tabs > 0 and not progress.wasCanceled():
                    # Force a redraw of the webview to ensure changes are visible
                    main_window.web_view.handle_content_change()
                    
                    # Update the theme view with progress overlay since we're processing multiple tabs
                    main_window.update_theme_view(show_progress=True)
                    
                    # Restore original tab after a delay to allow the update to complete
                    def restore_original_tab():
                        if current_tab_index >= 0 and current_tab_index < scene_tabs.count():
                            scene_tabs.setCurrentIndex(current_tab_index)
                        main_window.status_bar.showMessage(f"Sorted {processed_tabs} tabs chronologically", 3000)
                    
                    QTimer.singleShot(500, restore_original_tab)
                else:
                    # Restore original tab immediately if cancelled or no tabs processed
                    if current_tab_index >= 0 and current_tab_index < scene_tabs.count():
                        scene_tabs.setCurrentIndex(current_tab_index)
                    
                    if processed_tabs > 0:
                        main_window.status_bar.showMessage(f"Sorted {processed_tabs} tabs chronologically", 3000)
                    else:
                        main_window.status_bar.showMessage("Sorting cancelled", 3000)
                return
            
            # Get the current tab to process
            tab_index, scene_name, list_widget = tabs_to_process[processed_tabs]
            
            # Update progress
            progress.setValue(processed_tabs)
            progress.setLabelText(f"Sorting '{scene_name}' ({processed_tabs + 1}/{len(tabs_to_process)})")
            QApplication.processEvents()
            
            # Check if cancelled
            if progress.wasCanceled():
                progress.close()
                self.sort_btn.setText(original_text)
                self.sort_btn.setEnabled(True)
                main_window.status_bar.showMessage("Sorting cancelled", 3000)
                return
            
            # Set the current tab for processing
            scene_tabs.setCurrentIndex(tab_index)
            QApplication.processEvents()
            
            # Get all annotation IDs for this scene
            scene_annotation_ids = []
            for j in range(list_widget.count()):
                item = list_widget.item(j)
                if item and not item.isHidden():
                    anno_id = item.data(Qt.ItemDataRole.UserRole)
                    if anno_id:
                        scene_annotation_ids.append(anno_id)
            
            if not scene_annotation_ids:
                # No annotations in this tab, move to next
                processed_tabs += 1
                QTimer.singleShot(10, process_next_tab)
                return
            
            print(f"\n=== SORTING ALL TABS: Processing {scene_name} ({len(scene_annotation_ids)} annotations) ===")
            
            # JavaScript to get positions for this scene's annotations
            js_code = '''
            (function() {
                var annotationIds = %s;
                var targetIds = new Set(annotationIds);
                
                var spans = document.querySelectorAll('span[data-annotation-id]');
                
                if (spans.length === 0) {
                    return {
                        sortedIds: [],
                        positionDetails: [],
                        totalSpans: 0,
                        matchedCount: 0,
                        error: "No annotation spans found in document"
                    };
                }

                var spanPositions = [];
                var processedIds = new Set();
                var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

                for (var i = 0; i < spans.length; i++) {
                    var span = spans[i];
                    var id = span.getAttribute('data-annotation-id');
                    
                    if (!targetIds.has(id) || processedIds.has(id)) continue;
                    
                    try {
                        var rect = span.getBoundingClientRect();
                        
                        if (!rect || (rect.width === 0 && rect.height === 0)) continue;
                        
                        spanPositions.push({
                            id: id,
                            position: rect.top + scrollTop
                        });
                        
                        processedIds.add(id);
                        
                        if (processedIds.size === annotationIds.length) break;
                        
                    } catch (e) {
                        continue;
                    }
                }

                if (spanPositions.length === 0) {
                    return {
                        sortedIds: [],
                        positionDetails: [],
                        totalSpans: spans.length,
                        matchedCount: 0,
                        error: "No matching spans found"
                    };
                }

                spanPositions.sort(function(a, b) {
                    return a.position - b.position;
                });

                return {
                    sortedIds: spanPositions.map(function(span) { return span.id; }),
                    positionDetails: spanPositions,
                    totalSpans: spans.length,
                    matchedCount: spanPositions.length
                };
            })();
            ''' % json.dumps(scene_annotation_ids)
            
            def handle_tab_results(result):
                nonlocal processed_tabs
                
                try:
                    if progress.wasCanceled():
                        return
                    
                    if not result or not result.get('sortedIds'):
                        print(f"No results for {scene_name}, skipping...")
                        processed_tabs += 1
                        QTimer.singleShot(10, process_next_tab)
                        return
                    
                    sorted_ids = result.get('sortedIds', [])
                    
                    # Check if order has actually changed
                    if scene_annotation_ids == sorted_ids:
                        print(f"Order already correct for {scene_name}")
                        processed_tabs += 1
                        QTimer.singleShot(10, process_next_tab)
                        return
                    
                    print(f"Reordering {scene_name}: {len(sorted_ids)} annotations")
                    
                    # Get scene annotations in sorted order
                    scene_annotations = []
                    used_ids = set()
                    
                    annotation_map = {anno.get('id'): anno for anno in main_window.web_view.annotations 
                                     if anno.get('scene') == scene_name}
                    
                    # Add annotations in sorted order
                    for anno_id in sorted_ids:
                        if anno_id in annotation_map and anno_id not in used_ids:
                            scene_annotations.append(annotation_map[anno_id])
                            used_ids.add(anno_id)
                    
                    # Add any remaining annotations for this scene
                    for anno_id, anno in annotation_map.items():
                        if anno_id not in used_ids:
                            scene_annotations.append(anno)
                            used_ids.add(anno_id)
                    
                    # Update the full annotation list
                    new_annotations = []
                    for anno in main_window.web_view.annotations:
                        if anno.get('scene') != scene_name:
                            new_annotations.append(anno)
                    
                    new_annotations.extend(scene_annotations)
                    
                    # Update annotations
                    main_window.web_view.annotations = new_annotations
                    main_window.mark_changes_pending()
                    
                    processed_tabs += 1
                    QTimer.singleShot(10, process_next_tab)
                    
                except Exception as e:
                    print(f"Error processing {scene_name}: {e}")
                    processed_tabs += 1
                    QTimer.singleShot(10, process_next_tab)
            
            # Run JavaScript for this tab
            main_window.web_view.page().runJavaScript(js_code, handle_tab_results)
        
        # Start processing the first tab after a short delay
        QTimer.singleShot(100, process_next_tab)

    def toggle_hide_used(self):
        """Toggle between three states: show all -> hide used -> show only used"""
        current_state = getattr(self, 'hide_used', 0)
        self.hide_used = (current_state + 1) % 3  # Cycle through 0, 1, 2

        # Update button appearance and tooltip
        if self.hide_used == 0:  # Show all
            self.hide_used_btn.setChecked(False)
            self.hide_used_btn.setProperty('state', 0)
            self.hide_used_btn.setText("◪")  # Empty square box
            self.hide_used_btn.setToolTip("Filter Used (Showing All Used and Unused)")
        elif self.hide_used == 1:  # Hide used
            self.hide_used_btn.setChecked(True)
            self.hide_used_btn.setProperty('state', 1)
            self.hide_used_btn.setText("☐")  # Crossed square box
            self.hide_used_btn.setToolTip("Filter Used (Showing Unused)")
        else:  # Show only used
            self.hide_used_btn.setChecked(True)
            self.hide_used_btn.setProperty('state', 2)
            self.hide_used_btn.setText("■")  # Filled square
            self.hide_used_btn.setToolTip("Filter Used (Showing Used)")

        self.hide_used_btn.style().unpolish(self.hide_used_btn)
        self.hide_used_btn.style().polish(self.hide_used_btn)

        # Update the view
        self.window().update_theme_view()

    # Add this new method to the ThemeViewSearch class:
    def show_search_context_menu(self, pos):
        """Show custom context menu with available tags"""
        menu = QMenu(self)
    
        # Set menu styling with improved appearance
        menu.setStyleSheet("""
            QMenu {
                background-color: white;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 8px 24px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #e3f2fd;
                color: #2C4952;
            }
            QMenu::separator {
                height: 1px;
                background: #e0e0e0;
                margin: 4px 0;
            }
        """)
    
        # Create a header widget for the title
        header_action = QWidgetAction(menu)
        header_widget = QWidget(menu)
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(8, 4, 8, 4)
    
        header_label = QLabel("Search Tags")
        header_label.setStyleSheet("""
            font-weight: bold;
            color: #2C4952;
            padding: 4px 16px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #e0e0e0;
        """)
        header_layout.addWidget(header_label)
    
        header_action.setDefaultWidget(header_widget)
        menu.addAction(header_action)
    
        # Add search bar widget
        search_action = QWidgetAction(menu)
        search_widget = QWidget(menu)
        search_layout = QVBoxLayout(search_widget)
        search_layout.setContentsMargins(8, 4, 8, 4)
        
        # Create search input
        tag_search = QLineEdit()
        tag_search.setPlaceholderText("Search tags...")
        tag_search.setFixedHeight(24)
        tag_search.setStyleSheet("""
            QLineEdit {
                padding: 4px 8px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: white;
                font-size: 11px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
        """)
        search_layout.addWidget(tag_search)
        
        search_action.setDefaultWidget(search_widget)
        menu.addAction(search_action)
        
        # Add separator after search bar
        menu.addSeparator()
        
        # Store tag actions for filtering
        tag_actions = []
    
        # Get tags from main window
        main_window = self.window()
        if hasattr(main_window, 'tags') and main_window.tags:
            # Add each tag as a menu item
            for tag in main_window.tags:
                action = menu.addAction(tag)
                action.triggered.connect(lambda checked, t=tag: self.insert_tag(t))
                tag_actions.append(action)
        else:
            # Show placeholder if no tags
            placeholder = menu.addAction("No tags available")
            placeholder.setEnabled(False)
            tag_actions.append(placeholder)
            
        # Connect search functionality
        def filter_tags(search_text):
            search_text = search_text.lower()
            visible_count = 0
            for action in tag_actions:
                tag_text = action.text().lower()
                if not search_text or search_text in tag_text:
                    action.setVisible(True)
                    visible_count += 1
                else:
                    action.setVisible(False)
            
            # Show/hide "no results" message
            if visible_count == 0 and search_text:
                if not hasattr(menu, '_no_results_action'):
                    menu._no_results_action = menu.addAction("No matching tags")
                    menu._no_results_action.setEnabled(False)
                menu._no_results_action.setVisible(True)
            elif hasattr(menu, '_no_results_action'):
                menu._no_results_action.setVisible(False)
                
        tag_search.textChanged.connect(filter_tags)
        
        # Add keyboard support for quick insertion
        def on_search_return():
            # Find first visible tag and insert it
            for action in tag_actions:
                if action.isVisible() and action.isEnabled():
                    tag_text = action.text()
                    if tag_text != "No tags available" and tag_text != "No matching tags":
                        self.insert_tag(tag_text)
                        menu.close()
                        return
                        
        tag_search.returnPressed.connect(on_search_return)
    
        # Always add separator and "Create new tag..." option
        menu.addSeparator()
        add_tag_action = menu.addAction("Create new tag...")
        add_tag_action.triggered.connect(lambda: self.open_tag_list_dialog())
    
        # Show the menu at cursor position and focus the search bar
        menu.exec(self.search_input.mapToGlobal(pos))
        # Focus the search input after menu is shown
        QTimer.singleShot(10, tag_search.setFocus)

    def open_tag_list_dialog(self):
        """Open the TagListDialog to manage tags"""
        main_window = self.window()
        if isinstance(main_window, ScriptoriaMain):
            # Get existing tags
            tags = main_window.tags if hasattr(main_window, 'tags') else []
        
            # Create and show the dialog
            dialog = TagListDialog(main_window, tags)
        
            # Connect the tagsChanged signal
            def on_tags_changed():
                # Update main window tags
                main_window.tags = dialog.get_tags()
                main_window.mark_changes_pending()
            
                # If the search input is empty, insert the first tag
                if self.search_input.text().strip() == "" and main_window.tags:
                    self.insert_tag(main_window.tags[0])
        
            dialog.tagsChanged.connect(on_tags_changed)
            dialog.exec()

    def insert_tag(self, tag):
        """Insert the selected tag at cursor position"""
        cursor = self.search_input.cursorPosition()
        current_text = self.search_input.text()
        new_text = current_text[:cursor] + tag + current_text[cursor:]
        self.search_input.setText(new_text)
        # Move cursor after inserted tag
        self.search_input.setCursorPosition(cursor + len(tag))

    def update_global_search_icon(self):
        """Update the global search button icon based on its state"""
        if self.global_search_enabled:
            self.global_search_btn.setText("🌐")  # Global search enabled
            self.search_input.setPlaceholderText("Type and press enter to search across all tabs...")
        else:
            self.global_search_btn.setText("🌐")  # Regular search
            self.search_input.setPlaceholderText("Type and press enter to search in current tab...")

    def update_global_search_tooltip(self):
        """Update the tooltip based on current search state"""
        if self.global_search_enabled:
            self.global_search_btn.setToolTip("Currently searching all tabs (click to search current tab only)")
        else:
            self.global_search_btn.setToolTip("Currently searching current tab only (click to search all tabs)")

    def toggle_global_search(self):
        """Toggle global search mode and update UI"""
        self.global_search_enabled = self.global_search_btn.isChecked()
        self.update_global_search_icon()
        self.update_global_search_tooltip()

    def toggle_favorites(self):
        """Toggle favorites filter and update view"""
        self.favorites_only = self.favorites_btn.isChecked()
    
        # Update tooltip based on state
        if self.favorites_only:
            self.favorites_btn.setToolTip("Toggle Favorites Filter (Showing Favorites)")
        else:
            self.favorites_btn.setToolTip("Toggle Favorites Filter (Showing All)")
    
        # Update sort button state
        self.update_sort_button_state()
        
        
        # Update clear button visibility
        self._update_clear_button_visibility()
    
        # Apply filter directly without expensive rebuild
        self.apply_current_filters()

    # Update the toggle_hide_used method to call update_sort_button_state

    def toggle_hide_used(self):
        """Toggle between three states: show all -> hide used -> show only used"""
        current_state = getattr(self, 'hide_used', 0)
        self.hide_used = (current_state + 1) % 3  # Cycle through 0, 1, 2

        # Update button appearance and tooltip
        if self.hide_used == 0:  # Show all
            self.hide_used_btn.setChecked(False)
            self.hide_used_btn.setProperty('state', 0)
            self.hide_used_btn.setText("◪")  # Empty square box
            self.hide_used_btn.setToolTip("Filter Used (Showing All)")
        elif self.hide_used == 1:  # Hide used
            self.hide_used_btn.setChecked(True)
            self.hide_used_btn.setProperty('state', 1)
            self.hide_used_btn.setText("☐")  # Crossed square box
            self.hide_used_btn.setToolTip("Filter Used (Showing Unused)")
        else:  # Show only used
            self.hide_used_btn.setChecked(True)
            self.hide_used_btn.setProperty('state', 2)
            self.hide_used_btn.setText("■")  # Filled square
            self.hide_used_btn.setToolTip("Filter Used (Showing Used)")

        self.hide_used_btn.style().unpolish(self.hide_used_btn)
        self.hide_used_btn.style().polish(self.hide_used_btn)

        # Update sort button state
        self.update_sort_button_state()
        
        
        # Update clear button visibility
        self._update_clear_button_visibility()

        # Apply filter directly without expensive rebuild
        self.apply_current_filters()

    def apply_current_filters(self):
        """Apply all current filters (search, favorites, hide used) without rebuilding theme view"""
        print("\n=== Applying filters directly ===")
        scene_tabs = self.window().scene_tabs
        
        total_shown = 0
        total_hidden = 0
        
        # Process all tabs
        for i in range(scene_tabs.count()):
            list_widget = scene_tabs.widget(i)
            if isinstance(list_widget, AnnotationListWidget):
                tab_visible_count = 0
                
                # Process each item in the tab
                for j in range(list_widget.count()):
                    item = list_widget.item(j)
                    if not item:
                        continue
                    
                    should_hide = False
                    widget = list_widget.itemWidget(item)
                    
                    if widget:
                        # Apply search filter
                        if self.current_search_text and self.search_confirmed:
                            annotation_text = item.text().lower()
                            search_text_lower = self.current_search_text.lower()
                            
                            # Check for tag-only search
                            search_terms = [term.lower() for term in self.current_search_text.replace("#", " #").replace(",", " , ").split() if term]
                            tags_only = all(term.startswith("#") for term in search_terms if term != ",")
                            
                            if tags_only:
                                # Tag search logic
                                notes_label = widget.findChild(QLabel, "notes_label")
                                if notes_label:
                                    notes_text = notes_label.text().lower()
                                    search_tags = [term[1:] for term in search_terms if term.startswith("#")]
                                    comma_separated = "," in search_terms
                                    
                                    if comma_separated:
                                        # OR mode: any tag matches
                                        if not any(f"#{tag}" in notes_text for tag in search_tags):
                                            should_hide = True
                                    else:
                                        # AND mode: all tags must match
                                        if not all(f"#{tag}" in notes_text for tag in search_tags):
                                            should_hide = True
                                else:
                                    should_hide = True
                            else:
                                # Regular text search
                                if search_text_lower not in annotation_text:
                                    should_hide = True
                        
                        # Get annotation data using the ID stored on the item
                        annotation_id = item.data(Qt.ItemDataRole.UserRole)
                        main_window = self.window()
                        annotation_data = None
                        
                        # Find the annotation data
                        if annotation_id and main_window and hasattr(main_window, 'web_view'):
                            for anno in main_window.web_view.annotations:
                                if anno.get('id') == annotation_id:
                                    annotation_data = anno
                                    break
                        
                        # Evaluate all filters independently, then combine with AND logic
                        # Apply hide used filter
                        hide_used_passed = True
                        if self.hide_used != 0 and annotation_data:
                            is_used = annotation_data.get('used', False)
                            if self.hide_used == 1 and is_used:  # Hide used
                                hide_used_passed = False
                            elif self.hide_used == 2 and not is_used:  # Show only used
                                hide_used_passed = False
                        
                        # Apply favorites filter  
                        favorites_passed = True
                        if self.favorites_only and annotation_data:
                            is_favorite = annotation_data.get('favorite', False)
                            if not is_favorite:
                                favorites_passed = False
                        
                        # Apply tag filters
                        tag_filter_passed = True
                        if self.selected_tags and annotation_data:
                            annotation_tags = set(tag.lower() for tag in annotation_data.get('tags', []))
                            selected_tags_lower = set(tag.lower() for tag in self.selected_tags)
                            
                            if self.strict_tag_filtering:
                                # Strict mode: annotation must have ALL selected tags
                                tag_filter_passed = selected_tags_lower.issubset(annotation_tags)
                            else:
                                # Loose mode: annotation must have ANY selected tag
                                tag_filter_passed = bool(selected_tags_lower & annotation_tags)
                        
                        # Apply header filters
                        header_filter_passed = True
                        if self.selected_headers and annotation_data:
                            # Get the scene title from annotation (speech_title or scene_title)
                            annotation_header = annotation_data.get('speech_title', '') or annotation_data.get('scene_title', '')
                            if annotation_header:
                                # Check if annotation's header matches any selected headers
                                selected_headers_lower = set(header.lower() for header in self.selected_headers)
                                header_filter_passed = annotation_header.lower() in selected_headers_lower
                            else:
                                # If annotation has no header, fail header filter when header filters are active
                                header_filter_passed = False
                        
                        # Apply theme filters (Filter by scene and secondary_scenes)
                        theme_filter_passed = True
                        if self.selected_themes and annotation_data:
                            # Get annotation themes from both scene and secondary_scenes fields
                            annotation_themes = set()
                            
                            # Add primary scene
                            primary_scene = annotation_data.get('scene', '')
                            if primary_scene:
                                annotation_themes.add(primary_scene.lower())
                            
                            # Add secondary scenes
                            secondary_scenes = annotation_data.get('secondary_scenes', [])
                            for secondary_scene in secondary_scenes:
                                if secondary_scene:
                                    annotation_themes.add(secondary_scene.lower())
                            
                            # Convert selected themes to lowercase for comparison
                            selected_themes_lower = set(theme.lower() for theme in self.selected_themes)
                            
                            # Check if annotation has ANY of the selected themes (OR logic for themes)
                            theme_filter_passed = bool(selected_themes_lower & annotation_themes)
                        
                        # Combine ALL filter results with AND logic - ALL must pass
                        if not (hide_used_passed and favorites_passed and tag_filter_passed and header_filter_passed and theme_filter_passed):
                            should_hide = True
                    
                    # Check if item visibility is changing from hidden to visible
                    was_hidden = item.isHidden()
                    
                    # Apply visibility
                    item.setHidden(should_hide)
                    
                    # If item is now visible and was previously hidden, update its size
                    if not should_hide and was_hidden and widget:
                        print(f"[DEBUG] Item was hidden, now visible - updating size for {annotation_id}")
                        list_widget.updateItemSize(item, widget, force_full_calculation=True)
                    
                    if not should_hide:
                        tab_visible_count += 1
                        total_shown += 1
                    else:
                        total_hidden += 1
                
                # Hide/show tab based on visible items
                scene_tabs.setTabVisible(i, tab_visible_count > 0)
                if tab_visible_count == 0:
                    print(f"[DEBUG] Hiding tab {scene_tabs.tabText(i)} - no items match filters")
        
        print(f"Filters applied: {total_shown} shown, {total_hidden} hidden")
        
        # Show/hide overlay placeholder based on results
        self._update_placeholder_overlay(total_shown)
        

    def refresh_theme_view_button(self):    
        # Let update_theme_view handle the filtering (with progress since user clicked button)
        self.window().update_theme_view(show_progress=True)

    def force_search(self):
        """Force an immediate search based on current mode"""
        print("\n=== force_search called (Enter pressed) ===")
        self.search_confirmed = True  # Set confirmation flag when enter is pressed
        
        scene_tabs = self.window().scene_tabs
        
        if self.global_search_enabled:
            # Perform search across all tabs
            for i in range(scene_tabs.count()):
                current_list = scene_tabs.widget(i)
                if isinstance(current_list, AnnotationListWidget):
                    self.current_list_widget = current_list
                    self.perform_search()
        else:
            # Search only current tab
            current_index = scene_tabs.currentIndex()
            if current_index >= 0:
                current_list = scene_tabs.widget(current_index)
                if isinstance(current_list, AnnotationListWidget):
                    print(f"Forcing search on current tab: {scene_tabs.tabText(current_index)}")
                    if self.current_list_widget != current_list:
                        print("Updating list widget reference")
                        self.current_list_widget = current_list
                    self.perform_search()
                else:
                    print("Current tab widget is not an AnnotationListWidget")
            else:
                print("No valid tab selected")


    def perform_search(self):
        """Filter items in list widget(s), preserving word boundaries."""
        import re
        print("\n=== perform_search called ===")
        print(f"Current search text: '{self.current_search_text}'")
        print(f"Global search enabled: {self.global_search_enabled}")
        print(f"Favorites only: {self.favorites_only}")
        print(f"Hide used: {self.hide_used}")
        print(f"Selected tags: {self.selected_tags}")
        print(f"Strict tag filtering: {self.strict_tag_filtering}")
        print(f"Selected themes: {self.selected_themes}")

        # Get list of widgets to search
        widgets_to_search = []
        if self.global_search_enabled:
            scene_tabs = self.window().scene_tabs
            for i in range(scene_tabs.count()):
                widget = scene_tabs.widget(i)
                if isinstance(widget, AnnotationListWidget):
                    widgets_to_search.append(widget)
        else:
            if self.current_list_widget:
                widgets_to_search.append(self.current_list_widget)
            else:
                print("Error: No current list widget set")
                return

        # --- Tag-Only Search Detection ---
        search_terms = [term.lower() for term in self.current_search_text.replace("#", " #").replace(",", " , ").split() if term]
        tags_only = all(term.startswith("#") for term in search_terms if term != ",")
        comma_separated = "," in search_terms

        if tags_only:
            search_tags = [term[1:] for term in search_terms if term.startswith("#")]
            if comma_separated:
                print(f"Tag-only search (OR mode): Searching for any of the tags {search_tags}")
            else:
                print(f"Tag-only search (AND mode): Searching for all tags {search_tags}")

        # Check if tag filters are active
        tag_filters_active = bool(self.selected_tags)
        if tag_filters_active:
            print(f"Tag filters active: {list(self.selected_tags)} (Strict: {self.strict_tag_filtering})")
        
        # Check if header filters are active
        header_filters_active = bool(self.selected_headers)
        if header_filters_active:
            print(f"Header filters active: {list(self.selected_headers)}")
        
        # Check if theme filters are active
        theme_filters_active = bool(self.selected_themes)
        if theme_filters_active:
            print(f"Theme filters active: {list(self.selected_themes)}")
        
        # Show all items if search is empty and no filters are active
        if not self.current_search_text and not self.favorites_only and not self.hide_used and not tags_only and not tag_filters_active and not header_filters_active and not theme_filters_active:
            print("Empty search with no filters - showing all items")
            for list_widget in widgets_to_search:
                for i in range(list_widget.count()):
                    item = list_widget.item(i)
                    item.setHidden(False)
                    item.setData(Qt.ItemDataRole.UserRole + 1, False)  # Reset visibility flag
            return

        total_hidden = 0
        total_shown = 0

        for list_widget in widgets_to_search:
            print(f"\nSearching in tab: {self.window().scene_tabs.tabText(self.window().scene_tabs.indexOf(list_widget))}")

            for i in range(list_widget.count()):
                item = list_widget.item(i)
                widget = list_widget.itemWidget(item)
                if widget:
                    label = widget.findChild(QLabel)
                    notes_edit = widget.findChild(QLineEdit)
                    checkbox = widget.findChild(CustomCheckBox)

                    # Get the used state
                    is_used = checkbox.isChecked() if checkbox else False

                    # Skip processing if item is already hidden by favorites filter
                    if self.favorites_only and item.isHidden():
                        continue

                    # Normalize notes for both tag and regular search
                    translator = str.maketrans("", "", string.punctuation + " " + string.digits)
                    notes = notes_edit.text().translate(translator).lower() if notes_edit else ""

                    # Initialize visibility
                    should_hide = False

                    # Apply hide used filter first
                    if self.hide_used and is_used:
                        should_hide = True
                    else:
                        # Handle search text filtering
                        if tags_only:
                            # Tag search logic from search text
                            if comma_separated:
                                any_tag_found = any(tag in notes for tag in search_tags)
                                should_hide = not any_tag_found
                            else:
                                all_tags_found = all(tag in notes for tag in search_tags)
                                should_hide = not all_tags_found
                        elif self.current_search_text:
                            # Normal Search Logic (only if there's search text)
                            # Preserve spaces to maintain word boundaries
                            text = re.sub(r'[^\w\s]', ' ', label.text().lower() if label else "")
                            text = ' '.join(text.split())  # Normalize multiple spaces to single spaces
                            notes_text = re.sub(r'[^\w\s]', ' ', notes_edit.text().lower() if notes_edit else "")
                            notes_text = ' '.join(notes_text.split())
                            search_text = re.sub(r'[^\w\s]', ' ', self.current_search_text.lower())
                            search_text = ' '.join(search_text.split())
                            
                            text_matches = search_text in text
                            notes_matches = search_text in notes_text
                            should_hide = not (text_matches or notes_matches)
                        # If no search text and no tag filters yet, don't hide based on search
                        
                        # Apply favorites filter
                        if self.favorites_only and not widget.findChild(QPushButton, "").isChecked():
                            should_hide = True

                    # Apply tag filters (independent of search text) - NEW: Use separate tags field
                    tag_filter_passed = True
                    if tag_filters_active:
                        # Get annotation tags from the separate tags field
                        annotation_id = item.data(Qt.ItemDataRole.UserRole)
                        annotation_tags = set()
                        
                        # Find the annotation in the main data to get its tags
                        main_window = list_widget.window()
                        if isinstance(main_window, ScriptoriaMain) and annotation_id:
                            for anno in main_window.web_view.annotations:
                                if anno.get('id') == annotation_id:
                                    annotation_tags = set(tag.lower() for tag in anno.get('tags', []))
                                    break
                        
                        if annotation_tags:
                            print(f"[DEBUG] Checking annotation {annotation_id} with tags: {list(annotation_tags)} for filters: {list(self.selected_tags)}")
                        
                        # Convert selected tags to lowercase for comparison
                        selected_tags_lower = set(tag.lower() for tag in self.selected_tags)
                        
                        if self.strict_tag_filtering:
                            # Strict mode: annotation must have ALL selected tags
                            tag_matches = selected_tags_lower.issubset(annotation_tags)
                            if not tag_matches:
                                missing_tags = selected_tags_lower - annotation_tags
                                print(f"[DEBUG] Annotation failed tag filter - missing tags: {missing_tags}")
                                tag_filter_passed = False
                        else:
                            # Loose mode: annotation must have ANY selected tag
                            tag_matches = bool(selected_tags_lower & annotation_tags)
                            if not tag_matches:
                                print(f"[DEBUG] Annotation failed tag filter - no matching tags found")
                                tag_filter_passed = False

                    # Apply header filters (independent of other filters)
                    header_filter_passed = True
                    if header_filters_active:
                        # Get annotation header information
                        annotation_id = item.data(Qt.ItemDataRole.UserRole)
                        annotation_header = ""
                        
                        # Find the annotation in the main data to get its header
                        main_window = list_widget.window()
                        if isinstance(main_window, ScriptoriaMain) and annotation_id:
                            for anno in main_window.web_view.annotations:
                                if anno.get('id') == annotation_id:
                                    annotation_header = anno.get('speech_title', '') or anno.get('scene_title', '')
                                    break
                        
                        if annotation_header:
                            # Check if annotation's header matches any selected headers
                            selected_headers_lower = set(header.lower() for header in self.selected_headers)
                            if annotation_header.lower() not in selected_headers_lower:
                                print(f"[DEBUG] Annotation failed header filter - header '{annotation_header}' not in selected headers")
                                header_filter_passed = False
                        else:
                            # If annotation has no header, fail header filter when header filters are active
                            print(f"[DEBUG] Annotation failed header filter - no header found")
                            header_filter_passed = False

                    # Apply theme filters (independent of other filters) - Filter by scene and secondary_scenes
                    theme_filter_passed = True
                    theme_filters_active = bool(self.selected_themes)
                    if theme_filters_active:
                        # Get annotation themes from both scene and secondary_scenes fields
                        annotation_id = item.data(Qt.ItemDataRole.UserRole)
                        annotation_themes = set()
                        
                        # Find the annotation in the main data to get its themes
                        main_window = list_widget.window()
                        if isinstance(main_window, ScriptoriaMain) and annotation_id:
                            for anno in main_window.web_view.annotations:
                                if anno.get('id') == annotation_id:
                                    # Add primary scene
                                    primary_scene = anno.get('scene', '')
                                    if primary_scene:
                                        annotation_themes.add(primary_scene.lower())
                                    
                                    # Add secondary scenes
                                    secondary_scenes = anno.get('secondary_scenes', [])
                                    for secondary_scene in secondary_scenes:
                                        if secondary_scene:
                                            annotation_themes.add(secondary_scene.lower())
                                    break
                        
                        if annotation_themes:
                            print(f"[DEBUG] Checking annotation {annotation_id} with themes: {list(annotation_themes)} for theme filters: {list(self.selected_themes)}")
                        
                        # Convert selected themes to lowercase for comparison
                        selected_themes_lower = set(theme.lower() for theme in self.selected_themes)
                        
                        # Check if annotation has ANY of the selected themes (OR logic for themes)
                        theme_matches = bool(selected_themes_lower & annotation_themes)
                        if not theme_matches:
                            print(f"[DEBUG] Annotation failed theme filter - no matching themes found. Annotation themes: {list(annotation_themes)}, Selected: {list(selected_themes_lower)}")
                            theme_filter_passed = False
                    
                    # Combine ALL filter results with AND logic - ALL must pass
                    if not tag_filter_passed or not header_filter_passed or not theme_filter_passed:
                        should_hide = True

                    # Set the visibility flag on the item and actually hide/show it
                    item.setData(Qt.ItemDataRole.UserRole + 1, should_hide)
                    item.setHidden(should_hide)  # Actually apply the visibility

                    if should_hide:
                        total_hidden += 1
                    else:
                        total_shown += 1

        # Hide/show tabs based on whether they have visible items
        scene_tabs = self.window().scene_tabs
        for i in range(scene_tabs.count()):
            list_widget = scene_tabs.widget(i)
            if isinstance(list_widget, AnnotationListWidget):
                # Check if this tab has any visible items
                has_visible_items = False
                for j in range(list_widget.count()):
                    item = list_widget.item(j)
                    if item and not item.isHidden():
                        has_visible_items = True
                        break
                
                # Hide/show the tab based on whether it has visible items
                scene_tabs.setTabVisible(i, has_visible_items)
                if not has_visible_items:
                    print(f"[DEBUG] Hiding tab {scene_tabs.tabText(i)} - no visible items")
        

        # Don't do full rebuild for search operations, visibility changes are already done above
        # self.window().update_theme_view()
        print(f"\nSearch complete:")
        print(f"- Total items shown: {total_shown}")
        print(f"- Total items hidden: {total_hidden}")
        
        # Show/hide overlay placeholder based on results
        self._update_placeholder_overlay(total_shown)


    def set_list_widget(self, list_widget):
        """Set the current list widget to search within"""
        self.current_list_widget = list_widget
        # Perform search if there's a search term
        # if self.current_search_text:
        #     if self.global_search_enabled:
        #         self.force_search()  # This will search all tabs
        #     else:
        #         self.perform_search()  # This will search only the current tab

    def on_text_changed(self, text):
        """Handle search text changes with debouncing"""
        self.current_search_text = text
        self.clear_button.setVisible(bool(text))
        self.search_confirmed = False  # Reset confirmation flag when text changes
        
        # Update clear filters button visibility when search text changes
        self._update_clear_button_visibility()
    
        # Update sort button state when text changes
        self.update_sort_button_state()
        
        # Stop any existing timer
        self.search_timer.stop()
        
        # If text is empty, search immediately to apply other filters
        if not text:
            self.force_search()
        else:
            # Start debounce timer (300ms delay)
            self.search_timer.start(300)

    def perform_debounced_search(self):
        """Perform search after debounce delay"""
        if self.global_search_enabled:
            self.force_search()  # Search all tabs
        else:
            self.perform_search()  # Search only current tab

    def clear_search(self):
        """Clear the search input and reset visibility"""
        self.search_input.clear()
        self.current_search_text = ""
        self.search_confirmed = False  # Reset confirmation flag when clearing
        self.clear_button.hide()
        
        # Update clear filters button visibility when search is cleared
        self._update_clear_button_visibility()
    
        # Update sort button state
        self.update_sort_button_state()
        
    
        # Hide the placeholder overlay if it exists
        self._hide_placeholder_overlay()
        
        # Force search to apply any other active filters and handle placeholder properly
        self.force_search()

    def resizeEvent(self, event):
        """Handle resize events to keep clear button positioned correctly"""
        super().resizeEvent(event)
        self.update_clear_button_position()

    def update_clear_button_position(self):
        """Update clear button position"""
        clear_button_container = self.clear_button.parent()
        if clear_button_container and self.search_input:
            search_rect = self.search_input.rect()
            x = search_rect.right() - clear_button_container.width() - 4
            y = (search_rect.height() - clear_button_container.height()) // 2
            if clear_button_container.pos().x() != x or clear_button_container.pos().y() != y:
                clear_button_container.move(x, y) #Search bar for THEME VIEW 

    def show_tag_filter_dialog(self):
        """Show the tag filter as a dropdown menu"""
        # Collect all available tags from the current annotations
        self._collect_available_tags()
        
        # Create dropdown menu
        menu = QMenu(self)
        menu.setMinimumWidth(300)
        menu.setMaximumHeight(400)
        
        # Header
        header_action = QWidgetAction(menu)
        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(8, 4, 8, 4)
        
        header_label = QLabel("Filter by Tags")
        header_label.setStyleSheet("font-weight: bold; font-size: 12px;")
        header_layout.addWidget(header_label)
        
        # Strict/Loose toggle
        radio_layout = QHBoxLayout()
        radio_layout.setSpacing(4)
        
        strict_radio = QRadioButton("Strict")
        loose_radio = QRadioButton("Loose")
        strict_radio.setToolTip("AND mode - must have ALL selected tags")
        loose_radio.setToolTip("OR mode - must have ANY selected tag")
        strict_radio.setChecked(self.strict_tag_filtering)
        loose_radio.setChecked(not self.strict_tag_filtering)
        
        radio_layout.addWidget(strict_radio)
        radio_layout.addWidget(loose_radio)
        radio_layout.addStretch()
        header_layout.addLayout(radio_layout)
        
        header_action.setDefaultWidget(header_widget)
        menu.addAction(header_action)
        menu.addSeparator()
        
        # Search bar for tags
        search_action = QWidgetAction(menu)
        search_widget = QWidget()
        search_layout = QVBoxLayout(search_widget)
        search_layout.setContentsMargins(8, 4, 8, 4)
        
        tag_search = QLineEdit()
        tag_search.setPlaceholderText("Search tags (comma-separated)...")
        tag_search.setFixedHeight(24)
        tag_search.setStyleSheet("""
            QLineEdit {
                padding: 4px 8px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: white;
                font-size: 11px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
        """)
        search_layout.addWidget(tag_search)
        search_action.setDefaultWidget(search_widget)
        menu.addAction(search_action)
        menu.addSeparator()
        
        # Scrollable tag area
        scroll_action = QWidgetAction(menu)
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout(scroll_widget)
        scroll_layout.setContentsMargins(4, 4, 4, 4)
        scroll_layout.setSpacing(2)
        
        # Create scroll area for tags
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setMaximumHeight(250)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        
        tag_container = QWidget()
        tag_layout = QGridLayout(tag_container)
        tag_layout.setSpacing(2)
        tag_layout.setVerticalSpacing(1)
        tag_layout.setContentsMargins(4, 4, 4, 4)
        
        # Add tag checkboxes
        row, col = 0, 0
        tag_checkboxes = {}
        for tag in self.available_tags:
            display_tag = tag if len(tag) <= 20 else tag[:17] + "..."
            checkbox = QCheckBox(f"#{display_tag}")
            checkbox.setChecked(tag in self.selected_tags)
            checkbox.setStyleSheet("font-size: 11px; padding: 1px;")
            checkbox.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
            
            if len(tag) > 20:
                checkbox.setToolTip(f"#{tag}")
            
            tag_checkboxes[tag] = checkbox
            tag_layout.addWidget(checkbox, row, col)
            tag_layout.setRowStretch(row, 0)
            
            col += 1
            if col >= 3:  # 3 columns for dropdown
                col = 0
                row += 1
        
        # Add bottom stretch
        tag_layout.setRowStretch(row + 1, 1)
        
        scroll_area.setWidget(tag_container)
        scroll_layout.addWidget(scroll_area)
        scroll_action.setDefaultWidget(scroll_widget)
        menu.addAction(scroll_action)
        
        # Connect search functionality
        def filter_tags(search_text):
            search_text = search_text.strip()
            if not search_text:
                # Show all tags when search is empty
                for checkbox in tag_checkboxes.values():
                    checkbox.setVisible(True)
            else:
                # Parse comma-separated search terms
                search_terms = [term.strip().lower().replace('#', '') for term in search_text.split(',') if term.strip()]
                
                for tag, checkbox in tag_checkboxes.items():
                    tag_text = tag.lower().replace('#', '')
                    # Check if tag matches any of the search terms
                    matches = any(search_term in tag_text for search_term in search_terms)
                    checkbox.setVisible(matches)
        
        def select_filtered_tags():
            """Select all currently visible (filtered) tags and clear search"""
            search_text = tag_search.text().strip()
            if not search_text:
                return  # Do nothing if search is empty
            
            # Parse comma-separated search terms
            search_terms = [term.strip().lower().replace('#', '') for term in search_text.split(',') if term.strip()]
            
            # Select all tags that match the search terms
            for tag, checkbox in tag_checkboxes.items():
                tag_text = tag.lower().replace('#', '')
                # Check if tag matches any of the search terms
                matches = any(search_term in tag_text for search_term in search_terms)
                if matches:
                    checkbox.setChecked(True)
            
            # Clear the search field
            tag_search.clear()
            # Trigger filter update to show all tags again
            filter_tags("")
        
        # Connect search events
        tag_search.textChanged.connect(filter_tags)
        
        # Override key handling to prevent menu from closing on Enter
        def search_key_press(event):
            if event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter:
                if tag_search.text().strip():  # If there's text, select filtered tags
                    select_filtered_tags()
                else:  # If empty, apply current filters
                    apply_filters()
                event.accept()  # Always consume Enter to prevent menu closure
                return
            QLineEdit.keyPressEvent(tag_search, event)
        
        tag_search.keyPressEvent = search_key_press
        
        # Set focus to search field
        QTimer.singleShot(1, tag_search.setFocus)
        
        # Apply/Clear buttons
        menu.addSeparator()
        button_action = QWidgetAction(menu)
        button_widget = QWidget()
        button_layout = QHBoxLayout(button_widget)
        button_layout.setContentsMargins(8, 4, 8, 4)
        
        clear_btn = QPushButton("Clear All")
        apply_btn = QPushButton("Apply")
        
        clear_btn.setStyleSheet("QPushButton { font-size: 11px; padding: 4px 8px; }")
        apply_btn.setStyleSheet("QPushButton { font-size: 11px; padding: 4px 8px; }")
        
        def apply_filters():
            self.selected_tags = {tag for tag, cb in tag_checkboxes.items() if cb.isChecked()}
            self.strict_tag_filtering = strict_radio.isChecked()
            self._update_filter_tags_button_text()
            self._apply_tag_filters()
            menu.close()
        
        def clear_all():
            for cb in tag_checkboxes.values():
                cb.setChecked(False)
        
        clear_btn.clicked.connect(clear_all)
        apply_btn.clicked.connect(apply_filters)
        
        button_layout.addWidget(clear_btn)
        button_layout.addWidget(apply_btn)
        button_action.setDefaultWidget(button_widget)
        menu.addAction(button_action)
        
        # Show menu at button position
        button_rect = self.filter_tags_btn.geometry()
        menu_pos = self.filter_tags_btn.mapToGlobal(QPoint(0, button_rect.height()))
        menu.exec(menu_pos)

    def show_header_filter_dialog(self):
        """Show the header filter as a dropdown menu"""
        # Create dropdown menu
        menu = QMenu(self)
        menu.setMinimumWidth(525)
        menu.setMaximumHeight(750)
        
        # Header
        header_action = QWidgetAction(menu)
        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(8, 4, 8, 4)
        
        header_label = QLabel("Filter by Headers")
        header_label.setStyleSheet("font-weight: bold; font-size: 12px;")
        header_layout.addWidget(header_label)
        
        header_action.setDefaultWidget(header_widget)
        menu.addAction(header_action)
        menu.addSeparator()
        
        # Scan Headers button
        scan_action = QWidgetAction(menu)
        scan_widget = QWidget()
        scan_layout = QVBoxLayout(scan_widget)
        scan_layout.setContentsMargins(8, 4, 8, 4)
        
        scan_btn = QPushButton("Scan Headers")
        scan_btn.setFixedHeight(28)
        scan_btn.setStyleSheet("""
            QPushButton {
                background: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 11px;
                padding: 4px 8px;
            }
            QPushButton:hover {
                background: #45a049;
            }
        """)
        scan_layout.addWidget(scan_btn)
        scan_action.setDefaultWidget(scan_widget)
        menu.addAction(scan_action)
        menu.addSeparator()
        
        # Search bar for headers
        search_action = QWidgetAction(menu)
        search_widget = QWidget()
        search_layout = QVBoxLayout(search_widget)
        search_layout.setContentsMargins(8, 4, 8, 4)
        
        header_search = QLineEdit()
        header_search.setPlaceholderText("Search headers...")
        header_search.setFixedHeight(24)
        header_search.setStyleSheet("""
            QLineEdit {
                padding: 4px 8px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: white;
                font-size: 11px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
        """)
        search_layout.addWidget(header_search)
        search_action.setDefaultWidget(search_widget)
        menu.addAction(search_action)
        menu.addSeparator()
        
        # Scrollable header area
        scroll_action = QWidgetAction(menu)
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout(scroll_widget)
        scroll_layout.setContentsMargins(4, 4, 4, 4)
        scroll_layout.setSpacing(2)
        
        # Create scroll area for headers
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setMaximumHeight(750)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        
        header_container = QWidget()
        header_layout = QGridLayout(header_container)
        header_layout.setSpacing(2)
        header_layout.setVerticalSpacing(1)
        header_layout.setContentsMargins(4, 4, 4, 4)
        
        # Initially populate with existing headers or show scan message
        if not self.session_headers:
            no_headers_label = QLabel("Click 'Scan Headers' to find scene titles")
            no_headers_label.setStyleSheet("color: #666; font-style: italic; padding: 10px;")
            no_headers_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            header_layout.addWidget(no_headers_label, 0, 0)
        
        scroll_area.setWidget(header_container)
        scroll_layout.addWidget(scroll_area)
        
        # Add spacer to push buttons to bottom
        scroll_layout.addStretch(1)
        
        scroll_action.setDefaultWidget(scroll_widget)
        menu.addAction(scroll_action)
        
        # Add header checkboxes if available
        header_checkboxes = {}
        
        def populate_headers():
            """Populate the header checkboxes from session_headers"""
            # Clear existing widgets
            for i in reversed(range(header_layout.count())):
                header_layout.itemAt(i).widget().setParent(None)
            
            if not self.session_headers:
                no_headers_label = QLabel("No headers found")
                no_headers_label.setStyleSheet("color: #666; font-style: italic; padding: 10px;")
                no_headers_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                header_layout.addWidget(no_headers_label, 0, 0)
                return
            
            row, col = 0, 0
            for header in self.session_headers:
                # Truncate header at 25 characters as requested
                display_header = header if len(header) <= 25 else header[:22] + "..."
                checkbox = QCheckBox(display_header)
                checkbox.setChecked(header in self.selected_headers)
                checkbox.setStyleSheet("font-size: 11px; padding: 1px;")
                checkbox.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
                
                if len(header) > 25:
                    checkbox.setToolTip(header)
                
                header_checkboxes[header] = checkbox
                header_layout.addWidget(checkbox, row, col)
                
                col += 1
                if col >= 3:  # Three columns
                    col = 0
                    row += 1
            
            # Dynamically resize scroll area based on number of headers
            num_headers = len(self.session_headers)
            rows_needed = (num_headers + 2) // 3  # 3 columns, so divide by 3 and round up
            
            # Calculate needed scroll area height
            row_height = 25   # Approximate height per row of checkboxes
            scroll_content_height = rows_needed * row_height + 40  # +40 for padding
            
            # Set reasonable limits for scroll area
            min_scroll_height = 100
            max_scroll_height = 500  # Keep reasonable to fit on screen
            new_scroll_height = max(min_scroll_height, min(scroll_content_height, max_scroll_height))
            
            # Update scroll area to expand and accommodate headers
            scroll_area.setMinimumHeight(new_scroll_height)
            scroll_area.setMaximumHeight(new_scroll_height)
            
            # Don't force scroll widget height - let it size naturally with the spacer
            # scroll_widget.setMinimumHeight(new_scroll_height + 80)  # Removed - was hiding buttons
            
            # Update the menu to accommodate the new scroll area size
            # Calculate total height: header(50) + scan button(40) + search(40) + scroll area + buttons(60) + padding(20)
            total_menu_height = new_scroll_height + 210
            
            # Ensure minimum height for buttons to be visible
            min_total_height = 350  # Minimum to show all UI elements including buttons
            max_total_height = 750  # Maximum reasonable height
            
            final_height = max(min_total_height, min(total_menu_height, max_total_height))
            
            menu.setMinimumHeight(final_height)
            menu.setMaximumHeight(final_height)
            
            print(f"[DEBUG] Expanded preview area for {num_headers} headers: {rows_needed} rows, scroll area: {new_scroll_height}px, total menu: {final_height}px")
        
        def scan_headers_func():
            """Scan DOM for h2.speech-title elements"""
            # Show progress
            scan_btn.setText("Scanning...")
            scan_btn.setEnabled(False)
            
            # Get the main window and web view
            main_window = self.window()
            if hasattr(main_window, 'web_view'):
                def handle_scan_result(result):
                    scan_btn.setText("Scan Headers")
                    scan_btn.setEnabled(True)
                    if result:
                        self.session_headers = result
                        self.available_headers = set(result)
                        populate_headers()
                        
                        # Immediately persist headers without full save
                        self._persist_session_headers()
                        
                        print(f"[DEBUG] Scanned and persisted {len(result)} headers: {result}")
                    else:
                        print("[DEBUG] No headers found during scan")
                
                # JavaScript to scan for h2.speech-title elements
                js_code = """
                (function() {
                    var headers = [];
                    var h2Elements = document.querySelectorAll('h2.speech-title');
                    for (var i = 0; i < h2Elements.length; i++) {
                        var text = h2Elements[i].textContent.trim();
                        if (text && headers.indexOf(text) === -1) {
                            headers.push(text);
                        }
                    }
                    return headers;
                })();
                """
                
                main_window.web_view.page().runJavaScript(js_code, handle_scan_result)
            else:
                scan_btn.setText("Scan Headers")
                scan_btn.setEnabled(True)
                print("[DEBUG] No web view available for scanning")
        
        scan_btn.clicked.connect(scan_headers_func)
        
        # Search functionality for headers
        def filter_headers():
            search_text = header_search.text().lower()
            for header, checkbox in header_checkboxes.items():
                should_show = search_text in header.lower()
                checkbox.setVisible(should_show)
        
        header_search.textChanged.connect(filter_headers)
        
        # Apply/Clear buttons (no separator)
        button_action = QWidgetAction(menu)
        button_widget = QWidget()
        button_layout = QHBoxLayout(button_widget)
        button_layout.setContentsMargins(8, 4, 8, 4)
        
        clear_btn = QPushButton("Clear All")
        apply_btn = QPushButton("Apply")
        
        clear_btn.setStyleSheet("QPushButton { font-size: 11px; padding: 4px 8px; }")
        apply_btn.setStyleSheet("QPushButton { font-size: 11px; padding: 4px 8px; }")
        
        def apply_filters():
            self.selected_headers = {header for header, cb in header_checkboxes.items() if cb.isChecked()}
            self._update_filter_headers_button_text()
            self._apply_header_filters()
            menu.close()
        
        def clear_all():
            for cb in header_checkboxes.values():
                cb.setChecked(False)
        
        clear_btn.clicked.connect(clear_all)
        apply_btn.clicked.connect(apply_filters)
        
        button_layout.addWidget(clear_btn)
        button_layout.addWidget(apply_btn)
        button_action.setDefaultWidget(button_widget)
        menu.addAction(button_action)
        
        # Populate existing headers if available (after all functions are defined)
        if self.session_headers:
            populate_headers()
        
        # Show menu at button position
        button_rect = self.filter_headers_btn.geometry()
        menu_pos = self.filter_headers_btn.mapToGlobal(QPoint(0, button_rect.height()))
        menu.exec(menu_pos)

    def _update_filter_headers_button_text(self):
        """Update the Filter Headers button tooltip to show active filters"""
        if not self.selected_headers:
            self.filter_headers_btn.setToolTip("Filter by Headers")
            self.filter_headers_btn.setProperty("has_filters", False)
        else:
            # Create tooltip showing selected headers
            header_list = sorted(list(self.selected_headers))
            if len(header_list) == 1:
                self.filter_headers_btn.setToolTip(f"Filtering by header: {header_list[0]}")
            else:
                tooltip_text = f"Filtering by {len(header_list)} headers:\n" + "\n".join(f"• {h}" for h in header_list)
                self.filter_headers_btn.setToolTip(tooltip_text)
            
            self.filter_headers_btn.setProperty("has_filters", True)
        
        # Force style update
        self.filter_headers_btn.style().polish(self.filter_headers_btn)

    def _apply_header_filters(self):
        """Apply header filters using the same efficient method as tag filters"""
        print(f"\n=== Applying header filters: {self.selected_headers} ===")
        
        # Update clear button visibility when header filters change
        self._update_clear_button_visibility()
        
        # Update sort button state when header filters change
        self.update_sort_button_state()
        
        self.apply_current_filters()
    
    def show_theme_filter_dialog(self):
        """Show the theme filter as a dropdown menu with colored chips"""
        # Get the main window to access scene_styles and ordered_scenes
        main_window = self.parent()
        while main_window and not hasattr(main_window, 'web_view'):
            main_window = main_window.parent()
            
        if not main_window or not hasattr(main_window, 'web_view'):
            print("[DEBUG] Could not find main window with web_view for themes")
            return
            
        scene_styles = getattr(main_window.web_view, 'scene_styles', {})
        ordered_scenes = getattr(main_window.web_view, 'ordered_scenes', list(scene_styles.keys()))
        
        if not scene_styles:
            print("[DEBUG] No scene styles available for theme filtering")
            return
        
        # Create dropdown menu
        menu = QMenu(self)
        menu.setMinimumWidth(265)
        menu.setMaximumHeight(600)
        
        # Header
        header_action = QWidgetAction(menu)
        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(8, 4, 8, 4)
        
        header_label = QLabel("Filter by Themes")
        header_label.setStyleSheet("font-weight: bold; font-size: 12px;")
        header_layout.addWidget(header_label)
        
        header_action.setDefaultWidget(header_widget)
        menu.addAction(header_action)
        menu.addSeparator()
        
        # Scrollable content area
        scroll_action = QWidgetAction(menu)
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout(scroll_widget)
        scroll_layout.setContentsMargins(8, 4, 8, 4)
        scroll_layout.setSpacing(6)
        
        # Create checkboxes for each theme with colored chips
        theme_checkboxes = {}
        for theme_name in ordered_scenes:
            if theme_name in scene_styles:
                checkbox_container = QWidget()
                checkbox_layout = QHBoxLayout(checkbox_container)
                checkbox_layout.setContentsMargins(0, 0, 0, 0)
                checkbox_layout.setSpacing(8)
                
                # Create colored chip
                chip = QLabel()
                chip.setFixedSize(16, 16)
                chip.setStyleSheet(f"""
                    QLabel {{
                        {scene_styles[theme_name]}
                        border: 1px solid #2C3333;
                        border-radius: 8px;
                    }}
                """)
                chip.setToolTip(theme_name)
                
                # Create checkbox
                checkbox = QCheckBox(theme_name)
                checkbox.setChecked(theme_name in self.selected_themes)
                checkbox.setStyleSheet("""
                    QCheckBox {
                        font-size: 11px;
                        padding: 2px;
                    }
                    QCheckBox::indicator {
                        width: 16px;
                        height: 16px;
                    }
                """)
                
                checkbox_layout.addWidget(chip)
                checkbox_layout.addWidget(checkbox)
                checkbox_layout.addStretch()
                
                scroll_layout.addWidget(checkbox_container)
                theme_checkboxes[theme_name] = checkbox
        
        scroll_action.setDefaultWidget(scroll_widget)
        menu.addAction(scroll_action)
        menu.addSeparator()
        
        # Apply and Clear buttons
        apply_action = QWidgetAction(menu)
        apply_widget = QWidget()
        apply_layout = QHBoxLayout(apply_widget)
        apply_layout.setContentsMargins(8, 4, 8, 4)
        
        # Clear All button
        clear_btn = QPushButton("Clear All")
        clear_btn.setFixedHeight(28)
        clear_btn.setStyleSheet("""
            QPushButton {
                background: #f44336;
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 11px;
                padding: 4px 12px;
            }
            QPushButton:hover {
                background: #d32f2f;
            }
        """)
        
        apply_btn = QPushButton("Apply")
        apply_btn.setFixedHeight(28)
        apply_btn.setStyleSheet("""
            QPushButton {
                background: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 11px;
                padding: 4px 16px;
            }
            QPushButton:hover {
                background: #45a049;
            }
        """)
        
        def apply_theme_filters():
            # Collect selected themes
            selected = set()
            for theme_name, checkbox in theme_checkboxes.items():
                if checkbox.isChecked():
                    selected.add(theme_name)
            
            # Update selected themes
            self.selected_themes = selected
            self._update_filter_themes_button_text()
            self._apply_theme_filters()
            
            # Update tab visual states for each theme
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'scene_tabs'):
                main_window = main_window.parent()
            
            if main_window and hasattr(main_window, 'scene_tabs'):
                # Update all tabs based on current filter state
                for theme_name in scene_styles.keys():
                    is_filtered = theme_name in selected
                    main_window.scene_tabs.update_tab_filter_state(theme_name, is_filtered)
            
            menu.close()
        
        def clear_all_themes():
            # Uncheck all checkboxes
            for checkbox in theme_checkboxes.values():
                checkbox.setChecked(False)
            
            # Clear selected themes and apply
            self.selected_themes.clear()
            self._update_filter_themes_button_text()
            self._apply_theme_filters()
            
            # Clear all tab visual states
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'scene_tabs'):
                main_window = main_window.parent()
            
            if main_window and hasattr(main_window, 'scene_tabs'):
                # Clear filter state for all tabs
                for theme_name in scene_styles.keys():
                    main_window.scene_tabs.update_tab_filter_state(theme_name, False)
            
            menu.close()
        
        clear_btn.clicked.connect(clear_all_themes)
        apply_btn.clicked.connect(apply_theme_filters)
        
        apply_layout.addStretch()
        apply_layout.addWidget(clear_btn)
        apply_layout.addWidget(apply_btn)
        apply_layout.addStretch()
        
        apply_action.setDefaultWidget(apply_widget)
        menu.addAction(apply_action)
        
        # Show menu at button position
        button_rect = self.filter_themes_btn.geometry()
        menu_pos = self.filter_themes_btn.mapToGlobal(QPoint(0, button_rect.height()))
        menu.exec(menu_pos)
    
    def _update_filter_themes_button_text(self):
        """Update the Filter Themes button tooltip and visual state"""
        has_filters = bool(self.selected_themes)
        
        if not has_filters:
            self.filter_themes_btn.setToolTip("Filter by Themes")
            self.filter_themes_btn.setProperty("has_filters", False)
        else:
            # Create tooltip showing selected themes
            theme_list = sorted(list(self.selected_themes))
            if len(theme_list) == 1:
                self.filter_themes_btn.setToolTip(f"Filtering by theme: {theme_list[0]}")
            else:
                tooltip_text = f"Filtering by {len(theme_list)} themes:\n" + "\n".join(f"• {t}" for t in theme_list)
                self.filter_themes_btn.setToolTip(tooltip_text)
            
            self.filter_themes_btn.setProperty("has_filters", True)
        
        # Update custom chip visual state
        self.filter_themes_btn.set_has_filters(has_filters)
        
        # Force style update
        self.filter_themes_btn.style().polish(self.filter_themes_btn)
    
    def _apply_theme_filters(self):
        """Apply theme filters using the same efficient method as tag filters"""
        print(f"\n=== Applying theme filters: {self.selected_themes} ===")
        
        # Update clear button visibility when theme filters change
        self._update_clear_button_visibility()
        
        # Update sort button state when theme filters change
        self.update_sort_button_state()
        
        # Use force_search like tag filters do
        self.force_search()

    def _persist_session_headers(self):
        """Persist session headers to the current session file without full save"""
        import json
        import os
        
        main_window = self.window()
        print(f"[DEBUG] Attempting to persist headers. Main window type: {type(main_window)}")
        
        # Try to find the main window by traversing up the parent chain
        if not hasattr(main_window, 'current_session_file'):
            print("[DEBUG] Direct window() doesn't have current_session_file, searching parent chain...")
            current = self.parent()
            while current:
                print(f"[DEBUG] Checking parent: {type(current)}")
                if hasattr(current, 'current_session_file'):
                    main_window = current
                    print(f"[DEBUG] Found main window with current_session_file: {type(main_window)}")
                    break
                current = current.parent() if hasattr(current, 'parent') else None
        
        if not hasattr(main_window, 'current_session_file'):
            print("[DEBUG] Main window has no current_session_file attribute")
            return
            
        current_file = main_window.current_session_file
        print(f"[DEBUG] Current session file: {current_file}")
        
        if not current_file:
            print("[DEBUG] No current session file set, cannot persist headers")
            return
            
        if not os.path.exists(current_file):
            print(f"[DEBUG] Session file does not exist: {current_file}")
            return
        
        try:
            print(f"[DEBUG] Reading session file: {current_file}")
            # Read current session file
            with open(current_file, 'r', encoding='utf-8') as f:
                session_data = json.load(f)
            
            print(f"[DEBUG] Loaded session data, updating session-headers with {len(self.session_headers)} headers")
            # Update only the session-headers field
            session_data['session-headers'] = self.session_headers
            
            print(f"[DEBUG] Writing updated session data back to: {current_file}")
            # Write back to file
            with open(current_file, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2, ensure_ascii=False)
            
            print(f"[DEBUG] Successfully persisted {len(self.session_headers)} headers to session file: {self.session_headers}")
            
        except Exception as e:
            print(f"[DEBUG] Failed to persist session headers: {e}")
            import traceback
            print(f"[DEBUG] Full traceback: {traceback.format_exc()}")
            # Don't raise exception, just log the error - scanning should still work

    def _collect_available_tags(self):
        """Collect all available tags from main tag list (much faster than scanning annotations)"""
        # Get the main window to access the tag list
        main_window = self.parent()
        while main_window and not hasattr(main_window, 'tags'):
            main_window = main_window.parent()
            
        if not main_window or not hasattr(main_window, 'tags'):
            print("[DEBUG] Could not find main window with tags")
            self.available_tags = []
            return
            
        # Use the main tag list directly - much faster than scanning annotations!
        # Remove # symbols from tags if they exist (normalize tag format)
        raw_tags = main_window.tags if main_window.tags else []
        self.available_tags = [tag.lstrip('#') for tag in raw_tags]
        
        print(f"[DEBUG] Loaded {len(self.available_tags)} tags from main tag list: {self.available_tags}")
        print(f"[DEBUG] Raw tags from main window: {raw_tags}")

    def _update_filter_tags_button_text(self):
        """Update the Filter Tags button tooltip to show active filters"""
        if not self.selected_tags:
            self.filter_tags_btn.setToolTip("Filter by Tags")
            self.filter_tags_btn.setProperty("has_filters", False)
        else:
            # Create tooltip showing selected tags
            tag_list = sorted(list(self.selected_tags))
            if len(tag_list) == 1:
                self.filter_tags_btn.setToolTip(f"Filtering by tag: {tag_list[0]}")
            else:
                tooltip_text = f"Filtering by {len(tag_list)} tags:\n" + "\n".join(f"• {t}" for t in tag_list)
                self.filter_tags_btn.setToolTip(tooltip_text)
            
            self.filter_tags_btn.setProperty("has_filters", True)
        
        # Update style
        self.filter_tags_btn.style().unpolish(self.filter_tags_btn)
        self.filter_tags_btn.style().polish(self.filter_tags_btn)

    def _apply_tag_filters(self):
        """Apply the tag filters to the current search"""
        print(f"[DEBUG] _apply_tag_filters called with selected_tags: {self.selected_tags}")
        print(f"[DEBUG] current_list_widget: {getattr(self, 'current_list_widget', 'NOT SET')}")
        
        # Update clear button visibility when tag filters change
        self._update_clear_button_visibility()
        
        # Update sort button state when tag filters change
        self.update_sort_button_state()
        
        if hasattr(self, 'current_list_widget') and self.current_list_widget:
            print("[DEBUG] Triggering force_search from _apply_tag_filters")
            # Trigger a search with current filters
            self.force_search()
        else:
            print("[DEBUG] No current_list_widget set, calling force_search anyway")
            # Force search anyway - the force_search method will handle finding the right widgets
            self.force_search()

    def _update_clear_button_visibility(self):
        """Update clear button visibility based on active filters"""
        has_filters = (
            bool(self.selected_tags) or                    # Tag filters active
            bool(self.selected_headers) or                 # Header filters active
            bool(self.selected_themes) or                  # Theme filters active
            bool(self.current_search_text.strip()) or      # Search text entered
            self.favorites_only or                         # Favorites filter active
            self.hide_used != 0 or                         # Hide used filter active
            not self.global_search_enabled                 # Global search disabled
        )
        
        self.clear_filters_btn.setVisible(has_filters)
        print(f"[DEBUG] Clear button visibility: {has_filters} (tags:{bool(self.selected_tags)}, headers:{bool(self.selected_headers)}, themes:{bool(self.selected_themes)}, search:{bool(self.current_search_text.strip())}, favorites:{self.favorites_only}, hide_used:{self.hide_used}, global:{self.global_search_enabled})")

    def clear_all_filters(self):
        """Clear all filters and reset to default state"""
        # Clear tag filters
        self.selected_tags.clear()
        self.strict_tag_filtering = True
        self._update_filter_tags_button_text()
        
        # Clear header filters
        self.selected_headers.clear()
        self._update_filter_headers_button_text()
        
        # Clear theme filters
        self.selected_themes.clear()
        self._update_filter_themes_button_text()
        
        # Clear tab filter visual states
        main_window = self.window()
        if main_window and hasattr(main_window, 'scene_tabs'):
            # Clear filter state for all tabs
            main_window.scene_tabs.colored_tab_bar.filtered_tabs.clear()
            main_window.scene_tabs.colored_tab_bar.update()
        
        # Clear search text
        self.search_input.clear()
        self.current_search_text = ""
        
        # Reset other filter states
        self.favorites_only = False
        self.hide_used = 0
        self.global_search_enabled = True
        
        # Update button states
        self.favorites_btn.setChecked(False)
        self.favorites_btn.setToolTip("Toggle Favorites Filter (Showing All)")
        
        self.hide_used_btn.setProperty("state", "0")
        self.hide_used_btn.setText("◪")
        self.hide_used_btn.setToolTip("Filter Used (Showing All Used and Unused)")
        
        self.global_search_btn.setChecked(True)
        self.global_search_enabled = True
        
        # Refresh styles
        for btn in [self.favorites_btn, self.hide_used_btn, self.global_search_btn]:
            btn.style().unpolish(btn)
            btn.style().polish(btn)
        
        # Clear search confirmation flag since we're clearing filters
        self.search_confirmed = False
        
        # Update button states
        self.update_sort_button_state()
        
        # Update clear button visibility
        self._update_clear_button_visibility()
        
        # Apply filters (which will clear them)
        self.apply_current_filters()

    def _update_placeholder_overlay(self, total_shown):
        """Show or hide overlay placeholder based on filter results"""
        main_window = self.window()
        scene_tabs = main_window.scene_tabs
        
        if total_shown == 0:
            # Build message components
            content_type = "content"
            qualifiers = []
            conditions = []
            
            # Add favorites qualifier
            if self.favorites_only:
                qualifiers.append("favorited")
            
            # Add used/unused qualifier
            if self.hide_used == 1:
                qualifiers.append("unused")
            elif self.hide_used == 2:
                qualifiers.append("used")
            
            # Build content type with qualifiers
            if qualifiers:
                content_type = " ".join(qualifiers) + " content"
            
            # Add search condition
            if self.search_confirmed and self.current_search_text:
                conditions.append(f"matching '{self.current_search_text}'")
            
            # Add tag condition
            if hasattr(self, 'selected_tags') and self.selected_tags:
                tag_list = ", ".join(self.selected_tags)
                mode = "all" if self.strict_tag_filtering else "any"
                conditions.append(f"with {mode} tags: {tag_list}")
            
            # Add header condition
            if hasattr(self, 'selected_headers') and self.selected_headers:
                header_list = ", ".join(self.selected_headers)
                conditions.append(f"under headers: {header_list}")
            
            # Build final message
            if conditions:
                message = f"No {content_type} {' '.join(conditions)}"
            else:
                # Friendly guidance when there are no annotations and no filters
                message = "Highlight text to create annotations"
            
            # Truncate if too long
            message = message[:47] + "..." if len(message) > 50 else message
            
            self._show_placeholder_overlay(message)
        else:
            self._hide_placeholder_overlay()

    def _show_placeholder_overlay(self, message):
        """Show overlay placeholder with message"""
        main_window = self.window()
        scene_tabs = main_window.scene_tabs
        
        # Create overlay if it doesn't exist
        if not hasattr(self, '_placeholder_overlay') or self._placeholder_overlay is None:
            self._placeholder_overlay = QLabel(scene_tabs)
            self._placeholder_overlay.setObjectName("placeholder_overlay")
            self._placeholder_overlay.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self._placeholder_overlay.setStyleSheet("""
                QLabel#placeholder_overlay {
                    background-color: rgba(255, 255, 255, 240);
                    color: #666666;
                    font-size: 16px;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    padding: 20px;
                }
            """)
            self._placeholder_overlay.setWordWrap(True)
        
        # Update message and show overlay
        self._placeholder_overlay.setText(message)
        self._placeholder_overlay.resize(scene_tabs.size())
        self._placeholder_overlay.show()
        self._placeholder_overlay.raise_()

    def _hide_placeholder_overlay(self):
        """Hide overlay placeholder"""
        if hasattr(self, '_placeholder_overlay') and self._placeholder_overlay:
            self._placeholder_overlay.hide()

    def _annotation_matches_current_filters(self, annotation_info):
        """Check if an annotation matches the current active filters"""
        import re
        
        # Evaluate all filters independently, then combine with AND logic
        # Apply favorites filter
        favorites_passed = True
        if self.favorites_only and not annotation_info.get('favorite', False):
            favorites_passed = False
        
        # Apply hide_used filter
        hide_used_passed = True
        is_used = annotation_info.get('used', False)
        if self.hide_used == 1 and is_used:  # Hide used
            hide_used_passed = False
        elif self.hide_used == 2 and not is_used:  # Show only used
            hide_used_passed = False
        
        # Apply search filter
        search_passed = True
        if self.search_confirmed and self.current_search_text:
            text = re.sub(r'[^\w\s]', ' ', annotation_info.get('text', '').lower())
            text = ' '.join(text.split())
            notes = re.sub(r'[^\w\s]', ' ', annotation_info.get('notes', '').lower())
            notes = ' '.join(notes.split())
            search_text = re.sub(r'[^\w\s]', ' ', self.current_search_text.lower())
            search_text = ' '.join(search_text.split())
            
            if not (search_text in text or search_text in notes):
                search_passed = False
        
        # Apply tag filters
        tag_filter_passed = True
        if self.selected_tags:
            annotation_tags = set(tag.lower() for tag in annotation_info.get('tags', []))
            selected_tags_lower = set(tag.lower() for tag in self.selected_tags)
            
            if self.strict_tag_filtering:
                # Strict mode: annotation must have ALL selected tags
                if not selected_tags_lower.issubset(annotation_tags):
                    tag_filter_passed = False
            else:
                # Loose mode: annotation must have ANY selected tag
                if not bool(selected_tags_lower & annotation_tags):
                    tag_filter_passed = False
        
        # Apply header filters
        header_filter_passed = True
        if self.selected_headers:
            # Get the scene title from annotation (speech_title or scene_title)
            annotation_header = annotation_info.get('speech_title', '') or annotation_info.get('scene_title', '')
            if annotation_header:
                # Check if annotation's header matches any selected headers
                selected_headers_lower = set(header.lower() for header in self.selected_headers)
                if annotation_header.lower() not in selected_headers_lower:
                    header_filter_passed = False
            else:
                # If annotation has no header, filter it out when header filters are active
                header_filter_passed = False
        
        # Apply theme filters (Filter by scene and secondary_scenes)
        theme_filter_passed = True
        if self.selected_themes:
            # Get annotation themes from both scene and secondary_scenes fields
            annotation_themes = set()
            
            # Add primary scene
            primary_scene = annotation_info.get('scene', '')
            if primary_scene:
                annotation_themes.add(primary_scene.lower())
            
            # Add secondary scenes
            secondary_scenes = annotation_info.get('secondary_scenes', [])
            for secondary_scene in secondary_scenes:
                if secondary_scene:
                    annotation_themes.add(secondary_scene.lower())
            
            # Convert selected themes to lowercase for comparison
            selected_themes_lower = set(theme.lower() for theme in self.selected_themes)
            
            # Check if annotation has ANY of the selected themes (OR logic for themes)
            theme_matches = bool(selected_themes_lower & annotation_themes)
            if not theme_matches:
                theme_filter_passed = False
        
        # Combine ALL filter results with AND logic - ALL must pass
        return favorites_passed and hide_used_passed and search_passed and tag_filter_passed and header_filter_passed and theme_filter_passed


class TagFilterDialog(QDialog):
    """Dialog for selecting tags to filter by"""
    
    def __init__(self, parent, available_tags, selected_tags, strict_mode):
        super().__init__(parent)
        # Preserve the original order of tags
        self.available_tags = list(available_tags)
        self.selected_tags = set(selected_tags)
        self.strict_mode = strict_mode
        self.tag_checkboxes = {}
        
        self.setWindowTitle("Filter by Tags")
        self.setFixedSize(600, 250)
        self.setup_ui()
        
    def setup_ui(self):
        """Setup the dialog UI"""
        layout = QVBoxLayout(self)
        layout.setSpacing(4)  # Reduced from 8 to make dialog more compact
        
        # Header
        header_label = QLabel("Select tags to filter by:")
        header_label.setStyleSheet("font-weight: bold; font-size: 14px; margin-bottom: 8px;")
        layout.addWidget(header_label)
        
        # Strict/Loose toggle
        filter_mode_layout = QHBoxLayout()
        filter_mode_layout.setSpacing(0)  # No spacing between radio buttons
        
        self.strict_radio = QRadioButton("Strict")
        self.loose_radio = QRadioButton("Loose")
        
        # Add tooltips with explanations
        self.strict_radio.setToolTip("AND mode - must have ALL selected tags")
        self.loose_radio.setToolTip("OR mode - must have ANY selected tag")
        
        self.strict_radio.setChecked(self.strict_mode)
        self.loose_radio.setChecked(not self.strict_mode)
        
        filter_mode_layout.addWidget(self.strict_radio)
        filter_mode_layout.addWidget(self.loose_radio)
        filter_mode_layout.addStretch()  # Push radio buttons to the left
        layout.addLayout(filter_mode_layout)
        
        # Separator
        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setFrameShadow(QFrame.Shadow.Sunken)
        layout.addWidget(line)
        
        # Tags list
        if not self.available_tags:
            no_tags_label = QLabel("No tags found in annotations.")
            no_tags_label.setStyleSheet("color: #666; font-style: italic; padding: 20px;")
            no_tags_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(no_tags_label)
        else:
            # Scroll area for tags in grid layout
            scroll_area = QScrollArea()
            scroll_widget = QWidget()
            scroll_widget.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Minimum)
            scroll_layout = QGridLayout(scroll_widget)
            scroll_layout.setSpacing(2)
            scroll_layout.setVerticalSpacing(2)  # Explicit small vertical spacing
            scroll_layout.setHorizontalSpacing(8)  # Explicit horizontal spacing
            scroll_layout.setContentsMargins(4, 4, 4, 4)
            
            # Arrange tags in grid with max 4 columns
            row = 0
            col = 0
            for tag in self.available_tags:
                # Truncate tag at 25 characters
                display_tag = tag if len(tag) <= 25 else tag[:22] + "..."
                checkbox = QCheckBox(f"#{display_tag}")
                checkbox.setChecked(tag in self.selected_tags)
                checkbox.setStyleSheet("padding: 1px; margin: 0px; font-family: monospace; font-size: 11px;")
                checkbox.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
                
                # Set full tag as tooltip if truncated
                if len(tag) > 25:
                    checkbox.setToolTip(f"#{tag}")
                
                self.tag_checkboxes[tag] = checkbox
                scroll_layout.addWidget(checkbox, row, col)
                
                # Set row stretch to 0 to prevent expansion
                scroll_layout.setRowStretch(row, 0)
                
                col += 1
                if col >= 4:  # Max 4 columns
                    col = 0
                    row += 1
            
            # Add stretch at the bottom to push all content up
            scroll_layout.setRowStretch(row + 1, 1)
                
            scroll_area.setWidget(scroll_widget)
            scroll_area.setWidgetResizable(True)
            layout.addWidget(scroll_area)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        select_all_btn = QPushButton("Select All")
        clear_all_btn = QPushButton("Clear All")
        
        select_all_btn.clicked.connect(self.select_all_tags)
        clear_all_btn.clicked.connect(self.clear_all_tags)
        
        button_layout.addWidget(select_all_btn)
        button_layout.addWidget(clear_all_btn)
        button_layout.addStretch()
        
        # OK/Cancel buttons
        ok_btn = QPushButton("Apply Filters")
        cancel_btn = QPushButton("Cancel")
        
        ok_btn.clicked.connect(self.accept)
        cancel_btn.clicked.connect(self.reject)
        
        ok_btn.setDefault(True)
        ok_btn.setStyleSheet("font-weight: bold;")
        
        button_layout.addWidget(ok_btn)
        button_layout.addWidget(cancel_btn)
        
        layout.addLayout(button_layout)
        
    def select_all_tags(self):
        """Select all available tags"""
        for checkbox in self.tag_checkboxes.values():
            checkbox.setChecked(True)
            
    def clear_all_tags(self):
        """Clear all tag selections"""
        for checkbox in self.tag_checkboxes.values():
            checkbox.setChecked(False)
            
    def get_selected_tags(self):
        """Get the set of selected tags"""
        selected = set()
        for tag, checkbox in self.tag_checkboxes.items():
            if checkbox.isChecked():
                selected.add(tag)
        return selected
        
    def get_strict_mode(self):
        """Get whether strict mode is enabled"""
        return self.strict_radio.isChecked()

class BookmarkDialog(QDialog):
    def __init__(self, parent=None, bookmark_data=None, anchor_widget=None):
        super().__init__(parent, Qt.WindowType.Popup | Qt.WindowType.FramelessWindowHint)
        self.setFixedWidth(350)

        # Store parent and position info
        self.parent = parent
        self.bookmark_data = bookmark_data.copy() if bookmark_data else {}
        print(f"Dialog init - Bookmark data: {self.bookmark_data}")

        # **Initialize Position**
        if bookmark_data and 'position' in bookmark_data:
            self.current_position = float(bookmark_data['position'])
            print(f"Dialog init - Using existing position: {self.current_position}")
        else:
            self.current_position = None
            print(f"Dialog init - No existing position, will get current")
            if parent and hasattr(parent, 'web_view'):
                parent.web_view.page().runJavaScript("window.pageYOffset", self._store_current_position)

        # Main Layout
        layout = QVBoxLayout(self)
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)

        # Main Frame
        frame = QFrame(self)
        frame.setObjectName("bookmarkFrame")
        frame_layout = QVBoxLayout(frame)
        frame_layout.setSpacing(3)
        frame_layout.setContentsMargins(15, 15, 15, 15)

        # **Header Section with Close Button**
        header_widget = QWidget()
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(10)

        header = QLabel("Create Bookmark" if bookmark_data is None else "Edit Bookmark")
        header.setObjectName("dialogHeader")
        header_layout.addWidget(header)

        close_button = QPushButton("❌")
        close_button.setObjectName("closeButton")
        close_button.setCursor(Qt.CursorShape.PointingHandCursor)
        close_button.clicked.connect(self.reject)
        header_layout.addWidget(close_button, alignment=Qt.AlignmentFlag.AlignRight)

        frame_layout.addWidget(header_widget)

        # Title input section
        self.name_input = QLineEdit()
        self.name_input.setPlaceholderText("Enter bookmark title...")
        self.name_input.setMaxLength(50)
        self.name_input.setObjectName("titleInput")
        self.name_input.textChanged.connect(self.update_char_count)
        frame_layout.addWidget(self.name_input)

        # Character Count Label
        self.char_count_label = QLabel("0/50")
        self.char_count_label.setObjectName("charCount")
        self.char_count_label.setAlignment(Qt.AlignmentFlag.AlignRight)
        frame_layout.addWidget(self.char_count_label)
        frame_layout.addSpacing(5)

        # **Description Section with Rich Text Editor**
        desc_label = QLabel("Description (optional)")
        desc_label.setObjectName("inputLabel")
        frame_layout.addWidget(desc_label)

        # Create toolbar for rich text formatting
        toolbar = QToolBar()
        toolbar.setObjectName("richTextToolbar")
        
        # Bold action
        bold_action = QAction("B", toolbar)
        bold_action.setCheckable(True)
        bold_action.setToolTip("Bold")
        bold_action.triggered.connect(lambda: self.format_text('bold'))
        toolbar.addAction(bold_action)
        
        # Italic action
        italic_action = QAction("I", toolbar)
        italic_action.setCheckable(True)
        italic_action.setToolTip("Italic")
        italic_action.triggered.connect(lambda: self.format_text('italic'))
        toolbar.addAction(italic_action)
        
        # Underline action
        underline_action = QAction("U", toolbar)
        underline_action.setCheckable(True)
        underline_action.setToolTip("Underline")
        underline_action.triggered.connect(lambda: self.format_text('underline'))
        toolbar.addAction(underline_action)

        frame_layout.addWidget(toolbar)

        # Rich text editor
        self.desc_input = QTextEdit()
        self.desc_input.setPlaceholderText("Enter description...")
        self.desc_input.setObjectName("descriptionInput")
        self.desc_input.setMinimumHeight(100)
        self.desc_input.setAcceptRichText(True)
        frame_layout.addWidget(self.desc_input)
        
        frame_layout.addSpacing(5)

        # Position section remains the same...
        position_container = QWidget()
        position_layout = QHBoxLayout(position_container)
        position_layout.setContentsMargins(0, -5, 0, -15)

        position_label = QLabel("Position")
        position_label.setObjectName("inputLabel")
        position_layout.addWidget(position_label)

        self.reset_position_btn = QPushButton("Reset to Current")
        self.reset_position_btn.setObjectName("resetButton")
        self.reset_position_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.reset_position_btn.clicked.connect(self._reset_position)
        position_layout.addWidget(self.reset_position_btn, alignment=Qt.AlignmentFlag.AlignRight)

        frame_layout.addWidget(position_container)

        # Position Info Display
        self.position_info = QLabel()
        self.position_info.setObjectName("positionInfo")
        frame_layout.addWidget(self.position_info)

        # Save and Cancel Buttons
        button_container = QWidget()
        button_layout = QHBoxLayout(button_container)
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_layout.setSpacing(6)

        save_button = QPushButton("Save")
        save_button.setObjectName("saveButton")
        save_button.setCursor(Qt.CursorShape.PointingHandCursor)
        save_button.clicked.connect(self.accept)
        save_button.setDefault(True)

        cancel_button = QPushButton("Cancel")
        cancel_button.setObjectName("cancelButton")
        cancel_button.setCursor(Qt.CursorShape.PointingHandCursor)
        cancel_button.clicked.connect(self.reject)

        button_layout.addWidget(cancel_button)
        button_layout.addWidget(save_button)
        frame_layout.addWidget(button_container)

        layout.addWidget(frame)

        # Initialize with existing data if provided
        if bookmark_data:
            self.name_input.setText(bookmark_data['name'])
            self.desc_input.setPlainText(bookmark_data['description'])  # Use plain text to avoid HTML parsing issues
            self.update_char_count()
        
        self._update_position_info()

        # Apply updated styles including rich text toolbar
        self.setStyleSheet("""
            QDialog {
                background: #ffffff;
                border: 1px solid #e0e0e0;
            }
            #bookmarkFrame {
                background-color: #ffffff;
                border: 0px solid #e0e0e0;
                border-radius: 8px;
            }
            #richTextToolbar {
                background: transparent;
                border: none;
                spacing: 2px;
                padding: 2px;
            }
            #richTextToolbar QAction {
                font-weight: bold;
                padding: 4px 8px;
                margin: 0 2px;
                border-radius: 4px;
            }
            #richTextToolbar QAction:checked {
                background: #e3f2fd;
            }
            #bookmarkFrame {
                background-color: #ffffff;
                border: 0px solid #e0e0e0;
                border-radius: 8px;
            }
            #dialogHeader {
                color: #2C4952;
                font-size: 16px;
                font-weight: bold;
            }
            #closeButton {
                background: transparent;
                border: none;
                color: #666;
                font-size: 14px;
                padding: 0px 4px;
                margin: 0;
                min-width: 20px;
                min-height: 20px;
            }
            #closeButton:hover {
                background: #f0f0f0;
                border-radius: 4px;
                color: #333;
            }
            #inputLabel {
                font-weight: 600;
                font-size: 13px;
                color: #2C4952;
            }
            #titleInput, #descriptionInput {
                padding: 8px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 13px;
                background: white;
            }
            #titleInput:focus, #descriptionInput:focus {
                border-color: #2196F3;
            }
            #charCount {
                font-size: 12px;
                color: #777;
                margin-top: 0px;
            }
            #saveButton, #cancelButton {
                padding: 8px 16px;
                min-width: 80px;
                border-radius: 4px;
                font-size: 13px;
                border: none;
            }
            #saveButton {
                background-color: #203740;
                color: white;
            }
            #saveButton:hover {
                background-color: #2C4952;
            }
            #cancelButton {
                background-color: #f0f0f0;
                color: #333;
            }
            #cancelButton:hover {
                background-color: #e0e0e0;
            }
            #resetButton {
                background-color: #f0f0f0;
                color: #333;
                border: none;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 12px;
            }
            #resetButton:hover {
                background-color: #e0e0e0;
            }
            #positionInfo {
                font-size: 12px;
                color: #666;
                font-style: italic;
                margin-top: 0px;
                margin-bottom: 5px;
            }
            QScrollBar:vertical {
                border: none;
                background: #f1f1f1;
                width: 8px;
                border-radius: 4px;
                margin: 0;
            }
            QScrollBar::handle:vertical {
                background: #c1c1c1;
                border-radius: 4px;
                min-height: 20px;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                border: none;
                background: none;
            }
        """)
        
        # Position dialog if anchor widget provided
        if anchor_widget:
            self.position_dialog(anchor_widget)
            
        # Add shadow effect
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(15)
        shadow.setColor(QColor(0, 0, 0, 40))
        shadow.setOffset(0, 2)
        self.setGraphicsEffect(shadow)
        
        # Install event filter for click-away handling
        self.installEventFilter(self)

    def _store_current_position(self, position):
        """Callback to store the current scroll position"""
        print(f"*store*current_position called with: {position}")
        if position is not None:
            self.current_position = float(position)
            self.bookmark_data['position'] = self.current_position  # Update bookmark_data
            print(f"Position stored as: {self.current_position}")
            self._update_position_info()
        else:
            print("Warning: Received None position in _store_current_position")

    def _update_position_info(self):
        """Update the position info label"""
        print(f"*update*position_info called with current_position: {self.current_position}")
        if self.current_position is not None:
            try:
                pixel_pos = int(self.current_position)
                self.position_info.setText(f"Position: {pixel_pos:,} px")
                print(f"Updated position display to: {pixel_pos}")
            except (ValueError, TypeError) as e:
                print(f"Error converting position to int: {e}")
                self.position_info.setText("Invalid position")
        else:
            self.position_info.setText("Position not set")

    def _reset_position(self):
        """Reset to current scroll position"""
        print("*reset*position called")
        if self.parent and hasattr(self.parent, 'web_view'):
            print("Executing JavaScript to get current position")
            self.parent.web_view.page().runJavaScript(
                """
                (function() {
                    let pos = window.pageYOffset || document.documentElement.scrollTop;
                    console.log('Current scroll position:', pos);
                    return pos;
                })();
                """,
                self._store_current_position
            )
        else:
            print("Warning: Parent or web_view not available")

    def accept(self):
        """Override accept to ensure we use the latest position"""
        print("Dialog accept called")
        print(f"Final position being saved: {self.current_position}")
        super().accept()


    def _set_new_position(self, position):
        """Set the new position and update display"""
        self.current_position = position
        self._update_position_info()

    def position_dialog(self, anchor_widget):
        """Positions the dialog relative to the anchor widget, ensuring visibility."""
        self.adjustSize()  # Crucial: Ensure dialog size is calculated correctly!

        anchor_rect = anchor_widget.rect()
        global_pos = anchor_widget.mapToGlobal(anchor_rect.topLeft())

        # Ideal initial position (to the left of the anchor)
        dialog_pos = QPoint(
            global_pos.x() - self.width() - 10,
            global_pos.y()
        )

        screen = QApplication.primaryScreen().availableGeometry()  # More accurate than geometry()

        # --- Horizontal Adjustment ---
        if dialog_pos.x() < screen.left():
            dialog_pos.setX(global_pos.x() + anchor_rect.width() + 10)
            # Check if it's still out of bounds on the right
            if dialog_pos.x() + self.width() > screen.right():
                dialog_pos.setX(screen.right() - self.width() - 10)

        # --- Vertical Adjustment ---
        if dialog_pos.y() + self.height() > screen.bottom():
            dialog_pos.setY(global_pos.y() - self.height() + anchor_rect.height())

        if dialog_pos.y() < screen.top():
            dialog_pos.setY(screen.top())

        self.move(dialog_pos)

    def showEvent(self, event):
        """Called just before the dialog is shown."""
        super().showEvent(event)
        if hasattr(self, 'anchor_widget') and self.anchor_widget:
            self.position_dialog(self.anchor_widget)

    def update_char_count(self):
        current_length = len(self.name_input.text())
        self.char_count_label.setText(f"{current_length}/50")

        if current_length >= 45:
            self.char_count_label.setStyleSheet("font-size: 12px; color: red;")
        else:
            self.char_count_label.setStyleSheet("font-size: 12px; color: #777;")

    def eventFilter(self, obj, event):
        """Handle click-away closing"""
        if event.type() == QEvent.Type.MouseButtonPress:
            global_click_pos = event.globalPosition().toPoint()
            if not self.geometry().contains(global_click_pos):
                self.reject()
                return True
        return super().eventFilter(obj, event)

    def format_text(self, format_type):
        """Apply rich text formatting to selected text"""
        cursor = self.desc_input.textCursor()
        text_format = QTextCharFormat()
    
        if format_type == 'bold':
            if cursor.charFormat().fontWeight() != QFont.Weight.Bold:
                text_format.setFontWeight(QFont.Weight.Bold)
            else:
                text_format.setFontWeight(QFont.Weight.Normal)
        elif format_type == 'italic':
            text_format.setFontItalic(not cursor.charFormat().fontItalic())
        elif format_type == 'underline':
            text_format.setFontUnderline(not cursor.charFormat().fontUnderline())
        
        cursor.mergeCharFormat(text_format)

    def get_bookmark_data(self):
        """Get the bookmark data including position and rich text description"""
        result = self.bookmark_data.copy()
        result.update({
            'name': self.name_input.text().strip(),
            'description': self.desc_input.toPlainText(),  # Save as plain text to avoid HTML document structure issues
            'position': int(self.current_position) if self.current_position is not None else 0
        })
        print(f"get_bookmark_data returning: {result}")
        return result #Bookmarks

class BookmarkDescriptionDialog(QDialog):
    def __init__(self, description, parent=None, anchor_widget=None):
        super().__init__(parent, Qt.WindowType.Popup | Qt.WindowType.FramelessWindowHint)
        self.setFixedSize(450, 550)
        
        # Create main layout
        layout = QVBoxLayout(self)
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Create frame for the entire dialog
        frame = QFrame(self)
        frame.setObjectName("descriptionFrame")
        frame_layout = QVBoxLayout(frame)
        frame_layout.setSpacing(10)
        frame_layout.setContentsMargins(15, 15, 15, 15)
        
        # Add header with close button
        header_widget = QWidget()
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(10)
        
        header = QLabel("Description")
        header.setObjectName("descriptionHeader")
        header_layout.addWidget(header)
        
        close_button = QPushButton("❌")
        close_button.setObjectName("closeButton")
        close_button.setCursor(Qt.CursorShape.PointingHandCursor)
        close_button.clicked.connect(self.close)
        header_layout.addWidget(close_button, alignment=Qt.AlignmentFlag.AlignRight)
        
        frame_layout.addWidget(header_widget)
        
        # Add description text as QTextBrowser for rich text display
        text = QTextBrowser()
        text.setHtml(description)  # Use setHtml instead of setPlainText
        text.setReadOnly(True)
        text.setObjectName("descriptionText")
        text.setOpenExternalLinks(True)  # Allow clicking links if present
        frame_layout.addWidget(text)
        
        layout.addWidget(frame)
        
        # Apply styles
        self.setStyleSheet("""
            QDialog {
                background: transparent;
            }
            #descriptionFrame {
                background-color: #ffffff;
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            }
            #descriptionHeader {
                color: #2C4952;
                font-size: 14px;
                font-weight: bold;
                padding-bottom: 5px;
            }
            #closeButton {
                background: transparent;
                border: none;
                color: #666;
                font-size: 14px;
                padding: 0px 4px;
                margin: 0;
                min-width: 20px;
                min-height: 20px;
            }
            #closeButton:hover {
                background: #f0f0f0;
                border-radius: 4px;
                color: #333;
            }
            #descriptionText {
                border: none;
                background-color: transparent;
                font-size: 13px;
                color: #333;
                line-height: 1.4;
            }
            QTextBrowser {
                selection-background-color: #e3f2fd;
                selection-color: #333333;
            }
            QScrollBar:vertical {
                border: none;
                background: #f1f1f1;
                width: 8px;
                border-radius: 4px;
                margin: 0;
            }
            QScrollBar::handle:vertical {
                background: #c1c1c1;
                border-radius: 4px;
                min-height: 20px;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                border: none;
                background: none;
            }
        """)
        
        # If we have an anchor widget, position the dialog next to it
        if anchor_widget:
            self.position_dialog(anchor_widget)
            
        # Install event filter for click-away closing
        self.installEventFilter(self)
            
    def position_dialog(self, anchor_widget):
        """Positions the dialog relative to the anchor widget, ensuring visibility."""
        self.adjustSize()

        anchor_rect = anchor_widget.rect()
        global_pos = anchor_widget.mapToGlobal(anchor_rect.topLeft())

        dialog_pos = QPoint(
            global_pos.x() - self.width() - 10,
            global_pos.y()
        )

        screen = QApplication.primaryScreen().availableGeometry()

        # --- Horizontal Adjustment ---
        if dialog_pos.x() < screen.left():
            dialog_pos.setX(global_pos.x() + anchor_rect.width() + 10)
            if dialog_pos.x() + self.width() > screen.right():
                dialog_pos.setX(screen.right() - self.width() - 10)

        # --- Vertical Adjustment ---
        if dialog_pos.y() + self.height() > screen.bottom():
            dialog_pos.setY(global_pos.y() - self.height() + anchor_rect.height())

        if dialog_pos.y() < screen.top():
            dialog_pos.setY(screen.top())

        self.move(dialog_pos)

    def showEvent(self, event):
        """Called just before the dialog is shown.
           Adds drop shadow and positions the dialog.
        """
        # Add drop shadow (from original showEvent)
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(15)
        shadow.setColor(QColor(0, 0, 0, 40))
        shadow.setOffset(0, 2)
        self.setGraphicsEffect(shadow)

        # Position dialog (from new logic)
        if hasattr(self, 'anchor_widget') and self.anchor_widget:
            self.position_dialog(self.anchor_widget)

        super().showEvent(event)  # Important: Call the base class showEvent
    
    def eventFilter(self, obj, event):
        """Handle click-away closing"""
        if event.type() == QEvent.Type.MouseButtonPress:
            global_click_pos = event.globalPosition().toPoint()
            if not self.geometry().contains(global_click_pos):
                self.close()
                return True
        return super().eventFilter(obj, event) #Bookmarks

class BookmarkListWidget(QListWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)
        self.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.setVerticalScrollMode(QAbstractItemView.ScrollMode.ScrollPerPixel)
        self.verticalScrollBar().setSingleStep(1)
        self.setDefaultDropAction(Qt.DropAction.MoveAction)
        
        # Clear selection after a short delay when clicked (for single clicks)
        self.itemClicked.connect(lambda item: QTimer.singleShot(200, self.clearSelection))
        
        # Ensure selection is visible during drag operations
        self.startDrag = lambda actions: self.drag_with_selection(actions)
    
    def mousePressEvent(self, event):
        """Handle mouse press events for selection behavior"""
        if event.button() == Qt.MouseButton.LeftButton:
            if event.modifiers() == Qt.KeyboardModifier.ShiftModifier:
                # Select all valid items (exclude separator)
                self.clearSelection()
                for i in range(self.count()):
                    item = self.item(i)
                    if item and item.data(Qt.ItemDataRole.UserRole):  # Only select actual bookmarks
                        item.setSelected(True)
                # Prevent the itemClicked signal from clearing the selection
                try:
                    self.itemClicked.disconnect()
                except TypeError:  # In case it's already disconnected
                    pass
                # Reconnect the signal after a brief delay
                QTimer.singleShot(300, lambda: self.itemClicked.connect(
                    lambda item: QTimer.singleShot(200, self.clearSelection)
                ))
            else:
                # Normal click behavior
                item = self.itemAt(event.pos())
                if item and not item.data(Qt.ItemDataRole.UserRole):
                    # If clicking separator, don't allow selection
                    item.setSelected(False)
                else:
                    # Default handling for normal clicks
                    super().mousePressEvent(event)
        else:
            super().mousePressEvent(event)
    
    def drag_with_selection(self, actions):
        self.dragged_item = self.currentItem()
        super().startDrag(actions)
        QTimer.singleShot(10, self.clearSelection)

    def startDrag(self, supportedActions):
        """Override startDrag to change cursor to closed hand during drag operation"""
        print("\n=== BOOKMARK START DRAG EVENT ===")
        
        # Change cursor to closed hand to indicate active dragging
        self.setCursor(Qt.CursorShape.ClosedHandCursor)
        print("Changed cursor to ClosedHandCursor")
        
        # Use the custom drag method
        self.drag_with_selection(supportedActions)
        print("=== BOOKMARK START DRAG EVENT END ===\n")

    def mouseReleaseEvent(self, event):
        """Handle mouse release events to restore cursor if drag was cancelled"""
        print("\n=== BOOKMARK MOUSE RELEASE EVENT ===")
        
        # Restore cursor to default if it's still set to closed hand
        if self.cursor().shape() == Qt.CursorShape.ClosedHandCursor:
            self.setCursor(Qt.CursorShape.ArrowCursor)
            print("Restored cursor from ClosedHand to ArrowCursor")
        
        super().mouseReleaseEvent(event)
        print("=== BOOKMARK MOUSE RELEASE EVENT END ===\n")

    def dropEvent(self, event):
        """
        Handle drop events, maintaining bookmark order and favorite status.
        Allows dropping in empty non-favorites section.
        """
        print("\n=== DROP EVENT START ===")

        # Get drop location and calculate empty space threshold
        drop_pos = self.mapFromGlobal(QCursor.pos())
        viewport_rect = self.viewport().rect()
        print(f"Drop position: {drop_pos.y()}")

        # Find separator
        separator_idx = -1
        for i in range(self.count()):
            item = self.item(i)
            if item and not item.data(Qt.ItemDataRole.UserRole):
                separator_idx = i
                break
        print(f"Separator index: {separator_idx}")

        # Get dragged item
        dragged_item = self.currentItem()
        if not dragged_item:
            print("No dragged item found - ignoring drop")
            self.setCursor(Qt.CursorShape.ArrowCursor)
            event.ignore()
            return

        # Store initial states
        original_states = {}
        for i in range(self.count()):
            item = self.item(i)
            if item and item.data(Qt.ItemDataRole.UserRole):
                bookmark = item.data(Qt.ItemDataRole.UserRole)
                original_states[bookmark['name']] = {
                    'favorite': bookmark['is_favorite'],
                    'position': i
                }

        # Get drop target item (if any)
        drop_item = self.itemAt(drop_pos)
        source_row = self.row(dragged_item)
        print(f"Source row: {source_row}")

        # Handle different drop scenarios
        if drop_item is None:
            # Dropping in empty space
            print("Drop in empty space detected")
            if separator_idx != -1:
                # If we're below the separator's bottom edge, move to end
                separator_rect = self.visualItemRect(self.item(separator_idx))
                if drop_pos.y() > separator_rect.bottom():
                    print("Drop below separator - moving to end")
                    dest_row = self.count()
                    model = self.model()
                    success = model.moveRow(QModelIndex(), source_row, QModelIndex(), dest_row)
                    if success:
                        event.accept()
                    else:
                        print("Move failed")
                        self.setCursor(Qt.CursorShape.ArrowCursor)
                        event.ignore()
                        return
                else:
                    self.setCursor(Qt.CursorShape.ArrowCursor)
                    event.ignore()
                    return
            else:
                self.setCursor(Qt.CursorShape.ArrowCursor)
                event.ignore()
                return
        elif not drop_item.data(Qt.ItemDataRole.UserRole):
            # Dropping on separator
            print("Drop on separator detected")
            separator_rect = self.visualItemRect(drop_item)
            separator_middle = separator_rect.top() + separator_rect.height() / 2
        
            if drop_pos.y() < separator_middle:
                print("  Redirecting to above separator (favorites section)")
                dest_row = separator_idx - 1
            else:
                print("  Redirecting to below separator (non-favorites section)")
                dest_row = separator_idx + 1
        
            # Move the row
            model = self.model()
            success = model.moveRow(QModelIndex(), source_row, QModelIndex(), dest_row)
            if success:
                event.accept()
            else:
                print("Move failed")
                self.setCursor(Qt.CursorShape.ArrowCursor)
                event.ignore()
                return
        else:
            # Normal drop on another item
            print(f"Normal drop on item at row {self.row(drop_item)}")
            super().dropEvent(event)

        # Update bookmark states after move
        bookmarks = []
        print("\nProcessing final positions:")
    
        for i in range(self.count()):
            item = self.item(i)
            if not item or not item.data(Qt.ItemDataRole.UserRole):
                continue
            
            bookmark = item.data(Qt.ItemDataRole.UserRole).copy()
            original = original_states[bookmark['name']]
        
            was_favorite = bookmark['is_favorite']
            is_in_favorites_section = (separator_idx == -1 or i < separator_idx)
        
            if item == dragged_item:
                # Dragged item changes status based on final position
                bookmark['is_favorite'] = is_in_favorites_section
            else:
                # Other items keep their original status
                bookmark['is_favorite'] = original['favorite']

            print(f"  {bookmark['name']}: position {i}, favorite: {was_favorite} -> {bookmark['is_favorite']}")
            bookmarks.append(bookmark)

        # Update parent
        parent = self.parent()
        if hasattr(parent, 'update_bookmarks'):
            parent.update_bookmarks(bookmarks)

        # Ensure cursor is restored
        if QApplication.overrideCursor():
            QApplication.restoreOverrideCursor()
        # Also set widget cursor to default to ensure proper restoration
        self.setCursor(Qt.CursorShape.ArrowCursor)
        print("Restored cursor to ArrowCursor after bookmark drop")

        print("=== DROP EVENT END ===\n") #Bookmarks 

class BookmarkPanel(QWidget):
    scroll_to_position = pyqtSignal(int)

    def __init__(self, web_view, parent=None):
        super().__init__(parent)
        self.web_view = web_view
        self.bookmarks = []
        self.dragged_item = None
        self.drag_start_pos = None
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)

        # Header with action buttons
        header_layout = QHBoxLayout()
        
        # Left side - Header and Search
        header_left_layout = QVBoxLayout()
        
        title_layout = QHBoxLayout()

        self.add_button = QPushButton("+")
        self.add_button.setCursor(Qt.CursorShape.PointingHandCursor)
        # Force exact 24×24 size so no layout expansions occur
        self.add_button.setFixedSize(22, 22)

        self.add_button.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50; /* green */
                color: white;
                border: none;
                border-radius: 10px; /* round button */
                font-weight: bold;
                font-size: 20px;
                /* Reset general spacing */
                padding-left: 1px;
                margin-left: 0px;
                margin-right: 0px;
                /* Adjust text position by adding padding to bottom */
                padding-bottom: 5px;  /* Adjust this value as needed */
                /* Alternative method using negative margin: */
                margin-top 4px;
                line-height: 24px;
                text-align: center;
            }
            QPushButton:hover {
                background-color: #43a047; /* darker green on hover */
            }
            QPushButton:pressed {
                background-color: #388e3c; /* even darker when pressed */
            }
        """)

        self.add_button.clicked.connect(self.add_bookmark)


        # Add the green plus button, then a small space, then the label
        title_layout.addWidget(self.add_button)
        title_layout.addSpacing(0)  # Reduced from 8
        header = QLabel("Bookmarks")
        header.setStyleSheet("""
            QLabel {
                font-size: 16px;
                font-weight: bold;
                color: #203740;
                padding: 0px;
                margin-left: -5px;
                margin-bottom: 2px;
            }
        """)
        title_layout.addWidget(header)

        # Search bar
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("Search bookmarks...")
        self.search_bar.setStyleSheet("""
            QLineEdit {
                border: 1px solid #cccccc;
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 12px;
                margin-top: 0px;
            }
            QLineEdit:focus {
                border-color: #999999;
            }
        """)
        self.search_bar.textChanged.connect(self.filter_bookmarks)
        title_layout.addWidget(self.search_bar)

        header_left_layout.addLayout(title_layout)

        
        header_layout.addLayout(header_left_layout)
        layout.addLayout(header_layout)

        # Create bookmark list
        self.bookmark_list = BookmarkListWidget(self)
        self.bookmark_list.setStyleSheet("""
            QListWidget {
                border: 1px solid #e0e0e0;
                border-radius: 6px;
                background: white;
                outline: none;
            }
            QListWidget::item {
                padding: 0px;
                border-bottom: 1px solid #f0f0f0;
            }
            QListWidget::item:selected {
                background-color: #e3f2fd;
            }
            QListWidget::item:hover:!selected {
                background-color: #f5f5f5;
            }
        """)
        self.bookmark_list.itemDoubleClicked.connect(self.navigate_to_bookmark)
        self.bookmark_list.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.bookmark_list.customContextMenuRequested.connect(self.show_context_menu)
        layout.addWidget(self.bookmark_list)

        # # Add bookmark button
        # self.add_button = QPushButton("Add Bookmark")
        # self.add_button.setStyleSheet("""
        #     QPushButton {
        #         background-color: transparent;
        #         color: #666666;
        #         border: 1px solid #cccccc;
        #         padding: 6px 12px;
        #         border-radius: 4px;
        #         font-size: 12px;
        #     }
        #     QPushButton:hover {
        #         background-color: #f5f5f5;
        #         border-color: #999999;
        #         color: #333333;
        #     }
        #     QPushButton:pressed {
        #         background-color: #eeeeee;
        #     }
        # """)
        # self.add_button.clicked.connect(self.add_bookmark)
        # layout.addWidget(self.add_button)


    def _mark_changes_pending(self):
        """Helper method to mark changes as pending in main window"""
        parent = self.window()
        if parent:
            # Only update window title to show changes
            if not parent.windowTitle().startswith('*'):
                parent.setWindowTitle(f'*{parent.windowTitle()}')
            # Set changes pending flag
            parent.changes_pending = True


    def filter_bookmarks(self):
        """Filters the bookmarks based on the search text."""
        search_text = self.search_bar.text().lower()
        for i in range(self.bookmark_list.count()):
            item = self.bookmark_list.item(i)
            if item and item.data(Qt.ItemDataRole.UserRole):
                bookmark = item.data(Qt.ItemDataRole.UserRole)
                if search_text in bookmark['name'].lower() or (
                    bookmark['description'] and search_text in bookmark['description'].lower()
                ):
                    item.setHidden(False)
                else:
                    item.setHidden(True)
            elif item: # Separator item
                item.setHidden(False)

    def update_bookmarks(self, new_bookmarks):
        """Called by the BookmarkListWidget after a drop event"""
        print("\n=== UPDATE BOOKMARKS ===")
        print(f"Previous bookmarks: {self.bookmarks}")
        print(f"New bookmarks: {new_bookmarks}")
        
        self.bookmarks = new_bookmarks
        self.refresh_list()
        self._mark_changes_pending()
        print("=== UPDATE BOOKMARKS END ===\n")

    def mousePressEvent(self, event):
        """
        Starts the drag operation for any bookmark item.
        """
        item = self.bookmark_list.itemAt(event.pos())
        if item and item.data(Qt.ItemDataRole.UserRole):  # Only proceed if it's a bookmark item
            self.dragged_item = item
            self.drag_start_pos = event.pos()
    
        # Call the original mousePressEvent to maintain default behavior
        super().mousePressEvent(event)


    def on_rows_moved(self, parent, start, end, destination, row):
        """
        Handles the reordering of items in the bookmark_list.
        This method is called after dropEvent has already processed the move.
        """
        # The dropEvent method now handles all the reordering and favorite status updates
        pass

    def mouseMoveEvent(self, event):
        """
        Handle mouse move events and start drag if needed.
        """
        if not (event.buttons() & Qt.MouseButton.LeftButton):
            return

        # Get the item under the mouse
        item = self.bookmark_list.itemAt(self.bookmark_list.mapFromParent(event.pos()))
        if not item or not item.data(Qt.ItemDataRole.UserRole):
            return
        
        bookmark = item.data(Qt.ItemDataRole.UserRole)
        print(f"\nDEBUG: Starting drag of {bookmark['name']}")

        # Create drag object
        drag = QDrag(self)
        mimedata = QMimeData()
    
        # Store the index of the dragged item
        encoded_data = str(self.bookmark_list.row(item)).encode()
        mimedata.setData('application/x-item-index', QByteArray(encoded_data))
    
        drag.setMimeData(mimedata)

        # Execute drag
        result = drag.exec(Qt.DropAction.MoveAction)
        print(f"DEBUG: Drag completed with result {result}")

    def dragEnterEvent(self, event):
        if event.mimeData().hasFormat('application/x-item-index'):
            event.accept()
        else:
            event.ignore()

    def refresh_list(self):
        """Refreshes the list widget with favorites, separator, and non-favorites."""
        current_scroll_pos = self.bookmark_list.verticalScrollBar().value()
        self.bookmark_list.clear()

        # Separate bookmarks into favorites and non-favorites
        favorites = [bookmark for bookmark in self.bookmarks if bookmark['is_favorite']]
        non_favorites = [bookmark for bookmark in self.bookmarks if not bookmark['is_favorite']]

        # Add favorites
        for bookmark in favorites:
            self._add_bookmark_item(bookmark)

        # Ensure separator is always added
        separator_item = QListWidgetItem()
        separator_widget = QWidget()
        separator_layout = QVBoxLayout(separator_widget)
        separator_layout.setContentsMargins(8, 8, 8, 8)

        # Add separator line
        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setStyleSheet("""
            QFrame {
                border: none;
                background-color: #e0e0e0;
                height: 2px;
            }
        """)
        separator_layout.addWidget(line)

        # Disable all interaction with separator
        separator_item.setFlags(Qt.ItemFlag.NoItemFlags)
        separator_item.setSizeHint(separator_widget.sizeHint())

        # Style to prevent hover effects
        separator_widget.setStyleSheet("""
            QWidget {
                background: transparent;
            }
            QWidget:hover {
                background: transparent;
            }
        """)

        self.bookmark_list.addItem(separator_item)
        self.bookmark_list.setItemWidget(separator_item, separator_widget)

        # Add non-favorites
        for bookmark in non_favorites:
            self._add_bookmark_item(bookmark)

        # Restore scroll position
        self.bookmark_list.verticalScrollBar().setValue(current_scroll_pos)


    def add_bookmark(self):
        # Create dialog and pass the add_button as the anchor widget
        dialog = BookmarkDialog(self, anchor_widget=self.add_button)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            bookmark_data = dialog.get_bookmark_data()
            if bookmark_data['name']:
                self.web_view.page().runJavaScript(
                    "window.pageYOffset",
                    lambda pos: self._create_bookmark(
                        bookmark_data['name'],
                        bookmark_data['description'],
                        pos
                    )
                )
                self._mark_changes_pending()

    def _create_bookmark(self, name, description, position):
        bookmark = {
            'name': name,
            'description': description,
            'position': position,
            'is_favorite': False
        }
        print(f"\n=== CREATING BOOKMARK ===")
        print(f"New bookmark: {bookmark}")
        self.bookmarks.append(bookmark)
        self._add_bookmark_item(bookmark)

    def _add_bookmark_item(self, bookmark):
        """Creates and adds a bookmark item to the list."""
        item = QListWidgetItem()
        item.setData(Qt.ItemDataRole.UserRole, bookmark)

        widget = QWidget()
        layout = QHBoxLayout(widget)
        layout.setContentsMargins(12, 8, 12, 8)
        layout.setSpacing(10)

        # Add star icon for favorites
        if bookmark['is_favorite']:
            star_label = QLabel("⭐")
            star_label.setStyleSheet("font-size: 14px;")
            layout.addWidget(star_label)

        # Container for title and description
        text_container = QWidget()
        text_layout = QHBoxLayout(text_container)
        text_layout.setContentsMargins(0, 0, 0, 0)
        text_layout.setSpacing(5)

        # Title label
        name_label = QLabel(bookmark['name'])
        name_label.setStyleSheet("""
            QLabel {
                font-weight: 600;
                font-size: 14px;
                color: #2C4952;
            }
        """)
        text_layout.addWidget(name_label)

        # Add description in parentheses (if available)
        if bookmark['description']:
            # Description is now plain text, no need for HTML parsing
            plain_desc = bookmark['description']
    
            # Remove line breaks and excessive whitespace, then truncate
            plain_desc = ' '.join(plain_desc.split())  # This replaces all whitespace (including newlines) with single spaces
            truncated_desc = (plain_desc[:72] + '...') if len(plain_desc) > 75 else plain_desc
    
            desc_label = QLabel(f"({truncated_desc})")
            desc_label.setStyleSheet("""
                QLabel {
                    font-size: 12px;
                    color: #777;
                }
            """)
            desc_label.setMaximumHeight(name_label.sizeHint().height())  # Restrict to same height as name label
            text_layout.addWidget(desc_label)

        # View description button
        if bookmark['description']:
            desc_link = QPushButton("ℹ️")
            desc_link.setToolTip("View description")
            desc_link.setCursor(Qt.CursorShape.PointingHandCursor)
            desc_link.setStyleSheet("""
                QPushButton {
                    background: none;
                    border: none;
                    color: #2196F3;
                    padding: 0;
                    font-size: 14px;
                }
                QPushButton:hover {
                    color: #1976D2;
                }
            """)
            desc_link.clicked.connect(
                lambda: self.show_description(bookmark['description'], widget)
            )
            layout.addWidget(desc_link)

        layout.addWidget(text_container)
        layout.addStretch()

        item.setSizeHint(widget.sizeHint())
        self.bookmark_list.addItem(item)
        self.bookmark_list.setItemWidget(item, widget)

    def show_description(self, description, anchor_widget=None):
        """Shows the description dialog.
    
        Args:
            description: The description text to show
            anchor_widget: The widget to position the dialog next to
        """
        dialog = BookmarkDescriptionDialog(description, self, anchor_widget)
        dialog.show()

    def show_context_menu(self, position):
        selected_items = self.bookmark_list.selectedItems()
        valid_items = [item for item in selected_items if item.data(Qt.ItemDataRole.UserRole)]
    
        if not valid_items:
            item = self.bookmark_list.itemAt(position)
            if not item or not item.data(Qt.ItemDataRole.UserRole):
                return
            valid_items = [item]
            item.setSelected(True)

        menu = QMenu(self)
    
        # Show different options based on selection count
        if len(valid_items) == 1:
            edit_action = menu.addAction("Edit")
            remove_action = menu.addAction("Remove")
        
            # Add favorite action for single selection
            bookmark = valid_items[0].data(Qt.ItemDataRole.UserRole)
            if bookmark['is_favorite']:
                favorite_action = menu.addAction("Unfavorite")
            else:
                favorite_action = menu.addAction("Favorite")
        else:
            remove_action = menu.addAction(f"Remove {len(valid_items)} bookmarks")
        
            # Add favorite actions for multiple selection
            all_favorites = all(item.data(Qt.ItemDataRole.UserRole)['is_favorite'] for item in valid_items)
            any_favorites = any(item.data(Qt.ItemDataRole.UserRole)['is_favorite'] for item in valid_items)
        
            if all_favorites:
                favorite_action = menu.addAction("Unfavorite all")
            elif not any_favorites:
                favorite_action = menu.addAction("Favorite all")
            else:
                favorite_action = menu.addAction("Toggle favorites")

        action = menu.exec(self.bookmark_list.mapToGlobal(position))

        if action == remove_action:
            self.remove_bookmarks(valid_items)
        elif len(valid_items) == 1 and action == edit_action:
            self.edit_bookmark(valid_items[0])
        elif action == favorite_action:
            if len(valid_items) == 1:
                self.toggle_favorite(valid_items[0])
            else:
                self.toggle_favorites_bulk(valid_items)

    def toggle_favorites_bulk(self, items):
        """Toggle favorite status for multiple bookmarks."""
        # Determine the target state based on current states
        all_favorites = all(item.data(Qt.ItemDataRole.UserRole)['is_favorite'] for item in items)
        any_favorites = any(item.data(Qt.ItemDataRole.UserRole)['is_favorite'] for item in items)
    
        # If all are favorites, unfavorite all
        # If none are favorites, favorite all
        # If mixed, make all match the majority
        target_state = not all_favorites if (all_favorites or not any_favorites) else True
    
        # Update all selected bookmarks
        for item in items:
            bookmark = item.data(Qt.ItemDataRole.UserRole)
            bookmark_index = self.bookmarks.index(bookmark)
            self.bookmarks[bookmark_index]['is_favorite'] = target_state

        # Refresh list instead of just sorting
        self.refresh_list()
        self._mark_changes_pending()

    def edit_bookmark(self, item):
        """Edit a bookmark with a floating dialog positioned next to the item."""
        print("\n--- Starting edit_bookmark ---")
    
        bookmark = item.data(Qt.ItemDataRole.UserRole)
        print(f"Original bookmark data: {bookmark}")
    
        current_widget = self.bookmark_list.itemWidget(item)
        dialog = BookmarkDialog(self, bookmark_data=bookmark, anchor_widget=current_widget)
        print("BookmarkDialog initialized.")
    
        if dialog.exec() == QDialog.DialogCode.Accepted:
            print("Dialog accepted.")
            new_bookmark_data = dialog.get_bookmark_data()
            print(f"New bookmark data from dialog: {new_bookmark_data}")
        
            if new_bookmark_data['name']:
                clicked_item_index = self.bookmark_list.row(item)
                print(f"Clicked item index in list: {clicked_item_index}")

                # Separate favorites and non-favorites before using them
                favorites = [b for b in self.bookmarks if b['is_favorite']]
                non_favorites = [b for b in self.bookmarks if not b['is_favorite']]

                # Debug output to verify data separation
                print(f"Favorites count: {len(favorites)}")
                print(f"Non-favorites count: {len(non_favorites)}")
                print(f"Clicked item index: {clicked_item_index}")

                # Adjusted logic since the separator is always present
                target_bookmark_index = None

                # If there are no favorites, non-favorites start from index 1 (because of separator at index 0)
                if len(favorites) == 0:
                    print("No favorites present. Separator is at index 0.")
                    adjusted_index = clicked_item_index - 1
                    print(f"Adjusted index after accounting for separator: {adjusted_index}")
                    if 0 <= adjusted_index < len(non_favorites):
                        target_bookmark_index = self.bookmarks.index(non_favorites[adjusted_index])
                        print(f"Target non-favorite bookmark found at index {target_bookmark_index}.")
                    else:
                        print(f"Error: Adjusted index {adjusted_index} is out of range for non-favorites list of size {len(non_favorites)}.")

                # If there are favorites, separator is placed at the index `len(favorites)`
                else:
                    print("Favorites present. Separator placed after the favorites.")
                    if clicked_item_index < len(favorites):
                        target_bookmark_index = self.bookmarks.index(favorites[clicked_item_index])
                        print(f"Target favorite bookmark found at index {target_bookmark_index}.")
                    elif clicked_item_index == len(favorites):
                        print("Clicked on the separator. Ignoring click.")
                    else:
                        # Adjust for separator presence
                        adjusted_index = clicked_item_index - len(favorites) - 1
                        print(f"Adjusted index for non-favorites: {adjusted_index}")
                        if 0 <= adjusted_index < len(non_favorites):
                            target_bookmark_index = self.bookmarks.index(non_favorites[adjusted_index])
                            print(f"Target non-favorite bookmark found at index {target_bookmark_index}.")
                        else:
                            print(f"Error: Adjusted index {adjusted_index} is out of range for non-favorites list of size {len(non_favorites)}.")

                # Final verification before using the result
                if target_bookmark_index is None:
                    print("Final Error: Target bookmark index not found.")
                else:
                    print(f"Final target_bookmark_index: {target_bookmark_index}")

                # Ensure we found the correct bookmark
                if target_bookmark_index is not None:
                    print(f"Updating bookmark at index {target_bookmark_index}.")
                    # Update the bookmark data
                    self.bookmarks[target_bookmark_index]['name'] = new_bookmark_data['name']
                    self.bookmarks[target_bookmark_index]['description'] = new_bookmark_data['description']
                    self.bookmarks[target_bookmark_index]['position'] = new_bookmark_data['position']
                    print(f"Updated bookmark data: {self.bookmarks[target_bookmark_index]}")
                
                    # Update the item widget
                    widget = self.bookmark_list.itemWidget(item)
                    layout = widget.layout()
                    print("Accessed item widget layout.")
                
                    # Find and update or remove the star label
                    star_label_item = layout.itemAt(0)
                    if isinstance(star_label_item.widget(), QLabel) and star_label_item.widget().text() == "⭐":
                        print("Star label found.")
                        star_label = star_label_item.widget()
                        if not self.bookmarks[target_bookmark_index]['is_favorite']:
                            print("Bookmark is no longer a favorite. Removing star label.")
                            layout.removeWidget(star_label)
                            star_label.deleteLater()
                        elif self.bookmarks[target_bookmark_index]['is_favorite']:
                            print("Bookmark is a favorite. Updating star label.")
                            star_label = QLabel("⭐")
                            star_label.setStyleSheet("font-size: 14px;")
                            layout.insertWidget(0, star_label)  # Insert at the beginning
                            print("Star label updated and inserted.")
                    else:
                        print("No existing star label found or incorrect widget type.")
                
                    # Find the text container
                    text_container = None
                    print("Searching for text container within item layout.")
                    for i in range(layout.count()):
                        widget_item = layout.itemAt(i)
                        if widget_item and isinstance(widget_item.widget(), QWidget):
                            # Check if this widget has a layout with name label and description
                            inner_layout = widget_item.widget().layout()
                            if inner_layout and isinstance(inner_layout, QHBoxLayout):
                                name_found = False
                                for j in range(inner_layout.count()):
                                    inner_widget = inner_layout.itemAt(j).widget()
                                    if isinstance(inner_widget, QLabel) and inner_widget.text() == bookmark['name']:
                                        name_found = True
                                        break
                                if name_found:
                                    text_container = widget_item.widget()
                                    print(f"Text container found at layout index {i}.")
                                    break
                
                    if text_container:
                        print("Updating text container with new bookmark data.")
                        text_layout = text_container.layout()
                    
                        # Update name label
                        name_label_item = text_layout.itemAt(0)
                        if name_label_item:
                            name_label = name_label_item.widget()
                            if isinstance(name_label, QLabel):
                                print(f"Updating name label from '{name_label.text()}' to '{new_bookmark_data['name']}'.")
                                name_label.setText(new_bookmark_data['name'])
                    
                        # Update or remove description label
                        desc_label_item = text_layout.itemAt(1)
                        if new_bookmark_data['description']:
                            # Add or update description label in parentheses
                            if len(new_bookmark_data['description']) > 75:
                                truncated_desc = new_bookmark_data['description'][:72] + '...'
                            else:
                                truncated_desc = new_bookmark_data['description']
                            print(f"Truncated description: {truncated_desc}")
                        
                            if desc_label_item:
                                desc_label = desc_label_item.widget()
                                if isinstance(desc_label, QLabel):
                                    print(f"Updating description label to '({truncated_desc})'.")
                                    desc_label.setText(f"({truncated_desc})")
                                else:
                                    print("Existing description widget is not a QLabel. Replacing it.")
                                    text_layout.removeWidget(desc_label_item.widget())
                                    desc_label_item.widget().deleteLater()
                                    desc_label = QLabel(f"({truncated_desc})")
                                    desc_label.setStyleSheet("""
                                        QLabel {
                                            font-size: 12px;
                                            color: #777;
                                        }
                                    """)
                                    text_layout.insertWidget(1, desc_label)  # Insert at index 1
                                    print("New description label created and inserted.")
                            else:
                                print("No existing description label. Creating and inserting new one.")
                                desc_label = QLabel(f"({truncated_desc})")
                                desc_label.setStyleSheet("""
                                    QLabel {
                                        font-size: 12px;
                                        color: #777;
                                    }
                                """)
                                text_layout.insertWidget(1, desc_label)  # Insert at index 1
                                print("New description label created and inserted.")
                        else:
                            if desc_label_item:
                                print("No description provided. Removing existing description label.")
                                desc_label = desc_label_item.widget()
                                if isinstance(desc_label, QLabel):
                                    text_layout.removeWidget(desc_label)
                                    desc_label.deleteLater()
                                    print("Description label removed.")
                
                    else:
                        print("Text container not found. Skipping text update.")
                
                    # Find description button
                    desc_button = None
                    print("Searching for description button within layout.")
                    for i in range(layout.count()):
                        widget_item = layout.itemAt(i)
                        if widget_item and isinstance(widget_item.widget(), QPushButton) and widget_item.widget().text() == "ℹ️":
                            desc_button = widget_item.widget()
                            print(f"Description button found at layout index {i}.")
                            break
                
                    # Update or remove description button
                    if new_bookmark_data['description']:
                        if desc_button:
                            print("Updating existing description button.")
                            try:
                                desc_button.clicked.disconnect()
                                print("Disconnected previous signal from description button.")
                            except TypeError:
                                print("No previous connections to disconnect.")
                            desc_button.clicked.connect(
                                lambda: self.show_description(new_bookmark_data['description'], widget)
                            )
                            print("Connected new signal to description button.")
                        else:
                            print("No existing description button. Creating a new one.")
                            desc_button = self.create_description_button(new_bookmark_data['description'], widget)
                            layout.addWidget(desc_button)  # Append to the end
                            print("New description button created and added to layout.")
                    else:
                        if desc_button:
                            print("No description provided. Removing existing description button.")
                            layout.removeWidget(desc_button)
                            desc_button.deleteLater()
                            print("Description button removed.")
                
                    # Near the bottom of edit_bookmark
                    # BEFORE we update the item data and refresh list, let's verify the position
                    print(f"Position in bookmarks before setData: {self.bookmarks[target_bookmark_index]['position']}")
                
                    # Print current scroll position
                    scroll_position = self.bookmark_list.verticalScrollBar().value()
                    print(f"Current scroll position before setData: {scroll_position}")
                
                    # Update the stored bookmark data in the item with a fresh copy
                    bookmark_to_save = self.bookmarks[target_bookmark_index].copy()  # Create a clean copy
                    print(f"Bookmark to save: {bookmark_to_save}")
                
                    item.setData(Qt.ItemDataRole.UserRole, bookmark_to_save)
                    print(f"Position after setData: {item.data(Qt.ItemDataRole.UserRole)['position']}")
                
                    # Print updated scroll position if it changes
                    new_scroll_position = self.bookmark_list.verticalScrollBar().value()
                    print(f"Scroll position after setData: {new_scroll_position}")
                
                    # **Then call update_bookmarks** to ensure the changes actually persist:
                    print("Calling update_bookmarks to persist changes.")
                    self.update_bookmarks(self.bookmarks)
                    print("update_bookmarks called.")
                
                    print("Refreshing bookmark list.")
                    self.refresh_list()
                    print("Bookmark list refreshed.")
                
                    print("Marking changes as pending.")
                    self._mark_changes_pending()
                    print("--- edit_bookmark completed successfully ---\n")
                else:
                    print("Error: Target bookmark index not found.")
            else:
                print("Error: New bookmark name is empty.")
        else:
            print("Dialog canceled. No changes made.")


    def create_description_button(self, description, widget):
        """Helper function to create a description button."""
        desc_button = QPushButton("ℹ️")
        desc_button.setToolTip("View description")
        desc_button.setCursor(Qt.CursorShape.PointingHandCursor)
        desc_button.setStyleSheet("""
            QPushButton {
                background: none;
                border: none;
                color: #2196F3;
                padding: 0;
                font-size: 14px;
            }
            QPushButton:hover {
                color: #1976D2;
            }
        """)
        desc_button.clicked.connect(
            lambda: self.show_description(description, widget)
        )
        return desc_button

    def remove_bookmarks(self, items):
        """Removes selected bookmarks after confirmation."""
        message = "Are you sure you want to delete these bookmarks?" if len(items) > 1 else "Are you sure you want to delete this bookmark?"
        reply = QMessageBox.question(
            self,
            'Remove Bookmarks',
            message,
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            for item in items:
                bookmark = item.data(Qt.ItemDataRole.UserRole)
                self.bookmarks.remove(bookmark)
                row = self.bookmark_list.row(item)
                self.bookmark_list.takeItem(row)
            
            self._mark_changes_pending()
            self.refresh_list()

    def navigate_to_bookmark(self, item):
        bookmark = item.data(Qt.ItemDataRole.UserRole)
        position = bookmark['position']
        self.scroll_to_position.emit(position)

    def toggle_favorite(self, item):
        bookmark = item.data(Qt.ItemDataRole.UserRole)
        bookmark_index = self.bookmarks.index(bookmark)

        # Ensure 'is_favorite' key exists
        if 'is_favorite' not in self.bookmarks[bookmark_index]:
            self.bookmarks[bookmark_index]['is_favorite'] = False

        # Toggle the favorite status
        self.bookmarks[bookmark_index]['is_favorite'] = not self.bookmarks[bookmark_index]['is_favorite']

        # Update the item widget
        widget = self.bookmark_list.itemWidget(item)
        layout = widget.layout()

        if self.bookmarks[bookmark_index]['is_favorite']:
            if not any(isinstance(layout.itemAt(i).widget(), QLabel) and 
                      layout.itemAt(i).widget().text() == "⭐" for i in range(layout.count())):
                star_label = QLabel("⭐")
                star_label.setStyleSheet("font-size: 14px;")
                layout.insertWidget(0, star_label)
        else:
            for i in range(layout.count()):
                star_label_item = layout.itemAt(i)
                if isinstance(star_label_item.widget(), QLabel) and star_label_item.widget().text() == "⭐":
                    star_label = star_label_item.widget()
                    layout.removeWidget(star_label)
                    star_label.deleteLater()
                    break

        # Sort and refresh the list with separator
        self.refresh_list()
        self._mark_changes_pending()
        
        self._mark_changes_pending()

    def load_bookmarks(self, bookmarks_data):
        # Ensure 'is_favorite' exists for all loaded bookmarks
        for bookmark in bookmarks_data:
            if 'is_favorite' not in bookmark:
                bookmark['is_favorite'] = False

        self.bookmarks = bookmarks_data
        self.bookmark_list.clear()
        for bookmark in self.bookmarks:
            self._add_bookmark_item(bookmark)
        self.sort_bookmarks()

        self.filter_bookmarks()  # Apply filter AFTER loading and sorting

    def get_bookmarks_data(self):
        return self.bookmarks

    def sort_bookmarks(self):
        # Separate favorites and other bookmarks
        favorites = [b for b in self.bookmarks if b['is_favorite']]
        others = [b for b in self.bookmarks if not b['is_favorite']]

        # Combine them, with favorites first
        self.bookmarks = favorites + others

        # Refresh the list widget
        self.refresh_list() #Bookmarks

class WelcomeDialog(QDialog):
    sessionSelected = pyqtSignal(dict)
    def __init__(self, parent=None, recent_sessions=None):
        super().__init__(parent)  # Make sure to pass parent
        self.main_window = parent
        self.recent_sessions = recent_sessions or {}
        self.session_info = None
        self.load_recent_sessions()

        # --- Custom Tooltip Initialization ---
        self.custom_tooltip = None
        self._tooltip_timer = QTimer(self)
        self._tooltip_timer.setSingleShot(True)
        self._tooltip_timer.setInterval(500)
        self._tooltip_timer.timeout.connect(self._show_custom_tooltip)
        # --- End Custom Tooltip Initialization ---
    
        # Set window flags to group with parent but retain minimize/maximize buttons
        self.setWindowFlags(
            Qt.WindowType.Window |  # Allows minimize/maximize
            Qt.WindowType.WindowTitleHint |
            Qt.WindowType.CustomizeWindowHint |
            Qt.WindowType.WindowCloseButtonHint
        )

        # For Windows taskbar grouping, set the icon the same as main window
        icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Img', 'video_transcript_manager.ico')
        self.setWindowIcon(QIcon(icon_path))
    
        # For Windows taskbar icon
        if os.name == 'nt':
            import ctypes
            # Use the same AppUserModelID as the main window
            myappid = 'mycompany.transcriptmanager.welcome.1'
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)

        self.init_ui()

        # Add main window event monitoring
        if self.main_window:
            self.main_window.installEventFilter(self)

    def _show_custom_tooltip(self):
        """Show a custom tooltip for the item currently under the mouse"""
        item = self._current_hover_item
        if not item:
            return

        # Get tooltip text directly from the item
        tooltip_text = item.toolTip()
        if not tooltip_text:
            return

        # Create tooltip label if it doesn't exist
        if self.custom_tooltip is None:
            self.custom_tooltip = QLabel(self)  # Parent is the dialog
            self.custom_tooltip.setObjectName("CustomTooltipLabel")  # For styling
            self.custom_tooltip.setStyleSheet(CUSTOM_TOOLTIP_STYLE)
            self.custom_tooltip.setWindowFlags(Qt.WindowType.ToolTip | Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint)
            self.custom_tooltip.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
            self.custom_tooltip.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose)  # Critical for proper cleanup

        # Update text and size
        self.custom_tooltip.setText(tooltip_text)
        self.custom_tooltip.adjustSize()

        # Calculate position
        try:
            # Get item rect relative to the list viewport
            viewport_rect = self.sessions_list.visualItemRect(item)
            # Map the bottom-left of the item rect to global coordinates
            global_pos = self.sessions_list.viewport().mapToGlobal(viewport_rect.bottomLeft())

            # Offset the tooltip slightly below and to the right
            tooltip_pos = global_pos + QPoint(5, 3)  # Adjust offset as needed

            # --- Screen Boundary Check ---
            screen = QApplication.screenAt(tooltip_pos)
            if not screen: screen = QApplication.primaryScreen()
            screen_rect = screen.availableGeometry()
            tooltip_rect = QRect(tooltip_pos, self.custom_tooltip.size())

            # Adjust horizontally if needed
            if tooltip_rect.right() > screen_rect.right():
                tooltip_pos.setX(screen_rect.right() - tooltip_rect.width() - 5)
            if tooltip_rect.left() < screen_rect.left():
                tooltip_pos.setX(screen_rect.left() + 5)

            # Adjust vertically if needed (prefer showing above if it overflows bottom)
            if tooltip_rect.bottom() > screen_rect.bottom():
                 # Map top-left of item to global
                 global_top_pos = self.sessions_list.viewport().mapToGlobal(viewport_rect.topLeft())
                 tooltip_pos.setY(global_top_pos.y() - tooltip_rect.height() - 3)  # Position above
                 # Recheck top boundary after moving above
                 if tooltip_pos.y() < screen_rect.top():
                     tooltip_pos.setY(screen_rect.top() + 5)  # Fallback to top edge

            # Move and show
            self.custom_tooltip.move(tooltip_pos)
            self.custom_tooltip.show()
            self._tooltip_item = item  # Mark which item this tooltip is for

        except Exception as e:
            print(f"Error positioning tooltip: {e}")
            self._hide_custom_tooltip()

    def _hide_custom_tooltip(self):
        """Hide the custom tooltip"""
        if self.custom_tooltip:
            self.custom_tooltip.hide()
            # Don't delete it, just hide it
        self._tooltip_item = None  # No item associated with tooltip anymore

    def eventFilter(self, source, event):
        """Handle events for window state monitoring only"""
        if source == self.main_window:
            if event.type() in [
                QEvent.Type.WindowStateChange,
                QEvent.Type.WindowActivate,
                QEvent.Type.Move,
                QEvent.Type.Resize,
                QEvent.Type.Show
            ]:
                self.raise_()
                self.activateWindow()
    
        return super().eventFilter(source, event)

    def moveEvent(self, event):
        """Handle window movement"""
        super().moveEvent(event)
        self.raise_()
        self.activateWindow()

    def resizeEvent(self, event):
        """Handle window resize"""
        super().resizeEvent(event)
        self.raise_()
        self.activateWindow()

    def changeEvent(self, event):
        """Handle window state changes"""
        if event.type() == QEvent.Type.WindowStateChange:
            if self.windowState() & Qt.WindowState.WindowMinimized:
                if not hasattr(self, 'is_manually_hidden'):
                    self.showMinimized()
                    if not hasattr(self, '_last_geometry'):
                        self._last_geometry = self.geometry()
            elif hasattr(self, '_last_geometry') and not (self.windowState() & Qt.WindowState.WindowMinimized):
                self.showNormal()
                self.setGeometry(self._last_geometry)
                del self._last_geometry
                if self.main_window.windowState() & Qt.WindowState.WindowMaximized:
                    self.raise_()
                    self.activateWindow()
        super().changeEvent(event)

    def init_ui(self):
        self.setWindowTitle("Scriptoria")
        self.setFixedSize(900, 600)
    
        # Main layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
    
        # Left panel (Welcome and Help)
        left_panel = QWidget()
        left_panel.setFixedWidth(300)
        left_panel.setStyleSheet("""
            QWidget {
                background-color: #203740;
                color: white;
            }
        """)
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(30, 40, 30, 40)
        left_layout.setSpacing(20)
    
        # Logo
        logo_label = QLabel()
        logo_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Img', 'delisimedia-header.png')
        logo_pixmap = QPixmap(logo_path)
        if not logo_pixmap.isNull():
            scaled_pixmap = logo_pixmap.scaled(200, 20, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
            logo_label.setPixmap(scaled_pixmap)
        logo_label.setAlignment(Qt.AlignmentFlag.AlignHCenter)
        left_layout.addWidget(logo_label)
    
        # Welcome text
        welcome_label = QLabel("Scriptoria")
        welcome_label.setStyleSheet("""
            QLabel {
                font-size: 24px;
                font-weight: bold;
                color: white;
            }
        """)
        welcome_label.setWordWrap(True)
        welcome_label.setAlignment(Qt.AlignmentFlag.AlignHCenter)
        left_layout.addWidget(welcome_label)
    
        # Version info
        version_label = QLabel("Version 2.5")
        version_label.setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 14px;")
        version_label.setAlignment(Qt.AlignmentFlag.AlignHCenter)
        #left_layout.addWidget(version_label)
    
        # Add spacer
        left_layout.addSpacing(20)
    
        # Quick help section
        help_container = QWidget()
        help_container.setStyleSheet("""
            QWidget {
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                margin-top: 10px;
            }
        """)
        help_layout = QVBoxLayout(help_container)
        help_layout.setContentsMargins(20, 30, 20, 30)
        help_layout.setSpacing(10)

        # Help items with updated text
        help_items = [
            ("💻", "Process video captions by removing timecodes and formatting in an external LLM."),
            ("📋", "Convert into stylized and structured documents."),
            ("✍️", "Organize content by assigning Themes. Highlight text by Themes."),
            ("📑", "Arrange and modify highlights in the Script Editor to create a video outline")
        ]

        for icon, text in help_items:
            item_widget = QWidget()
            item_widget.setStyleSheet("background: transparent;")
            item_layout = QHBoxLayout(item_widget)
            item_layout.setContentsMargins(0, 0, 0, 0)
            item_layout.setSpacing(5)
    
            # Icon with no background
            icon_label = QLabel(icon)
            icon_label.setStyleSheet("""
                font-size: 18px;
                background: transparent;
            """)
            item_layout.addWidget(icon_label)
    
            # Text with no background
            text_label = QLabel(text)
            text_label.setStyleSheet("""
                color: rgba(255, 255, 255, 0.9);
                font-size: 13px;
                background: transparent;
            """)
            text_label.setWordWrap(True)
            item_layout.addWidget(text_label, 1)
    
            help_layout.addWidget(item_widget)
    
        left_layout.addWidget(help_container)

        # Add watch demo button - COMMENTED OUT: video is outdated
        # watch_demo_btn = QPushButton("Watch Demo")
        # watch_demo_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        # watch_demo_btn.setStyleSheet("""
        #     QPushButton {
        #         background-color: rgba(255, 255, 255, 0.15);
        #         color: white;
        #         border: 1px solid rgba(255, 255, 255, 0.3);
        #         border-radius: 4px;
        #         padding: 8px 16px;
        #         font-size: 13px;
        #     }
        #     QPushButton:hover {
        #         background-color: rgba(255, 255, 255, 0.2);
        #         border: 1px solid rgba(255, 255, 255, 0.4);
        #     }
        #     QPushButton:pressed {
        #         background-color: rgba(255, 255, 255, 0.1);
        #     }
        # """)
        # watch_demo_btn.clicked.connect(self.show_demo_video)
        # watch_demo_btn.setDefault(False)  # Prevent spacebar from triggering
        # watch_demo_btn.setAutoDefault(False)  # Prevent automatic default behavior
        # left_layout.addWidget(watch_demo_btn, alignment=Qt.AlignmentFlag.AlignCenter)

        left_layout.addStretch()
    
        # Right panel (Actions)
        right_panel = QWidget()
        right_panel.setStyleSheet("""
            QWidget {
                background-color: white;
            }
        """)
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(40, 40, 40, 40)
        right_layout.setSpacing(30)
    
        # Get Started section
        get_started_label = QLabel("Get Started")
        get_started_label.setStyleSheet("""
            QLabel {
                font-size: 20px;
                font-weight: bold;
                color: #203740;
                border: none;
            }
        """)
        right_layout.addWidget(get_started_label)
    
        # New Session button
        new_session_btn = QPushButton("Create New Session")
        new_session_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        new_session_btn.setStyleSheet("""
            QPushButton {
                background-color: #DCF3E5;     
                color: #333333;                   
                border: 1px solid #cccccc;        
                border-radius: 4px;              
                padding: 10px 20px;                
                font-size: 14px;                     
                font-weight: normal;                 
                text-align: center;                     
                min-width: 180px;                     
            }
            QPushButton:hover {
                background-color: #CAEADB;           
                border: 1px solid #b3b3b3;           
            }
            QPushButton:pressed {
                background-color: #B8E1CF;           
                border: 1px solid #999999;           
            }
        """)
        new_session_btn.clicked.connect(self.create_new_session)
        right_layout.addWidget(new_session_btn)
    
        # Recent Sessions section
        recent_label = QLabel("Recent Sessions")
        recent_label.setStyleSheet("""
            QLabel {
                font-size: 20px;
                font-weight: bold;
                color: #203740;
                margin-top: 20px;
                border: none;
            }
        """)
        right_layout.addWidget(recent_label)
    
        # Sessions list with improved styling
        self.sessions_list = QListWidget()
        # Disable native tooltips
        self.sessions_list.setToolTipDuration(0)
        self.sessions_list.setStyleSheet("""
            QListWidget {
                border: 1px solid #e0e0e0;
                border-radius: 6px;
                background: white;
                outline: none;
                padding: 2px;
            }
            QListWidget::item {
                padding: 0px;
                border-bottom: 1px solid #e0e0e0;
                min-height: 40px;
                background-color: #f9f9f9;
                margin: 2px;
                border-radius: 4px;
            }
            QListWidget::item:last-child {
                border-bottom: none;
            }
            QListWidget::item:selected {
                background-color: #e3f2fd;
                border: 1px solid #90caf9;
            }
            QListWidget::item:hover:!selected {
                background-color: #eaeaea;
            }
            QScrollBar:vertical {
                border: none;
                background: #f5f5f5;
                width: 6px;
                margin: 0px;
            }
            QScrollBar::handle:vertical {
                background: #c1c1c1;
                min-height: 20px;
                border-radius: 3px;
            }
            QScrollBar::handle:vertical:hover {
                background: #a8a8a8;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
                background: none;
            }
        """)

        # Enable mouse tracking for the list and viewport
        self.sessions_list.setMouseTracking(True)
        self.sessions_list.viewport().setMouseTracking(True)
        self.sessions_list.installEventFilter(self)

        self.sessions_list.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.sessions_list.customContextMenuRequested.connect(self.show_context_menu)
        self.sessions_list.itemClicked.connect(self.load_selected_session)
        self.sessions_list.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        right_layout.addWidget(self.sessions_list)
    
        # Browse button
        browse_btn = QPushButton("Browse Sessions...")
        browse_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        browse_btn.setStyleSheet("""
            QPushButton {
                background-color: #f5f5f5;
                color: #203740;
                border: 1px solid #e0e0e0;
                border-radius: 6px;
                padding: 12px;
                font-size: 14px;
                text-align: center;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
        """)
        browse_btn.clicked.connect(self.browse_session)
        right_layout.addWidget(browse_btn)
    
        # Add panels to main layout
        layout.addWidget(left_panel)
        layout.addWidget(right_panel, 1)
    
        # Center dialog on screen
        self.center_on_screen()
    
        # Populate recent sessions
        self.populate_recent_sessions()

    # --------------------- Recent Sessions Management ---------------------

    def load_recent_sessions(self):
        """Load recent sessions from a JSON file."""
        try:
            # Determine the program directory
            if getattr(sys, "frozen", False):
                program_dir = os.path.dirname(sys.executable)
            else:
                program_dir = os.path.dirname(os.path.abspath(__file__))
            
            data_folder = os.path.join(program_dir, "Data")
            file_path = os.path.join(data_folder, "recent_sessions.json")
    
            if os.path.exists(file_path):
                with open(file_path, "r", encoding="utf-8") as f:
                    sessions_list = json.load(f)
                # Convert list to dictionary for easier management
                self.recent_sessions = {
                    os.path.basename(session["path"]): {
                        "path": session["path"],
                        "last_accessed": session.get("last_accessed", "Unknown")
                    }
                    for session in sessions_list
                }
            else:
                self.recent_sessions = {}
        except Exception as e:
            print(f"Error loading recent sessions: {e}")
            self.recent_sessions = {}

    # COMMENTED OUT: demo video is outdated - may add back when updated
    # def show_demo_video(self):
    #     """Open the demo video in the system's default video player."""
    #     video_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Img', 'scriptoria_demo.mp4')
    # 
    #     if os.path.exists(video_path):
    #         try:
    #             # Use QDesktopServices to open the video with default player
    #             from PyQt6.QtGui import QDesktopServices
    #             from PyQt6.QtCore import QUrl
    #         
    #             url = QUrl.fromLocalFile(video_path)
    #             if not QDesktopServices.openUrl(url):
    #                 # If QDesktopServices fails, try the system-specific approach
    #                 if sys.platform.startswith('darwin'):  # macOS
    #                     subprocess.call(['open', video_path])
    #                 elif sys.platform.startswith('win'):  # Windows
    #                     os.startfile(video_path)
    #                 else:  # Linux
    #                     subprocess.call(['xdg-open', video_path])
    #         except Exception as e:
    #             QMessageBox.warning(self, "Error", f"Could not open demo video: {str(e)}")
    #     else:
    #         QMessageBox.warning(self, "Error", f"Demo video not found: {video_path}")
    
    def save_recent_sessions(self):
        """Save the list of recent sessions to a JSON file in the program's directory."""
        try:
            # Determine the program directory
            if getattr(sys, "frozen", False):
                program_dir = os.path.dirname(sys.executable)
            else:
                program_dir = os.path.dirname(os.path.abspath(__file__))
            
            # Create Data folder path
            data_folder = os.path.join(program_dir, "Data")
            file_path = os.path.join(data_folder, "recent_sessions.json")
    
            # Ensure the Data folder exists
            if not os.path.exists(data_folder):
                os.makedirs(data_folder, exist_ok=True)
    
            # Prepare the session data
            sessions_list = [
                {
                    "path": session_data["path"],
                    "last_accessed": session_data["last_accessed"]
                }
                for session_data in self.recent_sessions.values()
            ]
    
            # Save the JSON file
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(sessions_list, f, indent=4)
        except Exception as e:
            print(f"Error saving recent sessions: {e}")
    
    def parse_timestamp_to_sortable_key(self, timestamp_text):
        """
        Converts any timestamp format to a sortable string key.
        Returns a string in format 'yyyyMMddHHmmss' for proper sorting.
        """
        # Default return value for invalid dates (very old date)
        default_key = "19700101000000"
    
        # Handle new format: "Accessed: h:mm AP on MM.dd.yy"
        if timestamp_text.startswith("Accessed:"):
            try:
                # Extract time and date parts
                parts = timestamp_text.split("Accessed: ")[1]
                time_part = parts.split(" on ")[0].strip()  # h:mm AP
                date_part = parts.split(" on ")[1].strip()  # MM.dd.yy
            
                # Parse MM.dd.yy
                month, day, short_year = date_part.split(".")
                year = "20" + short_year  # Assuming 20xx
            
                # Parse h:mm AP
                time_val, am_pm = time_part.rsplit(" ", 1)
                hour, minute = time_val.split(":")
                hour = int(hour)
            
                # Convert to 24-hour format
                if am_pm.upper() == "PM" and hour < 12:
                    hour += 12
                elif am_pm.upper() == "AM" and hour == 12:
                    hour = 0
            
                # Format as sortable string: yyyyMMddHHmmss
                return f"{year}{month.zfill(2)}{day.zfill(2)}{str(hour).zfill(2)}{minute.zfill(2)}00"
            except Exception as e:
                print(f"Error parsing 'Accessed:' format: {timestamp_text}, Error: {e}")
    
        # Handle ISO format: "yyyy-MM-dd HH:mm:ss"
        elif "-" in timestamp_text and ":" in timestamp_text and len(timestamp_text) >= 16:
            try:
                # Extract date and time parts
                date_part, time_part = timestamp_text.split(" ", 1)
                year, month, day = date_part.split("-")
                hour, minute, second = time_part.split(":")
            
                # Format as sortable string: yyyyMMddHHmmss
                return f"{year}{month}{day}{hour}{minute}{second}"
            except Exception as e:
                print(f"Error parsing ISO format: {timestamp_text}, Error: {e}")
    
        # For any other format, try Qt date parsing as last resort
        try:
            dt = QDateTime.fromString(timestamp_text, Qt.DateFormat.TextDate)
            if dt.isValid():
                return dt.toString("yyyyMMddhhmmss")
        except:
            pass
        
        print(f"Failed to parse timestamp: {timestamp_text}, using default sorting")
        return default_key

    def add_to_recent_sessions(self, file_path):
        """Add a new session while managing the maximum limit."""
        now_dt = QDateTime.currentDateTime()
        time_str = now_dt.toString("h:mm AP")
        date_str = now_dt.toString("MM.dd.yy")
        formatted_timestamp = f"Accessed: {time_str} on {date_str}"
    
        basename = os.path.basename(file_path)

        # If entry already exists, just update timestamp
        if basename in self.recent_sessions:
            self.recent_sessions[basename]["last_accessed"] = formatted_timestamp
            self.recent_sessions[basename]["path"] = file_path
        else:
            # Remove oldest entry if limit reached
            if len(self.recent_sessions) >= 10:
                # Sort by timestamp to find the oldest
                sorted_sessions = sorted(
                    self.recent_sessions.items(),
                    key=lambda x: self.parse_timestamp_to_sortable_key(x[1]["last_accessed"])
                )
            
                # Delete the oldest (first item after sorting)
                if sorted_sessions:
                    del self.recent_sessions[sorted_sessions[0][0]]
        
            # Add new entry
            self.recent_sessions[basename] = {
                "path": file_path,
                "last_accessed": formatted_timestamp
            }

        self.save_recent_sessions()
        self.populate_recent_sessions()
    
    def remove_session(self, item):
        """Remove a session from the list and update storage."""
        file_path = item.data(Qt.ItemDataRole.UserRole)
        if not file_path:
            row = self.sessions_list.row(item)
            if row >= 0:
                self.sessions_list.takeItem(row)
            return
    
        basename = os.path.basename(file_path)
    
        if basename in self.recent_sessions:
            del self.recent_sessions[basename]
            row = self.sessions_list.row(item)
            if row >= 0:
                self.sessions_list.takeItem(row)
        
            self.save_recent_sessions()
        
        self.populate_recent_sessions()
    
    # --------------------- UI Interaction Methods ---------------------
    
    def show_context_menu(self, position):
        """Show context menu for list items."""
        item = self.sessions_list.itemAt(position)
        if item:
            menu = QMenu()
            menu.setStyleSheet("""
                QMenu {
                    background-color: white;
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    padding: 4px;
                    box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1);
                }
                QMenu::item {
                    padding: 8px 24px;
                    border-radius: 2px;
                }
                QMenu::item:selected {
                    background-color: #e3f2fd;
                    color: #2C4952;
                }
            """)
    
            remove_action = menu.addAction("Remove from Recent")
            action = menu.exec(self.sessions_list.mapToGlobal(position))
    
            if action == remove_action:
                self.remove_session(item)
    
    def center_on_screen(self):
        """Center the dialog on the screen."""
        screen = QApplication.primaryScreen().geometry()
        x = (screen.width() - self.width()) // 2
        y = (screen.height() - self.height()) // 2
        self.move(x, y)
    
    def populate_recent_sessions(self):
        """Populate the recent sessions list in the UI with proper chronological sorting."""
        self.sessions_list.clear()

        if not self.recent_sessions:
            # Add placeholder item
            placeholder = QListWidgetItem("No recent sessions")
            placeholder.setFlags(placeholder.flags() & ~Qt.ItemFlag.ItemIsEnabled)
            placeholder.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.sessions_list.addItem(placeholder)
            return

        # Sort sessions by timestamp (newest first)
        sorted_sessions = sorted(
            self.recent_sessions.items(),
            key=lambda x: self.parse_timestamp_to_sortable_key(x[1]["last_accessed"]),
            reverse=True  # Most recent first
        )

        def format_timestamp(timestamp_text):
            """Format or convert timestamp to our standard format"""
            if timestamp_text.startswith("Accessed:"):
                return timestamp_text
    
            try:
                # Try to parse different timestamp formats
                if "-" in timestamp_text and len(timestamp_text) > 16:
                    # Parse ISO format (yyyy-MM-dd HH:mm:ss)
                    date_part, time_part = timestamp_text.split(" ", 1)
                    year, month, day = date_part.split("-")
                    hour, minute, second = time_part.split(":")
    
                    # Convert hour to 12-hour format
                    hour_int = int(hour)
                    am_pm = "AM"
                    if hour_int >= 12:
                        am_pm = "PM"
                        if hour_int > 12:
                            hour_int -= 12
                    elif hour_int == 0:
                        hour_int = 12
    
                    # Format in new style
                    return f"Accessed: {hour_int}:{minute} {am_pm} on {month}.{day}.{year[2:]}"
            except Exception:
                pass
    
            return timestamp_text  # Return original if parsing fails

        def truncate_name(name, max_length=40):
            clean_name = name.replace('.session', '')  # Remove extension
            if len(clean_name) <= max_length:
                return clean_name, False  # Not truncated
            return clean_name[:max_length-3] + "...", True  # Truncated

        for basename, session in sorted_sessions:
            path = session.get('path', '')
            timestamp_text = session.get('last_accessed', 'Unknown')
            formatted_timestamp = format_timestamp(timestamp_text)

            if path:
                # Get full name before truncation for tooltip
                full_session_name = os.path.basename(path).replace('.session', '')
                # Truncate name for display and get truncation flag
                truncated_session_name, was_truncated = truncate_name(full_session_name)

                # Create container widget with transparent background
                container = QWidget()
                container.setStyleSheet("background-color: transparent; border: none;")
                container_layout = QHBoxLayout(container)
                container_layout.setContentsMargins(12, 8, 12, 8)
                container_layout.setSpacing(8)
                container.setCursor(Qt.CursorShape.PointingHandCursor)
    
                # Add small circle indicator
                circle_indicator = QLabel()
                circle_indicator.setFixedSize(8, 8)
                circle_indicator.setStyleSheet("""
                    QLabel {
                        background-color: #2C4952;
                        border-radius: 4px;
                        border: none;
                    }
                """)
                container_layout.addWidget(circle_indicator)

                # Session name label with padding for descenders
                name_label = QLabel(truncated_session_name)
                name_label.setStyleSheet("""
                    QLabel {
                        font-size: 14px;
                        font-weight: bold;
                        color: #203740;
                        background: transparent;
                        border: none;
                        padding-bottom: 2px;
                        min-height: 18px;
                    }
                """)
                container_layout.addWidget(name_label)
    
                # Add stretch to push the date label to the right
                container_layout.addStretch()

                # Last accessed label
                date_label = QLabel(formatted_timestamp)
                date_label.setStyleSheet("""
                    QLabel {
                        font-size: 12px;
                        color: #666666;
                        background: transparent;
                        border: none;
                    }
                """)
                container_layout.addWidget(date_label)

                # Create list item
                item = QListWidgetItem()
                item.setData(Qt.ItemDataRole.UserRole, path)
            
                # Only set tooltip if the name was truncated
                if was_truncated:
                    item.setToolTip(full_session_name)
            
                item.setSizeHint(container.sizeHint())

                self.sessions_list.addItem(item)
                self.sessions_list.setItemWidget(item, container)
    
    def create_new_session(self):
        """Handle the creation of a new session."""
        dialog = NewSessionDialog(self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            session_info = {
                'type': 'new',
                'data': dialog.get_session_info()
            }
            # Assuming session_info contains the path to the new session
            # If not, adjust accordingly
            new_session_path = session_info['data'].get('path')
            if new_session_path:
                self.add_to_recent_sessions(new_session_path)
            self.session_info = session_info
            self.accept()
    
    def load_selected_session(self, item):
        """Handle the selected recent session with error handling and drive letter fallback."""
        print("\n=== LOAD SELECTED START ===")

        if not item:
            print("No item selected. Exiting method.")
            print("=== LOAD SELECTED END ===\n")
            return

        file_path = item.data(Qt.ItemDataRole.UserRole)
        print(f"Item: {item}, File path retrieved from item: {file_path}")

        # Step 1: Check if the file exists at the specified path
        if not os.path.exists(file_path):
            print(f"File not found at path: {file_path}")

            # Step 2: Attempt to rebuild the path using the program's drive letter
            if getattr(sys, 'frozen', False):
                # If running as an executable, the base directory is where the executable is
                program_dir = os.path.dirname(sys.executable)
            else:
                # If running as a script, the base directory is where the script is
                program_dir = os.path.dirname(os.path.abspath(__file__))

            program_drive = os.path.splitdrive(program_dir)[0]
            print(f"Program drive letter: {program_drive}")

            stored_drive, relative_path = os.path.splitdrive(file_path)
            print(f"Stored drive: {stored_drive}, Relative path: {relative_path}")

            rebuilt_path = program_drive + os.path.sep + relative_path.lstrip("\\/")

            print(f"Rebuilt path: {rebuilt_path}")

            # Check if the file exists at the rebuilt path
            if os.path.exists(rebuilt_path):
                print(f"File found at rebuilt path: {rebuilt_path}")
                file_path = rebuilt_path  # Update the file path
            else:
                print(f"File not found at rebuilt path: {rebuilt_path}")

                # Step 3: Prompt the user to locate the file manually
                reply = QMessageBox.question(
                    self,
                    "File Not Found",
                    f"Cannot find file in:\n{file_path}\n\nWould you like to update its location?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.Yes
                )
                print(f"User response to update location: {reply}")

                if reply == QMessageBox.StandardButton.Yes:
                    file_dialog = QFileDialog(self)
                    file_dialog.setWindowTitle("Update Session File Location")
                    file_dialog.setNameFilter("Session Files (*.session);;All Files (*)")
                    file_dialog.setFileMode(QFileDialog.FileMode.ExistingFile)
                    file_dialog.setViewMode(QFileDialog.ViewMode.Detail)

                    if file_dialog.exec() == QDialog.DialogCode.Accepted:
                        new_path = file_dialog.selectedFiles()[0]
                        print(f"New path selected by user: {new_path}")
                        print(f"Original file_path before update: {file_path}") # Debugging print
                        try:
                            # Test if new file is readable
                            with open(new_path, 'r', encoding='utf-8') as f:
                                f.read(1)

                            # Update file_path to the new path FIRST
                            file_path = new_path
                            # Now get the basename from the new path
                            basename = os.path.basename(file_path)
                            print(f"Basename for session update: {basename}")
                            print(f"Recent sessions keys before check: {self.recent_sessions.keys()}") # Debugging

                            if basename in self.recent_sessions:
                                print(f"Updating recent session with new path: {new_path}")
                                self.add_to_recent_sessions(new_path)  # Update timestamp and path
                                # file_path is already new_path
                            else:
                                print(f"Basename '{basename}' not found in recent sessions.") # Debugging
                        except (PermissionError, OSError) as e:
                            print(f"Error opening file at new path: {e}")
                            QMessageBox.critical(
                                self,
                                "Error",
                                f"Could not open the session file:\n{new_path}\n\nError: {str(e)}"
                            )
                            self.remove_session(item)
                            print("=== LOAD SELECTED END ===\n")
                            return
                    else:
                        print("User canceled file selection.")
                        self.remove_session(item)
                        print("=== LOAD SELECTED END ===\n")
                        return
                else:
                    print("User chose not to update file location.")
                    self.remove_session(item)
                    print("=== LOAD SELECTED END ===\n")
                    return

        try:
            # Test if file is readable
            print(f"Testing readability of file: {file_path}")
            with open(file_path, 'r', encoding='utf-8') as f:
                f.read(1)

            # Update recent sessions
            print(f"Adding file to recent sessions: {file_path}")
            self.add_to_recent_sessions(file_path)
            self.session_info = {
                'type': 'load',
                'data': file_path
            }
            print(f"File successfully loaded: {file_path}")
            self.accept()

        except (PermissionError, OSError) as e:
            print(f"Error reading file: {file_path}, Error: {e}")
            QMessageBox.critical(
                self,
                "Error",
                f"Could not open the session file:\n{file_path}\n\nError: {str(e)}"
            )
            self.remove_session(item)

        print("=== LOAD SELECTED END ===\n")

    
    def browse_session(self):
        """Browse for a new session file."""
        file_dialog = QFileDialog(self)
        file_dialog.setWindowTitle("Browse Sessions...")
        file_dialog.setNameFilter("Session Files (*.session);;All Files (*)")
        file_dialog.setFileMode(QFileDialog.FileMode.ExistingFile)
        file_dialog.setViewMode(QFileDialog.ViewMode.Detail)

        if file_dialog.exec() == QDialog.DialogCode.Accepted:
            selected_files = file_dialog.selectedFiles()
            if selected_files:
                file_path = selected_files[0]
        
                try:
                    # Test if file is readable
                    with open(file_path, 'r', encoding='utf-8') as f:
                        f.read(1)
                
                    # Add to recent sessions
                    self.add_to_recent_sessions(file_path)
                    self.session_info = {
                        'type': 'load',
                        'data': file_path
                    }
                    self.accept()
            
                except (PermissionError, OSError) as e:
                    QMessageBox.critical(
                        self,
                        "Error",
                        f"Could not open the session file:\n{file_path}\n\nError: {str(e)}"
                    )

    def get_session_info(self):
        """Return the selected session information."""
        return self.session_info

class NewSessionDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.init_ui()
        
    def init_ui(self):
        self.setWindowTitle("New Session")
        self.setMinimumWidth(500)
        self.setFixedHeight(260)
        
        # Main layout
        layout = QVBoxLayout(self)
        layout.setSpacing(20)
        layout.setContentsMargins(30, 30, 30, 30)

        # Title label
        title_label = QLabel("Create New Session")
        title_label.setStyleSheet("""
            QLabel {
                font-size: 18px;
                font-weight: bold;
                color: #203740;
            }
        """)
        layout.addWidget(title_label)

        # Form layout for inputs
        form = QFormLayout()
        form.setSpacing(15)
        form.setContentsMargins(0, 10, 0, 0)

        # Session name input with character count
        self.name_container = QWidget()
        name_layout = QVBoxLayout(self.name_container)
        name_layout.setContentsMargins(0, 0, 0, 0)
        name_layout.setSpacing(4)

        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Enter session name...")
        self.name_edit.setMaxLength(50)
        self.name_edit.setStyleSheet("""
            QLineEdit {
                padding-left: 2px;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                line-height: 2;
                min-height: 30px;
                font-size: 14px;
                background: white;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
        """)
        name_layout.addWidget(self.name_edit)

        # Character counter
        self.char_count = QLabel("0/50")
        self.char_count.setStyleSheet("""
            QLabel {
                color: #666666;
                font-size: 11px;
                margin-right: 4px;
            }
        """)
        self.char_count.setAlignment(Qt.AlignmentFlag.AlignRight)
        #name_layout.addWidget(self.char_count)

        # Location selection
        self.location_container = QWidget()
        location_layout = QHBoxLayout(self.location_container)
        location_layout.setContentsMargins(0, 0, 0, 0)
        location_layout.setSpacing(8)

        self.location_edit = QLineEdit()
        self.location_edit.setReadOnly(True)
        self.location_edit.setPlaceholderText("Choose save location...")
        self.location_edit.setStyleSheet("""
            QLineEdit {
                padding: 8px;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                font-size: 13px;
                background: #f8f9fa;
            }
        """)
        location_layout.addWidget(self.location_edit)

        self.browse_button = QPushButton("Browse...")
        self.browse_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.browse_button.setStyleSheet("""
            QPushButton {
                padding: 8px 16px;
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                color: #444;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #e9ecef;
                border-color: #dee2e6;
            }
            QPushButton:pressed {
                background-color: #dee2e6;
            }
        """)
        location_layout.addWidget(self.browse_button)

        # Add rows to form
        form.addRow("Session Name:", self.name_container)
        form.addRow("Save Location:", self.location_container)
        layout.addLayout(form)

        # Add stretch to push buttons to bottom
        layout.addStretch()

        # Button box
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | 
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.button(QDialogButtonBox.StandardButton.Ok).setText("Create")
        button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(False)
        
        # Style buttons
        for button in button_box.buttons():
            if button_box.buttonRole(button) == QDialogButtonBox.ButtonRole.AcceptRole:
                button.setStyleSheet("""
                    QPushButton {
                        padding: 8px 16px;
                        background-color: #203740;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        min-width: 80px;
                        font-size: 13px;
                    }
                    QPushButton:hover {
                        background-color: #2C4952;
                    }
                    QPushButton:disabled {
                        background-color: #cccccc;
                    }
                """)
            else:
                button.setStyleSheet("""
                    QPushButton {
                        padding: 8px 16px;
                        background-color: #f8f9fa;
                        border: 1px solid #dee2e6;
                        border-radius: 4px;
                        min-width: 80px;
                        font-size: 13px;
                    }
                    QPushButton:hover {
                        background-color: #e9ecef;
                    }
                """)

        layout.addWidget(button_box)

        # Connect signals
        self.name_edit.textChanged.connect(self.update_char_count)
        self.name_edit.textChanged.connect(self.validate_inputs)
        self.browse_button.clicked.connect(self.browse_location)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        # Ensure the "Create" button is properly initialized
        self.validate_inputs()

        # Center dialog on screen
        self.center_on_screen()

    def center_on_screen(self):
        # Get the screen geometry
        screen = QApplication.primaryScreen().geometry()
        # Calculate position
        x = (screen.width() - self.width()) // 2
        y = (screen.height() - self.height()) // 2
        self.move(x, y)

    def update_char_count(self, text):
        count = len(text)
        self.char_count.setText(f"{count}/50")
        if count >= 40:
            self.char_count.setStyleSheet("color: #ff9800; font-size: 11px;")  # Warning color
        else:
            self.char_count.setStyleSheet("color: #666666; font-size: 11px;")

    def validate_inputs(self):
        name = self.name_edit.text().strip()
        invalid_chars = r'<>:"/\|?*'

        # Check for invalid characters
        if any(c in invalid_chars for c in name):
            QMessageBox.warning(
                self,
                "Invalid Characters",
                "The session title contains invalid characters:\n< > : \" / \\ | ? *\nThey will be removed automatically."
            )
            # Remove invalid characters from the name
            sanitized_name = ''.join(c for c in name if c not in invalid_chars)
            self.name_edit.setText(sanitized_name)
            return

        # Always enable the "Create" button
        ok_button = self.findChild(QDialogButtonBox).button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setEnabled(True)

    def browse_location(self):
        default_name = self.name_edit.text().strip() or "New Session"
        file_name, _ = QFileDialog.getSaveFileName(
            self,
            "Save Session",
            f"{default_name}.session",
            "Session Files (.session);;"
        )
    
        if file_name:
            if not file_name.endswith('.session'):
                file_name += '.session'
            self.location_edit.setText(file_name)  # Set only if user selects a location
        else:
            self.location_edit.clear()  # Ensure no location is set if canceled
        self.validate_inputs()

    def get_session_info(self):
        name = self.name_edit.text().strip() or "New Session"
        location = self.location_edit.text().strip()  # Return an empty string if no location is set
        return {
            'name': name,
            'location': location  # Keep empty if user didn't specify a location
        }

class ThemeNameEdit(QLineEdit):
    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        self.char_count_color = QColor("#666")
        self.setMaxLength(40)
        
        # Set minimal left margin for proper spacing
        self.setTextMargins(2, 0, 55, 0)  
        self.setAlignment(Qt.AlignmentFlag.AlignLeft)  # Left-align text for display
        self.setCursorPosition(0)  # Ensure text displays from the beginning initially

        # Allow typing from the end when focusing the field
        self.textChanged.connect(self.scroll_to_end_on_edit)

    def scroll_to_end_on_edit(self):
        """Move the cursor to the end when typing."""
        self.setCursorPosition(len(self.text()))  # Allow typing from the end

    def update_char_count_color(self):
        """Update the character counter color."""
        if len(self.text()) >= 35:
            self.char_count_color = QColor("#ff9800")  # Warning color
        else:
            self.char_count_color = QColor("#666")  # Normal color
        self.update()  

    def paintEvent(self, event):
        """Custom paint event to draw the character count."""
        super().paintEvent(event)
        
        painter = QPainter(self)
        painter.setPen(self.char_count_color)
        
        # Use a smaller font for the counter
        font = painter.font()
        font.setPointSize(8)
        painter.setFont(font)
        
        # Calculate text width and position for the counter
        count_text = f"{len(self.text())}/40"
        text_width = painter.fontMetrics().horizontalAdvance(count_text)
        
        # Position the counter on the right side with padding
        x = self.width() - text_width - 8  
        y = (self.height() + painter.fontMetrics().ascent() - painter.fontMetrics().descent()) // 2
        
        painter.drawText(x, y, count_text)

    def closeEvent(self, event):
        self._hide_custom_tooltip() # Hide tooltip immediately
        # Stop the timer if it's active
        if hasattr(self, '_tooltip_timer') and self._tooltip_timer.isActive():
            self._tooltip_timer.stop()
        # Explicitly delete the tooltip widget if it exists
        if self.custom_tooltip:
            self.custom_tooltip.deleteLater()
            self.custom_tooltip = None
        super().closeEvent(event)

class CreateTranscriptTextEdit(QTextEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
    
        # Initialize syntax highlighter for headers
        self.header_highlighter = HeaderSyntaxHighlighter(self.document())
        
        # Store reference to self in highlighter for active tab checking
        self.header_highlighter.editor = self
    
        # Set default font and styling
        default_font = self.font()
        default_font.setPointSize(13)
        self.setFont(default_font)
    
        # Set explicit text color
        self.setTextColor(QColor(0, 0, 0))  # Black
    
        # Create a timer for debouncing
        self.check_timer = QTimer()
        self.check_timer.setSingleShot(True)
        self.check_timer.timeout.connect(self._perform_orphaned_check)
    
        # Processing lock flag
        self._is_processing = False
    
        # Connect text changes directly  
        self.textChanged.connect(self._schedule_orphaned_check)
        # Note: _notify_changes_pending is already called in _on_text_changed, but we add this for direct textChanged events
        
        # Store original event handlers
        self._original_focus_in_event = self.focusInEvent
        
        # Replace with our custom handlers (but don't keep checking them)
        if not hasattr(self, '_handlers_replaced'):
            self.focusInEvent = self._enhanced_focus_in_event
            self._handlers_replaced = True
            
        # Add flags to prevent recursive operations
        self._is_processing_text = False
        self._visibility_checked = False
        self._visibility_ensured = False  # Add this missing attribute
        self._last_check_time = time.time()

        # Use a single timer with a state flag
        self.keypress_timer = QTimer()
        self.keypress_timer.setSingleShot(True)
        self.keypress_timer.timeout.connect(self._perform_orphaned_check)

        # Add cancellation flags
        self._orphan_check_active = False
        self._header_refresh_active = False
        self._cancel_requested = False
        
        # Add last keystroke timestamp
        self._last_keystroke_time = time.time()
        
        # Typing-aware timer to monitor active operations
        self._operation_monitor = QTimer()
        self._operation_monitor.setSingleShot(False)  # Continuous monitoring
        self._operation_monitor.setInterval(100)  # Check every 100ms
        self._operation_monitor.timeout.connect(self._check_operation_status)
        self._operation_monitor.start()
    
        # Flag to indicate pending changes
        self._has_pending_changes = False
    
        # Processing lock
        self._is_processing = False
    
        # Connect to textChanged directly
        self.textChanged.connect(self._on_text_changed)
        
    def is_on_active_tab(self):
        """
        Check if this widget is on the currently active tab.
        Returns True if on active tab, False otherwise.
        """
        try:
            # Navigate up through parent chain to find main window with tabs
            parent = self.parent()
            while parent:
                # Check if this parent has a tabs attribute and we're in the current widget
                if hasattr(parent, 'tabs') and hasattr(parent.tabs, 'currentWidget'):
                    current_widget = parent.tabs.currentWidget()
                    input_widget = parent.input_widget if hasattr(parent, 'input_widget') else None
                    
                    # Check if we're on the input tab
                    if input_widget is current_widget:
                        return True
                    
                    # Check if we're a child of the current widget
                    if self.isAncestorOf(current_widget) or current_widget.isAncestorOf(self):
                        return True
                    
                    # Not on active tab
                    return False
                
                # Move up to next parent
                parent = parent.parent()
            
            # If we can't determine, check if we're visible as fallback
            return self.isVisibleTo(self.window())
            
        except Exception as e:
            print(f"[is_on_active_tab] Error: {e}")
            # Default to True if there's an error to avoid suppressing highlighting
            return True

    def _debug_timestamp(self):
        """Generate timestamp for debug messages"""
        # Format: [HH:MM:SS.mmm]
        current_time = QTime.currentTime()
        return f"[{current_time.toString('HH:mm:ss.zzz')}]"


    def _on_text_changed(self):
        """Optimized unified handler for text changes with cross-class loop prevention"""
        start_time = time.time()
        #print(f"{self._debug_timestamp()} [on_text_changed] STARTED")
    
        # LOOP PREVENTION 1: Skip if parent is updating headers
        parent = self.parent()
        if parent and hasattr(parent, '_updating_headers') and parent._updating_headers:
            #print(f"{self._debug_timestamp()} [on_text_changed] Parent is updating headers, skipping to prevent loop")
            return
    
        # LOOP PREVENTION 2: Skip if already handling a key event
        if hasattr(self, '_handling_key_event') and self._handling_key_event:
            #print(f"{self._debug_timestamp()} [on_text_changed] Already handling key event, skipping duplicate processing")
            return
    
        # LOOP PREVENTION 3: Skip if header refresh has suppressed orphaned checks
        if parent and hasattr(parent, '_suppress_orphaned_check') and parent._suppress_orphaned_check:
            #print(f"{self._debug_timestamp()} [on_text_changed] Orphaned check suppressed by parent, skipping")
            return
    
        # Track changes state
        was_already_pending = self._has_pending_changes
        self._has_pending_changes = True
    
        # OPTIMIZATION: Hash-based change detection to avoid redundant processing
        current_text = self.toPlainText()
        text_length = len(current_text)
        #print(f"{self._debug_timestamp()} [on_text_changed] Processing text change, length: {text_length} chars")
    
        if text_length > 1000:
            # For longer texts, use hash comparison for efficiency
            current_hash = hash(current_text)
            hash_changed = not hasattr(self, '_last_text_hash') or self._last_text_hash != current_hash
            length_changed = not hasattr(self, '_last_text_len') or self._last_text_len != text_length
        
            if not hash_changed and not length_changed:
                #print(f"{self._debug_timestamp()} [on_text_changed] No meaningful change detected, skipping")
                return
        
            # Update tracking info with changes
            if not hasattr(self, '_last_text_hash') or self._last_text_hash != current_hash:
                #print(f"{self._debug_timestamp()} [on_text_changed] Text hash changed")
                self._last_text_hash = current_hash
            
            if not hasattr(self, '_last_text_len') or self._last_text_len != text_length:
                #print(f"{self._debug_timestamp()} [on_text_changed] Text length changed: {getattr(self, '_last_text_len', 0)} → {text_length}")
                self._last_text_len = text_length
    
        # Reset any existing timer
        if self.keypress_timer.isActive():
            print(f"{self._debug_timestamp()} [on_text_changed] Stopping existing timer")
            self.keypress_timer.stop()
    
        # OPTIMIZATION: Adaptive delay based on text characteristics
        if text_length > 10000:
            # For very large documents
            delay = 1000
            delay_reason = "large document"
        elif '**' in current_text or '[[' in current_text:
            # Documents with headers need more processing
            delay = 800
            delay_reason = "contains headers"
        else:
            # Simple documents
            delay = 500
            delay_reason = "simple document"
    
        # Start a new timer
        #print(f"{self._debug_timestamp()} [on_text_changed] Starting timer with {delay}ms delay ({delay_reason})")
        self.keypress_timer.start(delay)
    
        # Always notify parent on text changes (main window handles deduplication)
        self._notify_changes_pending()
    
        # Calculate and log execution time
        elapsed_ms = int((time.time() - start_time) * 1000)
        #print(f"{self._debug_timestamp()} [on_text_changed] COMPLETED in {elapsed_ms}ms")

    def _notify_changes_pending(self):
        """Notify the main window that changes are pending"""
        # Find the main window parent
        parent = self.parent()
        while parent and not hasattr(parent, "mark_changes_pending"):
            parent = parent.parent()
    
        # If we found the main window, notify it only if not loading a session
        if parent and hasattr(parent, "mark_changes_pending"):
            # Check if we're loading a session - if so, don't mark changes
            if hasattr(parent, "is_loading_session") and parent.is_loading_session:
                return  # Skip marking changes when loading a session
        
            # Otherwise, mark the changes as pending
            parent.mark_changes_pending()

    def keyPressEvent(self, event):
        """Override key press event to prevent multiple event propagation"""
        # Set a flag to track that we're processing a key event
        self._handling_key_event = True
    
        try:
            # Call original implementation
            super().keyPressEvent(event)
        
            # Schedule just one headers refresh at the TextEdit level
            if hasattr(self, 'schedule_headers_refresh'):
                self.schedule_headers_refresh()
            
            # Mark the event as handled to prevent further propagation
            event.accept()
        finally:
            # Clear flag after short delay to allow UI to update
            QTimer.singleShot(50, self._clear_key_handling_flag)
    
    def _clear_key_handling_flag(self):
        """Clear the key handling flag"""
        self._handling_key_event = False
    
    def _cancel_active_operations(self):
        """Immediately cancel any active operations to prioritize typing"""
        # Cancel orphaned text check
        if self._orphan_check_active:
            print("[_cancel_active_operations] Canceling active orphaned text check for typing")
            self._cancel_requested = True
            
            # Reset processing flags immediately
            self._is_processing = False
            self._orphan_check_active = False
            
            # Cancel any pending timer as well
            if self.check_timer.isActive():
                self.check_timer.stop()
            if self.keypress_timer.isActive():
                self.keypress_timer.stop()
        
        # Cancel header refresh
        parent = self.parent()
        if parent and hasattr(parent, '_headers_refresh_active') and parent._headers_refresh_active:
            print("[_cancel_active_operations] Canceling active header refresh for typing")
            parent._headers_cancel_requested = True
            
            # Immediately reset parent's refresh flags
            parent._headers_refresh_active = False
            
            # Cancel any pending refresh timer
            if hasattr(parent, '_headers_refresh_timer') and parent._headers_refresh_timer.isActive():
                parent._headers_refresh_timer.stop()
        
        # Also cancel highlighting if it's active
        if hasattr(self.header_highlighter, '_highlighting_active') and self.header_highlighter._highlighting_active:
            print("[_cancel_active_operations] Canceling active highlighting for typing")
            self.header_highlighter._highlighting_cancelled = True
            self.header_highlighter._highlighting_active = False
    
    def _check_operation_status(self):
        try:
            """Periodically check if operations are running too long and should be cancelled"""
            # If user typed recently (last 500ms) but operations are still running, force cancel
            current_time = time.time()
            recent_typing = (current_time - self._last_keystroke_time) < 0.5  # 500ms
        
            if recent_typing:
                if self._orphan_check_active or self._is_processing:
                    print("[_check_operation_status] Detected lingering orphan check during typing - forcing cancellation")
                    self._cancel_active_operations()
            
                parent = self.parent()
                if parent and hasattr(parent, '_headers_refresh_active') and parent._headers_refresh_active:
                    print("[_check_operation_status] Detected lingering header refresh during typing - forcing cancellation")
                    self._cancel_active_operations()
        except KeyboardInterrupt:
            print("Operation cancelled by user")
            self._cancel_active_operations()
            return False
    
    def _schedule_orphaned_check(self):
        # Skip if suppressed
        if hasattr(self.parent(), '_suppress_orphaned_check') and self.parent()._suppress_orphaned_check:
            print("[_schedule_orphaned_check] Suppressed during header refresh. Skipping.")
            return
        if self.check_timer.isActive():
            self.check_timer.stop()
            
        # Reset cancellation flag when scheduling a new check
        self._cancel_requested = False
        
        # Get current text for comparison
        current_text = self.toPlainText()
        
        # Skip scheduling if text hasn't changed since last check
        if hasattr(self, '_last_checked_text') and self._last_checked_text == current_text:
            return
            
        # Calculate adaptive delay - longer delay when typing is happening
        current_time = time.time()
        time_since_keystroke = current_time - self._last_keystroke_time
        
        # Longer delay if actively typing
        if time_since_keystroke < 0.5:  # Typing actively
            delay = 1000  # Longer delay when typing
        else:
            # Standard adaptive delay based on text length
            text_length = len(current_text)
            if text_length > 10000:
                delay = 800
            elif text_length > 5000:
                delay = 500
            else:
                delay = 300
                
        # Schedule the check
        self.check_timer.start(delay)
    
    # Modified _perform_orphaned_check to implement cancellation
    def _perform_orphaned_check(self):
        """
        Perform orphaned text check, merging the old logic of
        _perform_orphaned_check and _check_orphaned_text.
        Includes cancellation support, pending-changes checks, etc.
        """
        #print(f"{self._debug_timestamp()} [_perform_orphaned_check] STARTED (merged)")
        #traceback.print_stack()

        # -----------------------------------------------------------
        # 1) Early exits: if we’re already processing, or user cancelled
        # -----------------------------------------------------------
        if self._is_processing or self._cancel_requested:
            print(f"{self._debug_timestamp()} [_perform_orphaned_check] Skipped (already processing or cancelled)")
            return

        # -----------------------------------------------------------
        # 2) If we track “pending changes,” ensure we only run if changes are pending
        # -----------------------------------------------------------
        # if not self._has_pending_changes:
        #     print(f"{self._debug_timestamp()} [_perform_orphaned_check] No pending changes, skipping")
        #     return

        # # We'll now clear _has_pending_changes because we're about to process
        # self._has_pending_changes = False

        # -----------------------------------------------------------
        # 3) Mark ourselves as processing
        # -----------------------------------------------------------
        self._is_processing = True
        self._orphan_check_active = True

        # Reset cancellation for this new run
        self._cancel_requested = False

        try:
            # -----------------------------------------------------------
            # 4) Grab current text
            # -----------------------------------------------------------
            current_text = self.toPlainText()
            if not current_text:
                print(f"{self._debug_timestamp()} [_perform_orphaned_check] Empty text, skipping")
                return

            # -----------------------------------------------------------
            # 5) Compare to last processed text to avoid re-checking identical data
            # -----------------------------------------------------------
            if hasattr(self, '_last_checked_text') and self._last_checked_text == current_text:
                print(f"{self._debug_timestamp()} [_perform_orphaned_check] Text unchanged since last check, skipping")
                return

            # Update our “last processed text” reference
            self._last_checked_text = current_text

            # -----------------------------------------------------------
            # 6) Check for cancellation again (just in case)
            # -----------------------------------------------------------
            if self._cancel_requested:
                print(f"{self._debug_timestamp()} [_perform_orphaned_check] Cancellation requested before highlight")
                return

            # -----------------------------------------------------------
            # 7) Actually perform the orphan check (if your highlighter supports it)
            # -----------------------------------------------------------
            if hasattr(self.header_highlighter, 'check_for_orphaned_text'):
                # If your highlighter has a “pause” or “resume” mechanism
                if getattr(self.header_highlighter, '_highlighting_paused', False):
                    self.header_highlighter._highlighting_paused = False

                # Let the highlighter see if it should abort for cancellation
                if hasattr(self.header_highlighter, 'set_cancellation_flag'):
                    self.header_highlighter.set_cancellation_flag(lambda: self._cancel_requested)

                # Count “headers” or anything that matters
                header_count = current_text.count('**') // 2
                main_header_count = current_text.count('[[') // 2
                total_headers = header_count + main_header_count

                # Full orphan check if text does have headers
                if not self._cancel_requested:
                    print(f"{self._debug_timestamp()} [_perform_orphaned_check] Headers found, running orphan check")
                    self.header_highlighter.check_for_orphaned_text()

        finally:
            # -----------------------------------------------------------
            # 8) Always clear flags in a finally block
            # -----------------------------------------------------------
            self._is_processing = False
            self._orphan_check_active = False

            # # If not cancelled, but user typed again while we were working,
            # # you might want to schedule another check. Example:
            # if not self._cancel_requested and not self.keypress_timer.isActive():
            #     print(f"{self._debug_timestamp()} [_perform_orphaned_check] Changes occurred during processing, rescheduling")
            #     self.keypress_timer.start(500)
        
    def _enhanced_focus_in_event(self, event):
        """Enhanced focus event with minimal overhead"""
        # Call original implementation
        self._original_focus_in_event(event)
        
        # Check if we've checked visibility recently
        current_time = time.time()
        if current_time - self._last_check_time > 5.0:  # Only check every 5 seconds max
            # Reset flag on focus
            self._visibility_checked = False
        
    def _check_visibility_if_needed(self):
        """Check visibility only if actually needed"""
        # Skip if we're already fixing or if there's no text
        if self._fixing_visibility or not self.toPlainText():
            return
            
        try:
            # Get a sample of the text format
            cursor = self.textCursor()
            original_position = cursor.position()
            
            # Move to start, then select a small sample
            cursor.setPosition(0)
            
            # Determine sample size (smaller of 20 chars or document length)
            sample_size = min(20, self.document().characterCount())
            if sample_size <= 0:
                return
                
            cursor.setPosition(sample_size, QTextCursor.MoveMode.KeepAnchor)
            format = cursor.charFormat()
            
            # Check if this format has a foreground color that's nearly white or transparent
            needs_fixing = False
            if format.hasProperty(QTextFormat.Property.ForegroundBrush):
                color = format.foreground().color()
                # Check if nearly white or very transparent
                if color.alpha() < 50 or (color.red() > 230 and color.green() > 230 and color.blue() > 230):
                    needs_fixing = True
            
            # Only fix if needed
            if needs_fixing:
                self.ensure_text_visible()
            else:
                # Mark as already checked
                self._visibility_ensured = True
                
            # Restore cursor position
            cursor.setPosition(original_position)
            self.setTextCursor(cursor)
            
        except Exception as e:
            print(f"Error in visibility check: {e}")
            
    def ensure_text_visible(self):
        """Applies a basic, explicitly non-bold black format to the entire document."""
        # Skip if no text
        if not self.toPlainText():
            return

        print(f"{self._debug_timestamp()} [ensure_text_visible] Applying basic NON-BOLD BLACK format.")

        # Disable UI updates temporarily for performance
        self.setUpdatesEnabled(False)
        # Store cursor/scroll
        cursor = self.textCursor()
        original_position = cursor.position()
        scroll_bar = self.verticalScrollBar()
        original_scroll = scroll_bar.value()

        # Block signals during direct format change
        self.blockSignals(True)
        try:
            doc_cursor = QTextCursor(self.document())
            doc_cursor.select(QTextCursor.SelectionType.Document)

            # Define the format
            basic_format = QTextCharFormat()
            basic_format.setForeground(QColor(0, 0, 0))  # Black
            basic_format.setFontWeight(QFont.Weight.Normal) # Explicitly Normal weight

            # Apply the format forcefully
            doc_cursor.setCharFormat(basic_format)

        finally:
            # Always re-enable signals and updates
            self.blockSignals(False)
            self.setUpdatesEnabled(True)

        # Restore cursor/scroll AFTER re-enabling updates
        cursor.setPosition(original_position)
        self.setTextCursor(cursor)
        scroll_bar.setValue(original_scroll)

        # Mark as done (if using the flag)
        self._visibility_ensured = True # Assuming this flag is managed elsewhere now

        # DO NOT pause/resume highlighter here
        print(f"{self._debug_timestamp()} [ensure_text_visible] Format applied.")
            
    def _delayed_resume_highlighting(self):
        """Resume highlighting with a delay"""
        if hasattr(self, 'header_highlighter') and hasattr(self.header_highlighter, 'resume_highlighting'):
            self.header_highlighter.resume_highlighting()
            
        
    # def on_keypress_timeout(self):
    #     """Process text after keyboard inactivity"""
    #     # If already processing, reschedule for later instead of skipping entirely
    #     if self._is_processing_text:
    #         # Reschedule the check for later
    #         self.keypress_timer.start(500)  # Try again in 500ms
    #         return
        
    #     try:
    #         # Mark as processing to prevent concurrent operations
    #         self._is_processing_text = True
        
    #         # Update check time
    #         self._last_check_time = time.time()
        
    #         # Check for orphaned text
    #         if hasattr(self.header_highlighter, 'check_for_orphaned_text'):
    #             # Make sure highlighting isn't paused
    #             if hasattr(self.header_highlighter, '_highlighting_paused') and self.header_highlighter._highlighting_paused:
    #                 self.header_highlighter._highlighting_paused = False
            
    #             # Run the check
    #             self.header_highlighter.check_for_orphaned_text()
            
    #     finally:
    #         # Always clear processing flag
    #         self._is_processing_text = False
    
    def eventFilter(self, obj, event):
        """Filter events to handle tooltips for orphaned text"""
        if event.type() == QEvent.Type.ToolTip:
            cursor = self.cursorForPosition(event.pos())
            block_number = cursor.blockNumber()
            
            # Only check for orphaned blocks if we're currently showing them
            if self.header_highlighter.check_orphaned and block_number in self.header_highlighter.get_orphaned_blocks():
                QToolTip.showText(
                    event.globalPos(), 
                    "Warning: This text is not under any header and will not appear in the final transcript.\n"
                    "Add a '**Header**' above this text to include it.", 
                    self
                )
                return True
            else:
                QToolTip.hideText()
                
        return super().eventFilter(obj, event)

    def contextMenuEvent(self, event):
        """Enhanced context menu with line check for header actions"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                border: 1px solid #d0d0d0;
            }
            QMenu::item {
                padding: 4px 20px 4px 10px;
            }
            QMenu::icon {
                padding-left: 8px;  /* Add space between edge and icon */
                padding-right: 4px; /* Reduce space between icon and text */
            }
            QMenu::item:selected {
                background-color: #e8f0ff;
                color: #000000;
            }
            QMenu::separator {
                height: 1px;
                background-color: #d0d0d0;
                margin: 3px 0px 3px 0px;
            }
        """)

        menu.addSeparator()

        # Ensure create_text_icon method exists in your class
        section_divider_icon = self.create_text_icon("[[ ]]", QColor(255, 215, 0))
        header_icon = self.create_text_icon("** **", QColor(33, 150, 243))
        remove_icon = self.create_text_icon("×", QColor(220, 53, 69))
        # reflow_icon = self.create_text_icon("¶", QColor(76, 175, 80)) # Uncomment if needed

        # --- Check Selection for Multi-line ---
        cursor = self.textCursor()
        has_selection = cursor.hasSelection()
        is_single_line_selection = False # Assume multi-line unless proven otherwise

        if has_selection:
            start_pos = cursor.selectionStart()
            # Use end_pos - 1 because selectionEnd() is *after* the last selected character.
            # If the selection ends exactly at the beginning of a new block,
            # end_pos - 1 will correctly be in the previous block.
            end_pos = cursor.selectionEnd()

            # Ensure there's actual content selected (start != end)
            if end_pos > start_pos:
                 doc = self.document()
                 start_block = doc.findBlock(start_pos)
                 # Find the block containing the *last selected character*
                 end_block = doc.findBlock(end_pos - 1)

                 # Check if both blocks are valid and are the same block
                 if start_block.isValid() and end_block.isValid() and start_block == end_block:
                     is_single_line_selection = True
            # Else: If end_pos == start_pos, has_selection should be False, but this handles it.
            # If selection is just one character (end_pos == start_pos + 1),
            # then end_pos - 1 == start_pos, and the blocks will match.

        # --- Add Header Manipulation Actions ---
        make_main_header_action = QAction(section_divider_icon, "Make Section Divider", self)
        make_main_header_action.triggered.connect(self.make_main_header)
        # Enable only if there is a selection AND it's contained within a single line
        make_main_header_action.setEnabled(has_selection and is_single_line_selection)
        menu.addAction(make_main_header_action)

        make_header_action = QAction(header_icon, "Make Header", self)
        make_header_action.triggered.connect(self.make_header)
        # Enable only if there is a selection AND it's contained within a single line
        make_header_action.setEnabled(has_selection and is_single_line_selection)
        menu.addAction(make_header_action)

        # Add "Remove Header" action - no line restriction needed for removal
        remove_header_action = QAction(remove_icon, "Remove Header", self)
        remove_header_action.triggered.connect(self.remove_header)
        # Potentially add logic here to enable only if near a header, but not strictly required by prompt
        menu.addAction(remove_header_action)

        # --- Add Special Action for Orphaned Text (If applicable) ---
        # Ensure header_highlighter and related attributes/methods exist
        if (hasattr(self, 'header_highlighter') and # Check if highlighter exists
            hasattr(self.header_highlighter, 'check_orphaned') and
            self.header_highlighter.check_orphaned and
            hasattr(self.header_highlighter, 'get_orphaned_blocks')):

            block_number = cursor.blockNumber() # Get block number where cursor is (even without selection)
            if block_number in self.header_highlighter.get_orphaned_blocks():
                orphaned_icon = self.create_text_icon("+ **", QColor(76, 175, 80))
                fix_orphaned_action = QAction(orphaned_icon, "Add Header for Orphaned Text", self)
                fix_orphaned_action.triggered.connect(self.add_header_for_orphaned_text)
                menu.addAction(fix_orphaned_action)

        # --- Add Reflow Text Submenu (Optional) ---
        # Uncomment if you have these methods and want the submenu
        # menu.addSeparator()
        # reflow_menu = QMenu("Reflow Text", menu)
        # reflow_menu.setIcon(reflow_icon)
        # double_breaks_action = QAction("Make Single Line Breaks into Double Line Breaks", self)
        # double_breaks_action.triggered.connect(self.make_single_breaks_double) # Ensure method exists
        # reflow_menu.addAction(double_breaks_action)
        # reform_paragraphs_action = QAction("Reform Paragraphs", self)
        # reform_paragraphs_action.triggered.connect(self.reform_paragraphs) # Ensure method exists
        # reflow_menu.addAction(reform_paragraphs_action)
        # menu.addMenu(reflow_menu)

        # --- Add Standard Menu Actions ---
        # Add separator only if custom actions were added before standard ones
        if menu.actions(): # Check if any custom actions were added
            menu.addSeparator()

        standard_menu = self.createStandardContextMenu()
        if standard_menu: # Check if a standard menu was created
            for action in standard_menu.actions():
                menu.addAction(action)
        # If standard_menu is None (e.g., in some contexts), this avoids an error

        # Show the menu at the cursor position
        menu.exec(event.globalPos())
    # --- END OF METHOD TO REPLACE ---

    def make_single_breaks_double(self):
        """Convert single line breaks to double line breaks to create proper paragraph separation"""
        # Store cursor position
        cursor = self.textCursor()
        original_position = cursor.position()
    
        # Get the text
        text = self.toPlainText()
    
        # Replace single line breaks with double line breaks, but preserve existing double breaks
        # Use negative lookbehind and lookahead to avoid affecting existing double breaks
        import re
        processed_text = re.sub(r'(?<!\n)\n(?!\n)', '\n\n', text)
    
        # Set the processed text back to the editor
        self.blockSignals(True)  # Prevent unnecessary signal emissions
        self.setPlainText(processed_text)
        self.blockSignals(False)
    
        # Restore cursor position (adjusting for potentially changed positions)
        new_position = min(original_position, len(processed_text))
        cursor.setPosition(new_position)
        self.setTextCursor(cursor)
    
        # Ensure text is visible and highlighting is updated
        self.schedule_highlight()
    
        # Trigger text changed event for any necessary updates
        self.textChanged.emit()

    def reform_paragraphs(self):
        """Reform paragraphs by removing single line breaks within paragraph blocks"""
        # Store cursor position
        cursor = self.textCursor()
        original_position = cursor.position()
    
        # Get the text
        text = self.toPlainText()
    
        # First identify paragraphs (text separated by double line breaks)
        import re
    
        # Split the text by double line breaks to get paragraphs
        paragraphs = re.split(r'\n\n+', text)
    
        # Process each paragraph to remove single line breaks
        for i in range(len(paragraphs)):
            # Skip headers and section dividers - don't modify their formatting
            if re.match(r'^\s*\*\*.*?\*\*\s*$', paragraphs[i]) or re.match(r'^\s*\[\[.*?\]\]\s*$', paragraphs[i]):
                continue
            
            # Replace single line breaks with spaces in this paragraph
            paragraphs[i] = re.sub(r'\n', ' ', paragraphs[i])
        
            # Remove any multiple spaces that might have been created
            paragraphs[i] = re.sub(r' {2,}', ' ', paragraphs[i])
        
            # Trim leading/trailing whitespace
            paragraphs[i] = paragraphs[i].strip()
    
        # Join the paragraphs back together with double line breaks
        processed_text = '\n\n'.join(paragraphs)
    
        # Set the processed text back to the editor
        self.blockSignals(True)  # Prevent unnecessary signal emissions
        self.setPlainText(processed_text)
        self.blockSignals(False)
    
        # Restore cursor position (adjusting for potentially changed positions)
        new_position = min(original_position, len(processed_text))
        cursor.setPosition(new_position)
        self.setTextCursor(cursor)
    
        # Ensure text is visible and highlighting is updated
        self.schedule_highlight()
    
        # Trigger text changed event for any necessary updates
        self.textChanged.emit()

    def create_text_icon(self, text, color):
        """Create a simple text-only icon with large font size"""
        # Create a pixmap
        pixmap = QPixmap(24, 24)
        pixmap.fill(Qt.GlobalColor.transparent)
    
        # Create a painter
        painter = QPainter(pixmap)
    
        # Enable text antialiasing
        painter.setRenderHint(QPainter.RenderHint.TextAntialiasing, True)
    
        # Set up font - larger size
        font = QFont()
        font.setBold(True)
        if text == "×":  # Make the 'x' even larger
            font.setPointSize(18)
        else:
            font.setPointSize(14)
        painter.setFont(font)
    
        # Draw text with specified color
        painter.setPen(color)
        painter.drawText(pixmap.rect(), Qt.AlignmentFlag.AlignCenter, text)
    
        painter.end()
        return QIcon(pixmap)

    def make_header(self):
        """Make selected text a header, removing any existing formatting first and ensuring proper spacing"""
        # Get the current cursor and selected text
        cursor = self.textCursor()
        selected_text = cursor.selectedText()
    
        if selected_text.strip():  # Ensure non-empty selection
            # Strip all common formatting patterns to get clean text
            stripped_text = selected_text.strip()
            
            # Remove various formatting patterns (order matters - most specific first)
            patterns_to_remove = [
                r'^\[\[(.*?)\]\]$',        # [[text]]
                r'^\*{2,}(.*?)\*{2,}$',    # **text** or ****text****
                r'^\*{1,}(.*?)\*{1,}$',    # *text* or **text (incomplete)
                r'^#{1,}\s*(.*?)$',        # #text or ##text or ###text
                r'^={1,}\s*(.*?)$',        # =text or ==text
                r'^-{1,}\s*(.*?)$',        # -text or --text
                r'^_{1,}(.*?)_{1,}$',      # _text_ or __text__
                r'^`{1,}(.*?)`{1,}$',      # `text` or ```text```
                r'^"(.*?)"$',              # "text"
                r"^'(.*?)'$",              # 'text'
                r'^\((.*?)\)$',            # (text)
                r'^\[(.*?)\]$',            # [text]
                r'^\{(.*?)\}$',            # {text}
                r'^<(.*?)>$',              # <text>
            ]
            
            # Apply pattern removal
            for pattern in patterns_to_remove:
                match = re.match(pattern, stripped_text)
                if match:
                    stripped_text = match.group(1).strip()
                    break
        
            # Get information about the surrounding text
            cursor_position = cursor.position()
            selection_start = cursor.selectionStart()
            selection_end = cursor.selectionEnd()
            document_text = self.toPlainText()
        
            # Check if we need to add newlines before the header
            need_newline_before = False
            if selection_start > 0 and document_text[selection_start-1] != '\n':
                need_newline_before = True
        
            # Check if we need to add newlines after the header
            need_newline_after = False
            if selection_end < len(document_text) and document_text[selection_end] != '\n':
                need_newline_after = True
        
            # Wrap the text with ** ** and proper spacing
            wrapped_text = ""
            if need_newline_before:
                wrapped_text += "\n\n"
        
            wrapped_text += f"**{stripped_text.strip()}**"
        
            if need_newline_after:
                wrapped_text += "\n\n"
        
            # Replace the selected text
            cursor.insertText(wrapped_text)
        
            # This will trigger textChanged which will schedule an orphaned text check

    def make_main_header(self):
        """Make selected text a section divider, removing any existing formatting first and ensuring proper spacing"""
        # Get the current cursor and selected text
        cursor = self.textCursor()
        selected_text = cursor.selectedText()
    
        if selected_text.strip():  # Ensure non-empty selection
            # Strip all common formatting patterns to get clean text
            stripped_text = selected_text.strip()
            
            # Remove various formatting patterns (order matters - most specific first)
            patterns_to_remove = [
                r'^\[\[(.*?)\]\]$',        # [[text]]
                r'^\*{2,}(.*?)\*{2,}$',    # **text** or ****text****
                r'^\*{1,}(.*?)\*{1,}$',    # *text* or **text (incomplete)
                r'^#{1,}\s*(.*?)$',        # #text or ##text or ###text
                r'^={1,}\s*(.*?)$',        # =text or ==text
                r'^-{1,}\s*(.*?)$',        # -text or --text
                r'^_{1,}(.*?)_{1,}$',      # _text_ or __text__
                r'^`{1,}(.*?)`{1,}$',      # `text` or ```text```
                r'^"(.*?)"$',              # "text"
                r"^'(.*?)'$",              # 'text'
                r'^\((.*?)\)$',            # (text)
                r'^\[(.*?)\]$',            # [text]
                r'^\{(.*?)\}$',            # {text}
                r'^<(.*?)>$',              # <text>
            ]
            
            # Apply pattern removal
            for pattern in patterns_to_remove:
                match = re.match(pattern, stripped_text)
                if match:
                    stripped_text = match.group(1).strip()
                    break
        
            # Get information about the surrounding text
            cursor_position = cursor.position()
            selection_start = cursor.selectionStart()
            selection_end = cursor.selectionEnd()
            document_text = self.toPlainText()
        
            # Check if we need to add newlines before the header
            need_newline_before = False
            if selection_start > 0 and document_text[selection_start-1] != '\n':
                need_newline_before = True
        
            # Check if we need to add newlines after the header
            need_newline_after = False
            if selection_end < len(document_text) and document_text[selection_end] != '\n':
                need_newline_after = True
        
            # Wrap the text with [[ ]] and proper spacing
            wrapped_text = ""
            if need_newline_before:
                wrapped_text += "\n\n"
        
            wrapped_text += f"[[{stripped_text.strip()}]]"
        
            if need_newline_after:
                wrapped_text += "\n\n"
        
            # Replace the selected text
            cursor.insertText(wrapped_text)

    def remove_header(self):
        """Detects and removes header formatting from text by replacing header markers 
        with plain text and clearing any formatting (bold, color) that was applied."""
        cursor = self.textCursor()
        # Create a default character format (no bold, no color) to force plain text insertion.
        default_format = QTextCharFormat()

        # If there's a selection, check if it's a header
        if cursor.hasSelection():
            start_pos = cursor.selectionStart()
            end_pos = cursor.selectionEnd()
            selected_text = self.toPlainText()[start_pos:end_pos]
    
            # Use the same normalization function as make_header
            normalized_text = self._normalize_header_text(selected_text)
            
            # If the text was normalized (formatting was removed), replace it
            if normalized_text != selected_text:
                cursor.insertText(normalized_text, default_format)
                return

        # No valid selection: try to find a header near the cursor position.
        position = cursor.position()
        document_text = self.toPlainText()
    
        # Find any formatted text around the cursor position and remove its formatting
        # Look for patterns that match any of the formatting we can normalize
        patterns_to_check = [
            r'\[\[(.*?)\]\]',          # [[text]]
            r'\*{2,}(.*?)\*{2,}',      # **text** or ****text****
            r'\*{1,}(.*?)\*{1,}',      # *text* or **text (incomplete)
            r'#{1,}\s*(.*?)(?=\s|$)',  # #text or ##text (end at space or end of line)
            r'={1,}\s*(.*?)(?=\s|$)',  # =text or ==text
            r'-{1,}\s*(.*?)(?=\s|$)',  # -text or --text
            r'_{1,}(.*?)_{1,}',        # _text_ or __text__
            r'`{1,}(.*?)`{1,}',        # `text` or ```text```
            r'"(.*?)"',                # "text"
            r"'(.*?)'",                # 'text'
            r'\((.*?)\)',              # (text)
            r'\[(.*?)\]',              # [text]
            r'\{(.*?)\}',              # {text}
            r'<(.*?)>',                # <text>
        ]
        
        for pattern in patterns_to_check:
            for match in re.finditer(pattern, document_text):
                if match.start() <= position <= match.end():
                    cursor.setPosition(match.start())
                    cursor.setPosition(match.end(), QTextCursor.MoveMode.KeepAnchor)
                    self.setTextCursor(cursor)
                    
                    # Extract the clean text using the normalization function
                    original_text = match.group(0)
                    normalized_text = self._normalize_header_text(original_text)
                    cursor.insertText(normalized_text, default_format)
                    return


    def add_header_for_orphaned_text(self):
        """Add a header before the current orphaned text block with proper spacing"""
        cursor = self.textCursor()
        block = cursor.block()
        block_position = block.position()
    
        # Move cursor to beginning of block
        cursor.setPosition(block_position)
        self.setTextCursor(cursor)
    
        # Insert header with proper spacing
        cursor.insertText("**New Header**\n\n")
    
        # Select the inserted header text for easy editing
        cursor.setPosition(block_position + 2)  # After first **
        cursor.setPosition(block_position + 2 + 9, QTextCursor.MoveMode.KeepAnchor)  # Select "New Header"
        self.setTextCursor(cursor)
    
        # This insertion will trigger textChanged which will schedule an orphaned text check

    def detect_headers(self):
        parent = self.parent()
        if parent:
            if hasattr(parent, 'detect_headers'):
                print("Debug: Calling detect_headers.")
                parent.detect_headers()
            else:
                print("Debug: detect_headers not found in parent.")
        else:
            print("Debug: No parent found.")

    def canInsertFromMimeData(self, source):
        """Check if the mime data can be inserted"""
        return super().canInsertFromMimeData(source)

    def detect_content_type(self, source):
        """
        Detect content type based on specific criteria with debug output:
        1. If HTML has H1-6 or BOLD tags with text, it's HTML
        2. If text has double asterisk bold formatting, it's Markdown
        3. Otherwise it's Plain/other
        """
        import re
    
        # Debug header
        print("\n===== CONTENT TYPE DETECTION =====")
    
        # Default to Plain/other
        content_type = "Plain/other"
    
        # Store detected tags for later use
        self.detected_tags = {
            'bold_tags': [],
            'header_tags': [],
            'markdown_bold': [],
            'markdown_headers': []
        }
    
        # First check if the MIME data has HTML
        self.mime_source = source
        has_html_mime = source.hasHtml()
        print(f"Has HTML MIME type: {has_html_mime}")
    
        if has_html_mime:
            html = source.html()
            # Store the original HTML
            self.original_html = html
            print(f"HTML length: {len(html)} characters")
        
            # Print a small sample of the HTML for debugging
            html_sample = html[:200] + "..." if len(html) > 200 else html
            print(f"HTML sample: {html_sample}")
        
            # Check for H1-H6 tags with content
            h_tags_pattern = r'<h([1-6])[^>]*>(.+?)</h\1>'
            h_tags_matches = list(re.finditer(h_tags_pattern, html, re.IGNORECASE | re.DOTALL))
        
            # Store the detected header tags
            self.detected_tags['header_tags'] = h_tags_matches
        
            if h_tags_matches:
                print(f"H1-H6 tags found: {len(h_tags_matches)}")
                # Show example of the first match
                h_level = h_tags_matches[0].group(1)
                h_content = h_tags_matches[0].group(2)
                print(f"Example: <h{h_level}>{h_content}</h{h_level}>")
                print("Decision: HTML content (contains header tags)")
                return "HTML"
            else:
                print("No H1-H6 tags found")
        
            # Check for BOLD tags with content
            bold_tags_pattern = r'<(b|strong)[^>]*>(.+?)</\1>'
            bold_tags_matches = list(re.finditer(bold_tags_pattern, html, re.IGNORECASE | re.DOTALL))
        
            # Store the detected bold tags
            self.detected_tags['bold_tags'] = bold_tags_matches
        
            if bold_tags_matches:
                print(f"Bold tags found: {len(bold_tags_matches)}")
                # Show example of the first match
                tag_name = bold_tags_matches[0].group(1)
                tag_content = bold_tags_matches[0].group(2)
                print(f"Example: <{tag_name}>{tag_content}</{tag_name}>")
                print("Decision: HTML content (contains bold tags)")
                return "HTML"
            else:
                print("No bold tags found")
        
            print("HTML MIME type exists but no H1-H6 or bold tags with content were found")
    
        # If not classified as HTML, check for Markdown
        # Get the text content
        text = source.text()
        print(f"Text length: {len(text)} characters")
    
        # Look specifically for double asterisk bold text (handle multiple asterisks)
        double_asterisk_pattern = r'\*{2,}([^\*\n]+)\*{2,}'
        double_asterisk_matches = list(re.finditer(double_asterisk_pattern, text))
    
        # Store markdown bold matches
        self.detected_tags['markdown_bold'] = double_asterisk_matches
    
        # Also detect markdown headers
        header_pattern = r'^#{1,6}\s+(.+?)$'
        header_matches = list(re.finditer(header_pattern, text, re.MULTILINE))
        self.detected_tags['markdown_headers'] = header_matches
    
        if double_asterisk_matches:
            print(f"Double asterisk bold found: {len(double_asterisk_matches)}")
            # Show example of the first match
            bold_content = double_asterisk_matches[0].group(1)
            print(f"Example: **{bold_content}**")
            print("Decision: Markdown content (contains double asterisk bold)")
            return "Markdown"
        else:
            print("No double asterisk bold found")
    
        # If neither HTML nor Markdown, it's Plain/other
        print("Decision: Plain/other content (no HTML tags or Markdown formatting detected)")
        return "Plain/other"

    def insertFromMimeData(self, source):
        """Custom handling of pasted content with formatting options dialog and paragraph preservation"""
        print(f"{self._debug_timestamp()} [insertFromMimeData] Paste detected") # Debug

        # --- NEW: Explicit State Reset ---
        highlighter = getattr(self, 'header_highlighter', None)
        if highlighter:
            print(f"{self._debug_timestamp()} [insertFromMimeData] Resetting highlighter state before paste processing")
            # Reset the core state variables that might be causing issues
            if hasattr(highlighter, 'orphaned_blocks'):
                highlighter.orphaned_blocks.clear()
            if hasattr(highlighter, 'previous_orphaned_blocks'):
                highlighter.previous_orphaned_blocks.clear()
            if hasattr(highlighter, 'header_blocks'):
                highlighter.header_blocks.clear()
            # Resetting check_orphaned might be too aggressive, but consider if needed
            # if hasattr(highlighter, 'check_orphaned'):
            #     highlighter.check_orphaned = False
            # Reset last processed text to force re-analysis
            if hasattr(highlighter, '_last_processed_text'):
                highlighter._last_processed_text = None # Use None or ""
            # Ensure highlighting isn't stuck paused (unless intended)
            # if hasattr(highlighter, '_highlighting_paused'):
            #     highlighter._highlighting_paused = False # Or restore intended state if needed
        # --- END NEW ---

        # Disable visibility checks during paste
        old_visibility = False # Default value
        if hasattr(self, '_visibility_ensured'): # Check if attribute exists
             old_visibility = self._visibility_ensured
             self._visibility_ensured = True
        else:
             print("[insertFromMimeData] Warning: _visibility_ensured attribute missing")


        cursor = self.textCursor()
        cursor_at_beginning = cursor.atStart() or cursor.atBlockStart()
        current_doc_empty = self.document().isEmpty()

        # Determine content type using the specific detection logic
        detected_content_type = self.detect_content_type(source)

        # Store the raw content for processing
        html = source.html() if source.hasHtml() else ""
        text = source.text()

        # Pass detected tags to the dialog
        detected_info = None
        if hasattr(self, 'detected_tags') and hasattr(self, 'original_html'):
            detected_info = {
                'original_html': self.original_html,
                'bold_tags': self.detected_tags.get('bold_tags', []),
                'header_tags': self.detected_tags.get('header_tags', []),
                'plain_text': text  # Add plain text for Markdown and plain preview
            }
        elif hasattr(self, 'detected_tags'): # Handle case where original_html might not exist
             detected_info = {
                'original_html': '', # Provide empty string
                'bold_tags': self.detected_tags.get('bold_tags', []),
                'header_tags': self.detected_tags.get('header_tags', []),
                'plain_text': text
            }


        # Show the paste formatting dialog with detected content type and detected info
        dialog = PasteFormatDialog(self, detected_content_type, detected_info)

        # --- Existing code from here ---
        if dialog.exec():
            # Get the formatting options chosen by the user
            format_options = dialog.get_formatting_options()

            # Get the user's selected content type
            user_content_type = format_options.get('content_type', detected_content_type)

            # Process based on the user-selected content type
            processed_text = "" # Initialize processed_text
            if user_content_type == "Plain/other":
                # For Plain/other, just paste the text without formatting
                processed_text = text
                # Use insertText for plain text
                print(f"{self._debug_timestamp()} [insertFromMimeData] Inserting Plain/other text")
                cursor.insertText(processed_text)
            elif user_content_type == "HTML":
                # Process as HTML
                if source.hasHtml() and html: # Check if html is not empty
                    normalized_html = self.normalize_paragraph_whitespace(html)
                    processed_text = self.process_html_with_options(normalized_html, format_options)
                else:
                    # Treat plain text as HTML-like for formatting if source only had text
                    processed_text = self.standardize_line_spacing(text)
                # Use insertText for processed HTML (which is now plain text with markers)
                print(f"{self._debug_timestamp()} [insertFromMimeData] Inserting processed HTML as text")
                cursor.insertText(processed_text)
            elif user_content_type == "Markdown":
                # Process as Markdown
                if self.has_special_markdown_elements(text) and format_options.get('use_default', True):
                    # With default processing, convert special elements to plain text
                    processed_text = self.convert_markdown_to_plain_text(text)
                else:
                    # Regular Markdown processing or custom options
                    processed_text = self.process_markdown_with_options(text, format_options)
                # Use insertText for processed Markdown
                print(f"{self._debug_timestamp()} [insertFromMimeData] Inserting processed Markdown as text")
                cursor.insertText(processed_text)

            # Schedule rehighlight after paste - only if we actually inserted text
            if processed_text: # Check if text was actually inserted
                 print(f"{self._debug_timestamp()} [insertFromMimeData] Scheduling highlight")
                 self.schedule_highlight()
            else:
                 print(f"{self._debug_timestamp()} [insertFromMimeData] No text processed/inserted, skipping highlight schedule")
        else:
            # Dialog was canceled, do nothing - cancels the paste operation entirely
            print(f"{self._debug_timestamp()} [insertFromMimeData] Paste cancelled by user")
            pass

        # Restore visibility flag (always do this, regardless of paste/cancel)
        if hasattr(self, '_visibility_ensured'): # Check attribute exists before restoring
            self._visibility_ensured = old_visibility
        print(f"{self._debug_timestamp()} [insertFromMimeData] Completed")

    def is_html_content(self, text):
        """
        Determines if the text is likely HTML content.
        Returns True if it contains HTML tags, False otherwise.
        """
        import re
    
        # Look for common HTML tags
        html_patterns = [
            # Opening tags with possible attributes
            r'<(?:p|div|span|h[1-6]|ul|ol|li|table|tr|td|th|a|img|br|hr|b|i|strong|em)[^>]*>',
            # Closing tags
            r'</(?:p|div|span|h[1-6]|ul|ol|li|table|tr|td|th|a|b|i|strong|em)>',
            # Self-closing tags
            r'<(?:br|hr|img)[^>]*/>',
            # HTML entities
            r'&(?:nbsp|lt|gt|amp|quot|apos|mdash|ndash|#\d+);'
        ]
    
        # Check for HTML patterns
        for pattern in html_patterns:
            if re.search(pattern, text, re.IGNORECASE):
                return True
    
        # Check for style attributes which are definitely HTML
        if re.search(r'style\s*=\s*["\'][^"\']*["\']', text, re.IGNORECASE):
            return True
    
        # Check for class attributes which are definitely HTML
        if re.search(r'class\s*=\s*["\'][^"\']*["\']', text, re.IGNORECASE):
            return True
        
        return False

    def is_markdown_text(self, text):
        """
        Determines if the text appears to be Markdown format rather than HTML.
    
        Returns True if it seems to be Markdown AND NOT HTML, False otherwise.
        """
        import re
    
        # First, check if it's HTML - if so, it's not Markdown
        if self.is_html_content(text):
            return False
    
        # Now check for Markdown indicators
        markdown_patterns = [
            # Headers at start of line
            r'^\s*#{1,6}\s+\S+',
            # Emphasis/italic with single asterisks (not part of a bold marker)
            r'(?<!\*)\*(?!\*)[^\*\n]+\*(?!\*)',
            # Emphasis/italic with single underscores (not part of a bold marker)
            r'(?<!_)_(?!_)[^_\n]+_(?!_)',
            # Strong/bold with double asterisks (handle multiple asterisks)
            r'\*{2,}[^\*\n]+\*{2,}',
            # Strong/bold with double underscores (handle multiple underscores)
            r'_{2,}[^_\n]+_{2,}',
            # Strikethrough
            r'~~.+?~~',
            # Links
            r'\[.+?\]\(.+?\)',
            # Lists at start of line
            r'^\s*[\*\+\-]\s+\S+',
            # Numbered lists at start of line
            r'^\s*\d+\.\s+\S+',
            # Fenced code blocks
            r'```[\s\S]*?```',
            # Inline code
            r'`[^`\n]+`',
            # Blockquotes at start of line
            r'^\s*>\s+\S+',
            # Horizontal rules
            r'^\s*(\*{3,}|-{3,}|_{3,})\s*$'
        ]
    
        # Check for Markdown patterns
        md_matches = 0
        for pattern in markdown_patterns:
            matches = re.findall(pattern, text, re.MULTILINE)
            md_matches += len(matches)
        
            # If we find multiple Markdown patterns, it's likely Markdown
            if md_matches >= 2:
                return True
    
        # If we've found at least one Markdown pattern and no HTML patterns
        return md_matches >= 1

    def has_special_markdown_elements(self, text):
        """
        Checks if the Markdown text contains the special elements that should be
        converted directly to plain text as per requirements.
        """
        import re
    
        # Check for emphasized text with single asterisks or underscores
        if re.search(r'(?<!\*)\*(?!\*)[^\*]+\*(?!\*)', text) or re.search(r'(?<!_)_(?!_)[^_]+_(?!_)', text):
            return True
    
        # Check for strikethrough
        if re.search(r'~~.+?~~', text):
            return True
    
        # Check for horizontal rules
        if re.search(r'^(\*{3,}|-{3,}|_{3,})\s*$', text, re.MULTILINE):
            return True
    
        return False

    def convert_markdown_to_plain_text(self, markdown_text):
        """
        Converts markdown with special elements to plain text.
        Used when special markdown elements are detected.
        """
        import re
    
        # Remove emphasis (single asterisks)
        text = re.sub(r'(?<!\*)\*(?!\*)(.*?)\*(?!\*)', r'\1', markdown_text)
        text = re.sub(r'(?<!_)_(?!_)(.*?)_(?!_)', r'\1', text)
    
        # Remove strikethrough
        text = re.sub(r'~~(.*?)~~', r'\1', text)
    
        # Remove horizontal rules
        text = re.sub(r'^(\*{3,}|-{3,}|_{3,})\s*$', '', text, flags=re.MULTILINE)
    
        # Also convert other common markdown to plain text
        # Headers
        text = re.sub(r'^#{1,6}\s+(.*?)$', r'\1', text, flags=re.MULTILINE)
    
        # Bold/Strong - handle multiple asterisks
        text = re.sub(r'\*{2,}(.*?)\*{2,}', r'\1', text)
        text = re.sub(r'_{2,}(.*?)_{2,}', r'\1', text)
    
        # Lists - keep text but remove markers
        text = re.sub(r'^\s*[\*\+\-]\s+(.*?)$', r'\1', text, flags=re.MULTILINE)
        text = re.sub(r'^\s*\d+\.\s+(.*?)$', r'\1', text, flags=re.MULTILINE)
    
        # Code blocks
        text = re.sub(r'```(?:.*?)\n([\s\S]*?)```', r'\1', text)
        text = re.sub(r'`(.*?)`', r'\1', text)
    
        # Blockquotes
        text = re.sub(r'^\s*>\s+(.*?)$', r'\1', text, flags=re.MULTILINE)
    
        # Links
        text = re.sub(r'\[(.*?)\]\(.*?\)', r'\1', text)
    
        # Images
        text = re.sub(r'!\[(.*?)\]\(.*?\)', r'\1', text)
    
        return self.standardize_line_spacing(text)

    def process_markdown_with_options(self, markdown_text, format_options):
        """
        Process Markdown content based on user-selected formatting options.
        """
        import re
    
        # Check if this has special Markdown elements that should be converted to plain text
        if self.has_special_markdown_elements(markdown_text):
            return self.convert_markdown_to_plain_text(markdown_text)
    
        # Process the Markdown based on formatting options
    
        # Process header elements based on options
        for h_level in range(1, 7):
            h_pattern = r'^#{' + str(h_level) + r'}\s+(.*?)$'
        
            # Determine which treatment to use (global or individual)
            if format_options['global_header_treatment']:
                treatment = format_options['global_header_treatment']
            else:
                treatment = format_options[f'h{h_level}_treatment']
        
            if treatment == 'header':
                # Format as our header style, normalizing any existing formatting
                def normalize_header_replacement(match):
                    header_text = match.group(1)
                    normalized_text = self._normalize_header_text(header_text)
                    return f'\n\n**{normalized_text}**\n\n'
                
                markdown_text = re.sub(h_pattern, normalize_header_replacement, markdown_text, flags=re.MULTILINE)
            elif treatment == 'section':
                # Format as section divider, normalizing any existing formatting
                def normalize_section_replacement(match):
                    section_text = match.group(1)
                    normalized_text = self._normalize_header_text(section_text)
                    return f'\n\n[[{normalized_text}]]\n\n'
                
                markdown_text = re.sub(h_pattern, normalize_section_replacement, markdown_text, flags=re.MULTILINE)
            else:  # 'plain'
                # Make it plain text, normalizing any existing formatting
                def normalize_plain_replacement(match):
                    plain_text = match.group(1)
                    normalized_text = self._normalize_header_text(plain_text)
                    return f'\n\n{normalized_text}\n\n'
                
                markdown_text = re.sub(h_pattern, normalize_plain_replacement, markdown_text, flags=re.MULTILINE)
    
        # Process bold/strong elements based on options
        if format_options['bold_as_header']:
            # Look for standalone bold lines (lines that contain only bold text)
            markdown_text = re.sub(r'^(\s*)\*\*(.*?)\*\*(\s*)$', r'\n\n**\2**\n\n', markdown_text, flags=re.MULTILINE)
            # Also handle underscore-style bold
            markdown_text = re.sub(r'^(\s*)__(.*?)__(\s*)$', r'\n\n**\2**\n\n', markdown_text, flags=re.MULTILINE)
            # Keep other bold formatting as is (inline bold)
        else:
            # Convert bold to plain text
            markdown_text = re.sub(r'\*\*(.*?)\*\*', r'\1', markdown_text)
            markdown_text = re.sub(r'__(.*?)__', r'\1', markdown_text)
    
        # Preserve list structures with proper spacing
        list_blocks = re.finditer(r'((?:^\s*[\*\+\-]\s.*?$\n?)+|(?:^\s*\d+\.\s.*?$\n?)+)', markdown_text, re.MULTILINE)
        for block in list_blocks:
            list_content = block.group(0)
            if not list_content.startswith('\n\n'):
                list_content = '\n\n' + list_content
            if not list_content.endswith('\n\n'):
                list_content = list_content + '\n\n'
            markdown_text = markdown_text.replace(block.group(0), list_content)
    
        # Preserve blockquotes with proper spacing
        quote_blocks = re.finditer(r'((?:^\s*>\s.*?$\n?)+)', markdown_text, re.MULTILINE)
        for block in quote_blocks:
            quote_content = block.group(0)
            if not quote_content.startswith('\n\n'):
                quote_content = '\n\n' + quote_content
            if not quote_content.endswith('\n\n'):
                quote_content = quote_content + '\n\n'
            markdown_text = markdown_text.replace(block.group(0), quote_content)
    
        # Ensure proper paragraph spacing
        markdown_text = self.standardize_line_spacing(markdown_text)
    
        return markdown_text

    def normalize_paragraph_whitespace(self, html):
        """
        Pre-process HTML to normalize whitespace within paragraph tags
        """
        import re
    
        try:
            from bs4 import BeautifulSoup
        
            # Parse HTML
            soup = BeautifulSoup(html, 'html.parser')
        
            # Process each paragraph to normalize internal whitespace
            for p in soup.find_all('p'):
                # Get the text content with normalized whitespace
                text = re.sub(r'\s+', ' ', p.get_text()).strip()
            
                # Clear the paragraph and set normalized content
                p.clear()
                p.append(text)
        
            return str(soup)
        
        except ImportError:
            # Fallback using regex if BeautifulSoup isn't available
            return re.sub(r'(<p>)(.*?)(</p>)', 
                         lambda m: m.group(1) + re.sub(r'\s+', ' ', m.group(2)).strip() + m.group(3), 
                         html, flags=re.IGNORECASE | re.DOTALL)
      

    def preserve_paragraphs_from_html(self, html):
        """
        Extract paragraphs from HTML with proper spacing and preserve bold formatting
        """
        import re
        print("\n===== PRESERVING PARAGRAPHS FROM HTML =====")
    
        try:
            from bs4 import BeautifulSoup
        
            # Parse HTML
            soup = BeautifulSoup(html, 'html.parser')
        
            # First, convert all bold elements to asterisk format
            for bold_tag in soup.find_all(['b', 'strong']):
                text = bold_tag.get_text().strip()
                if text:
                    print(f"Converting bold tag to double asterisks: '{text}'")
                    bold_tag.replace_with(f"**{text}**")
            
            # Also convert CSS-based bold text
            for elem in soup.find_all(style=re.compile(r'font-weight:\s*(bold|[6-9]00)')):
                if elem.name not in ['b', 'strong']:  # Skip already processed elements
                    text = elem.get_text().strip()
                    if text:
                        print(f"Converting CSS bold to double asterisks: '{text}'")
                        elem.replace_with(f"**{text}**")
        
            # Get all paragraphs
            paragraphs = []
            for p in soup.find_all('p'):
                # Get the text with normalized whitespace
                text = p.get_text().strip()
                if text:
                    print(f"Found paragraph: '{text[:50]}...' " if len(text) > 50 else f"Found paragraph: '{text}'")
                    paragraphs.append(text)
            
            # Also process header elements as paragraphs with additional formatting
            for h_level in range(1, 7):
                for heading in soup.find_all(f'h{h_level}'):
                    text = heading.get_text().strip()
                    if text:
                        # For headers, we'll add ** ** formatting by default
                        if not text.startswith('**') and not text.endswith('**'):
                            text = f"**{text}**"
                        print(f"Found h{h_level} header: '{text}'")
                        paragraphs.append(text)
        
            # Join paragraphs with double line breaks
            result = "\n\n".join(paragraphs)
            print(f"Result has {len(paragraphs)} paragraphs")
        
            # Print a sample of the final text
            text_sample = result[:200] + "..." if len(result) > 200 else result
            print(f"Result sample: {text_sample}")
        
            return result
    
        except ImportError:
            # Fallback if BeautifulSoup isn't available
            print("BeautifulSoup not available, using regex fallback")
            paragraphs = []
        
            # First convert bold tags to ** **
            html = re.sub(r'<(?:b|strong)>(.*?)</(?:b|strong)>', r'**\1**', html, flags=re.IGNORECASE)
        
            # Extract paragraph content
            for match in re.finditer(r'<p>(.*?)</p>', html, flags=re.IGNORECASE | re.DOTALL):
                # Get text with normalized whitespace
                text = re.sub(r'\s+', ' ', match.group(1)).strip()
                if text:
                    paragraphs.append(text)
            
            # Extract header content
            for h_level in range(1, 7):
                pattern = f'<h{h_level}>(.*?)</h{h_level}>'
                for match in re.finditer(pattern, html, flags=re.IGNORECASE | re.DOTALL):
                    text = re.sub(r'\s+', ' ', match.group(1)).strip()
                    if text:
                        # For headers, we'll add ** ** formatting by default
                        if not text.startswith('**') and not text.endswith('**'):
                            text = f"**{text}**"
                        paragraphs.append(text)
        
            # Join paragraphs with double line breaks
            result = "\n\n".join(paragraphs)
        
            # Print a sample of the final text
            text_sample = result[:200] + "..." if len(result) > 200 else result
            print(f"Result sample: {text_sample}")
        
            return result

    def _insert_with_proper_breaks(self, cursor, processed_text, cursor_at_beginning, current_doc_empty, is_html=False):
        """Helper method to insert text with proper line break handling"""
        if cursor_at_beginning or current_doc_empty:
            # When at beginning, remove leading breaks
            processed_text = processed_text.lstrip('\n')
            cursor.insertText(processed_text)
            return
    
        # Get a larger context to analyze line breaks properly
        cursor_position = cursor.position()
        context_size = min(50, cursor_position)  # Look back up to 50 chars
        preceding_text = self.toPlainText()[cursor_position-context_size:cursor_position]
    
        # Check first element of pasted content to detect if it's block-level
        first_line = processed_text.split('\n', 1)[0] if '\n' in processed_text else processed_text
        is_block_start = False
    
        # Detect if pasted content starts with header or block-level element
        if '**' in first_line or '[[' in first_line:
            is_block_start = True
        elif is_html and any(f"<{tag}" in first_line for tag in ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6']):
            is_block_start = True
    
        # Check surrounding context for line breaks
        has_single_break = preceding_text.endswith('\n') and not preceding_text.endswith('\n\n')
        has_double_break = preceding_text.endswith('\n\n')
        trailing_char = preceding_text[-1] if preceding_text else ''
    
        # Determine what kind of break we need (if any)
        if has_double_break:
            # Already have double break, no additional breaks needed
            cursor.insertText(processed_text)
        elif has_single_break:
            # Have single break, add another if pasting block content
            if is_block_start:
                cursor.insertText('\n' + processed_text)
            else:
                cursor.insertText(processed_text)
        else:
            # No breaks, determine what to add
            if is_block_start:
                # Pasting block content, add double break
                cursor.insertText('\n\n' + processed_text)
            elif trailing_char and trailing_char in '.!?":;)]}':
                # After sentence-ending punctuation, add double break
                cursor.insertText('\n\n' + processed_text)
            else:
                # Otherwise add single break
                cursor.insertText('\n' + processed_text)

    def process_html_with_options(self, html, format_options):
        """Process HTML content based on user-selected formatting options with paragraph preservation"""
        import re
    
        print("\n===== PROCESSING HTML WITH OPTIONS =====")
        print(f"Bold as header option: {format_options.get('bold_as_header', True)}")
    
        # First try the HTML parameter directly
        try:
            from bs4 import BeautifulSoup
        
            # Try with the provided HTML first
            soup = BeautifulSoup(html, 'html.parser')
        
            # Count tags to verify processing
            bold_tags = soup.find_all(['b', 'strong'])
            header_tags = []
            for h_level in range(1, 7):
                header_tags.extend(soup.find_all(f'h{h_level}'))
        
            print(f"BeautifulSoup found {len(bold_tags)} bold tags and {len(header_tags)} header tags in provided HTML")
        
            # If we didn't find any tags but we found them during detection, try mime source as fallback
            if (len(bold_tags) == 0 and len(header_tags) == 0) and hasattr(self, 'mime_source') and self.mime_source.hasHtml():
                print("No tags found in provided HTML, trying mime source as fallback")
                original_html = self.mime_source.html()
                soup = BeautifulSoup(original_html, 'html.parser')
            
                # Recount tags
                bold_tags = soup.find_all(['b', 'strong'])
                header_tags = []
                for h_level in range(1, 7):
                    header_tags.extend(soup.find_all(f'h{h_level}'))
            
                print(f"BeautifulSoup found {len(bold_tags)} bold tags and {len(header_tags)} header tags in mime source HTML")
        
            # Process bold elements
            for bold_tag in bold_tags:
                text = bold_tag.get_text().strip()
                if text:
                    # Normalize text by stripping existing formatting patterns
                    normalized_text = self._normalize_header_text(text)
                    
                    if format_options.get('bold_as_header', True):
                        is_standalone = self._is_standalone_element(bold_tag)
                        if is_standalone:
                            bold_tag.replace_with(f"\n\n**{normalized_text}**\n\n")
                        else:
                            bold_tag.replace_with(f"**{normalized_text}**")
                    else:
                        bold_tag.replace_with(f"**{normalized_text}**")
        
            # Process header elements
            for header_tag in header_tags:
                level = int(header_tag.name[1])  # extract the number from 'h1', 'h2', etc.
                text = header_tag.get_text().strip()
            
                if text:
                    # Normalize text by stripping existing formatting patterns
                    normalized_text = self._normalize_header_text(text)
                    
                    # Determine which treatment to use
                    if format_options.get('global_header_treatment', ''):
                        treatment = format_options['global_header_treatment']
                    else:
                        treatment = format_options.get(f'h{level}_treatment', 'header')
                
                    if treatment == 'header':
                        header_tag.replace_with(f"\n\n**{normalized_text}**\n\n")
                    elif treatment == 'section':
                        header_tag.replace_with(f"\n\n[[{normalized_text}]]\n\n")
                    else:  # 'plain'
                        header_tag.replace_with(f"\n\n{normalized_text}\n\n")
        
            # Process paragraphs
            para_count = 0
            for p in soup.find_all('p'):
                text = p.get_text().strip()
                if text:
                    para_count += 1
                    p.replace_with(f"{text}\n\n")
        
            print(f"Processed {para_count} paragraphs")
        
            # Get the final text
            processed_text = soup.get_text()
        
        except (ImportError, Exception) as e:
            print(f"BeautifulSoup processing failed, using regex: {str(e)}")
        
            # Fallback to regex processing
            processed_text = html
        
            # Process bold and header tags
            processed_text = re.sub(
                r'<(?:b|strong)[^>]*>(.*?)</(?:b|strong)>', 
                lambda m: f"\n\n**{m.group(1).strip()}**\n\n" if format_options.get('bold_as_header', True) else f"**{m.group(1).strip()}**",
                processed_text, 
                flags=re.IGNORECASE | re.DOTALL
            )
        
            # Process headers
            for h_level in range(1, 7):
                h_pattern = f'<h{h_level}[^>]*>(.*?)</h{h_level}>'
            
                # Determine which treatment to use
                if format_options.get('global_header_treatment', ''):
                    treatment = format_options['global_header_treatment']
                else:
                    treatment = format_options.get(f'h{h_level}_treatment', 'header')
            
                if treatment == 'header':
                    processed_text = re.sub(h_pattern, r'\n\n**\1**\n\n', processed_text, flags=re.IGNORECASE | re.DOTALL)
                elif treatment == 'section':
                    processed_text = re.sub(h_pattern, r'\n\n[[\1]]\n\n', processed_text, flags=re.IGNORECASE | re.DOTALL)
                else:  # 'plain'
                    processed_text = re.sub(h_pattern, r'\n\n\1\n\n', processed_text, flags=re.IGNORECASE | re.DOTALL)
        
            # Process paragraphs and other elements
            processed_text = re.sub(r'<p[^>]*>(.*?)</p>', r'\1\n\n', processed_text, flags=re.IGNORECASE | re.DOTALL)
            processed_text = re.sub(r'<br[^>]*/?>', '\n', processed_text, flags=re.IGNORECASE)
            processed_text = re.sub(r'<li[^>]*>(.*?)</li>', r'• \1\n', processed_text, flags=re.IGNORECASE | re.DOTALL)
        
            # Remove remaining HTML tags
            processed_text = re.sub(r'<[^>]+>', ' ', processed_text)
    
        # Common cleanup for all methods
        processed_text = re.sub(r'\n{3,}', '\n\n', processed_text)
        processed_text = re.sub(r' {2,}', ' ', processed_text)
        processed_text = processed_text.strip()
    
        # # Print a sample of the processed text
        # text_sample = processed_text[:200] + "..." if len(processed_text) > 200 else processed_text
        # print(f"Processed text sample: {text_sample}")

        return processed_text

    def _replace_tags(self, html, open_tag, close_tag, replace_func):
        """Helper method to replace content between tags with a replacement function"""
        result = ""
        remainder = html
    
        # Simple tag replacement without using regex
        while True:
            start_pos = remainder.lower().find(open_tag.lower())
            if start_pos == -1:
                result += remainder
                break
            
            # Add everything before the opening tag
            result += remainder[:start_pos]
        
            # Find the closing tag
            after_open = remainder[start_pos + len(open_tag):]
            end_pos = after_open.lower().find(close_tag.lower())
        
            if end_pos == -1:
                # No closing tag found, just add the rest and stop
                result += remainder[start_pos:]
                break
            
            # Extract the content between tags
            content = after_open[:end_pos].strip()
        
            # Apply the replacement function to the content
            result += replace_func(content)
        
            # Update the remainder
            remainder = after_open[end_pos + len(close_tag):]
    
        return result

    def _is_standalone_element_text(self, tag_text, full_html):
        """Helper method to determine if a tag is standalone based on regex context"""
        import re
    
        # Check if the tag appears inside a paragraph tag by itself
        standalone_in_p = re.search(r'<p[^>]*>\s*' + re.escape(tag_text) + r'\s*</p>', 
                                   full_html, re.IGNORECASE | re.DOTALL)
        if standalone_in_p:
            return True
    
        # Check if tag is at the beginning of a paragraph with minimal content after
        start_of_p = re.search(r'<p[^>]*>\s*' + re.escape(tag_text) + r'([^<]{0,20})</p>', 
                              full_html, re.IGNORECASE | re.DOTALL)
        if start_of_p:
            after_text = start_of_p.group(1).strip()
            if not after_text or re.match(r'^[\s\.,;:!?]*$', after_text):
                return True
    
        # Check if tag is by itself between block elements or at beginning/end of content
        tag_pos = full_html.find(tag_text)
    
        # Look at content before the tag
        preceding = full_html[:tag_pos].strip()
        preceding_ends_with_block = re.search(r'(>|^)\s*$', preceding)
    
        # Look at content after the tag
        following = full_html[tag_pos + len(tag_text):].strip()
        following_starts_with_block = re.search(r'^\s*(<|$)', following)
    
        if preceding_ends_with_block and following_starts_with_block:
            return True
    
        # If no evidence of standalone, assume it's inline
        return False

    def _normalize_header_text(self, text):
        """
        Normalize header text by stripping all common formatting patterns.
        This ensures consistent header formatting regardless of source.
        """
        import re
        
        stripped_text = text.strip()
        
        # Remove various formatting patterns (order matters - most specific first)
        patterns_to_remove = [
            r'^\[\[(.*?)\]\]$',        # [[text]]
            r'^\*{2,}(.*?)\*{2,}$',    # **text** or ****text****
            r'^\*{1,}(.*?)\*{1,}$',    # *text* or **text (incomplete)
            r'^#{1,}\s*(.*?)$',        # #text or ##text or ###text
            r'^={1,}\s*(.*?)$',        # =text or ==text
            r'^-{1,}\s*(.*?)$',        # -text or --text
            r'^_{1,}(.*?)_{1,}$',      # _text_ or __text__
            r'^`{1,}(.*?)`{1,}$',      # `text` or ```text```
            r'^"(.*?)"$',              # "text"
            r"^'(.*?)'$",              # 'text'
            r'^\((.*?)\)$',            # (text)
            r'^\[(.*?)\]$',            # [text]
            r'^\{(.*?)\}$',            # {text}
            r'^<(.*?)>$',              # <text>
        ]
        
        # Apply pattern removal
        for pattern in patterns_to_remove:
            match = re.match(pattern, stripped_text)
            if match:
                stripped_text = match.group(1).strip()
                break
        
        return stripped_text

    def _is_standalone_element(self, element):
        """
        Determine if an element is standalone (should be on its own line) or inline.
        Returns True if element appears to be a standalone paragraph-level element.
        """
        # Check if element is the only child of a block element like p, div, etc.
        if element.parent and element.parent.name in ['p', 'div', 'li', 'blockquote']:
            # Check if it's the only text content in its parent (ignoring whitespace)
            parent_text = element.parent.get_text().strip()
            element_text = element.get_text().strip()
            return parent_text == element_text
    
        # Check if element is preceded and followed by block elements or newlines
        prev_sibling = element.previous_sibling
        next_sibling = element.next_sibling
    
        # If no siblings or only whitespace siblings, it's standalone
        if (not prev_sibling or (hasattr(prev_sibling, 'strip') and not prev_sibling.strip())) and \
           (not next_sibling or (hasattr(next_sibling, 'strip') and not next_sibling.strip())):
            return True
    
        return False

    def standardize_line_spacing(self, text):
        """
        Preserve paragraph structure while formatting headers and verse numbers correctly.
        Ensures paragraphs stay separated by blank lines and headers are properly spaced.
        """
        import re

        # Standardize line breaks (replace Windows-style \r\n with \n)
        text = text.replace('\r\n', '\n')

        # First, normalize all paragraph breaks to exactly two newlines
        # This preserves the paragraph structure
        text = re.sub(r'\n{2,}', '\n\n', text)

        # Remove excessive spaces within lines (not newlines)
        text = re.sub(r' {2,}', ' ', text)

        # Remove leading/trailing spaces from lines
        text = re.sub(r'^ +| +$', '', text, flags=re.MULTILINE)

        # Ensure all headers have proper spacing - check for headers without proper spacing
        # Section Headers [[ ]]
        text = re.sub(r'(?<!\n\n)(\[\[.*?\]\])(?!\n\n)', r'\n\n\1\n\n', text)
    
        # Regular Headers ** **
        text = re.sub(r'(?<!\n\n)(\*\*.*?\*\*)(?!\n\n)', r'\n\n\1\n\n', text)
    
        # Clean up any excessive newlines that might have been created
        text = re.sub(r'\n{3,}', '\n\n', text)

        # Special handling for verse numbers - don't add paragraph breaks between numbered verses
        # But do preserve paragraph structure for non-verse content
        text = re.sub(r'([.!?])\n(?!\s*(?:\d+\.|\(\d+\)|\[\d+\]))', r'\1\n\n', text)

        return text

    def detect_and_format_verse_numbers(self, text):
        """Detect unformatted verse numbers in text and format them as superscript"""
        import re
    
        # Pattern 1: Space followed by number then capital letter (e.g., " 1Alif")
        text = re.sub(r'([.,:;?!\s])(\d+)([A-Z])', r'\1^\\2^\3', text)
    
        # Pattern 2: Lowercase letter after a word likely a note (e.g., "doubt,b")
        text = re.sub(r'([a-z],)([a-z])(\s)', r'\1^\\2^\3', text)
    
        # Pattern 3: Letter after comma or period (e.g., "prayer,a")
        text = re.sub(r'([,.])([a-z])(\s)', r'\1^\\2^\3', text)
    
        return text

    def format_verse_numbers(self, text):
        """Format verse numbers consistently while preserving their structure"""
        import re
    
        # Format verse numbers in parentheses: (1) Text of verse
        text = re.sub(r'\s*\((\d+)\)\s+', r' (\1) ', text)
    
        # Format verse numbers with periods: 1. Text of verse
        text = re.sub(r'^\s*(\d+)\.\s+', r'\1. ', text, flags=re.MULTILINE)
    
        # Format verse numbers in brackets: [1] Text of verse
        text = re.sub(r'\s*\[(\d+)\]\s+', r' [\1] ', text)
    
        return text
        
    def setPlainTextWithVisibilityCheck(self, text):
        """Set plain text and ensure it's visible"""
        self._visibility_ensured = True  # Prevent extra checks
        super().setPlainText(text)
        
        # Force black text color for all
        cursor = self.textCursor()
        cursor.select(QTextCursor.SelectionType.Document)
        format = QTextCharFormat()
        format.setForeground(QColor(0, 0, 0))  # Black
        cursor.mergeCharFormat(format)
        
        # Clear selection
        cursor.clearSelection()
        self.setTextCursor(cursor)
        
    def schedule_highlight(self):
        """Schedule highlighting after text changes like paste operations"""
        # Cancel any pending timer
        if hasattr(self, 'highlight_timer'):
            if self.highlight_timer.isActive():
                self.highlight_timer.stop()
        else:
            self.highlight_timer = QTimer()
            self.highlight_timer.setSingleShot(True)
            self.highlight_timer.timeout.connect(self.delayed_highlight)
    
        # Start a new timer with longer delay
        self.highlight_timer.start(250)  # 500ms delay
    
    def delayed_highlight(self):
        """
        Run highlighting after a delay. Relies on final highlighting pass
        to apply header/orphan/default formats after analysis.
        """
        print(f"{self._debug_timestamp()} [delayed_highlight] Starting delayed highlight process")

        highlighter = getattr(self, 'header_highlighter', None)
        if not highlighter and self.document():
            highlighter = getattr(self.document(), 'syntaxHighlighter', lambda: None)()

        progress = None
        original_paused_state = False
        original_rehighlighting_state = False
        text_content = self.toPlainText()

        try:
            if len(text_content) < 10:
                print(f"{self._debug_timestamp()} [delayed_highlight] Text too short, skipping.")
                return

            if highlighter:
                original_paused_state = getattr(highlighter, '_highlighting_paused', False)
                original_rehighlighting_state = getattr(highlighter, '_rehighlighting', False)
                print(f"{self._debug_timestamp()} [delayed_highlight] Original highlighter state: paused={original_paused_state}, rehighlighting={original_rehighlighting_state}")

            # --- Progress Dialog Setup ---
            show_progress_dialog = len(text_content) > 5000
            parent = self.parent()
            if hasattr(parent, '_suppress_progress_dialogs') and parent._suppress_progress_dialogs:
                 show_progress_dialog = False
                 print(f"{self._debug_timestamp()} [delayed_highlight] Progress dialog suppressed by parent.")

            if show_progress_dialog:
                print(f"{self._debug_timestamp()} [delayed_highlight] Creating progress dialog.")
                dialog_parent = parent if isinstance(parent, QWidget) else self
                progress = QProgressDialog("Processing document...", "Cancel", 0, 100, dialog_parent)
                progress.setWindowTitle("Document Processing")
                try:
                     progress.setWindowModality(Qt.WindowModality.WindowModal)
                except AttributeError:
                     try: progress.setWindowModality(Qt.WindowModal)
                     except AttributeError: print("Warning: Could not set progress dialog modality.")
                progress.setMinimumDuration(500)
                progress.show()
                QApplication.processEvents()
                if highlighter:
                    progress.canceled.connect(lambda: setattr(highlighter, '_highlighting_cancelled', True))
                    highlighter._shared_progress_dialog = progress
                    highlighter._shared_progress_min = 0
                    highlighter._shared_progress_max = 100
            elif highlighter:
                highlighter._shared_progress_dialog = None

            # --- STEP 1: Ensure Visibility ---
            if progress:
                progress.setLabelText("Ensuring text visibility...")
                progress.setValue(10)
                QApplication.processEvents()
                if progress.wasCanceled(): raise OperationCanceledError("Cancelled during visibility step")

            if hasattr(self,'ensure_text_visible') and hasattr(self, '_visibility_ensured'):
                 if not self._visibility_ensured:
                     print(f"{self._debug_timestamp()} [delayed_highlight] Ensuring text visibility.")
                     self.ensure_text_visible()
                 else:
                     print(f"{self._debug_timestamp()} [delayed_highlight] Visibility already ensured.")
            else:
                 print(f"{self._debug_timestamp()} [delayed_highlight] Visibility check skipped (method/attribute missing).")

            # --- STEP 2: Wait for Header Refresh ---
            if progress:
                progress.setLabelText("Checking header status...")
                progress.setValue(20)
                QApplication.processEvents()
                if progress.wasCanceled(): raise OperationCanceledError("Cancelled during header status check")

            if parent and hasattr(parent, '_headers_refresh_active') and parent._headers_refresh_active:
                 # ... (wait loop as before) ...
                 print(f"{self._debug_timestamp()} [delayed_highlight] Waiting for header refresh...")
                 wait_count = 0
                 while parent._headers_refresh_active and wait_count < 40:
                     QCoreApplication.processEvents()
                     time.sleep(0.05)
                     wait_count += 1
                     if progress and progress.wasCanceled(): raise OperationCanceledError("Cancelled while waiting")
                 if parent._headers_refresh_active: print(f"{self._debug_timestamp()} [delayed_highlight] Warning: Header refresh timed out.")
                 else: print(f"{self._debug_timestamp()} [delayed_highlight] Header refresh completed.")


            # --- STEP 3: Apply Header Formatting --- (REMOVED) ---
            # We will rely on the final rehighlight pass triggered by resume_highlighting

            # --- STEP 4: Force Orphaned Text Analysis ---
            if highlighter and hasattr(highlighter, 'check_for_orphaned_text'):
                if progress:
                    progress.setLabelText("Analyzing orphaned text...")
                    # Define progress range for this step
                    highlighter._shared_progress_min = 30 # Adjusted start range
                    highlighter._shared_progress_max = 90 # Allocate 30-90% for this
                    progress.setValue(30)
                    QApplication.processEvents()
                    if progress.wasCanceled(): raise OperationCanceledError("Cancelled before orphan check")

                print(f"{self._debug_timestamp()} [delayed_highlight] Forcing orphaned text analysis")

                # Temporarily override state flags
                flags_restored = False
                try:
                    print(f"{self._debug_timestamp()} [delayed_highlight] Temporarily setting paused=False, rehighlighting=False for orphan check")
                    if hasattr(highlighter, '_highlighting_paused'): highlighter._highlighting_paused = False
                    if hasattr(highlighter, '_rehighlighting'): highlighter._rehighlighting = False

                    highlighter.check_for_orphaned_text(use_shared_dialog=(progress is not None))

                    if getattr(highlighter, '_highlighting_cancelled', False):
                        raise OperationCanceledError("Orphan check cancelled internally or by user")

                except OperationCanceledError as cancel_err:
                     print(f"{self._debug_timestamp()} [delayed_highlight] Orphaned text check cancelled: {cancel_err}")
                     raise
                except Exception as e_check:
                     print(f"{self._debug_timestamp()} [delayed_highlight] Error during forced check: {e_check}")
                     # Decide how to handle this error
                finally:
                    # Restore original flags *immediately*
                    print(f"{self._debug_timestamp()} [delayed_highlight] Restoring highlighter flags after orphan check to: paused={original_paused_state}, rehighlighting={original_rehighlighting_state}")
                    if hasattr(highlighter, '_highlighting_paused'): highlighter._highlighting_paused = original_paused_state
                    if hasattr(highlighter, '_rehighlighting'): highlighter._rehighlighting = original_rehighlighting_state
                    flags_restored = True
            elif highlighter:
                print(f"{self._debug_timestamp()} [delayed_highlight] Highlighter has no check_for_orphaned_text method.")


            # --- STEP 5: Resume Highlighting (Crucial Step) ---
            # This will trigger the throttled rehighlight which should apply ALL formats correctly.
            if highlighter:
                 print(f"{self._debug_timestamp()} [delayed_highlight] Requesting resume_highlighting.")
                 if progress:
                     progress.setLabelText("Applying final format...")
                     progress.setValue(95) # Indicate starting final step
                     QApplication.processEvents()
                     if progress.wasCanceled(): raise OperationCanceledError("Cancelled before resuming highlight")

                 # Ensure highlighting is NOT paused before resuming
                 if hasattr(highlighter, '_highlighting_paused'):
                      highlighter._highlighting_paused = False

                 if hasattr(highlighter, 'resume_highlighting'):
                     highlighter.resume_highlighting()
                 else:
                     # Fallback if resume method doesn't exist
                     if hasattr(highlighter, 'rehighlight'): highlighter.rehighlight()

            # --- STEP 6: Final Completion ---
            if progress:
                progress.setValue(100)
                progress.setLabelText("Processing complete.")
                QApplication.processEvents()


        except OperationCanceledError as op_cancel:
             print(f"{self._debug_timestamp()} [delayed_highlight] Operation cancelled during processing: {op_cancel}")
             # Ensure highlighting is resumed if possible

        except Exception as e:
            print(f"{self._debug_timestamp()} [delayed_highlight] Error during delayed highlight: {e}")
            traceback.print_exc()
            # Ensure highlighting is resumed if possible

        finally:
            print(f"{self._debug_timestamp()} [delayed_highlight] Entering finally block.")
            # --- Cleanup ---
            if highlighter: # Check if highlighter exists before accessing it
                # Clear shared dialog reference and range
                if hasattr(highlighter, '_shared_progress_dialog'):
                    highlighter._shared_progress_dialog = None
                if hasattr(highlighter, '_shared_progress_min'):
                    highlighter._shared_progress_min = 0 # Reset default range
                if hasattr(highlighter, '_shared_progress_max'):
                    highlighter._shared_progress_max = 100 # Reset default range

                # **Final Highlighting State Check**
                # Ensure highlighting is left in the state it was *before* this method was called.
                current_paused = getattr(highlighter, '_highlighting_paused', False)
                if current_paused != original_paused_state:
                    print(f"{self._debug_timestamp()} [delayed_highlight] Final state mismatch: current_paused={current_paused}, original_paused={original_paused_state}. Adjusting...")
                    if original_paused_state:
                         # It should be paused, but isn't
                         if hasattr(highlighter, 'pause_highlighting'):
                             print(f"{self._debug_timestamp()} [delayed_highlight] Final check: Re-pausing highlighting.")
                             highlighter.pause_highlighting()
                         else: highlighter._highlighting_paused = True
                    else:
                         # It should be running, but isn't (paused)
                         if hasattr(highlighter, 'resume_highlighting'):
                             print(f"{self._debug_timestamp()} [delayed_highlight] Final check: Resuming highlighting.")
                             # Use QTimer to avoid direct call from finally if problematic
                             QTimer.singleShot(0, highlighter.resume_highlighting)
                         else:
                             highlighter._highlighting_paused = False
                             if hasattr(highlighter, 'rehighlight'): QTimer.singleShot(0, highlighter.rehighlight)
                else:
                     print(f"{self._debug_timestamp()} [delayed_highlight] Final highlighter pause state ({current_paused}) matches original ({original_paused_state}).")

                # Reset cancellation flag after processing is fully finished
                # *** Ensure this line has the same indentation as the lines above inside the 'if highlighter:' block ***
                print(f"{self._debug_timestamp()} [delayed_highlight] Resetting cancellation flag.")
                setattr(highlighter, '_highlighting_cancelled', False)

            # Close dialog
            if progress:
                # Ensure dialog shows completion/cancellation state before closing
                if progress.wasCanceled():
                    progress.setLabelText("Processing cancelled.")
                else:
                    # Check if progress object still exists and update
                    try:
                        progress.setValue(100) # Ensure it's 100 if not cancelled
                        progress.setLabelText("Processing complete.")
                    except RuntimeError: # Handle cases where the dialog might already be deleted
                        print(f"{self._debug_timestamp()} [delayed_highlight] Warning: Progress dialog was deleted before final update.")

                QTimer.singleShot(300, progress.close) # Slightly longer delay

            print(f"{self._debug_timestamp()} [delayed_highlight] Delayed highlight process finished.")

def log_js_result(result):
    print("\n=== DEBUG: JavaScript Result in highlight_text ===")
    print(f"Result: {result}")

def get_data_folder():
    """Get the path to the Data folder, creating it if necessary."""
    if getattr(sys, "frozen", False):  # Running as a bundled app
        program_dir = os.path.dirname(sys.executable)
    else:  # Running as a script
        program_dir = os.path.dirname(os.path.abspath(__file__))
    
    data_folder = os.path.join(program_dir, "Data")
    os.makedirs(data_folder, exist_ok=True)  # Create the folder if it doesn't exist
    return data_folder

class LoadRecentSessionDialog(QDialog):
    """Custom dialog to load recent or new session."""
    def __init__(self, recent_sessions, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Load Session")
        self.setFixedSize(550, 575)

        # --- Custom Tooltip Initialization ---
        self.custom_tooltip = None
        self._tooltip_item = None # Track the item the tooltip is currently for
        self._tooltip_timer = QTimer(self) # Timer to delay showing tooltip
        self._tooltip_timer.setSingleShot(True)
        self._tooltip_timer.setInterval(500) # Delay in milliseconds (e.g., 500ms)
        self._tooltip_timer.timeout.connect(self._show_custom_tooltip)
        self._current_hover_item = None # Item currently under the mouse
        # --- End Custom Tooltip Initialization ---


        # Center dialog (code assumed correct)
        if parent:
            parent_geometry = parent.geometry()
            x = parent_geometry.x() + (parent_geometry.width() - self.width()) // 2
            y = parent_geometry.y() + (parent_geometry.height() - self.height()) // 2
            self.move(x, y)
        else:
            screen_geometry = QApplication.primaryScreen().geometry()
            self.move(
                (screen_geometry.width() - self.width()) // 2,
                (screen_geometry.height() - self.height()) // 2
            )


        # Define class-level styles (LIST_WIDGET_STYLE, BUTTON_STYLE assumed correct)
        self.LIST_WIDGET_STYLE = """
            QListWidget {
                border: 1px solid #e0e0e0; border-radius: 6px; background: white;
                outline: none; padding: 2px; }
            QListWidget::item {
                padding: -2px; /* Let custom widget handle padding */
                min-height: 50px; /* Ensure enough height */
                background-color: #f9f9f9;
                margin: 2px; border-radius: 4px; border: none; }
            QListWidget::item:selected { background-color: #e3f2fd; }
            QListWidget::item:hover:!selected { background-color: #eaeaea; }
            QScrollBar:vertical { border: none; background: #f5f5f5; width: 8px; margin: 0px; }
            QScrollBar::handle:vertical { background: #c1c1c1; min-height: 25px; border-radius: 4px; }
            QScrollBar::handle:vertical:hover { background: #a8a8a8; }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical { background: none; }
        """
        # ----- THIS IS THE FIX -----
        # Ensure this has the actual styling rules, not placeholders
        self.BUTTON_STYLE = """
            QPushButton {
                background-color: #f0f0f0;
                color: #333333;
                border: 1px solid #cccccc;
                padding: 8px 16px;
                margin-left: 10px;
                margin-right: 10px;
                border-radius: 4px;
                font-weight: 500; /* Or normal */
            }
            QPushButton:hover {
                background-color: #e0e0e0;
                border-color: #b0b0b0;
            }
            QPushButton:pressed {
                background-color: #d0d0d0;
                border-color: #909090;
            }
        """

        # Process recent sessions (code assumed correct)
        self.recent_sessions = {}
        for session in recent_sessions:
             if isinstance(session, str):
                 self.recent_sessions[os.path.basename(session)] = {"path": session, "last_accessed": "Unknown"}
             elif isinstance(session, dict) and "path" in session:
                 self.recent_sessions[os.path.basename(session["path"])] = {
                     "path": session["path"],
                     "last_accessed": session.get("last_accessed", "Unknown")
                 }

        self.selected_file = None

        # --- Layout Setup ---
        layout = QVBoxLayout(self)
        layout.setContentsMargins(16, 20, 16, 24)
        layout.setSpacing(16)

        # Title label
        self.title_label = QLabel("Recent Sessions")
        self.title_label.setAlignment(Qt.AlignmentFlag.AlignLeft)
        self.title_label.setStyleSheet("""
            QLabel { color: #203740; font-size: 18px; font-weight: bold;
                     margin-left: 8px; margin-bottom: 4px; border: none; padding: 0; }
        """)
        layout.addWidget(self.title_label)

        # Placeholder label
        self.placeholder_label = QLabel("No recent sessions available.")
        self.placeholder_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.placeholder_label.setStyleSheet("""
            QLabel { color: #6c757d; font-size: 14px; font-style: italic; padding: 24px;
                     background-color: #f9f9f9; border-radius: 6px; }
        """)
        layout.addWidget(self.placeholder_label)

        # List container
        list_container = QWidget()
        list_container.setStyleSheet("""
            QWidget { background-color: #ffffff; border-radius: 6px; border: 1px solid #e0e0e0; }
        """)
        list_layout = QVBoxLayout(list_container)
        list_layout.setContentsMargins(1, 1, 1, 1)

        # Recent sessions list
        self.recent_list = QListWidget()
        self.recent_list.setStyleSheet(self.LIST_WIDGET_STYLE)
        self.recent_list.setCursor(Qt.CursorShape.PointingHandCursor)
        self.recent_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.recent_list.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.recent_list.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.recent_list.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)

        # --- Enable Mouse Tracking and Install Event Filter ---
        self.recent_list.setMouseTracking(True) # Crucial for receiving mouse move events constantly
        self.recent_list.viewport().setMouseTracking(True) # Also track on the viewport
        self.recent_list.installEventFilter(self) # Filter events on the list widget
        # --- End Event Filter Setup ---

        list_layout.addWidget(self.recent_list)
        layout.addWidget(list_container)

        self.refresh_recent_list()
        self.recent_list.itemClicked.connect(self.load_selected)
        # self.installEventFilter(self) # Removed filter on dialog, using list filter

        # Buttons layout
        button_layout = QHBoxLayout()
        button_layout.setSpacing(12)
        button_layout.setContentsMargins(8, 8, 8, 0)
        button_container = QWidget()
        button_container.setStyleSheet("""
            QWidget { background-color: #f5f5f5; border-radius: 6px; padding: 4px; }
        """)
        button_container_layout = QHBoxLayout(button_container)
        button_container_layout.setContentsMargins(8, 8, 8, 8)
        button_container_layout.setSpacing(12)
        browse_button = QPushButton("Browse...")
        browse_button.clicked.connect(self.browse_file)
        browse_button.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        browse_button.setStyleSheet(self.BUTTON_STYLE)
        button_container_layout.addWidget(browse_button)
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.reject)
        cancel_button.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        cancel_button.setStyleSheet(self.BUTTON_STYLE)
        button_container_layout.addWidget(cancel_button)
        layout.addWidget(button_container)

        # Context menu
        self.recent_list.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.recent_list.customContextMenuRequested.connect(self.show_context_menu)

    # --- NEW: Method to show the custom tooltip ---
    def _show_custom_tooltip(self):
        item = self._current_hover_item
        if not item:
            return

        tooltip_text = item.toolTip()
        if not tooltip_text:
            return

        # Create tooltip label if it doesn't exist
        if self.custom_tooltip is None:
            self.custom_tooltip = QLabel(self) # Parent is the dialog
            self.custom_tooltip.setObjectName("CustomTooltipLabel") # For styling
            self.custom_tooltip.setStyleSheet(CUSTOM_TOOLTIP_STYLE)
            self.custom_tooltip.setWindowFlags(Qt.WindowType.ToolTip | Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint)
            self.custom_tooltip.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
            self.custom_tooltip.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose) # Ensure cleanup

        # Update text and size
        self.custom_tooltip.setText(tooltip_text)
        self.custom_tooltip.adjustSize()

        # Calculate position
        try:
            # Get item rect relative to the list viewport
            viewport_rect = self.recent_list.visualItemRect(item)
            # Map the bottom-left of the item rect to global coordinates
            global_pos = self.recent_list.viewport().mapToGlobal(viewport_rect.bottomLeft())

            # Offset the tooltip slightly below and to the right of the item's bottom-left
            tooltip_pos = global_pos + QPoint(5, 3) # Adjust offset as needed

            # --- Screen Boundary Check ---
            screen = QApplication.screenAt(tooltip_pos)
            if not screen: screen = QApplication.primaryScreen()
            screen_rect = screen.availableGeometry()
            tooltip_rect = QRect(tooltip_pos, self.custom_tooltip.size())

            # Adjust horizontally if needed
            if tooltip_rect.right() > screen_rect.right():
                tooltip_pos.setX(screen_rect.right() - tooltip_rect.width() - 5)
            if tooltip_rect.left() < screen_rect.left():
                tooltip_pos.setX(screen_rect.left() + 5)

            # Adjust vertically if needed (prefer showing above if it overflows bottom)
            if tooltip_rect.bottom() > screen_rect.bottom():
                 # Map top-left of item to global
                 global_top_pos = self.recent_list.viewport().mapToGlobal(viewport_rect.topLeft())
                 tooltip_pos.setY(global_top_pos.y() - tooltip_rect.height() - 3) # Position above
                 # Recheck top boundary after moving above
                 if tooltip_pos.y() < screen_rect.top():
                     tooltip_pos.setY(screen_rect.top() + 5) # Fallback to top edge

            # Move and show
            self.custom_tooltip.move(tooltip_pos)
            self.custom_tooltip.show()
            self._tooltip_item = item # Mark which item this tooltip is for

        except Exception as e:
            print(f"Error positioning tooltip: {e}")
            self._hide_custom_tooltip()

    # --- NEW: Method to hide the custom tooltip ---
    def _hide_custom_tooltip(self):
        if self.custom_tooltip and self.custom_tooltip.isVisible():
            self.custom_tooltip.hide()
        self._tooltip_item = None # No item associated with tooltip anymore


    def parse_timestamp_to_sortable_key(self, timestamp_text):
        """
        Converts any timestamp format to a sortable string key.
        Returns a string in format 'yyyyMMddHHmmss' for proper sorting.
        """
        # Default return value for invalid dates (very old date)
        default_key = "19700101000000"
    
        # Handle new format: "Accessed: h:mm AP on MM.dd.yy"
        if timestamp_text.startswith("Accessed:"):
            try:
                # Extract time and date parts
                parts = timestamp_text.split("Accessed: ")[1]
                time_part = parts.split(" on ")[0].strip()  # h:mm AP
                date_part = parts.split(" on ")[1].strip()  # MM.dd.yy
            
                # Parse MM.dd.yy
                month, day, short_year = date_part.split(".")
                year = "20" + short_year  # Assuming 20xx
            
                # Parse h:mm AP
                time_val, am_pm = time_part.rsplit(" ", 1)
                hour, minute = time_val.split(":")
                hour = int(hour)
            
                # Convert to 24-hour format
                if am_pm.upper() == "PM" and hour < 12:
                    hour += 12
                elif am_pm.upper() == "AM" and hour == 12:
                    hour = 0
            
                # Format as sortable string: yyyyMMddHHmmss
                return f"{year}{month.zfill(2)}{day.zfill(2)}{str(hour).zfill(2)}{minute.zfill(2)}00"
            except Exception as e:
                print(f"Error parsing 'Accessed:' format: {timestamp_text}, Error: {e}")
    
        # Handle ISO format: "yyyy-MM-dd HH:mm:ss"
        elif "-" in timestamp_text and ":" in timestamp_text and len(timestamp_text) >= 16:
            try:
                # Extract date and time parts
                date_part, time_part = timestamp_text.split(" ", 1)
                year, month, day = date_part.split("-")
                hour, minute, second = time_part.split(":")
            
                # Format as sortable string: yyyyMMddHHmmss
                return f"{year}{month}{day}{hour}{minute}{second}"
            except Exception as e:
                print(f"Error parsing ISO format: {timestamp_text}, Error: {e}")
    
        # For any other format, try Qt date parsing as last resort
        try:
            dt = QDateTime.fromString(timestamp_text, Qt.DateFormat.TextDate)
            if dt.isValid():
                return dt.toString("yyyyMMddhhmmss")
        except:
            pass
        
        print(f"Failed to parse timestamp: {timestamp_text}, using default sorting")
        return default_key

    def add_to_recent_sessions(self, file_path):
        """Add a new session with current timestamp in a consistent format."""
        now_dt = QDateTime.currentDateTime()
    
        # Always use the new format for consistency
        time_str = now_dt.toString("h:mm AP")
        date_str = now_dt.toString("MM.dd.yy")
        formatted_timestamp = f"Accessed: {time_str} on {date_str}"
    
        basename = os.path.basename(file_path)

        # If entry already exists, just update timestamp
        if basename in self.recent_sessions:
            self.recent_sessions[basename]["last_accessed"] = formatted_timestamp
            self.recent_sessions[basename]["path"] = file_path
        else:
            # Remove oldest entry if limit reached
            if len(self.recent_sessions) >= 10:
                # Sort by timestamp to find the oldest
                sorted_sessions = sorted(
                    self.recent_sessions.items(),
                    key=lambda x: self.parse_timestamp_to_sortable_key(x[1]["last_accessed"])
                )
            
                # Delete the oldest (first item after sorting)
                if sorted_sessions:
                    del self.recent_sessions[sorted_sessions[0][0]]
        
            # Add new entry
            self.recent_sessions[basename] = {
                "path": file_path,
                "last_accessed": formatted_timestamp
            }

        self.save_recent_sessions()
        self.refresh_recent_list()

    def show_context_menu(self, position):
        """Show context menu for list items."""
        item = self.recent_list.itemAt(position)
        if item:
            menu = QMenu()
            menu.setStyleSheet("""
                QMenu {
                    background-color: white;
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    padding: 4px;
                    box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1);
                }
                QMenu::item {
                    padding: 8px 24px;
                    border-radius: 2px;
                }
                QMenu::item:selected {
                    background-color: #e3f2fd;
                    color: #2C4952;
                }
            """)
        
            remove_action = menu.addAction("Remove from Recent")
            action = menu.exec(self.recent_list.mapToGlobal(position))
        
            if action == remove_action:
                self.remove_session(item)

    def refresh_recent_list(self):
        """
        Refresh the recent sessions list with custom item widgets, styling,
        and setup for custom tooltips.
        """
        # --- Initial Setup ---
        self.recent_list.clear() # Clear previous items
        self.recent_list.setStyleSheet(self.LIST_WIDGET_STYLE) # Apply base list style

        # --- Sorting Sessions ---
        # Sort sessions by timestamp (most recent first)
        sorted_sessions = sorted(
            self.recent_sessions.items(),
            key=lambda x: self.parse_timestamp_to_sortable_key(x[1].get("last_accessed", "Unknown")),
            reverse=True
        )

        # --- Handle Empty List State ---
        list_container = self.recent_list.parentWidget() # Get the QWidget containing the list

        if not sorted_sessions:
            # List is empty: Show placeholder, hide list/title
            self.placeholder_label.setVisible(True)
            self.title_label.setVisible(False)
            self.recent_list.setVisible(False)

            # Style the placeholder for the empty state
            self.placeholder_label.setStyleSheet("""
                QLabel {
                    color: #6c757d; font-size: 14px; font-style: italic;
                    padding: 40px; background-color: #fdfdfd; border-radius: 6px;
                    border: 1px dashed #cccccc; /* Dashed border indicates empty */
                    margin: 1px; /* Ensure border fits */
                }""")
            # Hide the border of the list's container
            if list_container:
                list_container.setStyleSheet("border: none;")
            return # Exit the method, nothing more to do
        else:
            # List has items: Hide placeholder, show list/title
            self.placeholder_label.setVisible(False)
            self.title_label.setVisible(True)
            self.recent_list.setVisible(True)

            # Restore the border style for the list's container
            if list_container:
                list_container.setStyleSheet("""
                    QWidget {
                        background-color: #ffffff;
                        border-radius: 6px;
                        border: 1px solid #e0e0e0; /* Restore border */
                    }""")

        # --- Helper Functions (Defined within refresh_recent_list scope) ---
        def format_timestamp(timestamp_text):
            """Format or convert timestamp to standard 'Accessed: h:mm AP on MM.dd.yy' format"""
            if not isinstance(timestamp_text, str) or not timestamp_text or timestamp_text == "Unknown":
                 return "Unknown Access Time"

            if timestamp_text.startswith("Accessed:") and " on " in timestamp_text:
                return timestamp_text

            parsed_dt = None
            # Try parsing ISO-like formats
            for fmt in [Qt.DateFormat.ISODate, Qt.DateFormat.ISODateWithMs, "yyyy-MM-dd HH:mm:ss"]:
                try:
                    dt_iso = QDateTime.fromString(timestamp_text, fmt)
                    if dt_iso.isValid():
                        parsed_dt = dt_iso
                        break
                except Exception: continue

            # Try parsing TextDate format as a fallback
            if not parsed_dt or not parsed_dt.isValid():
                try:
                     dt_text = QDateTime.fromString(timestamp_text, Qt.DateFormat.TextDate)
                     if dt_text.isValid(): parsed_dt = dt_text
                except Exception: pass

            # Format if parsing succeeded
            if parsed_dt and parsed_dt.isValid():
                time_str = parsed_dt.toString("h:mm AP")
                date_str = parsed_dt.toString("MM.dd.yy")
                return f"Accessed: {time_str} on {date_str}"

            # Fallback: return original or default if unparseable
            print(f"Warning: Could not parse timestamp '{timestamp_text}', displaying as is.")
            return timestamp_text

        def truncate_name(name, max_length=42):
            """Truncate session name for display, removing .session extension."""
            clean_name = name.replace('.session', '') # Remove extension
            if len(clean_name) <= max_length:
                return clean_name, False  # Not truncated
            # Truncate and add ellipsis
            return clean_name[:max_length-3] + "...", True  # Truncated
        # --- End Helper Functions ---


        # --- Populate the List with Custom Item Widgets ---
        for basename, session_data in sorted_sessions:
            path = session_data.get('path', '')
            timestamp_text = session_data.get('last_accessed', 'Unknown')

            # Skip if essential data is missing
            if not path:
                 continue

            # Prepare display text and tooltip text
            formatted_timestamp = format_timestamp(timestamp_text)
            full_session_name = basename.replace('.session', '')  # Full name without extension
            display_session_name, was_truncated = truncate_name(basename)  # Display shows truncated name

            # --- Create Custom Item Widget ---
            item_widget = QWidget()
            # IMPORTANT: Transparent background allows QListWidget::item styles to show through
            item_widget.setStyleSheet("background-color: transparent; border: none;")
            item_layout = QHBoxLayout(item_widget)
            item_layout.setContentsMargins(12, 8, 12, 8) # Padding within the item
            item_layout.setSpacing(6)                   # Space between elements inside the item
            item_widget.setCursor(QCursor(Qt.CursorShape.PointingHandCursor)) # Indicate clickability

            # 1. Circle Indicator
            circle_indicator = QLabel()
            circle_indicator.setFixedSize(8, 8) # Small indicator size
            circle_indicator.setStyleSheet("""
                QLabel {
                    background-color: #2C4952; /* Indicator color */
                    border-radius: 4px;       /* Makes it a circle */
                    border: none;
                    /* Vertical alignment handled by QHBoxLayout */
                }
            """)
            # Add indicator, centered vertically by the layout
            item_layout.addWidget(circle_indicator, alignment=Qt.AlignmentFlag.AlignVCenter)

            # 2. Session Name Label
            name_label = QLabel(display_session_name) # Use truncated name
            name_label.setStyleSheet("""
                QLabel {
                    font-size: 14px;
                    font-weight: bold;    /* Make name stand out */
                    color: #203740;       /* Dark text color for name */
                    background: transparent; /* Ensure no background override */
                    border: none;
                    padding-bottom: 1px;  /* Fine-tune alignment if needed */
                }
            """)
            name_label.setMinimumWidth(150) # Prevent date label from crushing the name
            item_layout.addWidget(name_label)

            # 3. Horizontal Stretch
            # Pushes the date label to the right edge
            item_layout.addStretch(1)

            # 4. Last Accessed Date/Time Label
            date_label = QLabel(formatted_timestamp)
            # Align text within the label itself to the right
            date_label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            date_label.setStyleSheet("""
                QLabel {
                    font-size: 12px;
                    color: #666666;      /* Lighter gray for date */
                    background: transparent; /* Ensure no background override */
                    border: none;
                    white-space: nowrap; /* Prevent date from wrapping */
                    padding-left: 10px;  /* Space between stretch and date */
                }
            """)
            item_layout.addWidget(date_label)
            # --- End Custom Item Widget Creation ---


            # --- Create QListWidgetItem ---
            item = QListWidgetItem(self.recent_list) # Add item to the list
            # Store the full path as user data (used when item is clicked/selected)
            item.setData(Qt.ItemDataRole.UserRole, path)
            # Set the size hint based on the custom widget's preferred size
            item.setSizeHint(item_widget.sizeHint())

            # *** STORE Tooltip Text on the ITEM only if truncated ***
            if was_truncated:
                item.setToolTip(full_session_name)

            # Assign the custom widget to be displayed for this QListWidgetItem
            self.recent_list.setItemWidget(item, item_widget)
        # --- End Loop ---


    def mousePressEvent(self, event):
        """Handle mouse press events and deselect if no specific item is clicked."""
        clicked_item = self.recent_list.itemAt(self.recent_list.mapFromParent(event.position().toPoint()))
        if not clicked_item:
            self.recent_list.clearSelection()
        super().mousePressEvent(event)

    def eventFilter(self, source, event):
        """Handle mouse clicks anywhere in the dialog to deselect items."""
        if event.type() == QEvent.Type.MouseButtonPress:
            # Check if the click is outside the recent_list
            if not self.recent_list.geometry().contains(self.mapFromGlobal(event.globalPosition().toPoint())):
                self.recent_list.clearSelection()
        return super().eventFilter(source, event)

    # The remaining methods (load_selected, browse_file, remove_session, save_recent_sessions, get_selected_file)
    # remain unchanged as they don't directly affect the visual appearance
    
    def load_selected(self, item=None):
        """Load the selected recent session with error handling and drive letter fallback."""
        print("\n=== LOAD SELECTED START ===")
    
        if item is None:
            item = self.recent_list.currentItem()
            print(f"Item retrieved from current selection: {item}")

        if not item:
            print("No item selected. Exiting method.")
            print("=== LOAD SELECTED END ===\n")
            return

        file_path = item.data(Qt.ItemDataRole.UserRole)
        print(f"File path retrieved from item: {file_path}")

        # Step 1: Check if the file exists at the specified path
        if not os.path.exists(file_path):
            print(f"File not found at path: {file_path}")

            # Step 2: Attempt to rebuild the path using the program's drive letter
            if getattr(sys, 'frozen', False):
                # If running as an executable, the base directory is where the executable is
                program_dir = os.path.dirname(sys.executable)
            else:
                # If running as a script, the base directory is where the script is
                program_dir = os.path.dirname(os.path.abspath(__file__))

            program_drive = os.path.splitdrive(program_dir)[0]
            print(f"Program drive letter: {program_drive}")

            stored_drive, relative_path = os.path.splitdrive(file_path)
            print(f"Stored drive: {stored_drive}, Relative path: {relative_path}")

            rebuilt_path = program_drive + os.path.sep + relative_path.lstrip("\\/")

            print(f"Rebuilt path: {rebuilt_path}")

            # Check if the file exists at the rebuilt path
            if os.path.exists(rebuilt_path):
                print(f"File found at rebuilt path: {rebuilt_path}")
                file_path = rebuilt_path  # Update the file path
            else:
                print(f"File not found at rebuilt path: {rebuilt_path}")

                # Step 3: Prompt the user to locate the file manually
                reply = QMessageBox.question(
                    self,
                    "File Not Found",
                    f"Cannot find file in:\n{file_path}\n\nWould you like to update its location?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.Yes
                )
                print(f"User response to update location: {reply}")

                if reply == QMessageBox.StandardButton.Yes:
                    file_dialog = QFileDialog(self)
                    file_dialog.setWindowTitle("Update Session File Location")
                    file_dialog.setNameFilter("Session Files (*.session);;All Files (*)")
                    file_dialog.setFileMode(QFileDialog.FileMode.ExistingFile)
                    file_dialog.setViewMode(QFileDialog.ViewMode.Detail)

                    if file_dialog.exec() == QDialog.DialogCode.Accepted:
                        new_path = file_dialog.selectedFiles()[0]
                        print(f"New path selected by user: {new_path}")
                        try:
                            # Test if new file is readable
                            with open(new_path, 'r', encoding='utf-8') as f:
                                f.read(1)

                            # Update the path in recent sessions
                            basename = os.path.basename(file_path)
                            print(f"Basename for session update: {basename}")

                            if basename in self.recent_sessions:
                                print(f"Updating recent session with new path: {new_path}")
                                self.add_to_recent_sessions(new_path)  # Update timestamp and path
                                file_path = new_path  # Update file_path for loading
                        except (PermissionError, OSError) as e:
                            print(f"Error opening file at new path: {e}")
                            QMessageBox.critical(
                                self,
                                "Error",
                                f"Could not open the session file:\n{new_path}\n\nError: {str(e)}"
                            )
                            self.remove_session(item)
                            print("=== LOAD SELECTED END ===\n")
                            return
                    else:
                        print("User canceled file selection.")
                        self.remove_session(item)
                        print("=== LOAD SELECTED END ===\n")
                        return
                else:
                    print("User chose not to update file location.")
                    self.remove_session(item)
                    print("=== LOAD SELECTED END ===\n")
                    return

        try:
            # Test if file is readable
            print(f"Testing readability of file: {file_path}")
            with open(file_path, 'r', encoding='utf-8') as f:
                f.read(1)

            # Update recent sessions
            print(f"Adding file to recent sessions: {file_path}")
            self.add_to_recent_sessions(file_path)
            self.selected_file = file_path
            print(f"File successfully loaded: {file_path}")
            self.accept()

        except (PermissionError, OSError) as e:
            print(f"Error reading file: {file_path}, Error: {e}")
            QMessageBox.critical(
                self,
                "Error",
                f"Could not open the session file:\n{file_path}\n\nError: {str(e)}"
            )
            self.remove_session(item)

        print("=== LOAD SELECTED END ===\n")
            
    def browse_file(self):
        """Browse for a new session file."""
        file_dialog = QFileDialog(self)
        file_dialog.setWindowTitle("Select Session File")
        file_dialog.setNameFilter("Session Files (*.session);;All Files (*)")
        file_dialog.setFileMode(QFileDialog.FileMode.ExistingFile)
        file_dialog.setViewMode(QFileDialog.ViewMode.Detail)
    
        if file_dialog.exec() == QDialog.DialogCode.Accepted:
            selected_files = file_dialog.selectedFiles()
            if selected_files:
                file_path = selected_files[0]
            
                try:
                    # Test if file is readable
                    with open(file_path, 'r', encoding='utf-8') as f:
                        f.read(1)
                
                    self.add_to_recent_sessions(file_path)
                    self.selected_file = file_path
                    self.accept()
                
                except (PermissionError, OSError) as e:
                    QMessageBox.critical(
                        self,
                        "Error",
                        f"Could not open the session file:\n{file_path}\n\nError: {str(e)}"
                    )

    def remove_session(self, item):
        """Remove a session from the list and update storage."""
        print("\n=== REMOVE SESSION START ===")
        if not item:
            print("No item provided to remove")
            return
        
        file_path = item.data(Qt.ItemDataRole.UserRole)
        print(f"File path to remove: {file_path}")
    
        if not file_path:
            print("No file path found, removing item directly from list")
            row = self.recent_list.row(item)
            if row >= 0:
                self.recent_list.takeItem(row)
            return
        
        basename = os.path.basename(file_path)
        print(f"Basename: {basename}")
    
        print(f"Current sessions before removal: {list(self.recent_sessions.keys())}")
    
        if basename in self.recent_sessions:
            print(f"Found session to remove: {basename}")
            del self.recent_sessions[basename]
            print(f"Sessions after dictionary removal: {list(self.recent_sessions.keys())}")
        
            row = self.recent_list.row(item)
            if row >= 0:
                print(f"Removing item from row {row}")
                self.recent_list.takeItem(row)
            
            print("Saving updated sessions...")
            self.save_recent_sessions()
        else:
            print(f"Session not found in recent_sessions: {basename}")

        self.refresh_recent_list()  # Refresh list
    
        print("=== REMOVE SESSION END ===\n")

    def save_recent_sessions(self):
        """Save the list of recent sessions to a JSON file in the program's directory."""
        print("\n=== SAVE RECENT SESSIONS START ===")
        try:
            # Get the directory of the executable or script
            if getattr(sys, "frozen", False):  # Check if running as a bundled app
                base_dir = sys._MEIPASS  # This is where the temporary directory is located
                program_dir = os.path.dirname(sys.executable)  # Executable directory
            else:
                program_dir = os.path.dirname(os.path.abspath(__file__))  # Script directory

            # Create Data folder path
            data_folder = os.path.join(program_dir, "Data")
            file_path = os.path.join(data_folder, "recent_sessions.json")

            print(f"Saving to: {file_path}")

            # Ensure the Data folder exists
            if not os.path.exists(data_folder):
                print(f"Creating folder: {data_folder}")
                os.makedirs(data_folder, exist_ok=True)

            # Prepare the session data
            sessions_list = [
                {
                    "path": session_data["path"],
                    "last_accessed": session_data["last_accessed"]
                }
                for session_data in self.recent_sessions.values()
            ]

            print(f"Sessions to save: {sessions_list}")

            # Save the JSON file
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(sessions_list, f, indent=4)

            print("Save successful")

        except Exception as e:
            print(f"Error saving recent sessions: {e}")

        print("=== SAVE RECENT SESSIONS END ===\n")

    def get_selected_file(self):
        """Return the selected file after the dialog is accepted."""
        return self.selected_file

class HTMLNormalizer(HTMLParser):
    """Custom HTML parser to normalize HTML content."""

    def __init__(self):
        super().__init__()
        self.normalized_html = []
        self.current_tag = None

    def handle_starttag(self, tag, attrs):
        self.current_tag = tag
        attrs_str = ' '.join(f'{key}="{value}"' for key, value in sorted(attrs))
        self.normalized_html.append(f'<{tag} {attrs_str}>' if attrs else f'<{tag}>')

    def handle_endtag(self, tag):
        self.normalized_html.append(f'</{tag}>')
        self.current_tag = None

    def handle_data(self, data):
        if self.current_tag == 'script':
            # Normalize script contents (collapse whitespace)
            self.normalized_html.append(' '.join(data.split()))
        else:
            self.normalized_html.append(data.strip())

    def handle_entityref(self, name):
        self.normalized_html.append(f'&{name};')

    def handle_charref(self, name):
        self.normalized_html.append(f'&#{name};')

    def get_normalized_html(self):
        return ''.join(self.normalized_html)

def normalize_html(html):
    """Normalize HTML by parsing and reconstructing it."""
    parser = HTMLNormalizer()
    parser.feed(html)
    return parser.get_normalized_html()

def sanitize_html(html_text):
    # Remove any inline font-size styles
    sanitized = re.sub(r'style="[^"]*font-size[^"]*"', '', html_text, flags=re.IGNORECASE)
    # Remove any <font size=""> tags
    sanitized = re.sub(r'<font[^>]*size=[^>]*>', '', sanitized, flags=re.IGNORECASE)
    sanitized = re.sub(r'</font>', '', sanitized, flags=re.IGNORECASE)
    return sanitized

class SaveProgressDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Saving")
        self.setFixedSize(400, 150)  # Increased height
        
        # Set window flags for always-on-top behavior
        self.setWindowFlags(
            Qt.WindowType.Dialog | 
            Qt.WindowType.CustomizeWindowHint |
            Qt.WindowType.WindowTitleHint |
            Qt.WindowType.WindowStaysOnTopHint
        )
        
        # Add drop shadow effect
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(20)
        shadow.setColor(QColor(0, 0, 0, 50))
        shadow.setOffset(0, 4)
        self.setGraphicsEffect(shadow)
        
        # Main layout with proper spacing
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(25, 20, 25, 20)
        
        # Set white background with subtle border
        self.setStyleSheet("""
            QDialog {
                background-color: white;
                border: 1px solid #e0e0e0;
                border-radius: 0px;
            }
        """)
        
        # Status label
        self.status_label = QLabel("Saving session...")
        self.status_label.setStyleSheet("""
            QLabel {
                color: #1a1a1a;
                font-size: 14px;
                font-weight: 600;
                padding: 0px;
            }
        """)
        layout.addWidget(self.status_label)
        
        # Progress bar - increased height and improved styling
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setMinimumHeight(25)  # Increased height
        self.progress_bar.setStyleSheet("""
            QProgressBar {
                border: none;
                border-radius: 6px;
                background-color: #f0f0f0;
                text-align: center;
                margin: 0px;
                font-size: 12px;
                font-weight: 500;
                color: white;  /* Text color */
            }
            QProgressBar::chunk {
                background-color: #203740;
                border-radius: 6px;
            }
        """)
        layout.addWidget(self.progress_bar)
        
        # Detail label with better spacing
        self.detail_label = QLabel()
        self.detail_label.setWordWrap(True)  # Enable word wrap
        self.detail_label.setStyleSheet("""
            QLabel {
                color: #666666;
                font-size: 12px;
                font-style: italic;
                padding: 2px;
                min-height: 20px;
            }
        """)
        layout.addWidget(self.detail_label)
        
        # Cancel button with improved styling
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.setFixedWidth(100)
        self.cancel_button.setCursor(Qt.CursorShape.PointingHandCursor)  # Hand cursor on hover
        self.cancel_button.setStyleSheet("""
            QPushButton {
                background-color: #f5f5f5;
                color: #2196F3;
                border: 1px solid #e0e0e0;
                padding: 8px 16px;
                border-radius: 6px;
                font-weight: 500;
                font-size: 13px;
                min-height: 20px;
            }
            QPushButton:hover {
                background-color: #e3f2fd;
                border-color: #2196F3;
            }
            QPushButton:pressed {
                background-color: #bbdefb;
            }
        """)
        self.cancel_button.clicked.connect(self.reject)
        
        # Button layout with proper spacing
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        #button_layout.addWidget(self.cancel_button)
        layout.addLayout(button_layout)
        
        # Timing and animation setup
        self.cancelled = False
        self.start_time = QDateTime.currentMSecsSinceEpoch()
        self.min_display_time = 1000  # 1 second minimum
        
        # Timer for smooth progress animation
        self.complete_timer = QTimer(self)
        self.complete_timer.setSingleShot(True)
        self.complete_timer.timeout.connect(self.finish_and_close)
        
        # Adjust to the parent monitor
        self.adjust_to_parent_monitor()

    def adjust_to_parent_monitor(self):
        """Center the dialog on the parent window, not just the monitor."""
        parent_window = self.parent()
        if parent_window:
            # Get the parent window's geometry
            parent_geometry = parent_window.geometry()
            # Center dialog on parent window
            self.move(
                parent_geometry.center().x() - self.width() // 2,
                parent_geometry.center().y() - self.height() // 2
            )
        else:
            # If no parent is set, center on the primary monitor
            primary_screen = QApplication.primaryScreen()
            if primary_screen:
                screen_geometry = primary_screen.geometry()
                self.move(
                    screen_geometry.center().x() - self.width() // 2,
                    screen_geometry.center().y() - self.height() // 2
                )


    def update_progress(self, value, detail=""):
        """Update the progress bar and detail text."""
        self.progress_bar.setValue(value)
        if detail:
            self.detail_label.setText(detail)
        QApplication.processEvents()

    def accept(self):
        """Override accept to ensure minimum display time and proper completion."""
        if self.progress_bar.value() < 100:
            # Ensure progress bar reaches 100%
            self.smooth_progress_to_complete()
        else:
            self.check_and_close()

    def reject(self):
        """Handle dialog rejection with minimum display time."""
        self.cancelled = True
        self.check_and_close()

    def check_and_close(self):
        """Check if minimum display time has elapsed before closing."""
        elapsed = QDateTime.currentMSecsSinceEpoch() - self.start_time
        if elapsed < self.min_display_time:
            # Wait for remaining time
            QTimer.singleShot(self.min_display_time - elapsed, self.finish_and_close)
        else:
            self.finish_and_close()

    def smooth_progress_to_complete(self):
        """Smoothly animate progress bar to 100%."""
        current = self.progress_bar.value()
        if current < 100:
            steps = 100 - current
            interval = min(10, max(1, int(500 / steps)))  # Max 500ms total animation
            
            def update_step():
                new_value = self.progress_bar.value() + 1
                self.progress_bar.setValue(new_value)
                if new_value < 100:
                    QTimer.singleShot(interval, update_step)
                else:
                    self.check_and_close()
            
            update_step()

    def finish_and_close(self):
        """Final cleanup and close."""
        if self.cancelled:
            super().reject()
        else:
            super().accept()

    def update_status(self, status):
        """Update the main status text."""
        self.status_label.setText(status)
    
    def was_cancelled(self):
        """Check if the operation was cancelled."""
        return self.cancelled

class StoryboardHeaderDialog(QDialog):
    def __init__(self, existing_header=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Header Options")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.char_limit = 60  # Character limit for header text
        self.setStyleSheet("""
            QDialog {
                background-color: #f5f5f5;
            }
            QGroupBox {
                font-weight: bold;
                font-size: 13px;
                border: 1px solid #ddd;
                border-radius: 6px;
                margin-top: 18px;
                margin-bottom: 10px;
                background-color: white;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                padding: 0 0px;
            }
            QLabel {
                font-size: 12px;
                color: #444;
            }
            QLineEdit {
                padding: 6px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 13px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
            QPushButton {
                padding: 6px 12px;
                border: none;
                border-radius: 4px;
                background-color: #203740;
                color: white;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
            QPushButton:disabled {
                background-color: #ccc;
            }
            QComboBox {
                padding: 6px;
                border: 1px solid #ddd;
                border-radius: 4px;
                min-width: 150px;
            }
            QCheckBox {
                font-size: 12px;
                color: #444;
            }
        """)

        # Initialize variables
        self.current_symbol = ""
        self.current_color = QColor("#ffff7f")  # Changed from "yellow" to "#ffff7f"
        
        # Parse existing header if provided
        self.existing_header = existing_header
        if existing_header:
            self.parse_existing_header(existing_header)
        
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # Header text section
        text_group = QGroupBox("Header Text")
        text_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                font-size: 13px;
                border: 0px solid #ddd;
                border-radius: 6px;
                margin-top: 12px;
                margin-left: 0px;
                margin-bottom: 10px;
                background-color: transparent;
            }

            QGroupBox::title {
                left: 8px;
            }
        """)
        text_layout = QVBoxLayout()

        # Input container for text field, remove button, and counter
        input_container = QHBoxLayout()
        
        self.text_input = QLineEdit()
        self.text_input.setStyleSheet("""
            QLineEdit {
                margin-left: 0px;
            }
        """)
        self.text_input.setPlaceholderText(f"Enter header text (max {self.char_limit} characters)...")
        if existing_header:
            self.text_input.setText(self.parsed_text)
        
        # Create character counter label
        self.char_counter = QLabel()
        self.char_counter.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.char_counter.setStyleSheet("""
            QLabel {
                color: #666;
                font-size: 11px;
                padding-right: 8px;
                min-width: 25px;
            }
        """)
        
        # Add Remove button inline if there's an existing header
        self._remove_header = False
        self.remove_button = None
        if existing_header:
            self.remove_button = QPushButton("Remove")
            self.remove_button.setStyleSheet("""
                QPushButton {
                    background-color: #DC3545;
                    color: white;
                    padding: 6px 12px;
                    border: none;
                    border-radius: 4px;
                    font-size: 12px;
                    max-width: 80px;
                }
                QPushButton:hover {
                    background-color: #C82333;
                }
            """)
            self.remove_button.clicked.connect(self.mark_for_removal)
        
        # Add widgets to input container with appropriate stretching
        input_container.addWidget(self.text_input, 4)  # Text input gets more space
        if self.remove_button:
            input_container.addWidget(self.remove_button)
        input_container.addWidget(self.char_counter)
        
        text_layout.addLayout(input_container)
        
        # Connect text input events
        self.text_input.textChanged.connect(self.on_text_changed)
        self.text_input.installEventFilter(self)  # Install event filter for key press handling
        
        text_group.setLayout(text_layout)
        layout.addWidget(text_group)

        # Highlight options section - changed to horizontal layout
        highlight_group = QGroupBox("Highlight")
        highlight_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                font-size: 13px;
                border: 0px solid #ddd;
                border-radius: 6px;
                margin-top: 15px;
                margin-left: 0px;
                margin-bottom: 0px;
                background-color: transparent;
            }

            QGroupBox::title {
                bottom: 2px;
                left: 6px;
            }
        """)
        highlight_layout = QHBoxLayout()  # Changed to horizontal layout

        # Initialize the checkbox with updated text
        self.highlight_cb = QCheckBox("Add Highlight")  # Renamed from "Add background highlight"
        self.highlight_cb.setChecked(False if not existing_header else self.has_highlight)
        self.highlight_cb.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)  # Keep checkbox at its natural size
        highlight_layout.addWidget(self.highlight_cb)

        # Initialize the color button - now with flexible width
        self.color_button = QPushButton()
        self.color_button.setFixedHeight(15)  # Reduced from 30 to 15
        self.update_color_button()
        self.color_button.clicked.connect(self.choose_color)
        highlight_layout.addWidget(self.color_button, 1)  # Give it a stretch factor of 1
        
        # No stretch needed since the color button will expand
        highlight_group.setLayout(highlight_layout)
        layout.addWidget(highlight_group)

        # Decorative Symbols section
        decorator_group = QGroupBox("Decorative Symbols")
        decorator_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                font-size: 13px;
                border: 0px solid #ddd;
                border-radius: 6px;
                margin-top: 12px;
                margin-left: 10px;
                margin-bottom: 0px;
                background-color: transparent;
            }
            QGroupBox::title {
                left: 8px;
            }

        """)
        decorator_layout = QVBoxLayout()
        category_layout = QHBoxLayout()
        category_label = QLabel("Symbol Category:")
        self.symbol_combo = QComboBox()
        self.symbol_sets = {
            "Basic": ["――――", "★", "🡅", "🡇"],
            "Faces": [
                "😀",  # Big smile / Very happy
                "😢",  # Crying / Very sad
                "😱",  # Surprised / Shocked
                "🤔",  # Thinking
            ],
        }
        self.symbol_combo.addItems(self.symbol_sets.keys())
        self.symbol_combo.currentTextChanged.connect(self.update_symbol_grid)
        category_layout.addWidget(category_label)
        category_layout.addWidget(self.symbol_combo)

        # Add the remove symbol button
        self.remove_symbol_button = QPushButton("Remove")
        self.remove_symbol_button.setStyleSheet("""
            QPushButton {
                background-color: #DC3545;
                color: white;
                padding: 4px 8px;
                border: none;
                border-radius: 4px;
                font-size: 11px;
                max-width: 70px;
            }
            QPushButton:hover {
                background-color: #C82333;
            }
        """)
        self.remove_symbol_button.clicked.connect(self.remove_symbols)
        self.remove_symbol_button.setVisible(bool(self.current_symbol))  # Only visible if symbol is selected
        category_layout.addWidget(self.remove_symbol_button)

        category_layout.addStretch()
        decorator_layout.addLayout(category_layout)

        self.symbol_grid = QGridLayout()
        self.symbol_grid.setSpacing(5)
        decorator_layout.addLayout(self.symbol_grid)
        decorator_group.setLayout(decorator_layout)
        layout.addWidget(decorator_group)

        # Preview section
        preview_group = QGroupBox("Preview")
        preview_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                font-size: 13px;
                border: 0px solid #ddd;
                border-radius: 6px;
                margin-top: 12px;
                margin-left: 0px;
                margin-bottom: 10px;
                background-color: transparent;
            }

            QGroupBox::title {
                left: 8px;
            }
        """)
        preview_layout = QVBoxLayout()
        self.preview_label = QLabel()
        self.preview_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.preview_label.setStyleSheet("""
            QLabel {
                padding: 15px;
                background-color: #fafafa;
                border: 1px solid #eee;
                border-radius: 4px;
                font-size: 14px;
            }
        """)
        preview_layout.addWidget(self.preview_label)
        preview_group.setLayout(preview_layout)
        layout.addWidget(preview_group)

        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | 
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

        self.update_symbol_grid()
        self.text_input.textChanged.connect(self.update_preview)
        self.highlight_cb.stateChanged.connect(self.update_preview)

        # Initialize character counter
        self.update_char_counter(self.text_input.text())
        self.update_preview()

    def remove_symbols(self):
        """Remove all occurrences of the current symbol from the header text."""
        if self.current_symbol:
            # Remove every instance of the symbol (e.g. "――――") from the input
            text = self.text_input.text().replace(self.current_symbol, "")
            self.text_input.setText(text)
        # Clear the stored symbol and hide the button
        self.current_symbol = ""
        self.remove_symbol_button.setVisible(False)
        self.update_preview()


    def add_remove_button(self):
        """Legacy method kept for compatibility - now handled in __init__"""
        pass  # We now create the Remove button in __init__

    def mark_for_removal(self):
        """Mark the header for removal and accept the dialog."""
        self._remove_header = True
        self.accept()

    def should_remove_header(self):
        """Return True if the header should be removed."""
        return self._remove_header

    def eventFilter(self, obj, event):
        """Event filter to handle key press events for character limiting"""
        if obj == self.text_input and event.type() == QEvent.Type.KeyPress:
            # Always allow navigation keys
            if event.key() in (Qt.Key.Key_Left, Qt.Key.Key_Right, Qt.Key.Key_Backspace, 
                             Qt.Key.Key_Delete, Qt.Key.Key_Home, Qt.Key.Key_End):
                return False
                
            # Block input if at limit, unless text is selected (will be replaced)
            if len(self.text_input.text()) >= self.char_limit and not self.text_input.hasSelectedText():
                return True
                
        return super().eventFilter(obj, event)

    def on_text_changed(self, text):
        """Handle text input changes"""
        self.update_char_counter(text)
        
        # Truncate text if it somehow exceeds the limit
        if len(text) > self.char_limit:
            self.text_input.setText(text[:self.char_limit])

    def update_char_counter(self, text):
        """Update the character counter and its styling"""
        count = len(text)
        self.char_counter.setText(f"{count}/{self.char_limit}")
        
        # Update counter color based on character count
        if count > self.char_limit:
            self.char_counter.setStyleSheet("""
                QLabel {
                    color: #dc3545;
                    font-size: 11px;
                    padding-right: 8px;
                    min-width: 50px;
                }
            """)
        else:
            self.char_counter.setStyleSheet("""
                QLabel {
                    color: #666;
                    font-size: 11px;
                    padding-right: 8px;
                    min-width: 50px;
                }
            """)

    def parse_existing_header(self, header):
        """Parse existing header to extract components"""
        if not header:  # Handle None or empty header
            self.has_highlight = False
            self.highlight_color = QColor("#ffff7f")  # Changed from "yellow" to "#ffff7f"
            self.current_color = self.highlight_color
            self.parsed_text = ""
            self.left_decorator = ""
            self.right_decorator = ""
            self.current_symbol = ""
            return

        # Remove div and newline
        header = header.replace("<div>", "").replace("</div>", "").strip()

        # Extract highlight information
        self.has_highlight = "background-color:" in header
        if self.has_highlight:
            match = re.search(r"background-color:\s*([^;'\"]+)", header)
            self.highlight_color = QColor(match.group(1) if match else "#ffff7f")  # Changed from "yellow" to "#ffff7f"
            self.current_color = self.highlight_color  # Set current color to match existing header

        # Extract text and decorators
        text = re.sub(r'<[^>]+>', '', header).strip()
        if text:
            # Check for decorators (symbols) at the start and end
            self.left_decorator = text[0] if len(text) > 0 and not text[0].isalnum() else ""
            self.right_decorator = text[-1] if len(text) > 1 and not text[-1].isalnum() else ""

            # Extract the actual text between decorators, if any
            if self.left_decorator and self.right_decorator:
                self.parsed_text = text[1:-1]
                if self.left_decorator == self.right_decorator:
                    self.current_symbol = self.left_decorator
                else:
                    self.current_symbol = ""
            else:
                self.parsed_text = text  # No decorators present
                self.current_symbol = ""
        else:
            self.parsed_text = ""
            self.left_decorator = ""
            self.right_decorator = ""
            self.current_symbol = ""

    def update_color_button(self):
        """Update the color button appearance without bottom padding"""
        gradient_style = f"""
            QPushButton {{
                background-color: {self.current_color.name()};
                min-height: 15px;
                height: 15px;
                border: 1px solid #ccc;
                border-radius: 4px;
                width: 100%;  /* Fill available width */
            }}
            QPushButton:hover {{
                border-color: #2196F3;
            }}
        """
        self.color_button.setStyleSheet(gradient_style)
        self.color_button.setToolTip(f"Current color: {self.current_color.name()}")

    def choose_color(self):
        """Open color picker dialog with enhanced functionality"""
        color_dialog = QColorDialog(self.current_color, self)
        color_dialog.setWindowTitle("Choose Background Color")
        color_dialog.setOption(QColorDialog.ColorDialogOption.ShowAlphaChannel, False)
        
        # Add custom colors
        custom_colors = [
            "#ffff7f",  # Default light yellow (first option)
            "#FFD700",  # Gold
            "#FFA07A",  # Light Salmon
            "#98FB98",  # Pale Green
            "#87CEFA",  # Light Sky Blue
            "#DDA0DD",  # Plum
            "#F0E68C",  # Khaki
            "#E6E6FA",  # Lavender
            "#FFB6C1",  # Light Pink
            "#FFDAB9",  # Peach Puff
        ]
        
        for i, color in enumerate(custom_colors):
            color_dialog.setCustomColor(i, QColor(color))
        
        if color_dialog.exec() == QDialog.DialogCode.Accepted:
            self.current_color = color_dialog.selectedColor()
            self.update_color_button()
            self.update_preview()

    def update_symbol_grid(self):
        """Update the symbol grid with improved styling"""
        while self.symbol_grid.count():
            item = self.symbol_grid.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        symbols = self.symbol_sets[self.symbol_combo.currentText()]
        for i, symbol in enumerate(symbols):
            btn = QPushButton(symbol)
            btn.setFixedSize(40, 40)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #f8f9fa;
                    border: 1px solid #dee2e6;
                    font-size: 16px;
                    color: black;
                }
                QPushButton:hover {
                    background-color: #e9ecef;
                    border-color: #2196F3;
                }
            """)
            btn.clicked.connect(lambda checked, s=symbol: self.add_symbol(s))
            self.symbol_grid.addWidget(btn, i // 5, i % 5)

    def add_symbol(self, symbol):
        """Add selected symbol to both sides of the text"""
        self.current_symbol = symbol
        self.remove_symbol_button.setVisible(True)  # Show the remove button
        self.update_preview()

    def update_preview(self):
        """Update the preview label with current settings"""
        text = self.text_input.text().strip()
    
        if not text:  # Gracefully handle empty or missing text
            self.preview_label.setText("<i>No preview available</i>")
            return
    
        formatted_text = f"{self.current_symbol}{text}{self.current_symbol}"
        if self.highlight_cb.isChecked():
            preview = f"<b style='background-color: {self.current_color.name()};'>{formatted_text}</b>"
        else:
            preview = f"<b>{formatted_text}</b>"
    
        self.preview_label.setText(preview)

    def get_header_html(self):
        """Get the final header HTML"""
        text = self.text_input.text().strip()
        
        # Validate text length before returning
        if len(text) > self.char_limit:
            text = text[:self.char_limit]  # Truncate if somehow longer than limit
            
        if text:
            formatted_text = f"{self.current_symbol}{text}{self.current_symbol}"
            if self.highlight_cb.isChecked():
                return f"<div><b style='background-color: {self.current_color.name()};'>{formatted_text}</b></div>"
            else:
                return f"<div><b>{formatted_text}</b></div>"
        return ""

def truncate_to_two_lines(full_text, font, max_width):
    """
    Truncate full_text so that it fits into two lines within max_width using font metrics.
    If it doesn't fit, append '...' at the end.
    This method tries words from the full text and measures the bounding rectangle repeatedly.
    """
    fm = QFontMetrics(font)

    # Determine line height
    line_height = fm.lineSpacing()
    max_height = line_height * 2

    # Check if the full text fits as is
    rect = fm.boundingRect(0, 0, max_width, 10000, Qt.TextFlag.TextWordWrap, full_text)
    if rect.height() <= max_height:
        return full_text  # Fits in two lines already

    # If not, we truncate
    words = full_text.split()
    # We'll do a binary search or iterative approach to find the max fitting text
    low, high = 0, len(words)
    best_fit = ""

    while low < high:
        mid = (low + high) // 2
        candidate = " ".join(words[:mid]) + "..."
        rect = fm.boundingRect(0, 0, max_width, 10000, Qt.TextFlag.TextWordWrap, candidate)
        if rect.height() <= max_height:
            # candidate fits, try for more words
            best_fit = candidate
            low = mid + 1
        else:
            # candidate too large
            high = mid

    return best_fit if best_fit else (words[0] + "...") if words else "..."

class EditTextDialog(QDialog):
    def __init__(self, current_text, current_notes="", parent=None):
        super().__init__(parent)
        self.setWindowTitle("Edit Annotation Content in Script Editor")
        self.setModal(True)
        self.setFixedSize(450, 425)  # Slightly increased height to accommodate new label
        # Customizing Stylesheet for Modern Look
        self.setStyleSheet("""
            QDialog {
                background-color: #f4f4f4;
                border-radius: 10px;
            }
            QLabel {
                font-size: 14px;
                font-weight: bold;
                color: #333;
            }
            QTextEdit {
                background-color: #ffffff;
                border: 1px solid #ddd;
                border-radius: 5px;
                font-size: 14px;
                padding: 8px;
                color: #444;
            }
            QLineEdit {
                background-color: #ffffff;
                border: 1px solid #ddd;
                border-radius: 5px;
                font-size: 14px;
                padding: 8px;
                color: #444;
            }
            QDialogButtonBox {
                button-layout: 0;
            }
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 5px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #005fa1;
            }
            QPushButton:pressed {
                background-color: #003f6b;
            }
        """)
        # Layout and Widgets
        layout = QVBoxLayout(self)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        # Info label at the top
        info_label = QLabel("Changes made to content will only appear in the Script Ediotr")
        info_label.setStyleSheet("""
            QLabel {
                font-size: 12px;
                font-weight: normal;
                color: #666666;
                font-style: italic;
            }
        """)
        info_label.setAlignment(Qt.AlignmentFlag.AlignLeft)
        layout.addWidget(info_label)

        # # Text section
        # text_label = QLabel("Content:")
        # layout.addWidget(text_label)
        
        self.text_edit = CustomTextEdit(current_text, self)
        self.text_edit.setMinimumHeight(150)
        layout.addWidget(self.text_edit)

        # # Info label at the top
        # info2_label = QLabel("Changes to footnootes will appear in theme view and storyboard.")
        # info2_label.setStyleSheet("""
        #     QLabel {
        #         font-size: 12px;
        #         font-weight: normal;
        #         color: #666666;
        #         font-style: italic;
        #     }
        # """)
        # info2_label.setAlignment(Qt.AlignmentFlag.AlignLeft)
        # layout.addWidget(info2_label)

        # Notes section
        #notes_label = QLabel("Footnotoes")
        #layout.addWidget(notes_label)
        
        #self.notes_edit = QLineEdit(current_notes, self)
        #self.notes_edit.setPlaceholderText("Add footnote...")
        # layout.addWidget(self.notes_edit)

        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Cancel)
        layout.addWidget(button_box)

        # Signals
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)

    def get_text(self):
        """Return the edited text with rich text formatting preserved."""
        doc = self.text_edit.document()
        # Convert document to HTML
        html = doc.toHtml()
        # Remove the full HTML document boilerplate
        html_content_match = re.search(r'<body[^>]*>(.*)</body>', html, re.DOTALL | re.IGNORECASE)
        if html_content_match:
            return html_content_match.group(1).strip()
        return html
        
    def get_notes(self):
        """Return the edited notes."""
        return self.notes_edit.text().strip()

class CustomTextEdit(QTextEdit):
    def __init__(self, initial_text, parent=None):
        super().__init__(parent)
        self.setText(initial_text)

    def contextMenuEvent(self, event):
        """Customize the context menu to include highlight options."""
        menu = self.createStandardContextMenu()

        # Add 'Highlight Text' Action
        highlight_action = QAction("Highlight Text", self)
        highlight_action.triggered.connect(self.highlight_selected_text)
        menu.addAction(highlight_action)

        # Add 'Remove Highlight' Action
        remove_highlight_action = QAction("Remove Highlight", self)
        remove_highlight_action.triggered.connect(self.remove_highlight)
        menu.addAction(remove_highlight_action)

        # Display the menu
        menu.exec(event.globalPos())

    def highlight_selected_text(self):
        """Highlight the currently selected text."""
        cursor = self.textCursor()
        if cursor.hasSelection():
            fmt = cursor.charFormat()
            fmt.setBackground(QColor("yellow"))  # Set the highlight color
            cursor.mergeCharFormat(fmt)

    def remove_highlight(self):
        """Remove highlight from the selected text."""
        cursor = self.textCursor()
        if cursor.hasSelection():
            fmt = QTextCharFormat()
            fmt.setProperty(QTextCharFormat.Property.BackgroundBrush, Qt.GlobalColor.transparent)  # Clear highlight
            cursor.mergeCharFormat(fmt)

class WordCountTimer:
    """
    Class to calculate word count and speech time estimates
    for text in the StoryboardDialog order list.
    Excludes header text and strikethrough text from counts.
    """
    def __init__(self, parent_dialog):
        self.parent = parent_dialog
        
        # Create the word count label with new format
        self.word_count_label = QLabel("Script Length | 0m:00s - 0m:00s - 0m:00s")
        self.word_count_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.word_count_label.setStyleSheet("""
            QLabel {
                background-color: #f5f5f5;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 5px 15px;
                font-size: 12px;
                color: #555;
                margin: 5px 0;
            }
        """)
        
        # Add the label to the parent dialog's layout
        parent_dialog.layout().addWidget(self.word_count_label)
        
        # Connect to events that might change the word count
        parent_dialog.order_list.model().rowsInserted.connect(self.update_word_count)
        parent_dialog.order_list.model().rowsRemoved.connect(self.update_word_count)
        
        # Initial update
        self.update_word_count()
    
    def update_word_count(self):
        """Calculate word count and speech time estimates, excluding headers and strikethrough text."""
        total_words = 0
        
        # Iterate through all items in the order list
        for i in range(self.parent.order_list.count()):
            item = self.parent.order_list.item(i)
            widget = self.parent.order_list.itemWidget(item)
            
            # Skip dividers
            if widget and hasattr(widget, 'is_divider') and widget.is_divider:
                continue
                
            # Get text label
            text_label = None
            if widget:
                for label in widget.findChildren(QLabel):
                    if label.objectName() == "main_content_label":
                        text_label = label
                        break
            
            if text_label:
                # Get text with HTML tags
                html_text = text_label.text()
                
                # Extract and remove header text (common header patterns)
                header_patterns = [
                    r'<div><b[^>]*>(.*?)</b></div>',                 # <div><b>Header</b></div>
                    r'<p[^>]*><b[^>]*>(.*?)</b></p>',                # <p><b>Header</b></p>
                    r'<b[^>]*>(.*?)</b>',                            # <b>Header</b>
                    r'<span[^>]*style=[\'"][^"\']*font-weight:700[^"\']*[\'"]>(.*?)</span>',  # styled span with font-weight:700
                    r'<h[1-6][^>]*>(.*?)</h[1-6]>'                   # <h1>-<h6> tags
                ]
                
                # Find and remove all header text
                html_without_headers = html_text
                header_words = 0
                
                for pattern in header_patterns:
                    headers = re.findall(pattern, html_without_headers)
                    for header in headers:
                        # Clean the header text of any nested HTML
                        clean_header = re.sub(r'<[^>]+>', '', header)
                        # Count words in the header
                        header_word_count = len(re.findall(r'\b\w+\b', clean_header))
                        header_words += header_word_count
                    
                    # Remove the headers from the text to avoid duplicated content
                    html_without_headers = re.sub(pattern, '', html_without_headers)
                
                # First get all words in the remaining text by removing all HTML tags
                plain_text = re.sub(r'<[^>]+>', '', html_without_headers)
                all_words = len(re.findall(r'\b\w+\b', plain_text))
                
                # Then get all words in strikethrough sections
                strikethrough_words = 0
                strikethrough_segments = re.findall(r'<s style=\"color:#FF9999;\">(.*?)</s>', html_without_headers)
                for segment in strikethrough_segments:
                    # Remove any potential nested HTML tags
                    clean_segment = re.sub(r'<[^>]+>', '', segment)
                    words_in_segment = len(re.findall(r'\b\w+\b', clean_segment))
                    strikethrough_words += words_in_segment
                
                # Calculate net words (excluding both headers and strikethrough)
                words_in_item = all_words - strikethrough_words
                total_words += words_in_item
                
                #print(f"Item {i}: Total words={all_words}, Strikethrough={strikethrough_words}, " 
                      #f"Headers={header_words}, Final count={words_in_item}")
        
        # Calculate speech times
        fast_seconds = (total_words / 215) * 60
        avg_seconds = (total_words / 200) * 60
        slow_seconds = (total_words / 180) * 60
        
        # Format times with the new format (minutes and seconds with m/s suffixes)
        fast_time = self._format_time_with_suffixes(fast_seconds)
        avg_time = self._format_time_with_suffixes(avg_seconds)
        slow_time = self._format_time_with_suffixes(slow_seconds)
        
        # Update the label with HTML formatting to highlight the average
        # Show times from shortest to longest (fast - avg - slow)
        self.word_count_label.setText(
            f"Script Length | "
            f"{fast_time} - <span style='font-weight:bold;color:#2C4952;'>{avg_time}</span> - {slow_time}"
        )
    
    def _format_time_with_suffixes(self, seconds):
        """Format seconds into hour:minute:second format with m/s suffixes."""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        
        if hours > 0:
            return f"{hours}h:{minutes}m:{secs:02d}s"
        else:
            return f"{minutes}m:{secs:02d}s"

class OrderListWidget(QListWidget):

    search_requested = pyqtSignal(str)
    def __init__(self, annotations, parent=None):
        super().__init__(parent)
        self.annotations = annotations
        self.scene_styles = {}
        
        # Store reference to main window for cleaner tab access
        self.main_window = getattr(parent, 'main_window', None) if parent else None
        self.setDragEnabled(True)
        
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.DragDropMode.DragDrop)
        self.setDefaultDropAction(Qt.DropAction.MoveAction)
        self.setWordWrap(True)
        self.setAlternatingRowColors(False)
        self.setTextElideMode(Qt.TextElideMode.ElideNone)
        self.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)

        # --- ADD THIS LINE ---
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        # ---------------------

        # Enable mouse tracking for cursor management
        self.setMouseTracking(True)
        self.viewport().setMouseTracking(True)

        # Keep track of the current width for resize detection
        self._last_width = self.viewport().width()

        # Improved auto-scroll settings
        self.setAutoScroll(True)
        self.setAutoScrollMargin(40)  # Increased margin for better control

        # Auto-scroll timer with improved settings
        self.scroll_timer = QTimer()
        self.scroll_timer.setInterval(85)  # Faster interval for smoother scrolling
        self.scroll_timer.timeout.connect(self.perform_scroll)
        self.current_scroll_direction = None
        self.scroll_step = 1  # Increased step size for smoother scrolling
        self.is_scrolling = False  # Flag to track scrolling state

        # Connect to the parent dialog's resize event
        if isinstance(self.window(), QDialog):
            self.window().installEventFilter(self)

        # Connect signals for item changes
        self.model().rowsInserted.connect(self.update)
        self.model().rowsRemoved.connect(self.update)
    
        # Handle our own resize events
        # This will capture when the list widget itself is resized
        self.viewport().installEventFilter(self)

        # Annotation lookup cache for O(1) performance
        self._annotation_cache = {}
        self._cache_dirty = True

        # Placeholder properties
        self.placeholder_text = "Drag and Drop From Theme Panel"
        self.placeholder_color = QColor("#888888")  # Grey color
        self.placeholder_font = self.font()
        self.placeholder_font.setPointSize(14)
        self.placeholder_font.setItalic(True)

        # Initial stylesheet for normal window state
        self.base_stylesheet = """
            QListWidget {
                background: #ffffff;
                border: 1px solid #ADADAD;
                margin-left: 20px;
                margin-right: 20px;
                border-radius: 5px;
                font-size: 16px;
                outline: none;
                padding: 5px;
            }
        
            QListWidget::item {
                background-color: #fafafa;
                border: 1px solid #e9ecef;
                border-radius: 4px;
                margin: 2px 5px;
                min-height: 20px;
            }
        
            QListWidget::item:selected {
                background-color: #e3f2fd;
                border: 1px solid #90caf9;
            }
        
            QListWidget::item:hover:!selected {
                background-color: #f5f5f5;
            }
            
            QListWidget[dragHover="true"] {
                border: 3px solid #2196F3 !important;
                background-color: rgba(33, 150, 243, 0.05) !important;
            }
        
            QLabel {
                font-size: 14px;
                color: #333;
                selection-background-color: #bbdefb;
                selection-color: #2C4952;
            }
        """
        
        self.maximized_stylesheet = """
            QListWidget {
                background: #ffffff;
                border: 1px solid #ADADAD;
                margin-left: 400px;
                margin-right: 400px;
                border-radius: 5px;
                font-size: 16px;
                outline: none;
                padding: 5px;
            }
        
            QListWidget::item {
                background-color: #fafafa;
                border: 1px solid #e9ecef;
                border-radius: 4px;
                margin: 2px 5px;
                min-height: 20px;
            }
        
            QListWidget::item:selected {
                background-color: #e3f2fd;
                border: 1px solid #90caf9;
            }
        
            QListWidget::item:hover:!selected {
                background-color: #f5f5f5;
            }
        
            QLabel {
                font-size: 14px;
                color: #333;
                selection-background-color: #bbdefb;
                selection-color: #2C4952;
            }
        """
    
        # Set initial stylesheet
        self.setStyleSheet(self.base_stylesheet)
    
        # Install event filter to monitor parent dialog's window state
        if isinstance(self.window(), QDialog):
            self.window().installEventFilter(self)

        # Signal connections moved to __init__ to avoid duplicate connections

    def _rebuild_annotation_cache(self):
        """Rebuild annotation lookup cache for O(1) access."""
        self._annotation_cache = {a.get('id'): a for a in self.annotations if a.get('id')}
        self._cache_dirty = False

    def _get_annotation(self, annotation_id):
        """Get annotation by ID with O(1) lookup."""
        if self._cache_dirty or not self._annotation_cache:
            self._rebuild_annotation_cache()
        return self._annotation_cache.get(annotation_id)

    def search_selected_text(self):
        """Handle F1 shortcut to search selected text"""
        current_item = self.currentItem()
        if not current_item:
            return

        widget = self.itemWidget(current_item)
        if not widget:
            return

        # Find the text label
        text_label = None
        for label in widget.findChildren(QLabel):
            if not label.text().startswith("[") and not label.text() == "⋮":
                text_label = label
                break

        if text_label and text_label.hasSelectedText():
            selected_text = text_label.selectedText()
            if selected_text.strip():
                self.request_theme_search(selected_text)

    def request_theme_search(self, text):
        """Request a search in the theme view with the selected text"""
        try:
            # Get main window
            main_window = None
            current_widget = self
            while current_widget:
                if isinstance(current_widget, ScriptoriaMain):
                    main_window = current_widget
                    break
                current_widget = current_widget.parent()

            if not main_window:
                return

            # If theme view isn't open or isn't visible
            if not main_window.theme_view or not main_window.theme_view.isVisible():
                main_window.view_annotations_button.setChecked(True)
                main_window.toggle_theme_view()
            
            # Clean text to ensure it's searchable
            clean_text = text.strip()
            if clean_text:
                self.search_requested.emit(clean_text)

        except Exception as e:
            print(f"Error requesting theme search: {e}")

    def mark_storyboard_widget_changes_pending(self):
        """Set the storyboard changes as pending and update the main window title."""
        # --- ADD THIS CHECK ---
        # If the list is currently being populated, don't mark changes as pending.
        # The population process itself will handle the final state.
        if hasattr(self, '_in_population') and self._in_population:
            # print("[DEBUG] Skipping changes_pending flag during population.")
            return
        # ---------------------

        parent_dialog = self.window()
        if isinstance(parent_dialog, StoryboardDialog):
            # Check if it's already true to avoid redundant operations/prints
            if not parent_dialog.changes_pending:
                parent_dialog.changes_pending = True
                print("[DEBUG] Storyboard changes_pending set to True") # Added debug
                if hasattr(parent_dialog.main_window, 'mark_changes_pending'):
                    # Call the main window's method to handle the title asterisk etc.
                    parent_dialog.main_window.mark_changes_pending()
                    print("[DEBUG] Called main_window.mark_changes_pending()") # Added debug
            # else: # Optional: print if already pending
            #     print("[DEBUG] Storyboard changes_pending was already True")

    def eventFilter(self, obj, event):
        if obj == self.window() and event.type() == QEvent.Type.WindowStateChange:
            if self.window().windowState() & Qt.WindowState.WindowMaximized:
                self.setStyleSheet(self.maximized_stylesheet)
                # Skip updates during population
                if not hasattr(self, '_in_population') or not self._in_population:
                    QTimer.singleShot(100, self._update_all_items_on_resize)
            else:
                self.setStyleSheet(self.base_stylesheet)
                # Reset cached width so that we force a fresh recalculation.
                self._last_width = None
                # Invalidate the layout so it recalculates from scratch.
                if self.layout():
                    self.layout().invalidate()
                # Force geometry updates
                self.updateGeometry()
                self.viewport().update()
                # Process pending events so that all geometry changes settle
                QCoreApplication.processEvents()
                # Skip updates during population
                if not hasattr(self, '_in_population') or not self._in_population:
                    # Use a slightly longer delay when leaving maximized mode
                    QTimer.singleShot(500, self._update_all_items_on_resize)
    
        # Handling for viewport resize events:
        if obj == self.viewport() and event.type() == QEvent.Type.Resize:
            new_width = self.viewport().width()
            if self._last_width is None or abs(self._last_width - new_width) > 10:
                self._last_width = new_width
                # Skip resize timer during population
                if hasattr(self, '_in_population') and self._in_population:
                    print(f"[DEBUG] Skipping resize timer during population")
                    return super().eventFilter(obj, event)
                
                if hasattr(self, '_resize_timer') and self._resize_timer.isActive():
                    self._resize_timer.stop()
                else:
                    self._resize_timer = QTimer()
                    self._resize_timer.setSingleShot(True)
                    self._resize_timer.timeout.connect(self._update_all_items_on_resize)
                self._resize_timer.start(150)
    
        return super().eventFilter(obj, event)

    # def handle_window_state_change(self, windowState):
    #     """Update margins based on window state"""
    #     if windowState & Qt.WindowState.WindowMaximized:
    #         self.setStyleSheet(self.maximized_stylesheet)
    #     else:
    #         self.setStyleSheet(self.base_stylesheet)


    def add_divider_interactive(self):
        """Opens a dialog to add a divider with user input for text and color."""
        print("Add Divider button clicked (interactive)")
        input_dialog = QDialog(self)
        input_dialog.setWindowTitle("Add Divider")
        input_dialog.setFixedWidth(400)  # Increased width for better layout
        dialog_layout = QVBoxLayout(input_dialog)

        # Create the form layout
        form_layout = QFormLayout()

        # Text input for divider label
        text_input = QLineEdit()
        text_input.setPlaceholderText("Enter divider label")
        # Prevent Enter key from propagating to other controls
        text_input.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        form_layout.addRow("Label:", text_input)

        # Color button to open QColorDialog
        color_button = QPushButton()
        color_button.setText("Choose Color")
        original_color = "#fff4c9"  # Default color
        color_button.setStyleSheet(f"""
            QPushButton {{
                background-color: {original_color};
                border: 1px solid #ccc;
                border-radius: 4px;
                min-height:30px;
            }}

            QPushButton:hover {{
                border: 1px solid #2196F3;
            }}
        """)
        # Make the color button stretch horizontally
        color_button.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        color_button.setCursor(Qt.CursorShape.PointingHandCursor)
        form_layout.addRow("Color:", color_button)

        dialog_layout.addLayout(form_layout)

        # Create dialog buttons (OK and Cancel)
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        dialog_layout.addWidget(button_box)

        # Create QColorDialog but do not embed it
        color_dialog = QColorDialog(QColor(original_color), input_dialog)
        color_dialog.setWindowTitle("Select Color")

        # Store the original color for reversion
        backup_color = original_color

        # Function to update the color live
        def update_color(color):
            if color.isValid():
                new_color = color.name()
                # Update the color button's appearance
                color_button.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {new_color};
                        border: 1px solid #ccc;
                        border-radius: 4px;
                        min-height:30px;
                    }}
                """)

        # Connect the QColorDialog's currentColorChanged signal to update_color
        color_dialog.currentColorChanged.connect(update_color)

        # Function to handle color dialog acceptance (OK)
        def accept_color_changes():
            # Color has already been applied live
            pass  # No additional action needed

        # Function to handle color dialog rejection (Cancel)
        def reject_color_changes():
            print("Reverting color changes")
            # Revert the color button's appearance
            color_button.setStyleSheet(f"""
                QPushButton {{
                    background-color: {backup_color};
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    min-height:30px;
                }}
            """)

        # Connect color dialog's accepted and rejected signals
        color_dialog.accepted.connect(accept_color_changes)
        color_dialog.rejected.connect(reject_color_changes)

        # Function to open the color dialog
        def open_color_dialog():
            # Show the color dialog modally
            color_dialog.exec()

        # Override key press event for the dialog
        def keyPressEvent(event):
            if event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter:
                accept_changes()
            else:
                QDialog.keyPressEvent(input_dialog, event)

        input_dialog.keyPressEvent = keyPressEvent

        # Function to handle dialog acceptance (OK)
        def accept_changes():
            new_text = text_input.text().strip()
            if new_text:
                print(f"Adding divider with label: {new_text}")
                # Get the chosen color from the button's stylesheet
                current_style = color_button.styleSheet()
                color_match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', current_style)
                chosen_color = color_match.group(1) if color_match else '#FFFFFF'
                self.add_divider(new_text, chosen_color)  # Call the non-interactive method
                parent_dialog = self.window()
                if isinstance(parent_dialog, StoryboardDialog):
                    parent_dialog.changes_pending = True
                    self.mark_storyboard_widget_changes_pending()
                    QTimer.singleShot(100, parent_dialog.apply_changes_lite)
            input_dialog.accept()

        # Function to handle dialog rejection (Cancel)
        def reject_changes():
            print("Adding divider cancelled")
            input_dialog.reject()

        # Connect just the button box signals
        button_box.accepted.connect(accept_changes)
        button_box.rejected.connect(reject_changes)

        # Connect the color button to open color dialog
        color_button.clicked.connect(open_color_dialog)

        # Set focus to text input
        text_input.setFocus()

        # Execute the dialog
        input_dialog.exec()

    def add_divider(self, label, color="#fff4c9"):
        """Add a divider to the list programmatically (without dialog)."""
        print(f"Adding divider with label: {label}, color: {color}")

        # Create divider widget
        divider_widget = QWidget()
        divider_widget.is_divider = True  # Flag to identify as divider
        layout = QVBoxLayout(divider_widget)
        layout.setContentsMargins(0, 0, 0, 0)

        # Create and configure divider label
        divider_label = QLabel(label)
        font_metrics = QFontMetrics(divider_label.font())
        height = font_metrics.height() + 18
        divider_widget.setFixedHeight(height)

        # Set label style
        divider_label.setStyleSheet(f"""
            QLabel {{
                background-color: {color};
                color: black;
                font-weight: bold;
                padding: 5px;
                border: 0px solid #ccc;
                border-radius: 8px;
                margin-bottom: 7px;
            }}
        """)
        divider_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(divider_label)

        # Create list item with UUID
        item = QListWidgetItem()
        divider_id = str(uuid.uuid4())
        item.setData(Qt.ItemDataRole.UserRole, divider_id)
        item.setSizeHint(divider_widget.sizeHint())

        # Add to list
        self.addItem(item)
        self.setItemWidget(item, divider_widget)

        # Setup right-click context menu
        divider_label.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        divider_label.customContextMenuRequested.connect(
            lambda pos: self.edit_divider(item, divider_label, pos)
        )

        return item

    def delete_divider(self, item, divider_id):
        """Mark a divider for deletion and visually remove it."""
        print(f"Marking divider for deletion: {divider_id}")

        # Add the divider ID to _pending_deletions
        self._pending_deletions.add(divider_id)

        # Remove the divider visually (only needs to be done once)
        self.takeItem(self.row(item))
        print(f"Divider with ID {divider_id} marked for deletion and removed from the list.")

        try:
            # Get reference to main window through StoryboardDialog
            parent_dialog = self.window()
            if not isinstance(parent_dialog, StoryboardDialog):
                print("Error: Could not retrieve valid StoryboardDialog")
                return

            main_window = parent_dialog.main_window

            # Atomic function to completely remove the divider
            def remove_from_list(data_list, location_name):
                original_count = len(data_list)
                data_list = [
                    anno for anno in data_list
                    if not (anno.get("id") == divider_id and anno.get("divider", False))
                ]
                removed_count = original_count - len(data_list)
                print(f"Removed {removed_count} items from {location_name}")
                return data_list

            # Remove from main window's annotations
            main_window.web_view.annotations = remove_from_list(
                main_window.web_view.annotations, "web_view.annotations"
            )

            # Remove from local dialog annotations
            self.annotations = remove_from_list(self.annotations, "local annotations")

            # Mark changes as pending and update window title
            parent_dialog.changes_pending = True
            if main_window.current_session_file and not main_window.windowTitle().startswith('*'):
                main_window.setWindowTitle(f'*{main_window.windowTitle()}')
                print("Window title updated to indicate unsaved changes")
    
            # Emit scenes_updated signal and update preview content
            main_window.web_view.scenes_updated.emit()
        
            # Mark changes as pending and apply changes
            if isinstance(parent_dialog, StoryboardDialog):
                parent_dialog.changes_pending = True
                self.mark_storyboard_widget_changes_pending()
                QTimer.singleShot(100, parent_dialog.apply_changes_lite)
            print("Triggered preview content update and emitted scenes_updated signal")

        except Exception as e:
            print(f"Error during divider deletion: {e}")

        print("=== DIVIDER DELETION COMPLETE ===\n")

    def edit_divider(self, item, label, pos):
        """Show combined edit menu for divider text and color"""
        print("Opening context menu for divider")
        menu = QMenu()
        menu.setStyleSheet("""
            QMenu {
                background-color: white;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 8px 24px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #e3f2fd;
                color: #2C4952;
            }
        """)

        edit_action = menu.addAction("Edit Divider")
        delete_action = menu.addAction("Delete Divider")

        action = menu.exec(label.mapToGlobal(pos))
        if action == edit_action:
            print("Edit Divider selected")

            # Extract the current color from the label's stylesheet
            current_style = label.styleSheet()
            color_match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', current_style)
            original_color = color_match.group(1) if color_match else '#FFFFFF'

            # Backup the original stylesheet to revert if needed
            backup_style = current_style

            # Create the edit dialog
            edit_dialog = QDialog(self)
            edit_dialog.setWindowTitle("Edit Divider")
            edit_dialog.setFixedWidth(400)  # Increased width for better layout
            dialog_layout = QVBoxLayout(edit_dialog)

            # Create the form layout
            form_layout = QFormLayout()

            # Text input for divider label
            text_input = QLineEdit(label.text())
            text_input.setPlaceholderText("Enter divider label")
            form_layout.addRow("Label:", text_input)

            # Color button to open QColorDialog
            color_button = QPushButton()
            color_button.setText("Choose Color")
            color_button.setStyleSheet(f"""
                QPushButton {{
                    background-color: {original_color};
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    min-height:30px;
                }}

                QPushButton:hover {{
                    border: 1px solid #2196F3;
                }}
            """)
            # Make the color button stretch horizontally
            color_button.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
            color_button.setCursor(Qt.CursorShape.PointingHandCursor)
            form_layout.addRow("Color:", color_button)

            dialog_layout.addLayout(form_layout)

            # Create dialog buttons (OK and Cancel)
            button_box = QDialogButtonBox(
                QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
            )
            dialog_layout.addWidget(button_box)

            # Create QColorDialog but do not embed it
            color_dialog = QColorDialog(QColor(original_color), edit_dialog)
            color_dialog.setWindowTitle("Select Color")

            # Store the original color for reversion
            backup_color = original_color

            # Function to update the color live
            def update_color(color):
                if color.isValid():
                    new_color = color.name()
                    # Update the color button's appearance
                    color_button.setStyleSheet(f"""
                        QPushButton {{
                            background-color: {new_color};
                            border: 1px solid #ccc;
                            border-radius: 4px;
                            min-height:30px;
                        }}
                    """)
                    # Update the label's stylesheet live
                    label.setStyleSheet(f"""
                        QLabel {{
                            background-color: {new_color};
                            color: black;
                            font-weight: bold;
                            padding: 5px;
                            border: 0px solid #ccc;
                            border-radius: 8px;
                            margin-bottom: 7px;
                        }}
                    """)

            # Connect the QColorDialog's currentColorChanged signal to update_color
            color_dialog.currentColorChanged.connect(update_color)

            # Function to handle color dialog acceptance (OK)
            def accept_color_changes():
                # Color has already been applied live
                pass  # No additional action needed

            # Function to handle color dialog rejection (Cancel)
            def reject_color_changes():
                print("Reverting color changes")
                # Revert the label's stylesheet to the original
                label.setStyleSheet(backup_style)
                # Revert the color button's appearance
                color_button.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {backup_color};
                        border: 1px solid #ccc;
                        border-radius: 4px;
                        min-height:30px;
                    }}
                """)

            # Connect color dialog's accepted and rejected signals
            color_dialog.accepted.connect(accept_color_changes)
            color_dialog.rejected.connect(reject_color_changes)

            # Function to open the color dialog
            def open_color_dialog():
                # Show the color dialog modally
                color_dialog.exec()

            # Connect the color button to open the QColorDialog
            color_button.clicked.connect(open_color_dialog)

            # Function to handle dialog acceptance (OK)
            def accept_changes():
                new_text = text_input.text().strip()
                if new_text:
                    print(f"Updating divider label to: {new_text}")
                    label.setText(new_text)
                # The color has already been updated live
                edit_dialog.accept()
                # Mark changes as pending and apply changes
                parent_dialog = self.window()
                if isinstance(parent_dialog, StoryboardDialog):
                    parent_dialog.changes_pending = True
                    self.mark_storyboard_widget_changes_pending()
                    QTimer.singleShot(100, parent_dialog.apply_changes_lite)

            # Override key press event for the dialog
            def keyPressEvent(event):
                if event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter:
                    accept_changes()
                else:
                    QDialog.keyPressEvent(edit_dialog, event)

            edit_dialog.keyPressEvent = keyPressEvent

            # Set focus policy for text input
            text_input.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

            # Set focus to text input
            text_input.setFocus()

            # Function to handle dialog rejection (Cancel)
            def reject_changes():
                print("Reverting text changes")
                # Revert the label's text to original if needed
                label.setText(label.text())  # Assuming no original text stored
                # Revert the color changes if not already reverted
                label.setStyleSheet(backup_style)
                edit_dialog.reject()

            # Connect dialog buttons to their respective functions
            button_box.accepted.connect(accept_changes)
            button_box.rejected.connect(reject_changes)

            # Execute the dialog
            edit_dialog.exec()

        elif action == delete_action:
            print("Delete Divider selected")

            # Remove the divider visually
            self.takeItem(self.row(item)) # Correct takeItem
            print("Divider deleted from list")

            # Find and remove the divider from session data
            divider_id = item.data(Qt.ItemDataRole.UserRole)
            for annotation in self.annotations:
                if annotation.get('id') == divider_id and annotation.get('divider', False):
                    self.annotations.remove(annotation)
                    print(f"Divider with ID {divider_id} removed from session data")
                    break

            # Mark changes as pending
            parent_dialog = self.window()
            if isinstance(parent_dialog, StoryboardDialog):
                parent_dialog.changes_pending = True
                self.mark_storyboard_widget_changes_pending()
                QTimer.singleShot(100, parent_dialog.apply_changes_lite)

    def open_edit_dialog(self, label, annotation_id):
        """Open a dialog to edit the text with proper sizing after edits."""
        # Find the original annotation to get current notes
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        current_notes = ""
        if annotation:
            current_notes = annotation.get('notes', '')

        edit_dialog = EditTextDialog(label.text(), current_notes, self)
        if edit_dialog.exec() == QDialog.DialogCode.Accepted:
            new_text = edit_dialog.get_text()
            #new_notes = edit_dialog.get_notes()
        
            # Begin batch updates to hide visual changes
            self.begin_batch_updates()
        
            try:
                # Call save_text directly (not using a timer)
                # But we'll pass a flag to prevent it from scheduling its own updates
                self.save_text(annotation_id, new_text, schedule_updates=False)
            
                # Create callback function for after batch updates
                def after_edit_complete():
                    # Apply changes using the dialog
                    dialog = self.window()
                    if isinstance(dialog, StoryboardDialog):
                        dialog.changes_pending = True
                        self.mark_storyboard_widget_changes_pending()
                    
                        # Use a timer to separate from the batch update
                        QTimer.singleShot(50, dialog.apply_changes_lite)
            
                # End batch updates with callback
                self.end_batch_updates(10, after_edit_complete)
            
            except Exception as e:
                print(f"[ERROR] Exception in open_edit_dialog: {e}")
                import traceback
                traceback.print_exc()
            
                # Ensure updates are restored even on error
                self.end_batch_updates(0)

    def get_display_text(self, annotation):
        """Get the text to display (either storyboard or original)."""
        if 'storyboard' in annotation and 'text' in annotation['storyboard']:
            return annotation['storyboard']['text']
        return annotation['text']

    def _finalize_widget_update(self, item):
        """
        Final stage of widget updates to ensure proper sizing after edits.
        This is called via timer to allow the initial layout changes to settle.
        """
        if not item:
            return
    
        widget = self.itemWidget(item)
        if not widget:
            return
    
        # Force another sizing update
        widget.adjustSize()
        item.setSizeHint(widget.sizeHint())
    
        # Force layout update on the list widget
        self.doItemsLayout()
    
        # Ensure visibility if item is partially visible
        self.scrollToItem(item)

    def update_widget_after_edit(self, annotation_id):
        """
        Specialized method to ensure proper widget sizing after text edits.
        This performs a comprehensive update of the widget's size and layout.
        """
        # Find the item associated with this annotation
        item = None
        for i in range(self.count()):
            current_item = self.item(i)
            if current_item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                item = current_item
                break
    
        if not item:
            return
    
        # Get the annotation to access the current text
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if not annotation:
            return
    
        # Get the current widget and text label
        widget = self.itemWidget(item)
        if not widget:
            return
    
        text_label = None
        for label in widget.findChildren(QLabel):
            if label.objectName() == "main_content_label":
                text_label = label
                break
    
        if not text_label:
            return
    
        # Get text from annotation, with strikethrough applied if needed
        display_text = annotation.get('text', '')
        if 'storyboard' in annotation:
            storyboard = annotation['storyboard']
            if 'text' in storyboard and storyboard['text']:
                display_text = storyboard['text']
        
            # Apply strikethrough if segments exist
            strikethrough_segments = storyboard.get('strikethrough_segments', {})
            for segment, is_struck in strikethrough_segments.items():
                if is_struck:
                    display_text = display_text.replace(segment, f"<s style=\"color:#FF9999;\">{segment}</s>")
    
        # Update the text label
        text_label.setText(display_text)
    
        # Calculate proper dimensions
        plain_text = display_text
        if "<" in plain_text and ">" in plain_text:
            plain_text = re.sub(r'<[^>]+>', '', plain_text)
    
        font_metrics = text_label.fontMetrics()
        available_width = self.get_available_text_width()
    
        text_rect = font_metrics.boundingRect(
            QRect(0, 0, available_width, 2000),
            Qt.TextFlag.TextWordWrap | Qt.TextFlag.TextExpandTabs,
            plain_text
        )
    
        # Set minimum height with extra padding
        calculated_height = text_rect.height() + font_metrics.descent() + 15  # Extra padding
        min_two_lines = int(font_metrics.lineSpacing() * 2.2 + font_metrics.descent())
        text_label.setMinimumHeight(max(calculated_height, min_two_lines))
    
        # Force complete layout update
        text_label.updateGeometry()
        widget.adjustSize()
        item.setSizeHint(widget.sizeHint())
    
        # Update the viewport
        self.viewport().update()
    
        # Schedule a second update to catch any pending changes
        QTimer.singleShot(50, lambda: self._finalize_widget_update(item))

    def save_text(self, annotation_id, new_text, schedule_updates=True):
        """
        Save edited text and notes as storyboard state of the original annotation.

        Args:
            annotation_id: ID of annotation to update
            new_text: Updated text content
            schedule_updates: Whether to schedule visual updates (set to False when called from within batch updates)
        """
        if not annotation_id:
            return

        # Begin batch updates if we're not already in one
        if schedule_updates:
            self.begin_batch_updates()

        try:
            # Sanitize the HTML to remove font size changes
            sanitized_text = sanitize_html(new_text)

            # Adjust text based on character count
            if len(sanitized_text) <= 155:
                if not sanitized_text.endswith('\n'):
                    sanitized_text += '\n'  # Add extra line spacing for short text
            else:
                if sanitized_text.endswith('\n'):
                    sanitized_text = sanitized_text.rstrip('\n')  # Remove extra line spacing for long text

            # Find the original annotation
            annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
            if annotation:
                # Always initialize storyboard state if it doesn't exist
                if 'storyboard' not in annotation:
                    annotation['storyboard'] = {}

                # Handle empty or modified text
                if not sanitized_text.strip() or sanitized_text != annotation['text']:
                    annotation['storyboard']['text'] = sanitized_text.replace('\n', '<br>')

                    # Preserve strikethrough state if it exists
                    strikethrough_segments = annotation['storyboard'].get('strikethrough_segments', {})
                    for segment, is_struck in strikethrough_segments.items():
                        if is_struck and segment in sanitized_text:  # Only apply strikethrough if segment still exists
                            annotation['storyboard']['text'] = annotation['storyboard']['text'].replace(
                                segment, f"<s style=\"color:#FF9999;\">{segment}</s>"
                            )
                else:
                    # If text matches original and isn't empty, remove storyboard text
                    annotation['storyboard'].pop('text', None)

                # Remove storyboard if text is None or empty
                if annotation['storyboard'].get('text') is None or annotation['storyboard'].get('text') == "":
                    del annotation['storyboard']

                # Update the item immediately (no timer)
                #self._update_item_for_edit(annotation_id)

                # Update item numbering
                self.refresh_item_display_and_renumber(annotation_id, with_visual_updates=False)

                # If scheduling updates, apply dialog changes
                if schedule_updates:
                    dialog = self.window()
                    if isinstance(dialog, StoryboardDialog):
                        dialog.changes_pending = True
                        self.mark_storyboard_widget_changes_pending()

                        # Define simple callback that just applies changes
                        def after_text_save():
                            dialog.apply_changes_lite()

                        # End batch updates with our callback
                        self.end_batch_updates(100, after_text_save)
            else:
                # End batch updates if we started them and no annotation was found
                if schedule_updates:
                    self.end_batch_updates(0)

        except Exception as e:
            print(f"[ERROR] Exception in save_text: {e}")
            import traceback
            traceback.print_exc()
            if schedule_updates:
                self.end_batch_updates(0)

    def _update_item_for_edit(self, annotation_id):
        """
        Update an item after text edit with proper sizing.
        This is a direct replacement for update_widget_after_edit that doesn't use timers.
        """
        # Find the item associated with this annotation
        item = None
        for i in range(self.count()):
            current_item = self.item(i)
            if current_item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                item = current_item
                break
    
        if not item:
            return
    
        # Get the annotation to access the current text
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if not annotation:
            return
    
        # Get the current widget and text label
        widget = self.itemWidget(item)
        if not widget:
            return
    
        text_label = None
        for label in widget.findChildren(QLabel):
            if label.objectName() == "main_content_label":
                text_label = label
                break
    
        if not text_label:
            return
    
        # Get text from annotation, with strikethrough applied if needed
        display_text = annotation.get('text', '')
        if 'storyboard' in annotation:
            storyboard = annotation['storyboard']
            if 'text' in storyboard and storyboard['text']:
                display_text = storyboard['text']
        
            # Apply strikethrough if segments exist
            strikethrough_segments = storyboard.get('strikethrough_segments', {})
            for segment, is_struck in strikethrough_segments.items():
                if is_struck:
                    display_text = display_text.replace(segment, f"<s style=\"color:#FF9999;\">{segment}</s>")
    
        # Update the text label
        text_label.setText(display_text)
    
        # Calculate proper dimensions and update sizes
        self.prepare_text_widget_sizing(text_label)
    
        # Update widget size
        widget.adjustSize()
        item.setSizeHint(widget.sizeHint())


    def prepare_text_widget_sizing(self, text_label):
        """
        Calculate and apply proper dimensions to a text label, ensuring it renders
        correctly with consistent spacing regardless of formatting.
    
        Args:
            text_label: The QLabel to size properly
        """
        # Get the text with any HTML tags
        html_text = text_label.text()

        # Get a plain version without any HTML tags for proper measurement
        plain_text = re.sub(r'<[^>]+>', '', html_text)

        # Get the font metrics for accurate text measurement
        font_metrics = text_label.fontMetrics()

        # Get the available width for the text
        available_width = self.get_available_text_width()

        # Calculate the text rectangle using the available width
        text_rect = font_metrics.boundingRect(
            QRect(0, 0, available_width, 2000),  # Large height to allow full calculation
            Qt.TextFlag.TextWordWrap | Qt.TextFlag.TextExpandTabs,
            plain_text
        )

        # Calculate proper height with standard padding (not special for strikethrough)
        # The font's descent is already sufficient padding for most formatting
        calculated_height = text_rect.height() + font_metrics.descent() + 8  # Standard padding

        # Calculate minimum height (equivalent to two lines of text)
        min_two_lines = int(font_metrics.lineSpacing() * 2.2)

        # Set the minimum height to the greater of calculated height or minimum two lines
        text_label.setMinimumHeight(max(calculated_height, min_two_lines))

        # Use fixed width to prevent stretching
        text_label.setFixedWidth(available_width)

        # Force layout update
        text_label.updateGeometry()

        return text_label
        

    def create_item_widget(self, text, annotation_id, number, notes="", tags=None, speech_title=""):
        """
        Create a clean, user-friendly widget for list items with improved text height calculation
        and proper spacing using layout stretch placed correctly.
        """
        widget = QWidget()

        # Main vertical layout for the widget
        main_layout = QVBoxLayout(widget)
        main_layout.setContentsMargins(8, 5, 8, 5)
        main_layout.setSpacing(2)  # Reduced spacing between layouts

        # Horizontal layout for the main content (drag, number, text)
        header_layout = QHBoxLayout()
        header_layout.setContentsMargins(0, 0, 5, 0)
        header_layout.setSpacing(6) # Spacing between drag, number, text

        # Drag handle
        drag_handle = QLabel("\u2630") # Hamburger icon for drag
        drag_handle.setFixedWidth(20)
        drag_handle.setStyleSheet("""
            QLabel {
                color: #888;
                font-size: 16px;
            }
        """)
        drag_handle.setAlignment(Qt.AlignmentFlag.AlignCenter)
        drag_handle.setCursor(Qt.CursorShape.ArrowCursor)

        # Number label
        number_label = QLabel(f"{number}.")
        number_label.setObjectName(f"number_label_{annotation_id}")  # Use annotation ID for fast lookup
        number_label.setStyleSheet("""
            QLabel {
                color: #555;
                font-size: 14px;
                font-weight: bold;
                min-width: 20px; /* Ensure some minimum space */
            }
        """)
        # Align left within its allocated space
        number_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Text label
        text_label = QLabel(text)
        text_label.setObjectName("main_content_label")
        text_label.setWordWrap(True)
        text_label.setStyleSheet("""
            QLabel {
                color: #333;
                font-size: 14px;
                background-color: transparent;
                padding: 20px 0px 0px 0px;
                line-height: 1.4;
            }
        """)
        # Allows the text label to grow and shrink horizontally
        text_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)
        text_label.setTextFormat(Qt.TextFormat.RichText) # Ensure proper HTML rendering

        # --- Height Calculation (header-aware like _apply_text_sizing_optimized) ---
        # Check if we have a header format FIRST
        has_header = ('<div><b' in text)
        
        # Use header-aware text processing
        plain_text_for_height = text
        if "<" in plain_text_for_height and ">" in plain_text_for_height:
            # First convert ALL break tag variations to \n for measurement since QLabel renders them as line breaks
            temp_text = plain_text_for_height.replace('<br>', '\n').replace('<BR>', '\n').replace('<br/>', '\n').replace('<BR/>', '\n')
            if has_header:
                # Convert <div> tags to line breaks for measurement since they create visual separation
                temp_text = re.sub(r'</div>', '\n', temp_text)
            # Strip ALL HTML tags including strikethrough - they don't affect text spacing
            # Use a more robust pattern that handles nested tags correctly
            while '<' in temp_text and '>' in temp_text:
                temp_text = re.sub(r'<[^>]*>', '', temp_text)
            plain_text_for_height = temp_text
        font_metrics = text_label.fontMetrics()
        available_width = self.get_available_text_width() # Get current available width
        text_rect = font_metrics.boundingRect(
            QRect(0, 0, available_width - drag_handle.width() - number_label.minimumSizeHint().width() - 2*header_layout.spacing(), 2000), # Estimate text width
            Qt.TextFlag.TextWordWrap | Qt.TextFlag.TextExpandTabs,
            plain_text_for_height
        )
        
        # Use same calculation logic as _apply_text_sizing_optimized
        base_height = text_rect.height()
        line_spacing = font_metrics.lineSpacing()
        line_count = max(len(plain_text_for_height.split('\n')), 2)
        
        calculated_height = max(
            base_height + font_metrics.descent() + 12,
            line_count * line_spacing + 12,
            int(line_spacing * 2.2 + font_metrics.descent())
        )
        
        # Add extra height for custom painted widgets (star button, checkbox)
        final_height = calculated_height + 8
        
        # Apply sizing same way as _apply_text_sizing_optimized
        text_label.setFixedWidth(available_width)
        text_label.setFixedHeight(final_height)
        text_label.updateGeometry()

        # Enable context menu and text selection
        text_label.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        # Ensure lambda captures annotation_id correctly
        text_label.customContextMenuRequested.connect(
            lambda pos, label=text_label, ann_id=annotation_id: self.show_context_menu(label, ann_id, pos)
        )
        text_label.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)

        # Add context menu to drag handle
        drag_handle.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        drag_handle.customContextMenuRequested.connect(
            lambda pos, label=text_label, ann_id=annotation_id: self.show_context_menu(label, ann_id, pos)
        )

        # Add context menu to number label
        number_label.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        number_label.customContextMenuRequested.connect(
            lambda pos, label=text_label, ann_id=annotation_id: self.show_context_menu(label, ann_id, pos)
        )

        # Find the annotation data first
        parent_dialog = self.window()
        local_annotations = self.annotations # Default to local
        if isinstance(parent_dialog, StoryboardDialog):
             # Prefer parent's data source if available
             if hasattr(parent_dialog.main_window, 'web_view') and hasattr(parent_dialog.main_window.web_view, 'annotations'):
                 local_annotations = parent_dialog.main_window.web_view.annotations

        annotation = next((a for a in local_annotations if a.get('id') == annotation_id), None)

        # Add scene title and tags row first (if content exists)
        scene_title_text = speech_title.strip() if speech_title and speech_title.strip() else ""
        if not scene_title_text and annotation:
            scene_title_text = annotation.get('speech_title', '').strip()
        
        annotation_tags = []
        if annotation and 'tags' in annotation:
            annotation_tags = annotation.get('tags', [])
        elif tags:  # Fallback to parameter if provided
            annotation_tags = tags

        # Speech title container (similar to add_item_with_checkbox)
        speech_title_container = None
        if scene_title_text:
            # Truncate speech title to 60 characters
            truncated_title = scene_title_text
            if len(truncated_title) > 60:
                truncated_title = truncated_title[:60] + "..."
            speech_title_widget = QLabel(truncated_title)
            # Set tooltip to show full title if it was truncated
            if len(scene_title_text) > 60:
                speech_title_widget.setToolTip(scene_title_text)
                
            speech_title_widget.setStyleSheet("""
                QLabel {
                    color: #333;
                    font-size: 10px;
                    font-weight: bold;
                    padding: 2px 4px;
                    background: transparent;
                }
            """)
            speech_title_widget.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
            speech_title_widget.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Minimum)
            speech_title_widget.setWordWrap(False)
            
            # Create transparent container for speech title (constrained to content size)
            speech_title_container = QWidget()
            speech_title_container_layout = QHBoxLayout(speech_title_container)
            speech_title_container_layout.setContentsMargins(0, 0, 0, 0)
            speech_title_container_layout.addWidget(speech_title_widget)
            # Remove addStretch() to constrain container to content size
            
            # Set size policy to constrain container to its content
            speech_title_container.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Minimum)
            speech_title_container.adjustSize()  # Fit to content

        # Tags display (similar to add_item_with_checkbox)
        tags_widget = None
        if annotation_tags:
            # Create single label with all tags (hover on entire area)
            tags_widget = QLabel()
            
            # Create tags text with # prefix (no character limit here - will be truncated by width in resize logic)
            tags_text = ", ".join([f"#{tag}" for tag in annotation_tags])
            tags_widget.setText(tags_text)
            
            # Enable text elision (automatic truncation with ...) when text doesn't fit
            tags_widget.setWordWrap(False)  # Ensure single line
            tags_widget.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)  # Prevent text selection issues with elision
            
            # Set tooltip with original full tags 
            original_tags_text = ", ".join([f"#{tag}" for tag in annotation_tags])
            tags_widget.setToolTip(f"Tags: {original_tags_text}")
            
            # Store the original tags text for dynamic truncation on resize
            tags_widget.setProperty('original_tags_text', tags_text)
            
            tags_widget.setStyleSheet("""
                QLabel {
                    color: #2196F3;
                    font-size: 10px;
                    font-weight: bold;
                    padding: 2px 4px;
                    background: transparent;
                    margin-left: 4px;
                }
                QLabel:hover {
                    color: #1976D2;
                }
            """)
            tags_widget.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignTop)  # Right align so it gets cut off on the right side
            tags_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)  # Allow horizontal expansion
            tags_widget.setCursor(Qt.CursorShape.PointingHandCursor)
            # Note: Context menu handling would need to be added if required

        # --- Add widgets to header_layout (drag handle, number, and text on same line) ---
        header_layout.addWidget(drag_handle)
        header_layout.addWidget(number_label)
        header_layout.addWidget(text_label) # Text back on same line as drag handle and number
        header_layout.addStretch(1)         # Fill remaining space

        # Add header_layout to the main vertical layout
        main_layout.addLayout(header_layout)
        
        # Add speech title as an overlay (not part of the flow layout)
        if speech_title_container:
            # Position the speech title overlay on top of the main content area
            speech_title_container.setParent(widget)
            speech_title_container.move(55, 5)  # Position after drag handle and number, aligned with main text
            # Lower the overlay so it doesn't block clicks on tags
            speech_title_container.lower()
            
        # Add tags as an overlay (not part of the flow layout) 
        if tags_widget:
            # Position tags overlay at top right corner
            tags_widget.setParent(widget)
            tags_widget.setProperty('is_tags_widget', True)  # Mark for identification in resize logic
            
            # Calculate correct position immediately
            tags_widget.adjustSize()
            tags_width = tags_widget.sizeHint().width()
            available_width = self.get_available_text_width()  # Use OrderListWidget's method + extra push for tags
            tags_x = available_width - tags_width + 60  # Right edge minus tags width plus extra push
            tags_widget.move(tags_x, 5)
            tags_widget.show()


        # --- Bottom Row: Scene Circle, Used, Favorite, Notes (Code is unchanged from previous version) ---

        # Check for existing widget state to preserve checkbox status
        current_used_state = None
        # (This loop seems fine, ensures checkbox state isn't lost on refresh)
        for i in range(self.count()):
            item = self.item(i)
            if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                existing_widget = self.itemWidget(item)
                if existing_widget:
                    used_checkbox = existing_widget.findChild(CustomCheckBox)
                    if used_checkbox:
                        current_used_state = used_checkbox.isChecked()
                break

        # Horizontal layout for notes section
        notes_layout = QHBoxLayout()
        notes_layout.setContentsMargins(5, 5, 5, 5)
        notes_layout.setSpacing(8)

        # Scene circle label
        scene_circle = QLabel()
        scene_circle.setFixedSize(14, 14)
        scene_name = "Unknown"
        scene_color = "#EEEEEE" # Default grey

        if annotation and 'scene' in annotation:
            scene_name = annotation['scene']
            scene_style = None
            if isinstance(parent_dialog, StoryboardDialog) and hasattr(parent_dialog, 'scene_styles'):
                scene_style = parent_dialog.scene_styles.get(scene_name, '')
            elif hasattr(self, 'scene_styles'): # Fallback to local
                scene_style = self.scene_styles.get(scene_name, '')

            if scene_style:
                 color_match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', scene_style)
                 if color_match:
                     scene_color = color_match.group(1)

        scene_circle.setStyleSheet(f"""
            QLabel {{
                background-color: {scene_color};
                border: 1px solid #CCCCCC;
                border-radius: 7px;
            }}
            QLabel:hover {{ border: 1px solid #999999; }}
        """)
        scene_circle.setToolTip(f"Theme: {scene_name}")
        notes_layout.addWidget(scene_circle)

        # 'Used' status checkbox
        is_used = current_used_state if current_used_state is not None else (annotation.get('used', False) if annotation else False)

        # Assuming DirectUpdateCheckBox class is defined
        class DirectUpdateCheckBox(QCheckBox):
             def __init__(self, parent=None, order_list_widget=None, annotation_id=None):
                 super().__init__(parent)
                 self._order_list_widget = order_list_widget
                 self._annotation_id = annotation_id

             def nextCheckState(self):
                 if not self._order_list_widget or not self._annotation_id: return
                 current = self.isChecked()
                 super().nextCheckState()
                 new_state = self.isChecked()
                 print(f"[DEBUG] Checkbox toggled: {current} -> {new_state}")
                 self._order_list_widget.send_dom_update_signal(self._annotation_id, "used", new_state)

        used_checkbox = CustomCheckBox()
        used_checkbox.setChecked(is_used)
        used_checkbox.setToolTip("Mark as Used")
        used_checkbox.setFixedSize(16, 16)
        used_checkbox.stateChanged.connect(
             lambda state, ann_id=annotation_id, cb=used_checkbox: self.update_annotation_status(ann_id, "used", cb.isChecked())
        )
        notes_layout.addWidget(used_checkbox)

        # Favorite star
        is_favorite = annotation.get('favorite', False) if annotation else False
        favorite_button = CustomStarButton()
        favorite_button.setChecked(is_favorite)
        favorite_button.setToolTip("Mark as Favorite")
        favorite_button.setFixedSize(16, 16)
        favorite_button.clicked.connect(lambda ann_id=annotation_id: self.toggle_favorite(ann_id))
        notes_layout.addWidget(favorite_button)

        # Notes label
        notes_text = notes
        truncated_notes = notes_text[:80] + "..." if len(notes_text) > 80 else notes_text
        notes_label = QLabel(truncated_notes)
        notes_label.setWordWrap(False)
        notes_label.setFixedHeight(18)
        notes_label.setStyleSheet("""
            QLabel {
                color: #777; font-size: 11px; font-style: italic; margin-left: 5px;
            }
        """)
        if len(notes_text) > 80:
            notes_label.setToolTip(notes_text)
        notes_layout.addWidget(notes_label)

        # Spacer to push notes to the left
        notes_layout.addStretch()

        # Add notes layout to the main layout
        main_layout.addLayout(notes_layout)

        # Ensure the overall widget resizes properly
        widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)
        widget.adjustSize() # Calculate initial size
        widget.updateGeometry() # Update geometry like _apply_text_sizing_optimized

        widget.setProperty('annotation_id', annotation_id)

        return widget, text_label
    
    def send_dom_update_signal(self, annotation_id, key, value):
        """
        A more direct method to send DOM update signals without any other processing.
        This bypasses any potential issues with checkbox state handling.
        """
        print(f"[DEBUG] Direct DOM update signal: {annotation_id}, {key}={value}")
    
        # Find the annotation
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if not annotation:
            print(f"[ERROR] Annotation not found for DOM update: {annotation_id}")
            return
        
        # Update our Python data structure
        annotation[key] = value
    
        # Get references
        dialog = self.window()
        if not isinstance(dialog, StoryboardDialog):
            print(f"[ERROR] Parent dialog is not StoryboardDialog")
            return
        
        main_window = dialog.main_window
        if not main_window:
            print(f"[ERROR] No main_window reference found")
            return
    
        # Create payload with explicit boolean value for "used" field
        update_payload = {
            'id': annotation_id,
            'text': annotation.get('text', ''),
            'used': bool(value) if key == 'used' else annotation.get('used', False),
            'favorite': bool(value) if key == 'favorite' else annotation.get('favorite', False),
            'notes': annotation.get('notes', ''),
            'notes_html': annotation.get('notes_html', ''),
            'tags': annotation.get('tags', []),
            'secondary_scenes': annotation.get('secondary_scenes', [])
        }
    
        # Log the exact payload for debugging
        print(f"[DEBUG] Emitting DOM update signal with payload type 'used'={type(update_payload['used'])}")
    
        # Emit the signal for DOM update
        main_window.web_view.annotation_updated.emit(json.dumps(update_payload))
    
        # Update internal state tracking
        main_window.mark_changes_pending()
        dialog.changes_pending = True

    def get_available_text_width(self):
        # Force the viewport geometry to update.
        self.viewport().updateGeometry()
        self.viewport().update()

        # The viewport width represents the available space for list items.
        viewport_width = self.viewport().width()
        # If the vertical scrollbar is visible, subtract its width.
        scrollbar_width = self.verticalScrollBar().width() if self.verticalScrollBar().isVisible() else 0

        # Fixed elements inside each item:
        #   drag handle: 20px, number label: 30px, layout spacing: ~16px, text label padding: ~20px.
        fixed_elements_width = 20 + 5 + 16 + 20  # = 86px
    
        # Add extra padding for right margin
        right_padding = 15  # Add 10px of right padding
    
        available_width = viewport_width - scrollbar_width - fixed_elements_width - right_padding
        return max(available_width, 200)

    def update_item_widget_size(self, item, label=None):
        """
        Update the size of an item widget after text content changes.
        Can be called with either the item and label, or just the item.
        """
        widget = self.itemWidget(item)
        if not widget:
            return
        
        # If label is provided, update its height
        if label:
            # Same improved height calculation as in create_item_widget
            plain_text = label.text()
            if "<" in plain_text and ">" in plain_text:
                # Convert <br> to \n before stripping HTML for proper height calculation
                plain_text = plain_text.replace('<br>', '\n')
                plain_text = re.sub(r'<[^>]+>', '', plain_text)
        
            font_metrics = label.fontMetrics()
            available_width = self.get_available_text_width()
            text_rect = font_metrics.boundingRect(
                QRect(0, 0, available_width, 2000),
                Qt.TextFlag.TextWordWrap | Qt.TextFlag.TextExpandTabs, 
                plain_text
            )
        
            # Calculate height with extra padding for safety
            calculated_height = text_rect.height() + font_metrics.descent() + 12
            min_two_lines = int(font_metrics.lineSpacing() * 2.2 + font_metrics.descent())
            label.setMinimumHeight(max(calculated_height, min_two_lines))
            label.updateGeometry()
    
        # Force layout update on the widget
        widget.adjustSize()
        widget.updateGeometry()
    
        # Update the list item size hint
        item.setSizeHint(widget.sizeHint())
    
        # Update the viewport
        self.updateGeometry()
        self.viewport().update()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if event.oldSize().width() == event.size().width():
            return  # Skip pure vertical changes.
    
        # Skip resize handling during population
        if hasattr(self, '_in_population') and self._in_population:
            print(f"[DEBUG] Skipping resize handling during population")
            return
    
        # Set all text labels to a constrained width during resize
        for i in range(self.count()):
            item = self.item(i)
            widget = self.itemWidget(item)
            if not widget:
                continue
            if hasattr(widget, 'is_divider') and widget.is_divider:
                continue
            
            # Find the text label
            text_label = None
            for label in widget.findChildren(QLabel):
                if label.objectName() == "main_content_label":
                    text_label = label
                    break
                
            if text_label:
                # Set a more responsive width constraint during resize
                text_label.setMaximumWidth(self.get_available_text_width())
            
            # Handle tags positioning and truncation during resize (similar to AnnotationListWidget)
            available_width = self.get_available_text_width()
            for child in widget.children():
                if isinstance(child, QLabel) and child.property('is_tags_widget'):
                    # Check if there's a speech title that would reduce available space for tags
                    speech_title_width = 0
                    for sibling in widget.children():
                        if isinstance(sibling, QWidget) and sibling != child:
                            # Look for speech title container widget (contains the speech title label)
                            if hasattr(sibling, 'layout') and sibling.layout():
                                for j in range(sibling.layout().count()):
                                    layout_item = sibling.layout().itemAt(j)
                                    if layout_item and layout_item.widget():
                                        potential_label = layout_item.widget()
                                        if isinstance(potential_label, QLabel) and potential_label.text() and potential_label.text() != "add tags" and not potential_label.property('is_tags_widget'):
                                            # This looks like a speech title label
                                            speech_title_width = sibling.sizeHint().width() + 20  # Use container width + padding
                                            break
                                if speech_title_width > 0:
                                    break
                    
                    # Calculate maximum width for tags, accounting for speech title positioning
                    base_tags_width = int(available_width * 0.90)
                    # Always account for speech title width to prevent overlap
                    max_tags_width = max(60, base_tags_width - speech_title_width)  # Minimum 60px for "...(X)" display
                    
                    # Get the original tags from stored property, fallback to current text
                    original_tags_text = child.property('original_tags_text')
                    if not original_tags_text:
                        # If no stored original, use current text and store it
                        original_tags_text = child.text()
                        child.setProperty('original_tags_text', original_tags_text)
                    
                    # Always start from the original full tags text
                    child.setText(original_tags_text)
                    child.adjustSize()
                    tags_width = child.sizeHint().width()
                    tags_height = child.sizeHint().height()
                    
                    # Truncate tags if they exceed 90% of available width
                    if tags_width > max_tags_width:
                        font_metrics = child.fontMetrics()
                        
                        # Parse tags from the original text (remove # prefix and split by comma)
                        tags_list = [tag.strip().lstrip('#') for tag in original_tags_text.split(',')]
                        
                        # Find how many tags fit within the available width
                        truncated_text = ""
                        visible_count = 0
                        
                        # First check if we have enough space for the minimal "...(X)" format
                        total_tag_count = len(tags_list)
                        minimal_text = f"...({total_tag_count})"
                        minimal_width = font_metrics.boundingRect(minimal_text).width()
                        
                        if minimal_width > max_tags_width:
                            # Extremely tight space - just show "..." 
                            final_text = "..."
                        else:
                            # Try to fit as many tags as possible
                            for j, tag in enumerate(tags_list):
                                tag_text = f"#{tag}"
                                if j == 0:
                                    test_text = tag_text
                                else:
                                    test_text = f"{truncated_text}, {tag_text}"
                                
                                # Reserve space for "...(X)" if needed
                                remaining_tags = len(tags_list) - j - 1
                                if remaining_tags > 0:
                                    ellipsis_text = f"...({remaining_tags})"
                                    test_width = font_metrics.boundingRect(test_text + ellipsis_text).width()
                                else:
                                    test_width = font_metrics.boundingRect(test_text).width()
                                
                                if test_width <= max_tags_width:
                                    truncated_text = test_text
                                    visible_count = j + 1
                                else:
                                    break
                            
                            # Add "...(X)" if there are hidden tags
                            hidden_count = len(tags_list) - visible_count
                            if hidden_count > 0:
                                if visible_count == 0:
                                    # No tags fit, just show count
                                    final_text = f"...({total_tag_count})"
                                else:
                                    final_text = f"{truncated_text}...({hidden_count})"
                            else:
                                final_text = truncated_text
                        
                        child.setText(final_text)
                        
                        # Set tooltip with full tags if truncated
                        if hidden_count > 0:
                            child.setToolTip(f"Tags: {original_tags_text}")
                        
                        # Recalculate size after truncation
                        child.adjustSize()
                        tags_width = child.sizeHint().width()
                    else:
                        # Clear tooltip if no truncation needed
                        child.setToolTip(f"Tags: {original_tags_text}")
                    
                    # Position at top right corner of widget (right-edge anchored)
                    tags_x = available_width - tags_width + 60  # Right edge minus tags width plus extra push
                    child.move(tags_x, 5)
                    child.show()
                    break
    
        # Use a shorter timer for more responsive updates
        if hasattr(self, '_resize_timer') and self._resize_timer.isActive():
            self._resize_timer.stop()
        else:
            self._resize_timer = QTimer()
            self._resize_timer.setSingleShot(True)
            self._resize_timer.timeout.connect(self._update_all_items_on_resize)
    
        # Reduce from 150ms to 50ms for more responsive updates
        self._resize_timer.start(50)

    def _update_all_items_on_resize(self):
        """
        Batch update all items' sizes after a resize event without visual flickering.
        Now skips updates if in population mode.
        """
        # Check if we're in population mode - skip resizing if we are
        if hasattr(self, '_in_population') and self._in_population:
            print(f"[DEBUG] Skipping _update_all_items_on_resize during population")
            return
        
        # ADDED: Store current scroll position
        current_scroll_position = self.verticalScrollBar().value()
        print(f"[DEBUG] Saving scroll position in _update_all_items_on_resize: {current_scroll_position}")
    
        # Disable updates during the calculation phase
        was_updates_enabled = self.updatesEnabled()
        if was_updates_enabled:
            self.setUpdatesEnabled(False)
    
        # Store viewport scroll position
        scroll_pos = self.verticalScrollBar().value()
    
        # Process all items in a single batch for efficiency
        new_width = self.get_available_text_width()
    
        # Pre-calculate all sizes first without applying them
        size_updates = []
    
        for i in range(self.count()):
            item = self.item(i)
            widget = self.itemWidget(item)
            if not widget:
                continue
            if hasattr(widget, 'is_divider') and widget.is_divider:
                continue

            # Locate the main content label
            text_label = None
            for label in widget.findChildren(QLabel):
                if label.objectName() == "main_content_label":
                    text_label = label
                    break

            if text_label:
                # Remove any maximum width constraints
                text_label.setMaximumWidth(16777215)  # Reset to QWIDGETSIZE_MAX
            
                # Use same header-aware text processing as _apply_text_sizing_optimized
                plain_text = text_label.text()
                
                # Check if we have a header format FIRST
                has_header = ('<div><b' in plain_text)
                
                if "<" in plain_text and ">" in plain_text:
                    # First convert ALL break tag variations to \n for measurement since QLabel renders them as line breaks
                    temp_text = plain_text.replace('<br>', '\n').replace('<BR>', '\n').replace('<br/>', '\n').replace('<BR/>', '\n')
                    if has_header:
                        # Convert <div> tags to line breaks for measurement since they create visual separation
                        temp_text = re.sub(r'</div>', '\n', temp_text)
                    # Strip ALL HTML tags including strikethrough - they don't affect text spacing
                    # Use a more robust pattern that handles nested tags correctly
                    while '<' in temp_text and '>' in temp_text:
                        temp_text = re.sub(r'<[^>]*>', '', temp_text)
                    plain_text = temp_text
            
                font_metrics = text_label.fontMetrics()
                text_rect = font_metrics.boundingRect(
                    QRect(0, 0, new_width, 2000),
                    Qt.TextFlag.TextWordWrap | Qt.TextFlag.TextExpandTabs,
                    plain_text
                )
                
                # Use same calculation logic as _apply_text_sizing_optimized
                base_height = text_rect.height()
                line_spacing = font_metrics.lineSpacing()
                line_count = max(len(plain_text.split('\n')), 2)
                
                calculated_height = max(
                    base_height + font_metrics.descent() + 12,
                    line_count * line_spacing + 12,
                    int(line_spacing * 2.2 + font_metrics.descent())
                )
                
                # Add extra height for custom painted widgets (star button, checkbox)
                new_height = calculated_height + 8
            
                # Store the calculations for later application
                size_updates.append((text_label, new_width, new_height))
    
        # Now apply all the size updates at once
        for text_label, width, height in size_updates:
            text_label.setFixedWidth(width)
            text_label.setFixedHeight(height)
        
            # Get associated widget and update its size
            parent_widget = text_label.parentWidget()
            if parent_widget:
                parent_widget.adjustSize()
            
                # Find the associated list item and update its size
                for i in range(self.count()):
                    if self.itemWidget(self.item(i)) == parent_widget:
                        item = self.item(i)
                        item.setSizeHint(parent_widget.sizeHint())
                        break

        # Force a complete layout update
        self.doItemsLayout()
    
        # MODIFIED: Restore the original scroll position to our saved value
        # instead of using scroll_pos which was only stored as a reference
        self.verticalScrollBar().setValue(current_scroll_position)
    
        # Finally re-enable updates to show all changes at once
        if was_updates_enabled:
            # Force layout and repaint before making visible again
            QApplication.processEvents()
            self.viewport().update()
            self.setUpdatesEnabled(True)
    
        print(f"[DEBUG] Restored scroll position to: {current_scroll_position}")



    def begin_batch_updates(self, saved_scroll_position=None):
        """Temporarily disable visual updates during complex sizing operations.
    
        Args:
            saved_scroll_position: Optional explicit scroll position to restore later.
        """
        # Use provided position if available; only store current position if none provided
        if saved_scroll_position is not None:
            self._saved_scroll_position = saved_scroll_position
            print(f"[DEBUG] begin_batch_updates - Using provided scroll position: {saved_scroll_position}")
        else:
            # Only capture current position if not explicitly provided
            self._saved_scroll_position = self.verticalScrollBar().value()
            print(f"[DEBUG] begin_batch_updates - _saved_scroll_position set to: {self._saved_scroll_position}")
    
        # Disable updates at all levels to prevent visual changes during the update
        self.setUpdatesEnabled(False)
        self.viewport().setUpdatesEnabled(False)
    
        # Block signals to prevent unnecessary event cascades
        self.blockSignals(True)
    
        # Disable auto-scroll so that nothing moves while updating
        self.setAutoScroll(False)
        
        # Ensure drag and drop remains enabled during batch updates
        # This is critical for drag operations that might be in progress
        self.setAcceptDrops(True)
    
        # Process pending events
        QApplication.processEvents()


    def end_batch_updates(self, delay_before_show=10, callback=None):
        """
        Re-enable visual updates after sizing calculations are complete.
    
        Args:
            delay_before_show: Milliseconds to wait before showing changes.
            callback: Optional function to call after updates are enabled.
        """
        # Process any pending events before starting.
        QApplication.processEvents()
    
        def restore_updates():
            print("[DEBUG] end_batch_updates.restore_updates - Starting layout update")
            # Perform a layout update.
            self.doItemsLayout()
    
            # Update sizes for each item (skipping dividers).
            for i in range(self.count()):
                item = self.item(i)
                widget = self.itemWidget(item)
                if not widget:
                    continue
                if hasattr(widget, 'is_divider') and widget.is_divider:
                    continue  # Skip divider items.
    
                text_label = None
                for label in widget.findChildren(QLabel):
                    if label.objectName() == "main_content_label":
                        text_label = label
                        break
                
                if text_label:
                    available_width = self.get_available_text_width()
                    #print(f"[DEBUG] Resizing text_label for item {i}: available_width = {available_width}")
                    self._resize_text_label(text_label, available_width)
                    widget.adjustSize()
                    item.setSizeHint(widget.sizeHint())
    
            # Final layout update.
            self.doItemsLayout()
            QApplication.processEvents()
    
            # Re-enable signals and auto-scroll.
            self.setAutoScroll(True)
            self.blockSignals(False)
    
            # Re-enable updates.
            self.viewport().setUpdatesEnabled(True)
            self.setUpdatesEnabled(True)
    
            # Restore scroll position from the saved value.
            if hasattr(self, '_saved_scroll_position'):
                print(f"[DEBUG] Restoring scroll position to: {self._saved_scroll_position}")
                self.verticalScrollBar().setValue(self._saved_scroll_position)
            else:
                print("[DEBUG] No _saved_scroll_position found during restoration")
    
            # Final update of the viewport.
            self.viewport().update()
    
            # Execute callback if provided.
            if callback:
                QTimer.singleShot(10, callback)
    
            print("[DEBUG] end_batch_updates.restore_updates - Finished")
    
        # Schedule restore_updates to run after the given delay.
        QTimer.singleShot(delay_before_show, restore_updates)



    def _resize_text_label(self, label, width):
        """Helper method to resize a text label to the correct dimensions"""
        plain_text = label.text()
        if "<" in plain_text and ">" in plain_text:
            # Convert <br> to \n before stripping HTML for proper height calculation
            plain_text = plain_text.replace('<br>', '\n')
            plain_text = re.sub(r'<[^>]+>', '', plain_text)
        
        font_metrics = label.fontMetrics()
        text_rect = font_metrics.boundingRect(
            QRect(0, 0, width, 2000),
            Qt.TextFlag.TextWordWrap | Qt.TextFlag.TextExpandTabs,
            plain_text
        )
    
        calculated_height = text_rect.height() + font_metrics.descent() + 15
        min_two_lines = int(font_metrics.lineSpacing() * 2.2 + font_metrics.descent())
    
        # Set exact dimensions
        label.setFixedWidth(width)
        label.setFixedHeight(max(calculated_height, min_two_lines))

    def toggle_favorite(self, annotation_id):
        """Toggle favorite status for an annotation with proper sizing and no flickering."""
        print(f"\n=== TOGGLE FAVORITE START: {annotation_id} ===")
    
        # Begin batch updates to hide visual changes
        self.begin_batch_updates()
    
        try:
            # Find the annotation in our data
            annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
            if not annotation:
                print(f"[ERROR] Annotation not found: {annotation_id}")
                self.end_batch_updates(0)  # End batch updates immediately
                return
        
            # Find the item in the list
            found_item = None
            for i in range(self.count()):
                current_item = self.item(i)
                if current_item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                    found_item = current_item
                    break
            
            if not found_item:
                print(f"[ERROR] List item not found for annotation: {annotation_id}")
                self.end_batch_updates(0)  # End batch updates immediately
                return
        
            # Get the existing widget
            widget = self.itemWidget(found_item)
            if not widget:
                print(f"[ERROR] Widget not found for item: {annotation_id}")
                self.end_batch_updates(0)  # End batch updates immediately
                return
    
            # Find the favorite label
            favorite_label = None
            for child in widget.findChildren(QLabel):
                if child.objectName() == "favorite_label":
                    favorite_label = child
                    break
            
            if not favorite_label:
                print(f"[ERROR] Favorite label not found: {annotation_id}")
                self.end_batch_updates(0)  # End batch updates immediately
                return
        
            # Toggle the favorite state in the data model
            current_state = annotation.get('favorite', False)
            new_state = not current_state
            annotation['favorite'] = new_state
            print(f"Toggled favorite for {annotation_id}: {current_state} -> {new_state}")
    
            # Update the visual representation
            favorite_label.setText("★" if new_state else "☆")
            favorite_label.setStyleSheet(f"""
                QLabel {{
                    font-size: 16px;
                    margin-bottom: 3px;
                    color: {'gold' if new_state else 'black'};
                }}
            """)
        
            # Get reference to the main window
            dialog = self.window()
            if isinstance(dialog, StoryboardDialog):
                main_window = dialog.main_window
                if main_window:
                    # Create a complete update payload for DOM update
                    update_payload = {
                        'id': annotation_id,
                        'text': annotation.get('text', ''),
                        'favorite': new_state,  # The new favorite status
                        'used': annotation.get('used', False),
                        'notes': annotation.get('notes', ''),
                        'notes_html': annotation.get('notes_html', ''),
                        'tags': annotation.get('tags', []),
                        'secondary_scenes': annotation.get('secondary_scenes', [])
                    }
                    print(f"DEBUG toggle_favorite: Emitting update payload for favorite={new_state}")
                    main_window.web_view.annotation_updated.emit(json.dumps(update_payload))
                    
                    # Apply targeted filtering after DOM attributes are updated (like theme view does)
                    scene = annotation.get('scene', '')
                    if scene and hasattr(main_window.web_view, '_apply_filters_to_annotation'):
                        # Small delay to ensure DOM attributes are updated first
                        def apply_targeted_filter():
                            print(f"[DEBUG] Applying targeted filtering after favorite change in storyboard: {annotation_id}")
                            main_window.web_view._apply_filters_to_annotation(annotation_id, scene, annotation)
                        QTimer.singleShot(50, apply_targeted_filter)
                
                    # Mark changes as pending
                    main_window.mark_changes_pending()
    
            # Create callback for additional operations after updates
            def after_favorite_toggle():
                # Mark changes as pending and apply changes
                dialog = self.window()
                if isinstance(dialog, StoryboardDialog):
                    dialog.changes_pending = True
                    self.mark_storyboard_widget_changes_pending()
            
                    # Use targeted sync instead of expensive apply_changes
                    if main_window.theme_view:
                        print("[DEBUG] Syncing theme view after favorite toggle")
                        QTimer.singleShot(10, lambda: dialog._sync_theme_view_items())
            
            # End batch updates with callback for follow-up operations
            self.end_batch_updates(10, after_favorite_toggle)
            print("=== TOGGLE FAVORITE END ===\n")
    
        except Exception as e:
            print(f"[ERROR] Exception in toggle_favorite: {e}")
            import traceback
            traceback.print_exc()
    
            # Ensure updates are restored even on error
            self.end_batch_updates(0)
        
    def update_annotation_status(self, annotation_id, key, value):
        """Update the given status for the annotation with improved debugging."""
        print(f"\n=== UPDATE_ANNOTATION_STATUS START: {annotation_id}, {key}={value} ===")
    
        # Debug state information if this is for a checkbox
        if key == "used":
            print(f"State details: type={type(value)}, value={value}")
        
            # Convert numeric state to boolean if needed
            if isinstance(value, int):
                if value == 2:  # Qt.CheckState.Checked
                    value = True
                    print("Converted Qt.CheckState.Checked (2) to True")
                elif value == 0:  # Qt.CheckState.Unchecked
                    value = False
                    print("Converted Qt.CheckState.Unchecked (0) to False")
    
        # Find the annotation
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if annotation:
            # Update the Python data structure
            old_value = annotation.get(key, None)
            annotation[key] = value
            print(f"Annotation {annotation_id} updated: {key} changed from {old_value} to {value}")
        
            # Get dialog and main window
            dialog = self.window()
            main_window = getattr(dialog, 'main_window', None) if isinstance(dialog, StoryboardDialog) else None
        
            if main_window:
                # Create complete update payload - CRUCIAL for DOM updates
                update_payload = {
                    'id': annotation_id,
                    'text': annotation.get('text', ''),
                    'favorite': annotation.get('favorite', False),
                    'used': annotation.get('used', False),
                    'notes': annotation.get('notes', ''),
                    'notes_html': annotation.get('notes_html', ''),
                    'tags': annotation.get('tags', []),
                    'secondary_scenes': annotation.get('secondary_scenes', [])
                }
            
                # Emit signal BEFORE any other operations to ensure DOM gets updated
                print(f"Emitting annotation_updated signal with payload: {json.dumps(update_payload)}")
                main_window.web_view.annotation_updated.emit(json.dumps(update_payload))
            
                # Apply targeted filtering after DOM attributes are updated (like theme view does)
                if key == "used":  # Only apply filtering for used status changes
                    scene = annotation.get('scene', '')
                    if scene and hasattr(main_window.web_view, '_apply_filters_to_annotation'):
                        # Small delay to ensure DOM attributes are updated first
                        def apply_targeted_filter():
                            print(f"[DEBUG] Applying targeted filtering after used status change in storyboard: {annotation_id}")
                            main_window.web_view._apply_filters_to_annotation(annotation_id, scene, annotation)
                        QTimer.singleShot(50, apply_targeted_filter)
            
                # Mark changes as pending in main window
                main_window.mark_changes_pending()
            
                # Mark changes as pending in dialog
                if isinstance(dialog, StoryboardDialog):
                    dialog.changes_pending = True
                    self.mark_storyboard_widget_changes_pending()
                
                    # Use targeted update instead of expensive apply_changes
                    print("Scheduling targeted annotation update")
                    QTimer.singleShot(10, lambda: dialog.update_annotation_visual_state(annotation_id, key, value))
            else:
                print("WARNING: Main window reference not found, DOM will not be updated!")
            
        else:
            print(f"ERROR: Annotation with ID {annotation_id} not found!")
    
        print(f"=== UPDATE_ANNOTATION_STATUS END ===\n")

    def enable_editing(self, label):
        """Enable editing for the QLabel."""
        text = label.text()
        parent_layout = label.parentWidget().layout()

        editor = QLineEdit(text)
        editor.setStyleSheet("""
            QLineEdit {
                border: none;
                margin: 0;
                padding: 0;
                font-size: 14px;
            }
        """)
        editor.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)

        def finish_editing():
            new_text = editor.text()
            parent_layout.replaceWidget(editor, label)
            label.setText(new_text)
            label.show()
            editor.deleteLater()

        editor.editingFinished.connect(finish_editing)
        parent_layout.replaceWidget(label, editor)
        label.hide()
        editor.setFocus()

    def dropEvent(self, event):
        """Handle dropping of items with optimized strikethrough processing."""
        
        # Reset drag hover styling
        if self.property("dragHover") == "true":
            print("Resetting drag hover styling after drop")
            self.setProperty("dragHover", "false")
            self.style().unpolish(self)
            self.style().polish(self)
            # Disable custom drop indicators for external drags
            self._custom_drop_indicators_active = False
            self.update()  # Clear any remaining indicators
        
        # Mark that an internal drop occurred
        if event.source() == self:
            print("*** INTERNAL DROP DETECTED - Clearing _drag_in_progress flag ***")
            self._drag_in_progress = False  # Mark internal drop completed
        else:
            print("*** EXTERNAL DROP DETECTED in dropEvent ***")
        print("\n=== DROP EVENT START ===")
        print(f"Accept drops enabled: {self.acceptDrops()}")
        print(f"Updates enabled: {self.updatesEnabled()}")

        # Capture the current scroll position
        original_scroll_position = self.verticalScrollBar().value()
        self._saved_scroll_position = original_scroll_position
        print(f"Captured scroll position: {original_scroll_position}")

        # Hide visual updates during the entire drop processing
        # self.begin_batch_updates()  # Commented out - no longer needed since we don't rebuild widgets

        # Make sure strikethrough improvements pending flag is cleared before renumbering
        dialog = self.window()
        if isinstance(dialog, StoryboardDialog) and hasattr(dialog, '_strikethrough_improvements_pending'):
            dialog._strikethrough_improvements_pending = False
            print("[DEBUG] Cleared _strikethrough_improvements_pending flag before drop processing")

        # Track the dropped annotation ID for targeted strikethrough processing
        dropped_annotation_id = None

        if event.source() == self:
            print("Internal reordering detected")
            # Internal reordering
            old_order = getattr(self, 'pre_drag_order', None)
            print(f"Old order: {old_order}")

            super().dropEvent(event)

            new_order = [self.item(i).data(Qt.ItemDataRole.UserRole) for i in range(self.count())]
            print(f"New order: {new_order}")

            if old_order is not None and old_order != new_order:
                print("Order changed - updating storyboard states")
                # Update storyboard order
                for i, anno_id in enumerate(new_order):
                    annotation = next((a for a in self.annotations if a.get('id') == anno_id), None)
                    if annotation:
                        print(f"\nProcessing annotation {anno_id}:")
                        print(f"Original text: {annotation.get('text')}")

                        # Handle missing or incomplete storyboard data:
                        if 'storyboard' not in annotation or annotation['storyboard'] is None:
                            print(f"Script Editor data missing or None for annotation {anno_id}. Initializing with default values.")
                            annotation['storyboard'] = {'order': i}  # Default values
                        else:
                            # Update order if storyboard exists
                            annotation['storyboard']['order'] = i

                        # Remove storyboard data if storyboard text is empty
                        if annotation['storyboard'].get('text') is None or annotation['storyboard'].get('text') == "":
                            del annotation['storyboard']

                        print(f"Updated storyboard state: {annotation.get('storyboard')}")

                    dialog = self.window()
                    if isinstance(dialog, StoryboardDialog):
                        dialog.changes_pending = True
                        print("Changes marked as pending")

                    # Ensure _strikethrough_improvements_pending is False before renumbering
                    if isinstance(dialog, StoryboardDialog) and hasattr(dialog, '_strikethrough_improvements_pending'):
                        dialog._strikethrough_improvements_pending = False
                        print("[DEBUG] Cleared _strikethrough_improvements_pending flag before renumbering")
        else:
            print("External drop detected (from theme view)")
            # Handle drops from theme view
            if event.mimeData().hasFormat("application/x-annotation-id"):
                anno_id = event.mimeData().data("application/x-annotation-id").data().decode('utf-8')
                print(f"\nProcessing dropped annotation ID: {anno_id}")
                dropped_annotation_id = anno_id  # Store for targeted processing

                # Check for duplicates
                existing_ids = [self.item(i).data(Qt.ItemDataRole.UserRole) for i in range(self.count())]
                if anno_id in existing_ids:
                    # End batch updates before showing message box
                    self.end_batch_updates(0)
                    # Restore cursor before showing dialog
                    self.setCursor(Qt.CursorShape.ArrowCursor)
                    QMessageBox.warning(
                        self,
                        "Duplicate Annotation",
                        "This annotation is already in the storyboard panel."
                    )
                    event.ignore()
                    return

                annotation = next((a for a in self.annotations if a.get('id') == anno_id), None)
                if annotation:
                    print(f"\nFound matching annotation:")
                    print(f"Original text: {annotation.get('text')}")
                    print(f"Original notes: {annotation.get('notes', '')}")

                    # Ensure annotation has required fields
                    if 'scene' not in annotation:
                        print("Warning: Annotation missing scene information")
                        annotation['scene'] = 'Unknown'  # Provide default scene

                    # Restore deleted annotation if applicable
                    if annotation.get('deleted', False):
                        annotation['deleted'] = False
                        print(f"Annotation {anno_id} restored from deleted state.")

                    try:
                        drop_point = event.position().toPoint()
                    except AttributeError:
                        drop_point = event.pos()

                    # Calculate drop index using same logic as visual indicator
                    drop_item = self.itemAt(drop_point)
                    if drop_item:
                        item_index = self.row(drop_item)
                        item_rect = self.visualItemRect(drop_item)
                        
                        # Determine insertion index based on position (same as _draw_custom_drop_indicator)
                        if drop_point.y() < item_rect.center().y():
                            # Will insert before this item
                            drop_index = item_index
                        else:
                            # Will insert after this item
                            drop_index = item_index + 1
                    else:
                        # No item at drop position - insert at end
                        drop_index = self.count()
                    
                    print(f"Drop index: {drop_index}")

                    # Create and add the item
                    new_item = QListWidgetItem()
                    new_item.setData(Qt.ItemDataRole.UserRole, anno_id)

                    if drop_index == -1:
                        self.addItem(new_item)
                        drop_index = self.count() - 1
                        print("Added item to end of list")
                    else:
                        self.insertItem(drop_index, new_item)
                        print(f"Inserted item at position {drop_index}")

                    # Get text from storyboard state if it exists
                    display_text = annotation.get('text', '')
                    notes = annotation.get('notes', '')
                    print(f"\nInitial display text: {display_text}")
                    print(f"Initial notes: {notes}")

                    # Handle missing or incomplete storyboard data:
                    if 'storyboard' not in annotation or annotation['storyboard'] is None:
                        print(f"Script Editor data missing or None for annotation {anno_id}. Initializing with default values.")
                        annotation['storyboard'] = {'order': drop_index, 'text': annotation.get('text', '').replace('\n', '<br>')}  # Default values with preserved text and HTML line breaks
                        storyboard = annotation['storyboard']
                    else:
                        storyboard = annotation['storyboard']

                    # ONLY get storyboard text if it's not None or ""
                    if storyboard.get('text') is not None and storyboard.get('text') != "":
                        display_text = storyboard.get('text').replace('\n', '<br>')

                    notes = storyboard.get('notes', notes)
                    print(f"After storyboard - display text: {display_text}")
                    print(f"After storyboard - notes: {notes}")

                    # Create widget with the appropriate text
                    widget, label = self.create_item_widget(
                        display_text,
                        anno_id,
                        drop_index + 1,
                        notes
                    )

                    new_item.setSizeHint(widget.sizeHint())
                    self.setItemWidget(new_item, widget)

                    # Update order in storyboard state
                    annotation['storyboard']['order'] = drop_index

                    # Remove storyboard data if storyboard text is empty
                    if annotation['storyboard'].get('text') is None or annotation['storyboard'].get('text') == "":
                        del annotation['storyboard']
                    
                    # Mark annotation as used when dropped into storyboard
                    if not annotation.get('used', False):
                        print(f"[DEBUG] Setting annotation {anno_id} as used after dropping into storyboard")
                        # Set the checkbox to checked in the widget we just created
                        used_checkbox = widget.findChild(CustomCheckBox)
                        if used_checkbox:
                            used_checkbox.setChecked(True)
                            print(f"[DEBUG] Set checkbox to checked for {anno_id}")
                        # Update the annotation status through the normal pathway
                        self.update_annotation_status(anno_id, "used", True)
                        
                        # Update visual state in storyboard dialog
                        if isinstance(dialog, StoryboardDialog):
                            dialog.update_annotation_visual_state(anno_id, "used", True, skip_theme_sync=True)
                            print(f"[DEBUG] Updated visual state for used status in storyboard for {anno_id}")
                            
                            # Force widget update to ensure visual changes are applied
                            widget.update()
                            print(f"[DEBUG] Triggered widget update for visual refresh")
                            
                            # ADDED: Refresh theme view filtering after marking annotation as used
                            main_window = dialog.main_window
                            if hasattr(main_window, 'theme_view') and main_window.theme_view:
                                search_widget = main_window.theme_view.findChild(ThemeViewSearch)
                                if search_widget and hasattr(search_widget, 'apply_current_filters'):
                                    print(f"[DEBUG] Refreshing theme view filters after marking {anno_id} as used")
                                    QTimer.singleShot(100, search_widget.apply_current_filters)
                                    print(f"[DEBUG] Scheduled theme view filter refresh")

                    # Ensure _strikethrough_improvements_pending is False before renumbering
                    if isinstance(dialog, StoryboardDialog) and hasattr(dialog, '_strikethrough_improvements_pending'):
                        dialog._strikethrough_improvements_pending = False
                        print("[DEBUG] Cleared _strikethrough_improvements_pending flag before renumbering")

                    event.acceptProposedAction()
                else:
                    self.end_batch_updates(0)
                    # Restore cursor before ignoring event
                    self.setCursor(Qt.CursorShape.ArrowCursor)
                    event.ignore()
                    return
            else:
                self.end_batch_updates(0)
                # Restore cursor before ignoring event
                self.setCursor(Qt.CursorShape.ArrowCursor)
                event.ignore()
                return

        # Use optimized renumber method that avoids widget rebuilds
        self.renumber_items_optimized(dropped_annotation_id=dropped_annotation_id)

        # Trigger tags positioning immediately after renumbering, while updates are still disabled
        dialog = self.window()
        if isinstance(dialog, StoryboardDialog):
            dialog._trigger_tags_positioning()

        # Check if we need to scroll to bottom and do it immediately
        scroll_to_bottom = False
        if dropped_annotation_id:
            # Check if the dropped item will be at the end
            for i in range(self.count()):
                item = self.item(i)
                if item and item.data(Qt.ItemDataRole.UserRole) == dropped_annotation_id:
                    if i == self.count() - 1:  # Last item
                        scroll_to_bottom = True
                    break
        
        if isinstance(self.window(), StoryboardDialog):
            self.window().apply_changes_lite()

        # ONLY process strikethroughs for the dropped annotation if it has them
        if dropped_annotation_id:
            annotation = next((a for a in self.annotations if a.get('id') == dropped_annotation_id), None)
            if annotation and 'storyboard' in annotation and annotation['storyboard'].get('strikethrough_segments'):
                print(f"[DEBUG] Improving strikethroughs only for dropped item: {dropped_annotation_id}")
                self.improve_strikethrough_display(dropped_annotation_id, skip_partial_fallback=True)
        # Commented out - no longer needed since we don't rebuild widgets, strikethroughs are preserved
        
        # Auto-select the dropped annotation
        if dropped_annotation_id:
            def select_and_scroll_to_dropped():
                # Find the item that was just dropped
                for i in range(self.count()):
                    item = self.item(i)
                    if item and item.data(Qt.ItemDataRole.UserRole) == dropped_annotation_id:
                        # Clear any existing selection
                        self.clearSelection()
                        # Select the dropped item
                        item.setSelected(True)
                        print(f"[DEBUG] Auto-selected dropped annotation: {dropped_annotation_id}")
                        
                        # Handle scrolling AFTER selection to prevent it from being overridden
                        if scroll_to_bottom:
                            # Scroll to absolute bottom
                            self.verticalScrollBar().setValue(self.verticalScrollBar().maximum())
                            print(f"[DEBUG] Scrolled to absolute bottom after selection")
                        elif hasattr(self, '_saved_scroll_position'):
                            self.verticalScrollBar().setValue(self._saved_scroll_position)
                        break
            
            # Use a short delay to ensure all UI updates are complete
            QTimer.singleShot(100, select_and_scroll_to_dropped)
        else:
            # No dropped annotation, handle scroll immediately
            if scroll_to_bottom:
                # Scroll to absolute bottom
                self.verticalScrollBar().setValue(self.verticalScrollBar().maximum())
                print(f"[DEBUG] Scrolled to absolute bottom after drop")
            elif hasattr(self, '_saved_scroll_position'):
                self.verticalScrollBar().setValue(self._saved_scroll_position)

        print(f"Restored scroll position to: {original_scroll_position}")
        
        # Simply set cursor to arrow after drop
        self.setCursor(Qt.CursorShape.ArrowCursor)
        print("Set cursor to ArrowCursor after drop")
        
        # Accept the drop event to signal successful handling
        event.accept()
        print("=== DROP EVENT END ===\n")

    def renumber_items_optimized(self, scroll_value=None, dropped_annotation_id=None, with_visual_updates=True, resize_all_items=False, preserve_states=True):
        """Efficiently update item numbers without rebuilding widgets.
        
        Enhanced version that handles all functionality of renumber_items_without_strikethrough
        but avoids expensive widget rebuilds. Updates numbers, preserves states, and handles
        text sizing without creating new widgets.
        
        Args:
            scroll_value: Optional scroll position to restore after renumbering
            dropped_annotation_id: ID of annotation that was just dropped, for targeted text resizing  
            with_visual_updates: Whether to allow visual updates during renumbering
            resize_all_items: Whether to resize text labels for all items (not just dropped)
            preserve_states: Whether to preserve and update widget states (checkboxes, favorites)
        """
        print("🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 RENUMBER_ITEMS_OPTIMIZED START 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥")
        print(f"🔥 scroll_value={scroll_value}, dropped_annotation_id={dropped_annotation_id}, with_visual_updates={with_visual_updates}, resize_all_items={resize_all_items}, preserve_states={preserve_states}")
        print("🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥")
        
        # 🔥 TRACK POSITIONAL STRIKETHROUGH CONTEXT AT START 🔥
        print("🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 POSITIONAL CONTEXT AT RENUMBER START 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥")
        for anno in self.annotations:
            anno_id = anno.get('id')
            storyboard = anno.get('storyboard', {})
            positional_data = storyboard.get('positional_strikethrough', {})
            if positional_data:
                for segment_key, segment_data in positional_data.items():
                    context_before = segment_data.get('context_before', '')
                    context_after = segment_data.get('context_after', '')
                    if context_before or context_after:
                        print(f"🔥 ANNO {anno_id} SEGMENT '{segment_key}' - BEFORE: '{context_before}' AFTER: '{context_after}'")
                    else:
                        print(f"🔥 ANNO {anno_id} SEGMENT '{segment_key}' - NO CONTEXT (EMPTY)")
        print("🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥")
        # Capture scroll position if not provided
        if scroll_value is None:
            scroll_value = self.verticalScrollBar().value()
        print(f"[DEBUG] Starting optimized renumbering: scroll={scroll_value}, resize_all={resize_all_items}, preserve_states={preserve_states}")
        
        # Handle batch updates if visual updates disabled
        if not with_visual_updates:
            self.begin_batch_updates()
        
        # Create annotation lookup cache for O(1) access
        annotation_cache = {anno.get('id'): anno for anno in self.annotations if anno.get('id')}
        
        try:
            number = 1
            updates = []
            
            for i in range(self.count()):
                item = self.item(i)
                widget = self.itemWidget(item)
                
                # Skip dividers (respecting original logic)
                if widget and hasattr(widget, 'is_divider') and widget.is_divider:
                    continue
                
                anno_id = item.data(Qt.ItemDataRole.UserRole)
                annotation = annotation_cache.get(anno_id)  # O(1) lookup
                
                if annotation:
                    # Update annotation storyboard order
                    if 'storyboard' not in annotation:
                        annotation['storyboard'] = {}
                    annotation['storyboard']['order'] = number
                    
                    if widget:
                        # Update number label
                        number_label = widget.findChild(QLabel, f"number_label_{anno_id}")
                        if number_label:
                            number_label.setText(f"{number}.")
                        else:
                            print(f"[DEBUG] Warning: Could not find number label for annotation {anno_id}")
                        
                        # Handle text sizing (targeted or all items)
                        should_resize = (
                            resize_all_items or 
                            anno_id == dropped_annotation_id
                        )
                        
                        if should_resize:
                            self._apply_text_sizing_optimized(widget, item, anno_id)
                        
                        # Sync widget text with annotation data ONLY in reassignment contexts
                        # Skip for normal operations like header changes to avoid unnecessary updates
                        if getattr(self.main_window, '_in_reassignment_context', False):
                            self._sync_widget_text_with_annotation(widget, annotation)
                        
                        # Handle state preservation without rebuilding
                        if preserve_states:
                            self._preserve_widget_states_optimized(widget, annotation)
                    
                    # Track updates
                    updates.append({
                        'id': anno_id,
                        'order': number,
                        'index': i
                    })
                    
                    number += 1
            
            print(f"[DEBUG] Optimized renumbering updated {len(updates)} items")
            
        finally:
            # Handle batch updates cleanup and scroll restoration
            def restore_scroll():
                self.verticalScrollBar().setValue(scroll_value)
                print(f"[DEBUG] Restored scroll position to: {scroll_value}")
            
            if not with_visual_updates:
                self.end_batch_updates(150, restore_scroll)
            else:
                # Use shorter delay since no widget rebuilding
                QTimer.singleShot(50, restore_scroll)
        
        # 🔥 TRACK POSITIONAL STRIKETHROUGH CONTEXT AT END 🔥
        print("🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 POSITIONAL CONTEXT AT RENUMBER END 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥")
        for anno in self.annotations:
            anno_id = anno.get('id')
            storyboard = anno.get('storyboard', {})
            positional_data = storyboard.get('positional_strikethrough', {})
            if positional_data:
                for segment_key, segment_data in positional_data.items():
                    context_before = segment_data.get('context_before', '')
                    context_after = segment_data.get('context_after', '')
                    if context_before or context_after:
                        print(f"🔥 ANNO {anno_id} SEGMENT '{segment_key}' - BEFORE: '{context_before}' AFTER: '{context_after}'")
                    else:
                        print(f"🔥 ANNO {anno_id} SEGMENT '{segment_key}' - NO CONTEXT (EMPTY)")
        print("🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥")
        
        print("🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 RENUMBER_ITEMS_OPTIMIZED END 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥")
        print("🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥")

    def _apply_text_sizing_optimized(self, widget, item, anno_id):
        """Apply proper text sizing to a widget without rebuilding it."""
        text_label = widget.findChild(QLabel, "main_content_label")
        if text_label:
            # Use same sizing logic as create_item_widget
            new_width = self.get_available_text_width()
            
            # Check if we have a header format FIRST
            has_header = ('<div><b' in text_label.text())
            
            # Standard sizing for all items
            plain_text = text_label.text()
            
            if "<" in plain_text and ">" in plain_text:
                # First convert ALL break tag variations to \n for measurement since QLabel renders them as line breaks
                temp_text = plain_text.replace('<br>', '\n').replace('<BR>', '\n').replace('<br/>', '\n').replace('<BR/>', '\n')
                if has_header:
                    # Convert <div> tags to line breaks for measurement since they create visual separation
                    temp_text = re.sub(r'</div>', '\n', temp_text)
                # Strip ALL HTML tags including strikethrough - they don't affect text spacing
                # Use a more robust pattern that handles nested tags correctly
                while '<' in temp_text and '>' in temp_text:
                    temp_text = re.sub(r'<[^>]*>', '', temp_text)
                plain_text = temp_text
            
            font_metrics = text_label.fontMetrics()
            text_rect = font_metrics.boundingRect(
                QRect(0, 0, new_width, 2000),
                Qt.TextFlag.TextWordWrap | Qt.TextFlag.TextExpandTabs,
                plain_text
            )
            
            # Standard calculation
            base_height = text_rect.height()
            line_spacing = font_metrics.lineSpacing()
            line_count = max(len(plain_text.split('\n')), 2)
            
            calculated_height = max(
                base_height + font_metrics.descent() + 12,
                line_count * line_spacing + 12,
                int(line_spacing * 2.2 + font_metrics.descent())
            )
            
            # Add extra height for custom painted widgets (star button, checkbox)
            calculated_height += 8
            
            # Apply sizing
            text_label.setFixedWidth(new_width)
            text_label.setFixedHeight(calculated_height)
            text_label.updateGeometry()  # This was missing!
            widget.adjustSize()
            widget.updateGeometry()
            item.setSizeHint(widget.sizeHint())
    
    def _preserve_widget_states_optimized(self, widget, annotation):
        """Preserve and sync widget states with annotation data without rebuilding."""
        if not widget or not annotation:
            return
            
        # Handle checkbox state synchronization
        checkbox = widget.findChild(CustomCheckBox)
        if checkbox:
            # Get annotation state and sync with widget
            annotation_checked = annotation.get('used', False)
            widget_checked = checkbox.isChecked()
            
            # If they differ, update annotation to match widget (widget is source of truth)
            if widget_checked != annotation_checked:
                annotation['used'] = widget_checked
                print(f"[DEBUG] Synced checkbox state for {annotation.get('id')}: {widget_checked}")
        
        # Handle favorite state synchronization  
        favorite_label = None
        for child in widget.children():
            if isinstance(child, QLabel) and child.objectName() == "favorite_label":
                favorite_label = child
                break
        
        if favorite_label:
            # Get annotation state and sync with widget
            annotation_favorite = annotation.get('favorite', False)
            widget_favorite = (favorite_label.text() == "★")
            
            # If they differ, update annotation to match widget (widget is source of truth)
            if widget_favorite != annotation_favorite:
                annotation['favorite'] = widget_favorite
                # Ensure visual state is correct
                if widget_favorite:
                    favorite_label.setText("★")
                    favorite_label.setStyleSheet("font-size: 16px; margin-bottom: 3px; color: gold;")
                print(f"[DEBUG] Synced favorite state for {annotation.get('id')}: {widget_favorite}")
    
    def _sync_widget_text_with_annotation(self, widget, annotation):
        """Sync widget text with annotation data - critical for handle_removal_and_reassign."""
        if not widget or not annotation:
            return
            
        # Get the current text from annotation (same logic as original renumber method)
        display_text = None
        
        # First try to get from storyboard if it exists and has content
        if 'storyboard' in annotation and 'text' in annotation['storyboard'] and annotation['storyboard']['text']:
            display_text = annotation['storyboard']['text']
        
        # Fall back to main annotation text
        if not display_text:
            display_text = annotation.get('text', '')
        
        # Only update if we have valid text and it differs from widget
        if display_text:
            text_label = widget.findChild(QLabel, "main_content_label")
            if text_label:
                current_widget_text = text_label.text()
                # Only update if text actually changed (to avoid unnecessary updates)
                if current_widget_text != display_text:
                    text_label.setText(display_text)
                    print(f"[DEBUG] Synced widget text for {annotation.get('id')}: '{display_text[:50]}...'")


    def renumber_items_without_strikethrough(self, with_visual_updates=True, scroll_value=None):
        """DEPRECATED: Redirects to optimized version to avoid full widget rebuilds.
        
        This method previously rebuilt all widgets but now redirects to the optimized
        version which preserves widgets and only updates necessary elements.
        """
        print(f"[DEBUG] renumber_items_without_strikethrough → optimized; scroll={scroll_value}, visual_updates={with_visual_updates}")
        
        # Redirect to optimized version with full functionality
        self.renumber_items_optimized(
            scroll_value=scroll_value,
            with_visual_updates=with_visual_updates,
            resize_all_items=True,  # Ensure all items get proper sizing
            preserve_states=True    # Maintain widget states
        )

    def update_after_change(self, main_window):
        print("Updating after change...")  # Debug
        main_window.web_view.scenes_updated.emit()
        if main_window.theme_view and main_window.theme_view.isVisible():
            main_window.update_theme_view()
        main_window.web_view.page().toHtml(main_window.update_preview_content)
        main_window.status_bar.showMessage('Clip order updated', 3000)
        
        if main_window.current_session_file:
            if not main_window.windowTitle().startswith('*'):
                main_window.setWindowTitle(f'*{main_window.windowTitle()}')

    def update_order_after_move(self, main_window):
        """Update the order of annotations after a move"""
        print("Updating order after move...")  # Debug

        # Ensure web_view exists
        if not hasattr(main_window, 'web_view') or not main_window.web_view:
            #print("Error: main_window has no 'web_view' or 'web_view' is None.")
            return

        ordered_annotations = []
        used_ids = set()

        # Add annotations in new list order
        for i in range(self.count()):
            item = self.item(i)
            anno_id = item.data(Qt.ItemDataRole.UserRole)
            for anno in main_window.web_view.annotations:
                if anno.get('id') == anno_id and anno_id not in used_ids:
                    anno['order'] = i  # Update order to match current position
                    ordered_annotations.append(anno)
                    used_ids.add(anno_id)
                    #print(f"Ordered annotation {i}: ID={anno_id}, Text={anno.get('text')[:30]}..., Notes={anno.get('notes', '')[:30]}...")  # Debug
                    break

        # Add remaining annotations
        for anno in main_window.web_view.annotations:
            if anno.get('id') not in used_ids:
                anno.pop('order', None)
                ordered_annotations.append(anno)
                #print(f"Added remaining annotation: ID={anno.get('id')}, Text={anno.get('text')[:30]}..., Notes={anno.get('notes', '')[:30]}...")  # Debug

        main_window.web_view.annotations = ordered_annotations
        self.update_after_change(main_window)
    
        # Always set changes pending when order is updated
        parent_dialog = self.parent()
        if isinstance(parent_dialog, StoryboardDialog):
            print("Setting changes_pending after order update")  # Debug
            parent_dialog.changes_pending = True


    def clear_final_order(self):
        """Clear all items from the order list after confirmation."""
        reply = QMessageBox.question(
            self,
            'Clear Script Editor',
            'Are you sure you want to delete all items in the Script Editor?',
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.clear()
        
            # Mark changes as pending
            main_window = self.window()
            if isinstance(main_window, ScriptoriaMain):
                # Set storyboard changes as pending
                dialog = self.window()
                if isinstance(dialog, StoryboardDialog):
                    dialog.changes_pending = True
                    self.mark_storyboard_widget_changes_pending()
                    QTimer.singleShot(100, dialog.apply_changes_lite)

    def wheelEvent(self, event):
        """Override wheel event to reduce scrolling speed and ensure proper cleanup."""
        # Clean up any ongoing auto-scroll
        self.scroll_timer.stop()
        self.current_scroll_direction = None
        self.is_scrolling = False

        # Reduce the scroll speed
        reduced_delta = event.angleDelta() / 3
        modified_event = QWheelEvent(
            event.position(),
            event.globalPosition(),
            event.pixelDelta(),
            reduced_delta,
            event.buttons(),
            event.modifiers(),
            event.phase(),
            event.inverted()
        )
        super().wheelEvent(modified_event)

    def delete_selected_text(self, label, annotation_id):
        """
        Delete the selected text from the label and update the annotation,
        including any whitespace/newlines in the selection,
        while removing any existing <br> tags at the beginning so that
        all text is handled as plain text when doing the deletion.

        After deletion, call a method to resize the widget to match the new text dimensions.
        """
        print("[DEBUG] Entering delete_selected_text method")

        if not label.hasSelectedText():
            print("[DEBUG] No text is currently selected")
            QMessageBox.warning(self, "No Text Selected", "Please select text to delete.")
            return

        selected_text = label.selectedText()
        print(f"[DEBUG] Selected text: {selected_text!r}")

        main_window = None
        current_widget = self
        while current_widget:
            if isinstance(current_widget, ScriptoriaMain):
                main_window = current_widget
                break
            current_widget = current_widget.parent()
        print(f"[DEBUG] Found main_window: {main_window}")

        msg_box = QMessageBox(main_window if main_window else self)
        msg_box.setWindowTitle("Confirm Delete")
        msg_box.setText(f'Are you sure you want to delete the selected text?\n\n"{selected_text}"')
        msg_box.setIcon(QMessageBox.Icon.Question)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        msg_box.setWindowFlags(msg_box.windowFlags() | Qt.WindowType.WindowStaysOnTopHint)
        print("[DEBUG] Showing confirmation dialog...")

        if msg_box.exec() == QMessageBox.StandardButton.Yes:
            full_text = label.text()
            print(f"[DEBUG] Original label text (length={len(full_text)}): {full_text!r}")

            full_text_no_br = re.sub(r'<br\s*/?>', '\n', full_text)
            print("[DEBUG] Removed existing <br> tags -> replaced with '\\n'")

            def normalize_line_seps(s: str) -> str:
                s = s.replace('\r\n', '\n').replace('\r', '\n')
                s = s.replace('\u2028', '\n').replace('\u2029', '\n')
                return s

            normalized_full = normalize_line_seps(full_text_no_br)
            normalized_selected = normalize_line_seps(selected_text)
            print(f"[DEBUG] Normalized full text (length={len(normalized_full)}): {normalized_full!r}")
            print(f"[DEBUG] Normalized selected text (length={len(normalized_selected)}): {normalized_selected!r}")

            idx = normalized_full.find(normalized_selected)
            print(f"[DEBUG] Index of selection in normalized text: {idx}")
            if idx != -1:
                updated_normalized = normalized_full[:idx] + normalized_full[idx + len(normalized_selected):]
                print("[DEBUG] Removed selected text by slicing")
            else:
                updated_normalized = normalized_full.replace(normalized_selected, "", 1)
                print("[DEBUG] Used replace() to remove selected text (fallback)")

            print(f"[DEBUG] Updated normalized text (length={len(updated_normalized)}): {updated_normalized!r}")

            updated_text = updated_normalized
            label.setText(updated_text)
            print("[DEBUG] Set label text to updated plain text")

            self._resize_deleted_text_widget(label)

            annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
            if annotation:
                annotation.setdefault('storyboard', {})['text'] = updated_text.replace('\n', '<br>')
                print("[DEBUG] Updated annotation storyboard text")

            dialog = self.window()
            if isinstance(dialog, StoryboardDialog):
                dialog.changes_pending = True
                print("[DEBUG] Marked dialog changes as pending")
                if dialog.main_window.current_session_file:
                    title = dialog.main_window.windowTitle()
                    if not title.startswith('*'):
                        new_title = f'*{title}'
                        dialog.main_window.setWindowTitle(new_title)
                        print(f"[DEBUG] Updated window title: {new_title}")
        else:
            print("[DEBUG] User canceled deletion")

        print("[DEBUG] Exiting delete_selected_text method")

    def _resize_deleted_text_widget(self, label):
        parent_widget = label.parentWidget()
        if not parent_widget:
            return
        item = self._item_from_widget(parent_widget)
        if item:
            item.setSizeHint(parent_widget.sizeHint())
        self.updateGeometry()
        self.viewport().update()


    def _item_from_widget(self, widget):
        for i in range(self.count()):
            if self.itemWidget(self.item(i)) == widget:
                return self.item(i)
        return None


    def show_context_menu(self, label, annotation_id, pos):
        """Show the context menu for editing, restoring, or removing the item with improved deletion handling."""
        menu = QMenu()
        menu.setStyleSheet("""
            QMenu {
                background-color: white;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 8px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #e3f2fd;
                color: #2C4952;
            }
            QMenu::separator {
                height: 1px;
                background: #e0e0e0;
                margin: 4px 0;
            }
        """)

        # Add find action only if this is the main content label
        find_action = None
        if label.objectName() == "main_content_label":
            find_action = menu.addAction('Go to Annotation in Theme View')
            menu.addSeparator()

        # Strikethrough options
        add_strike = menu.addAction("Add Strikethrough")
        remove_strike = menu.addAction("Remove Strikethrough")

        menu.addSeparator()
        copy_action = menu.addAction("Copy Selection")
        copy_first_20_action = menu.addAction("Copy Caption")
        menu.addSeparator()

        # Header / restore / delete
        make_header = menu.addAction("Add/Edit Header")
        menu.addSeparator()
        restore_action = menu.addAction("Restore Original Text")
        
        # Check if multiple items are selected for batch delete
        selected_items = self.selectedItems()
        selected_count = len(selected_items)
        if selected_count > 1:
            delete_action = menu.addAction(f"Remove Annotation ({selected_count})")
        else:
            delete_action = menu.addAction("Remove Annotation")

        # Show it
        action = menu.exec(label.mapToGlobal(pos))
        if action is None:
            return

        parent = self.window()
        if action == find_action and isinstance(parent, StoryboardDialog):
            main = parent.main_window
            if not main.theme_view or not main.theme_view.isVisible():
                main.view_annotations_button.setChecked(True)
                main.toggle_theme_view()
                # Store annotation_id to select after theme view is populated
                main._pending_theme_view_selection = annotation_id
            else:
                self.select_annotation_in_theme_view(annotation_id)

        elif action == make_header:
            self.make_header(label, annotation_id)

        elif action == copy_action:
            QApplication.clipboard().setText(
                label.selectedText() if label.hasSelectedText() else label.text()
            )

        elif action == copy_first_20_action:
            # Use smart copy with cleaner tab matching
            smart_text = self.smart_copy_text(label.text())
            QApplication.clipboard().setText(smart_text)

        elif action == restore_action:
            self.restore_original_state(annotation_id)

        elif action == add_strike:
            self.add_strikethrough(label, annotation_id)

        elif action == remove_strike:
            self.remove_strikethrough(label, annotation_id)

        elif action == delete_action:
            # Check if multiple items are selected for batch delete
            if selected_count > 1:
                # Get all selected annotation IDs
                selected_annotation_ids = []
                for item in selected_items:
                    item_annotation_id = item.data(Qt.ItemDataRole.UserRole)
                    widget = self.itemWidget(item)
                    # Skip dividers
                    if item_annotation_id and widget and not hasattr(widget, 'is_divider'):
                        selected_annotation_ids.append(item_annotation_id)
                
                if selected_annotation_ids:
                    self.delete_multiple_items(selected_annotation_ids)
            else:
                # Single item delete - existing functionality
                self.delete_item(annotation_id)

    def extract_clean_text_from_html(self, text_content):
        """Extract clean text from HTML content, removing headers, strikethrough, and HTML tags."""
        import re
        
        # Remove strikethrough text (anything inside <s> tags)
        text_without_strikethrough = re.sub(r'<s[^>]*>.*?</s>', '', text_content, flags=re.DOTALL)
        
        # Remove headers (anything inside <b> tags or <strong> tags)
        text_without_headers = re.sub(r'<b[^>]*>.*?</b>', '', text_without_strikethrough, flags=re.DOTALL)
        text_without_headers = re.sub(r'<strong[^>]*>.*?</strong>', '', text_without_headers, flags=re.DOTALL)
        
        # Remove all remaining HTML tags
        plain_text = re.sub(r'<[^>]*>', '', text_without_headers)
        
        # Strip leading/trailing whitespace
        return plain_text.strip()

    def get_cleaner_tab_text(self):
        """Get the text from the cleaner tab's 'Cleaned Text Without Timecodes' section."""
        if not self.main_window:
            return ""
        
        try:
            cleaner_text = self.main_window.cleaner_output_text.toPlainText().strip()
            return cleaner_text
        except AttributeError:
            return ""

    def find_text_on_single_line(self, search_text, cleaner_lines):
        """Check if search_text exists as a continuous string on any single line."""
        if not search_text or not cleaner_lines:
            return False
        
        for line in cleaner_lines:
            line_clean = line.strip()
            if search_text in line_clean:
                return True
        return False

    def extract_text_segments(self, clean_text, char_count):
        """Extract sequential text segments of specified character count."""
        segments = []
        if len(clean_text) < char_count:
            return [clean_text] if clean_text else []
        
        for i in range(len(clean_text) - char_count + 1):
            segment = clean_text[i:i + char_count]
            if segment.strip():  # Only add non-empty segments
                segments.append(segment)
        
        return segments

    def smart_copy_text(self, label_text):
        """Smart text extraction with cleaner tab matching logic."""
        # Extract clean text using existing logic
        clean_text = self.extract_clean_text_from_html(label_text)
        
        # Get cleaner tab text
        cleaner_text = self.get_cleaner_tab_text()
        
        # If no cleaner text, return first 25 chars as fallback
        if not cleaner_text:
            return clean_text[:25] if clean_text else ""
        
        # Split cleaner text into lines
        cleaner_lines = [line.strip() for line in cleaner_text.splitlines() if line.strip()]
        
        # Try 25-character matching
        segments_25 = self.extract_text_segments(clean_text, 25)
        for segment in segments_25:
            if self.find_text_on_single_line(segment, cleaner_lines):
                return segment
        
        # Fallback to 8-character matching
        segments_8 = self.extract_text_segments(clean_text, 8)
        for segment in segments_8:
            if self.find_text_on_single_line(segment, cleaner_lines):
                return segment
        
        # Final fallback: first 25 characters
        return clean_text[:25] if clean_text else ""

    def extract_clean_text_for_display(self, label_text):
        """Extract clean text for display in drag pixmaps - no matching, just cleaning."""
        # Use the same cleaning logic as smart_copy_text but return full 50 chars
        clean_text = self.extract_clean_text_from_html(label_text)
        return clean_text  # Return the full cleaned text, pixmap will handle truncation

    # Add this new method to OrderListWidget class
    def select_annotation_in_theme_view(self, annotation_id):
        """Find, select, and scroll to annotation with the given ID in theme view and web view."""
        try:
            # Get main window reference directly from StoryboardDialog
            parent_dialog = self.window()
            if not isinstance(parent_dialog, StoryboardDialog):
                return
    
            main_window = parent_dialog.main_window
            if not main_window:
                return
    
            # Theme view should already be visible when this method is called
    
            # Find the annotation's scene
            annotation_scene = None
            annotation = None
            for anno in main_window.web_view.annotations:
                if anno.get('id') == annotation_id:
                    annotation_scene = anno.get('scene')
                    annotation = anno
                    break

            # 1. First, scroll to the annotation in the web view
            if annotation:
                # Clean text for JS injection by escaping special characters
                text_escaped = annotation.get('text', '').replace('\\', '\\\\').replace('"', '\\"').replace("'", "\\'").replace('\n', '\\n')
            
                # Using the exact same highlighting mechanics as in scroll_to_annotation:
                js_code = f'''
                    (function() {{
                    // Define variables for this execution context - now scoped to this IIFE
                    const annotationId = "{annotation_id}";
                    const textToMatch = "{text_escaped}";
        
                    // This function adds a class-based approach with animation cleanup
                    function scrollToText() {{
                        console.log("scrollToText: Searching for span with annotation id:", annotationId);
                        var spans = document.querySelectorAll(`span[data-annotation-id="${{annotationId}}"]`);
                        if (spans.length > 0) {{
                            console.log("scrollToText: Found span(s) using annotation id.");
                            return spans;
                        }}
                        console.warn("scrollToText: No span found with annotation id. Falling back to text match.");
                        var allSpans = document.querySelectorAll('span');
                        for (var i = 0; i < allSpans.length; i++) {{
                            if (allSpans[i].textContent.trim() === textToMatch.trim()) {{
                                console.log("scrollToText: Found span using text match at index", i);
                                return [allSpans[i]];
                            }}
                        }}
                        console.error("scrollToText: No span found matching the text.");
                        return [];
                    }}

                    // First, ensure we have a cleanup function in the global scope if not already defined
                    if (typeof window.cleanupHighlights !== 'function') {{
                        // Store all active highlight animations
                        window.activeHighlights = window.activeHighlights || new Map();
            
                        // Global cleanup function that can be called to clear all highlights
                        window.cleanupHighlights = function() {{
                            if (window.activeHighlights) {{
                                window.activeHighlights.forEach((timerId, element) => {{
                                    clearTimeout(timerId);
                                    element.classList.remove('annotation-highlight');
                                    element.classList.remove('annotation-highlight-fadeout');
                                    element.style.boxShadow = '';
                                }});
                                window.activeHighlights.clear();
                            }}
                        }};
            
                        // Add the CSS for our highlight animation if not already present
                        if (!document.getElementById('highlight-animation-styles')) {{
                            const style = document.createElement('style');
                            style.id = 'highlight-animation-styles';
                            style.textContent = `
                                .annotation-highlight {{
                                    transition: box-shadow 0.5s ease-in-out;
                                }}
                                .annotation-highlight-fadeout {{
                                    box-shadow: none !important;
                                    transition: box-shadow 0.5s ease-out !important;
                                }}
                            `;
                            document.head.appendChild(style);
                        }}
                    }}

                    // Helper function to get true complementary color using proper color theory
                    function getComplementaryColor(color) {{
                        console.log("Getting complementary color for:", color);
            
                        // Extract RGB components
                        let r, g, b;
            
                        try {{
                            // Handle rgba or rgb format
                            const rgbMatch = color.match(/rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([\\d.]+)\\s*)?\\)/i);
                            if (rgbMatch) {{
                                r = parseInt(rgbMatch[1], 10);
                                g = parseInt(rgbMatch[2], 10);
                                b = parseInt(rgbMatch[3], 10);
                            }}
                            // Handle hex format
                            else if (color.match(/#[0-9a-f]{{3,6}}/i)) {{
                                let hex = color.replace(/^#/, '');
                                if (hex.length === 3) {{
                                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                                }}
                                r = parseInt(hex.substring(0, 2), 16);
                                g = parseInt(hex.substring(2, 4), 16);
                                b = parseInt(hex.substring(4, 6), 16);
                            }}
                            // Handle color names
                            else {{
                                const colorMap = {{
                                    'yellow': [255, 255, 0], 'lightyellow': [255, 255, 224], 'gold': [255, 215, 0],
                                    'orange': [255, 165, 0], 'red': [255, 0, 0], 'pink': [255, 192, 203],
                                    'purple': [128, 0, 128], 'blue': [0, 0, 255], 'lightblue': [173, 216, 230],
                                    'green': [0, 128, 0], 'lightgreen': [144, 238, 144], 'white': [255, 255, 255],
                                    'black': [0, 0, 0], 'gray': [128, 128, 128], 'brown': [165, 42, 42]
                                }};
                                const lowerColor = color.toLowerCase();
                                for (const [name, rgb] of Object.entries(colorMap)) {{
                                    if (lowerColor.includes(name)) {{
                                        [r, g, b] = rgb;
                                        break;
                                    }}
                                }}
                                if (r === undefined) {{
                                    [r, g, b] = [255, 255, 240]; // Default to light yellow
                                }}
                            }}
                
                            // Convert RGB to HSL
                            function rgbToHsl(r, g, b) {{
                                r /= 255; g /= 255; b /= 255;
                                const max = Math.max(r, g, b);
                                const min = Math.min(r, g, b);
                                let h, s, l = (max + min) / 2;
                
                                if (max === min) {{
                                    h = s = 0; // achromatic
                                }} else {{
                                    const d = max - min;
                                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                                    switch (max) {{
                                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                                        case g: h = (b - r) / d + 2; break;
                                        case b: h = (r - g) / d + 4; break;
                                    }}
                                    h /= 6;
                                }}
                                return [h * 360, s, l];
                            }}
                
                            // Convert HSL to RGB
                            function hslToRgb(h, s, l) {{
                                h /= 360;
                                function hue2rgb(p, q, t) {{
                                    if (t < 0) t += 1;
                                    if (t > 1) t -= 1;
                                    if (t < 1/6) return p + (q - p) * 6 * t;
                                    if (t < 1/2) return q;
                                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                                    return p;
                                }}
                
                                if (s === 0) {{
                                    r = g = b = l; // achromatic
                                }} else {{
                                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                                    const p = 2 * l - q;
                                    r = hue2rgb(p, q, h + 1/3);
                                    g = hue2rgb(p, q, h);
                                    b = hue2rgb(p, q, h - 1/3);
                                }}
                                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
                            }}
                
                            if (r !== undefined && g !== undefined && b !== undefined) {{
                                console.log("Original RGB:", r, g, b);
                                
                                // Convert to HSL
                                const [h, s, l] = rgbToHsl(r, g, b);
                                console.log("HSL:", h, s, l);
                                
                                // Calculate complementary hue (opposite on color wheel)
                                let compHue = (h + 180) % 360;
                                
                                // Enhance saturation and adjust lightness for better visibility
                                let compSat = Math.min(1, s + 0.2); // Boost saturation slightly
                                let compLight = l < 0.5 ? Math.min(0.7, l + 0.3) : Math.max(0.3, l - 0.3); // Ensure good contrast
                                
                                // Convert back to RGB
                                const [compR, compG, compB] = hslToRgb(compHue, compSat, compLight);
                                console.log("Complementary RGB:", compR, compG, compB);
                                
                                return `rgba(${{compR}}, ${{compG}}, ${{compB}}, 0.9)`;
                            }}
                        }} catch (e) {{
                            console.error("Error calculating complementary color:", e);
                        }}
            
                        // Fallback to vibrant blue
                        return 'rgba(0, 100, 255, 0.9)';
                    }}

                    // Clean up any existing animations before starting new ones
                    window.cleanupHighlights();

                    var targetSpans = scrollToText();
                    if (targetSpans.length > 0) {{
                        console.log("scroll_to_annotation: Scrolling to first matching span.");
                        targetSpans[0].scrollIntoView({{ behavior: 'smooth', block: 'center' }});
            
                        targetSpans.forEach(function(span) {{
                            // Get the background color and calculate complementary color
                            const bgColor = window.getComputedStyle(span).backgroundColor;
                            const compColor = getComplementaryColor(bgColor);
                            console.log("Background color:", bgColor, "Complementary color:", compColor);
                
                            // Apply highlight with complementary color
                            span.classList.add('annotation-highlight');
                            span.style.boxShadow = `0 0 10px 3px ${{compColor}}`; // Increased shadow size and spread
                
                            // Set a timeout to start fading out
                            const fadeStartTime = setTimeout(() => {{
                                // Add the fadeout class
                                span.classList.add('annotation-highlight-fadeout');
                    
                                // Set another timeout to completely clean up after fade completes
                                const fadeEndTime = setTimeout(() => {{
                                    span.classList.remove('annotation-highlight');
                                    span.classList.remove('annotation-highlight-fadeout');
                                    span.style.boxShadow = '';
                                    window.activeHighlights.delete(span);
                                }}, 600); // slightly longer than transition time to ensure it completes
                    
                                // Update the timer ID in our map
                                window.activeHighlights.set(span, fadeEndTime);
                            }}, 1000);
                
                            // Store the initial animation timer in our tracking map
                            window.activeHighlights.set(span, fadeStartTime);
                        }});
                    }} else {{
                        console.warn("scroll_to_annotation: No matching annotation span found.");
                    }}
                    }})(); // Close the IIFE
                '''
                main_window.web_view.page().runJavaScript(js_code)
    
            # 2. Then find and select the annotation in the theme view
            theme_view_found = False
        
            # Using the scene_tabs which we know works based on the debug output
            if annotation_scene and hasattr(main_window, 'scene_tabs'):
                # Find the tab with this scene name
                for i in range(main_window.scene_tabs.count()):
                    if main_window.scene_tabs.tabText(i) == annotation_scene:
                        # Switch to this tab
                        main_window.scene_tabs.setCurrentIndex(i)
                
                        # The tab widget itself is an AnnotationListWidget
                        list_widget = main_window.scene_tabs.widget(i)
                        if isinstance(list_widget, AnnotationListWidget):
                            # Search for our annotation by ID
                            for j in range(list_widget.count()):
                                item = list_widget.item(j)
                                if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                                    # Clear all existing selections across all tabs first
                                    main_window.clear_all_tab_selections()
                                    
                                    # Select and scroll to the item
                                    list_widget.setCurrentItem(item)
                                    item.setSelected(True)
                                    list_widget.scrollToItem(item, QAbstractItemView.ScrollHint.PositionAtCenter)
                            
                                    # Provide visual feedback
                                    main_window.status_bar.showMessage(f"Found annotation in '{annotation_scene}'", 3000)
                            
                                    # Optional: Flash the item for better visibility
                                    # self._flash_list_item(list_widget, item)
                                    theme_view_found = True
                                    break
    
            # If not found using direct method, try text search as fallback
            if not theme_view_found and annotation and annotation.get('text') and hasattr(main_window, 'handle_theme_search'):
                clean_text = annotation.get('text').strip()
                main_window.handle_theme_search(clean_text)
                main_window.status_bar.showMessage("Searched for annotation text in Theme View", 3000)
                return False
            else:
                return theme_view_found
    
        except Exception as e:
            print(f"Error selecting annotation in theme view: {e}")
            import traceback
            traceback.print_exc()
            return False

    # # Helper method to flash an item for better visibility
    # def _flash_list_item(self, list_widget, item):
    #     """Create a simple highlight that doesn't affect child elements"""
    #     try:
    #         # Create a separate highlight widget that will overlay the item in the list view
    #         highlight = QWidget(list_widget.viewport())
        
    #         # Get the visual rectangle of the item in viewport coordinates
    #         rect = list_widget.visualItemRect(item)
        
    #         # Set the geometry of our highlight to match the item
    #         highlight.setGeometry(rect)
        
    #         # Make highlight semi-transparent and ensure it doesn't interact with mouse events
    #         highlight.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
    #         highlight.setWindowFlags(Qt.WindowType.FramelessWindowHint)
        
    #         # Style it with just a background - no effect on children since this is a separate widget
    #         highlight.setStyleSheet("""
    #             background-color: rgba(66, 133, 244, 0.25);
    #             border: 1px solid rgba(66, 133, 244, 0.5);
    #             border-radius: 3px;
    #         """)
        
    #         # Show the highlight
    #         highlight.show()
        
    #         # Schedule it to be removed after a single flash
    #         QTimer.singleShot(400, highlight.deleteLater)
        
    #     except Exception as e:
    #         print(f"Error creating highlight: {e}")
    #         import traceback
    #         traceback.print_exc()


    def make_header(self, label, annotation_id):
        """Create or edit a header with simplified handling of strikethrough."""
        # Guard against multiple calls
        if hasattr(self, '_header_in_progress') and self._header_in_progress:
            print("[DEBUG] Header editing already in progress, ignoring duplicate call")
            return

        # Set flag at beginning to track progress
        self._header_in_progress = True
    
        # Capture initial scroll position before any changes
        self._original_scroll_position = self.verticalScrollBar().value()
        print(f"[DEBUG] Saved initial scroll position in make_header: {self._original_scroll_position}")

        current_text = label.text()
        existing_header = None
        remaining_text = current_text

        # Find the annotation to access strikethrough data
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if not annotation:
            self._header_in_progress = False  # Clear flag if we exit early
            return
    
        # Track any existing strikethrough segments
        strikethrough_segments = {}
        if 'storyboard' in annotation and 'strikethrough_segments' in annotation['storyboard']:
            strikethrough_segments = annotation['storyboard']['strikethrough_segments'].copy()

        # Remove existing strikethrough tags for clean text processing
        clean_text = re.sub(r'<s style=(?:\"|\')color:#FF9999;(?:\"|\')\>|</s>', '', current_text)
    
        def extract_header(html_text):
            # Try different header patterns in order of specificity
            patterns = [
                # Pattern 1: <div><b style='...'> format
                r'<div><b[^>]*style=[\'"](.*?)[\'"]>(.*?)</b></div>',
                # Pattern 2: Simple <div><b> format
                r'<div><b>(.*?)</b></div>',
                # Pattern 3: Just <b> tags anywhere
                r'<b[^>]*>(.*?)</b>'
            ]

            for pattern in patterns:
                match = re.search(pattern, html_text, re.DOTALL)
                if match:
                    if 'style=' in pattern:
                        # For styled headers
                        style = match.group(1)
                        header_text = match.group(2)
                        return f"<div><b style='{style}'>{header_text}</b></div>", header_text
                    else:
                        # Simple header
                        header_text = match.group(1)
                        return f"<div><b>{header_text}</b></div>", header_text
            return None, None

        # Extract existing header
        html_header, header_text = extract_header(clean_text)
    
        if html_header and header_text:
            existing_header = html_header
        
            # Get text without the header - more robust approach using regex
            match = re.search(f'^{re.escape(html_header)}\\s*', clean_text, re.DOTALL)
            if match:
                # Get everything after the header
                remaining_text = clean_text[match.end():].strip()
            else:
                # Fallback to original text if header pattern not found
                remaining_text = clean_text
            print(f"[DEBUG] Found existing header: '{html_header}'")
            print(f"[DEBUG] Remaining text length (after header removal): {len(remaining_text)}")
        else:
            # No header found
            remaining_text = clean_text
            print(f"[DEBUG] No existing header found")

        # Create and show header dialog
        header_dialog = StoryboardHeaderDialog(existing_header, self)

        # Add remove button to the dialog if we're editing an existing header
        if hasattr(header_dialog, 'add_remove_button') and existing_header:
            header_dialog.add_remove_button()
            print(f"[DEBUG] Added remove button to header dialog")

        if header_dialog.exec() == QDialog.DialogCode.Accepted:
            try:
                # CRITICAL: Check for header removal before anything else
                should_remove = False
                if hasattr(header_dialog, 'should_remove_header'):
                    should_remove = header_dialog.should_remove_header()
                    print(f"[DEBUG] Header remove flag: {should_remove}")
            
                # Check if header should be removed
                if should_remove:
                    # CRITICAL FIX: Make sure we FULLY remove any header content from the text
                    # Don't rely on remaining_text - strip the header explicitly
                    updated_text = re.sub(r'^<div><b[^>]*>.*?</b></div>\s*', '', clean_text, flags=re.DOTALL)
                    print(f"[DEBUG] REMOVING HEADER. Fully stripped header tags. Remaining text length: {len(updated_text)}")
                else:
                    # Get new header HTML
                    header_html = header_dialog.get_header_html()
                    print(f"[DEBUG] New header HTML: {header_html[:30] if header_html else 'None'}")
                
                    if header_html:
                        # CRITICAL FIX: Make sure there are no headers in the remaining text
                        # This prevents duplicate headers by removing any existing header at the start
                        clean_remaining = re.sub(r'^<div><b[^>]*>.*?</b></div>\s*', '', remaining_text, flags=re.DOTALL)
                    
                        # Add new header with proper spacing
                        updated_text = f"{header_html}{clean_remaining}"
                        print(f"[DEBUG] Adding header. Updated text length: {len(updated_text)}")
                    else:
                        # No header provided - use remaining text
                        updated_text = remaining_text
                        print(f"[DEBUG] No header provided. Using remaining text (length: {len(remaining_text)})")

                # Update the storyboard state
                if annotation:
                    if 'storyboard' not in annotation:
                        annotation['storyboard'] = {}

                    # Store the clean text without any strikethrough tags
                    annotation['storyboard']['text'] = updated_text.replace('\n', '<br>')
                    print(f"[DEBUG] Updated annotation storyboard text. Length: {len(updated_text)}")

                    # VERIFICATION: Double-check the storyboard text directly if removing header
                    if should_remove:
                        # Force an extra check to ensure header is gone
                        current_text = annotation['storyboard']['text']
                        if current_text.startswith('<div><b'):
                            print(f"[DEBUG] HEADER STILL PRESENT! Forcing removal.")
                            annotation['storyboard']['text'] = re.sub(r'^<div><b[^>]*>.*?</b></div>\s*', '', current_text, flags=re.DOTALL)
                            print(f"[DEBUG] After forced header removal. Final text length: {len(annotation['storyboard']['text'])}")

                    # Preserve existing strikethrough segments
                    if strikethrough_segments:
                        annotation['storyboard']['strikethrough_segments'] = strikethrough_segments

                    # Find the widget for this annotation and update it directly
                    widget = None
                    for i in range(self.count()):
                        item = self.item(i)
                        if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                            widget = self.itemWidget(item)
                            break
                    
                    if widget:
                        # Update widget directly instead of rebuilding
                        if self._update_widget_header_directly(widget, annotation, updated_text):
                            # Force an immediate layout update to ensure proper sizing
                            QCoreApplication.processEvents()
                        else:
                            print(f"[DEBUG] Failed to update widget directly, falling back to refresh")
                            # Fallback to refresh if direct update fails
                            self.refresh_item_display_and_renumber(annotation_id)
                    else:
                        print(f"[DEBUG] Could not find widget for annotation {annotation_id}")
                
                    # Mark changes as pending on the main window
                    window = self.window()
                    if isinstance(window, StoryboardDialog):
                        window.changes_pending = True
                        self.mark_storyboard_widget_changes_pending()
                        
                        # Apply changes and clear flag
                        window.apply_changes_lite()
                        
                        # CRITICAL: Improve strikethrough display for the header item
                        if hasattr(self, 'improve_strikethrough_display'):
                            print(f"[DEBUG] Improving strikethrough display for header item {annotation_id}")
                            self.improve_strikethrough_display(annotation_id)
                            
                            # NOW resize after strikethrough has been properly applied
                            item = None
                            for i in range(self.count()):
                                if self.item(i).data(Qt.ItemDataRole.UserRole) == annotation_id:
                                    item = self.item(i)
                                    widget = self.itemWidget(item)
                                    break
                            if item and widget:
                                print(f"[DEBUG] Resizing text after strikethrough improvement for {annotation_id}")
                                self._apply_text_sizing_optimized(widget, item, annotation_id)
                        
                        self._header_in_progress = False
                        print("[DEBUG] Header update completed successfully")

            except Exception as e:
                print(f"[ERROR] Exception in make_header: {e}")
                import traceback
                traceback.print_exc()

                # Ensure flag cleared on error
                self._header_in_progress = False
            
            # Add a guaranteed cleanup that runs regardless of other errors
            QTimer.singleShot(3000, lambda: setattr(self, '_header_in_progress', False))
        else:
            # Dialog was cancelled - clear flag
            self._header_in_progress = False

    def _update_widget_header_directly(self, widget, annotation, updated_text):
        """Directly update the widget's text without rebuilding the entire widget."""
        if not widget or not annotation:
            return False
            
        # Find the main content label
        text_label = widget.findChild(QLabel, "main_content_label")
        if not text_label:
            print("[DEBUG] Could not find main_content_label in widget")
            return False
            
        # Update the label text directly
        text_label.setText(updated_text)
        
        # Update the annotation data
        if 'storyboard' not in annotation:
            annotation['storyboard'] = {}
        annotation['storyboard']['text'] = updated_text.replace('\n', '<br>')
        
        # CRITICAL: Recalculate and apply proper sizing for the new content using standard method
        # Find the item for this widget
        item = None
        for i in range(self.count()):
            if self.itemWidget(self.item(i)) == widget:
                item = self.item(i)
                break
        
        if item:
            anno_id = item.data(Qt.ItemDataRole.UserRole)
            if anno_id:
                self._apply_text_sizing_optimized(widget, item, anno_id)
        
        print(f"[DEBUG] Directly updated widget text and size for {annotation.get('id')}")
        return True
    
    def _recalculate_widget_size_for_header_change(self, widget, text_label, updated_text):
        """Recalculate widget size when header content changes significantly."""
        if not widget or not text_label:
            return
            
        # Get the available width for text
        new_width = self.get_available_text_width()
        
        # Check if we have a header format FIRST
        has_header = ('<div><b' in updated_text)
        
        # Prepare text for measurement - handle HTML content properly (preserve strikethrough)
        plain_text = updated_text
        if "<" in plain_text and ">" in plain_text:
            # Convert <br> to \n for proper height calculation
            temp_text = plain_text.replace('<br>', '\n')
            if has_header:
                # Convert <div> tags to line breaks for measurement since they create visual separation
                temp_text = re.sub(r'</div>', '\n', temp_text)
            # Remove most HTML but preserve strikethrough structure for measurement (same as _apply_text_sizing_optimized)
            temp_text = re.sub(r'<(?!s\s|/s)[^>]+>', '', temp_text)
            plain_text = temp_text
        
        # Calculate required height based on content with more generous sizing
        font_metrics = text_label.fontMetrics()
        text_rect = font_metrics.boundingRect(
            QRect(0, 0, new_width, 4000),  # Increased max height for calculation
            Qt.TextFlag.TextWordWrap | Qt.TextFlag.TextExpandTabs,
            plain_text
        )
        
        # Calculate more generous height for headers (headers need extra space)
        base_height = text_rect.height()
        line_spacing = font_metrics.lineSpacing()
        
        # Count actual lines in the content for better sizing
        line_count = len(plain_text.split('\n'))
        if line_count < 2:
            line_count = 2  # Minimum 2 lines
        
        # Count strikethrough segments for additional padding
        strikethrough_count = updated_text.count('<s style="color:#FF9999;">') if '<s style="color:#FF9999;">' in updated_text else 0
        extra_strikethrough_padding = max(0, (strikethrough_count - 1) * 8)  # Extra padding for multiple segments
        
        print(f"[DEBUG] Found {strikethrough_count} strikethrough segments, adding {extra_strikethrough_padding}px extra padding")
        
        # Standard height calculation (same as create_item_widget)
        calculated_height = max(
            base_height + font_metrics.descent() + 12 + extra_strikethrough_padding,  # Base calculation with standard padding
            line_count * line_spacing + 12 + extra_strikethrough_padding,  # Line-based calculation with standard padding
            int(line_spacing * 2.2 + font_metrics.descent())  # Standard minimum
        )
        
        # Add extra height for custom painted widgets (star button, checkbox)
        calculated_height += 8
        
        print(f"[DEBUG] Header sizing: plain_text_lines={line_count}, base_height={base_height}, calculated_height={calculated_height}")
        
        # CRITICAL: Remove any height restrictions and set proper sizing
        text_label.setMaximumHeight(16777215)  # Remove height restrictions
        text_label.setFixedWidth(new_width)
        text_label.setMinimumHeight(calculated_height)
        
        # Set size policy to allow expansion
        text_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Expanding)
        
        # Force widget layout recalculation
        widget.setMaximumHeight(16777215)  # Remove widget height restrictions too
        widget.adjustSize()
        widget.updateGeometry()
        
        # CRITICAL: Find and update the list item's size hint properly
        list_item = None
        for i in range(self.count()):
            item = self.item(i)
            if item and self.itemWidget(item) == widget:
                list_item = item
                break
        
        if list_item:
            # Get the widget's preferred size after adjustment
            widget_size = widget.sizeHint()
            # Ensure the widget size is at least as tall as our calculation
            final_height = max(widget_size.height(), calculated_height + 10)  # Extra buffer
            final_size = QSize(widget_size.width(), final_height)
            
            # Update the item size hint
            list_item.setSizeHint(final_size)
            print(f"[DEBUG] Updated item size hint: {final_size.width()}x{final_size.height()}")
        
        print(f"[DEBUG] Recalculated widget size: height={calculated_height}, width={new_width}, final_widget_height={widget.sizeHint().height()}")

    def fix_position_mapping(self, label, annotation_id):
        """
        Create an accurate mapping between HTML positions and plain text positions
        that correctly handles existing strikethrough tags.
        """
        import re
        html_text = label.text()
    
        # First, create a special representation where we preserve tag boundaries
        # with special marker characters for precise position mapping
        marker_start = '§'  # Marker for start of tag
        marker_end = '¶'    # Marker for end of tag
    
        # Replace all HTML tags with markers
        marked_text = re.sub(r'<([^>]*)>', lambda m: f"{marker_start}{m.group(1)}{marker_end}", html_text)
    
        # Now build the mapping with awareness of the markers
        html_to_plain_map = []
        plain_to_html_map = []
        html_pos = 0
        plain_pos = 0
        skip_mode = False
    
        for i, char in enumerate(marked_text):
            if char == marker_start:
                skip_mode = True
                # Map the corresponding HTML position (this is a < character)
                # but don't advance plain_pos as we're skipping tags
                continue
            elif char == marker_end:
                skip_mode = False
                # Map the corresponding HTML position (this is a > character)
                # but don't advance plain_pos as we're skipping tags
                continue
            elif skip_mode:
                # Inside a tag, continue skipping
                continue
            else:
                # Regular character, map positions
                original_html_pos = html_text.find(char, html_pos)
                if original_html_pos >= html_pos:  # Make sure we're moving forward
                    html_pos = original_html_pos
                    html_to_plain_map.append((html_pos, plain_pos))
                    plain_to_html_map.append((plain_pos, html_pos))
                    plain_pos += 1
                    html_pos += 1
    
        # Now handle the selection range
        selection_start = label.selectionStart()
        selection_length = len(label.selectedText())
        selection_end = selection_start + selection_length
    
        # Convert HTML positions to plain text positions
        plain_selection_start = None
        plain_selection_end = None
    
        # Find the nearest mapping points
        for html_pos, plain_pos in sorted(html_to_plain_map):
            if html_pos >= selection_start and plain_selection_start is None:
                plain_selection_start = plain_pos
            if html_pos >= selection_end and plain_selection_end is None:
                plain_selection_end = plain_pos
                break
    
        # Fallback if exact positions weren't found
        if plain_selection_start is None:
            plain_selection_start = 0
        if plain_selection_end is None:
            plain_selection_end = plain_pos  # Use the last position
    
        # Get plain text for debugging
        plain_html = re.sub(r'<[^>]+>', '', html_text)
    
        print(f"IMPROVED POSITION MAPPING:")
        print(f"Original selection in HTML: {selection_start}-{selection_end}")
        print(f"Mapped to plain text: {plain_selection_start}-{plain_selection_end}")
        print(f"Selected text: '{plain_html[plain_selection_start:plain_selection_end]}'")
    
        # Check for actual overlaps with existing strikethroughs
        did_overlap = self.check_for_real_overlaps(plain_html, plain_selection_start, 
                                                  plain_selection_end, annotation_id)
    
        return not did_overlap  # Return True if no overlaps (can proceed with strikethrough)

    def check_for_real_overlaps(self, plain_text, new_start, new_end, annotation_id):
        """
        Check if the selection actually overlaps with existing strikethroughs
        by examining the actual text content rather than relying solely on positions.
        """
        import re
    
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if not annotation or 'storyboard' not in annotation:
            return False
    
        storyboard = annotation['storyboard']
        strikethrough_segments = storyboard.get('strikethrough_segments', {})
        positional_strikethrough = storyboard.get('positional_strikethrough', {})
    
        # Get the selected text
        selected_text = plain_text[new_start:new_end]
    
        # For visual debugging
        context_size = 30
        selection_context_start = max(0, new_start - context_size)
        selection_context_end = min(len(plain_text), new_end + context_size)
        context_before = plain_text[selection_context_start:new_start]
        context_after = plain_text[new_end:selection_context_end]
    
        print("\nIMPROVED OVERLAP DETECTION:")
        print(f"Selection: '{selected_text}'")
        print(f"Context: ...{context_before}[{selected_text}]{context_after}...")
    
        # Check each existing strikethrough
        for segment_key, is_struck in strikethrough_segments.items():
            if not is_struck:
                continue
            
            segment_data = positional_strikethrough.get(segment_key, {})
            if not segment_data:
                continue
            
            positions = segment_data.get('positions', [])
            for start_pos, end_pos in positions:
                existing_text = plain_text[start_pos:end_pos]
            
                # Visual representation for existing strikethrough
                st_context_start = max(0, start_pos - context_size)
                st_context_end = min(len(plain_text), end_pos + context_size)
                st_context_before = plain_text[st_context_start:start_pos]
                st_context_after = plain_text[end_pos:st_context_end]
            
                print(f"\nExisting strikethrough: '{existing_text}'")
                print(f"Context: ...{st_context_before}[{existing_text}]{st_context_after}...")
            
                # Check for text-based overlaps rather than just position-based
                # This is a much more reliable approach
            
                # Case 1: Selection contains existing strikethrough
                if new_start <= start_pos and new_end >= end_pos:
                    # The selection wholly contains an existing strikethrough
                    contains = existing_text in selected_text
                    exact_match = selected_text.find(existing_text)
                    print(f"Selection contains existing strikethrough? {contains}")
                    print(f"Exact match at position {exact_match} within selection")
                
                    # Only consider it an overlap if the text actually appears in the selection
                    if contains and exact_match >= 0:
                        print(f"REAL OVERLAP DETECTED: Selection contains existing strikethrough")
                        QMessageBox.warning(self, "Strikethrough Error", 
                                          "This selection contains an existing strikethrough.\n"
                                          "Please select text that doesn't overlap with existing strikethroughs.")
                        return True
            
                # Case 2: Existing strikethrough contains selection
                elif start_pos <= new_start and end_pos >= new_end:
                    # The existing strikethrough wholly contains the selection
                    contains = selected_text in existing_text
                    exact_match = existing_text.find(selected_text)
                    print(f"Existing strikethrough contains selection? {contains}")
                    print(f"Exact match at position {exact_match} within existing strikethrough")
                
                    # Only consider it an overlap if the text actually appears in the existing strikethrough
                    if contains and exact_match >= 0:
                        print(f"REAL OVERLAP DETECTED: Existing strikethrough contains selection")
                        QMessageBox.warning(self, "Strikethrough Error", 
                                          "This selection is contained within an existing strikethrough.\n"
                                          "Please select text that doesn't overlap with existing strikethroughs.")
                        return True
            
                # Case 3: Potential partial overlap
                else:
                    # Instead of relying on positions, check if there's actual text overlap
                    # This is more reliable for detecting real overlaps
                
                    # Get the potential overlap region in the plain text
                    overlap_start = max(new_start, start_pos)
                    overlap_end = min(new_end, end_pos)
                
                    if overlap_start < overlap_end:
                        overlap_text = plain_text[overlap_start:overlap_end]
                        print(f"Potential overlap text: '{overlap_text}'")
                    
                        # Only consider it an overlap if there's actual text in the overlap region
                        if overlap_text.strip():
                            print(f"REAL OVERLAP DETECTED: Text overlap '{overlap_text}'")
                            QMessageBox.warning(self, "Strikethrough Error", 
                                              f"This selection partially overlaps with an existing strikethrough.\n"
                                              f"Overlap text: '{overlap_text}'\n"
                                              f"Please select text that doesn't overlap with existing strikethroughs.")
                            return True
                        else:
                            print("No meaningful text overlap detected")
    
        print("No real overlaps detected with existing strikethroughs")
        return False

    def update_html_mapping_state(self, annotation, html_text):
        """
        Update the HTML mapping state with an improved algorithm that correctly
        handles HTML tags like strikethroughs.
        """
        import re
        marker_start = '§'  # Marker for start of tag
        marker_end = '¶'    # Marker for end of tag
    
        # Replace all HTML tags with markers
        marked_text = re.sub(r'<([^>]*)>', lambda m: f"{marker_start}{m.group(1)}{marker_end}", html_text)
    
        # Now build the mapping with awareness of the markers
        mapping = []
        html_pos = 0
        plain_pos = 0
        skip_mode = False
    
        for i, char in enumerate(marked_text):
            if char == marker_start:
                skip_mode = True
                continue
            elif char == marker_end:
                skip_mode = False
                continue
            elif skip_mode:
                continue
            else:
                original_html_pos = html_text.find(char, html_pos)
                if original_html_pos >= html_pos:
                    html_pos = original_html_pos
                    mapping.append((html_pos, plain_pos))
                    plain_pos += 1
                    html_pos += 1
    
        # Store the mapping
        annotation['storyboard']['html_mapping_state'] = {
            'html_length': len(html_text),
            'plain_length': plain_pos,
            'mapping': mapping
        }
    
        print(f"Updated HTML mapping state (stored {len(mapping)} mapping points)")


    def add_strikethrough(self, label, annotation_id):
        """Add strikethrough ONLY to the specific instance of text that was selected."""
        import re
        import json
        print("\n==== ADD STRIKETHROUGH START ====")

        # Debug log for initial state
        print("\nSTRIKETHROUGH SEGMENTS INVENTORY [INITIAL]:")
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if annotation and 'storyboard' in annotation and 'strikethrough_segments' in annotation['storyboard']:
            print(f"{json.dumps(annotation['storyboard']['strikethrough_segments'], indent=2)}")

            # Clean up any malformed strikethrough segments that contain HTML
            strikethrough_segments = annotation['storyboard']['strikethrough_segments']
            cleaned_segments = {}
            for segment, value in strikethrough_segments.items():
                clean_segment = re.sub(r'<[^>]+>|</[^>]+>', '', segment)
                if clean_segment != segment:
                    print(f"FIXING CORRUPTED SEGMENT: '{segment}' -> '{clean_segment}'")
                cleaned_segments[clean_segment] = value

            annotation['storyboard']['strikethrough_segments'] = cleaned_segments
            #print("\nCLEANED STRIKETHROUGH SEGMENTS INVENTORY:")
            #print(f"{json.dumps(cleaned_segments, indent=2)}")
        else:
            print("None or empty")

        # Get current text with any HTML
        html_text = label.text()
        if not label.hasSelectedText():
            QMessageBox.information(self, "No Selection", "No text selected. Please select text to add strikethrough.")
            return

        selected_text = label.selectedText()
        print(f"Selected Text: '{selected_text}'")

        # Check if selection spans break tags by examining the annotation's storyboard text
        # Do this check FIRST before any text processing
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if annotation:
            # Get the source text - prefer storyboard text if available
            source_text = annotation.get('text', '')
            if 'storyboard' in annotation and 'text' in annotation['storyboard']:
                source_text = annotation['storyboard']['text']
            
            print(f"[DEBUG] Checking break tags in annotation {annotation_id}")
            print(f"[DEBUG] Source text length: {len(source_text)}")
            print(f"[DEBUG] Has break tags: {'<br' in source_text.lower()}")
            print(f"[DEBUG] Selected text length: {len(selected_text)}")
            
            # If source has break tags, check if selection might span them
            if '<br' in source_text.lower():
                # Clean selected text for comparison
                clean_selected = re.sub(r'<[^>]+>', '', selected_text).strip()
                # Clean source text for comparison (convert breaks to spaces like QLabel does)
                clean_source = source_text.replace('<br>', ' ').replace('<BR>', ' ').replace('<br/>', ' ').replace('<BR/>', ' ')
                clean_source = re.sub(r'<[^>]+>', '', clean_source).strip()
                
                print(f"[DEBUG] Clean selected: '{clean_selected[:100]}...'")
                print(f"[DEBUG] Clean source: '{clean_source[:100]}...'")
                
                # Find where selection appears in clean source
                if clean_selected in clean_source:
                    start_pos = clean_source.find(clean_selected)
                    end_pos = start_pos + len(clean_selected)
                    
                    print(f"[DEBUG] Selection found at position {start_pos}-{end_pos}")
                    
                    # Now map back to original source to see if we span break tags
                    # Simple approach: count characters while tracking break tag positions
                    char_count = 0
                    break_positions = []
                    i = 0
                    while i < len(source_text):
                        if source_text[i:i+4].lower() == '<br>' or source_text[i:i+5].lower() == '<br/>':
                            # Found a break tag, record its position in the character count
                            break_positions.append(char_count)
                            # Skip the tag
                            if source_text[i:i+5].lower() == '<br/>':
                                i += 5
                            else:
                                tag_end = source_text.find('>', i)
                                i = tag_end + 1 if tag_end != -1 else i + 4
                        elif source_text[i] == '<':
                            # Skip other HTML tags
                            tag_end = source_text.find('>', i)
                            i = tag_end + 1 if tag_end != -1 else i + 1
                        else:
                            # Regular character
                            char_count += 1
                            i += 1
                    
                    print(f"[DEBUG] Break positions in clean text: {break_positions}")
                    
                    # Check if any break positions fall within our selection range
                    for break_pos in break_positions:
                        if start_pos < break_pos < end_pos:
                            QMessageBox.warning(self, "Strikethrough Error", 
                                "The selected text spans across line breaks that cannot be included in strikethrough formatting.\n\n"
                                "Please select text segments before and after the line breaks separately.")
                            print(f"[DEBUG] Selection spans break tag at position {break_pos}")
                            self._header_in_progress = False
                            return
                    
                    print(f"[DEBUG] Selection does not span break tags")
                else:
                    print(f"[DEBUG] Could not find selection in source text")
            else:
                print(f"[DEBUG] No break tags in source text")

        # THIS IS THE GLASGOW BLOCK PART 1
        # if "<s style=\"color:#FF9999;\">" in selected_text or "<s style='color:#FF9999;'>" in selected_text or "</s>" in selected_text:
        #     QMessageBox.warning(self, "Strikethrough Error", "The selected text already contains strikethrough formatting.\nPlease select text without existing strikethrough.")
        #     print(f"Strikethrough tags found in selection: '{selected_text}'")
        #     return

        # Clean the selected text
        clean_selected = re.sub(r'<s style=\"color:#FF9999;\">|<s style="color:#FF9999;">|</s>', '', selected_text)
        
        # Check if selection contains <br> tags and needs to be split
            # Remove any remaining HTML tags from each segment and filter out empty ones
            
            # Process each segment as a separate strikethrough
                
                
                # Add each text segment as a separate strikethrough
                        # Generate unique key for this segment
                        
                
                # Update the display
        
        plain_selected = re.sub(r'<[^>]+>', '', clean_selected)
        print(f"Cleaned Selected Text: '{plain_selected}'")

        # Get plain text for processing from annotation (for finding instances)
        plain_html = re.sub(r'<[^>]+>', '', html_text)
        
        
        # If exact match fails, check storyboard text for <br> tags in selection
                
                # Normalize the storyboard text (replace <br> with space for comparison)
                
                    
                    # Find where selection maps to in original storyboard text with <br> tags
                    
                    # Count words to map back to original text with <br> tags
                    
                    # Get original storyboard words preserving <br> tags
                    
                    # Extract selection from original preserving <br>
                    
                    
                        
                            
                            
        
        # If exact match fails, try finding the text by normalizing whitespace and detecting line breaks
            
            # Normalize whitespace in both texts 
            
            
            # Try to find where the selected text might start in the full text
                
                # We found the start, now create segments based on where line breaks would be
                
                # Use the original HTML with LINEBREAK_MARKER to find split points
                
                # Find where our selection appears in the marked text
                    
                    # Simple approach: use the selection length to extract from marked text
                    # Add some buffer to ensure we capture the full selection
                    
                    # Find all LINEBREAK_MARKER positions within this range
                    
                    
                    # Look for LINEBREAK_MARKER within the selection
                        
                        # Split at each marker position
                        
                            # Extract segment before this marker
                                # Map back to the original selection to get the actual text
                                # Find this segment in the original normalized selection
                                # Remove strict matching - just add all meaningful segments
                            
                            # Move past the marker
                        
                        # Add the final segment after the last marker
                        
                        
                            
                            # Create separate strikethrough segments
                                
                                
                                    # Generate unique key for this segment
                                    
                                
                                # Update the display
            
                
                # Find where this text appears when split by the original line breaks
                # Convert <br> back to markers to find split points
                
                # Find the selection in the marked text
                    # Try to reconstruct what the original segments would be
                        # Split the full text on LINEBREAK_MARKER and find which segments contain our words
                        
                        # Find segments that contain parts of our selection
                                    # Find what portion of the selection is in this part
                                    
                                    
                        
                            
                            # Create separate strikethrough segments
                                
                                
                                    # Generate unique key for this segment
                                    
                                
                                # Update the display
    
        # Get full document text for proper context calculation
        # This JavaScript gets the full document text content
        get_document_js = """
        document.body.textContent || document.body.innerText || '';
        """
        
        def process_instances_with_full_context(full_document_text):
            # --------- TEXT-BASED APPROACH: Use the actual text as source of truth ----------
            
            # Find all instances of the selected text in the annotation text first
            instances = []
            start_pos = 0
            
            while True:
                pos = plain_html.find(plain_selected, start_pos)
                if pos == -1:
                    break
                
                # Now find the same text in the full document to get proper context
                # We'll search for the text with some surrounding context to find the right instance
                annotation_context_before = plain_html[max(0, pos-50):pos]
                annotation_context_after = plain_html[pos+len(plain_selected):min(len(plain_html), pos+len(plain_selected)+50)]
                
                # Search in full document using the annotation context as a guide
                search_pattern = annotation_context_before[-20:] + plain_selected if len(annotation_context_before) >= 20 else plain_selected
                full_doc_pos = full_document_text.find(search_pattern)
                
                if full_doc_pos != -1:
                    # Adjust position to account for the context we added to the search
                    if len(annotation_context_before) >= 20:
                        full_doc_pos += 20  # Offset by the context we prepended
                    
                    # Calculate context from full document
                    context_before = full_document_text[max(0, full_doc_pos-15):full_doc_pos]
                    context_after = full_document_text[full_doc_pos+len(plain_selected):min(len(full_document_text), full_doc_pos+len(plain_selected)+15)]
                    
                    print(f"Found instance in full document at position {full_doc_pos}")
                    print(f"Context before: '{context_before}'")
                    print(f"Context after: '{context_after}'")
                else:
                    # Fallback to annotation context if we can't find it in full document
                    print(f"WARNING: Could not find text in full document, using annotation context")
                    context_before = plain_html[max(0, pos-15):pos]
                    context_after = plain_html[pos+len(plain_selected):min(len(plain_html), pos+len(plain_selected)+15)]
                
                instance = {
                    "start": pos,  # Keep annotation-relative position for other logic
                    "end": pos + len(plain_selected),
                    "text": plain_selected,
                    "context_before": context_before,
                    "context_after": context_after
                }
                instances.append(instance)
                start_pos = pos + 1
            
            return instances
        
        # Get full document text asynchronously then process
        def handle_full_document_text(full_document_text):
            instances = process_instances_with_full_context(full_document_text or '')
            self.continue_strikethrough_processing(instances, plain_selected, plain_html, annotation, html_text, label, annotation_id)
        
        # Execute JavaScript to get full document text
        if self.main_window and hasattr(self.main_window, 'web_view'):
            self.main_window.web_view.page().runJavaScript(get_document_js, handle_full_document_text)
        else:
            # Fallback: process without full document context
            instances = process_instances_with_full_context('')
            self.continue_strikethrough_processing(instances, plain_selected, plain_html, annotation, html_text, label, annotation_id)
        return  # Exit here, processing continues in the callback
        
    def continue_strikethrough_processing(self, instances, plain_selected, plain_html, annotation, html_text, label, annotation_id):
    
        print(f"Found {len(instances)} instances of '{plain_selected}'")
        for i, instance in enumerate(instances):
            print(f"  Instance #{i+1}:")
            print(f"    Position: {instance['start']}-{instance['end']}")
            print(f"    Before: '{instance['context_before']}'")
            print(f"    Text: '{instance['text']}'")
            print(f"    After: '{instance['context_after']}'")
    
        # If no instances found, check if it's because selection spans break tags
        if not instances:
            print(f"ERROR: Could not find '{plain_selected}' in plain text")
            
            # FALLBACK: Check if selection spans break tags in the data model
            annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
            if annotation:
                source_text = annotation.get('text', '')
                if 'storyboard' in annotation and 'text' in annotation['storyboard']:
                    source_text = annotation['storyboard']['text']
                
                print(f"[FALLBACK DEBUG] Checking if selection spans break tags")
                print(f"[FALLBACK DEBUG] Source has break tags: {'<br' in source_text.lower()}")
                
                # If source has break tags, this might be why we can't find the text
                if '<br' in source_text.lower():
                    QMessageBox.warning(self, "Strikethrough Error", 
                        "The selected text spans across line breaks that cannot be included in strikethrough formatting.\n\n"
                        "Please select text segments before and after the line breaks separately.")
                    print(f"[FALLBACK DEBUG] Blocking strikethrough - selection likely spans break tags")
                    return
            
            # If not a break tag issue, show the original error
            QMessageBox.warning(self, "Text Not Found", 
                               "Could not find the selected text in the document.\n"
                               "This might be due to special formatting or hidden characters.")
            return

        # Determine if we need to show the multi-instance selection dialog
        multi_instance = len(instances) > 1
    
        # If it's a single instance, check for overlaps with existing strikethroughs
        # For multi-instance cases, we'll let the user choose and bypass overlap check
        if not multi_instance and annotation and 'storyboard' in annotation:
            storyboard = annotation['storyboard']
            strikethrough_segments = storyboard.get('strikethrough_segments', {})
            positional_strikethrough = storyboard.get('positional_strikethrough', {})
        
            # For single instances, check for overlap
            instance = instances[0]
            instance_start = instance['start']
            instance_end = instance['end']
            has_overlap = False
        
            print(f"\nChecking single instance at {instance_start}-{instance_end} for overlaps")
            # Check against each existing strikethrough
            for segment_key, is_struck in strikethrough_segments.items():
                if not is_struck:
                    continue
                
                segment_data = positional_strikethrough.get(segment_key, {})
                if not segment_data:
                    continue
                
                positions = segment_data.get('positions', [])
                for start_pos, end_pos in positions:
                    # Get the existing strikethrough text
                    existing_text = plain_html[start_pos:end_pos]
                
                    print(f"  Comparing with existing strikethrough: '{existing_text}' at {start_pos}-{end_pos}")
                
                    # Check for any overlap
                    if (instance_start <= start_pos < instance_end or 
                        instance_start < end_pos <= instance_end or
                        start_pos <= instance_start < end_pos or
                        start_pos < instance_end <= end_pos):
                    
                        # Check if there's actual text overlap
                        overlap_start = max(instance_start, start_pos)
                        overlap_end = min(instance_end, end_pos)
                    
                        if overlap_start < overlap_end:
                            overlap_text = plain_html[overlap_start:overlap_end]
                            print(f"  Overlap detected: '{overlap_text}' at {overlap_start}-{overlap_end}")
                            has_overlap = True
                            break
                    else:
                        print(f"  No position overlap")
            
                if has_overlap:
                    break
        
            # THE GLASGOW BLOCK (P2)
            if has_overlap:
                QMessageBox.warning(self, "Strikethrough Error", 
                                   "The selected text overlaps with an existing strikethrough. Please adjust your selection.")
                print(f"ERROR: Single instance of '{plain_selected}' overlaps with existing strikethroughs")
                return
    
        # After validating, find the most likely instance
        likely_instance = None
        if instances:
            cursor_pos = label.selectionStart()
            # Use HTML position to estimate which instance is most likely
            html_plain_ratio = len(plain_html) / len(html_text)
            estimated_plain_pos = int(cursor_pos * html_plain_ratio)
        
            best_distance = float('inf')
            for instance in instances:
                distance = abs((instance['start'] + instance['end']) / 2 - estimated_plain_pos)
                if distance < best_distance:
                    best_distance = distance
                    likely_instance = instance
        
            print(f"\nMost likely instance: Position {likely_instance['start']}-{likely_instance['end']}")
            print(f"  Before: '{likely_instance['context_before']}'")
            print(f"  Text: '{likely_instance['text']}'")
            print(f"  After: '{likely_instance['context_after']}'")

        # Define local function for unique key generation
        def get_next_segment_key(segments, base_word):
            """Generate the next available numbered key for a base word."""
            max_num = 0
            for key in segments.keys():
                m = re.match(rf"^{re.escape(base_word)}_(\d+)$", key)
                if m:
                    num = int(m.group(1))
                    if num > max_num:
                        max_num = num
            return f"{base_word}_{max_num + 1}"

        # Retrieve existing strikethrough data
        if not annotation:
            return

        storyboard = annotation.setdefault('storyboard', {})
        strikethrough_segments = storyboard.setdefault('strikethrough_segments', {})
        positional_strikethrough = storyboard.setdefault('positional_strikethrough', {})

        # Unique-key generation:
        if multi_instance:
            unique_key = get_next_segment_key(strikethrough_segments, plain_selected)
            print(f"Generated unique key for multiple instances: '{unique_key}'")
        else:
            if plain_selected not in strikethrough_segments:
                unique_key = plain_selected
                print(f"Generated unique key for single instance (no numbering): '{unique_key}'")
            else:
                unique_key = get_next_segment_key(strikethrough_segments, plain_selected)
                print(f"Generated unique key for single instance (numbered due to conflict): '{unique_key}'")

        plain_selected = re.sub(r'<[^>]+>', '', plain_selected)
        strikethrough_segments[unique_key] = True

        print("\nSTRIKETHROUGH SEGMENTS INVENTORY [AFTER MARKING SEGMENT]:")
        print(f"{json.dumps(strikethrough_segments, indent=2)}")

        if multi_instance:
            print("Showing multi-instance selection dialog (BYPASSING OVERLAP CHECK)")
            dialog = InstanceSelectionDialog(instances, self)
            if likely_instance:
                dialog.pre_select_instance(likely_instance)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                selected_instance = dialog.get_selected_instance()
                if selected_instance:
                    print(f"User selected instance #{instances.index(selected_instance)+1}")
                    # For multi-instance, we don't do additional overlap checks
                    positional_strikethrough[unique_key] = {
                        "positions": [(selected_instance['start'], selected_instance['end'])],
                        "original_length": len(plain_selected),
                        "context_before": selected_instance['context_before'],
                        "context_after": selected_instance['context_after'],
                        "is_context_specific": True,
                        "base_word": plain_selected
                    }
                    print(f"Added context-specific positional data for: '{unique_key}'")
                else:
                    print("Selected instance is None! This should not happen.")
                    strikethrough_segments.pop(unique_key, None)
                    return
            else:
                print("User canceled instance selection")
                strikethrough_segments.pop(unique_key, None)
                return
        elif instances:
            selected_instance = instances[0]
            print("Using the only instance found (already checked for overlaps)")
            positional_strikethrough[unique_key] = {
                "positions": [(selected_instance['start'], selected_instance['end'])],
                "original_length": len(plain_selected),
                "context_before": selected_instance['context_before'],
                "context_after": selected_instance['context_after'],
                "is_context_specific": False,
                "base_word": plain_selected
            }
        else:
            print("ERROR: No instances found")
            strikethrough_segments.pop(unique_key, None)
            return

        print("\nSTRIKETHROUGH SEGMENTS INVENTORY [AFTER SETTING POSITIONS]:")
        print(f"{json.dumps(strikethrough_segments, indent=2)}")

        clean_text = re.sub(r'<s style=\"color:#FF9999;\">|<s style="color:#FF9999;">|</s>', '', html_text)
        header_pattern = r'(<div><b[^>]*>.*?</b></div>)'
        header_match = re.search(header_pattern, clean_text)
        header_html = header_match.group(1) if header_match else None
        if header_html:
            remaining_content = re.sub(f'^{re.escape(header_html)}\\s*', '', clean_text)
            content_to_process = remaining_content
        else:
            content_to_process = clean_text

        plain_content = re.sub(r'<[^>]+>', '', content_to_process)
        print(f"Plain content for processing: '{plain_content[:100]}...'") 

        print("\nSTRIKETHROUGH SEGMENTS INVENTORY [BEFORE APPLYING STRIKETHROUGHS]:")
        print(f"{json.dumps(strikethrough_segments, indent=2)}")

        result = content_to_process

        for segment_key, is_struck in strikethrough_segments.items():
            if not is_struck:
                continue
            match = re.match(r'^(.+)_\d+$', segment_key)
            actual_segment = match.group(1) if match else segment_key
            segment_data = positional_strikethrough.get(segment_key, {})
            if segment_data and segment_data.get('is_context_specific', False):
                context_before = segment_data.get('context_before', '')
                context_after = segment_data.get('context_after', '')
                print(f"Looking for context-specific segment '{actual_segment}' (key: {segment_key})")
                print(f"  Context before: '{context_before}'")
                print(f"  Context after: '{context_after}'")
                for match in re.finditer(re.escape(actual_segment), plain_content):
                    start_pos = match.start()
                    prefix_len = min(len(context_before), start_pos)
                    prefix = plain_content[start_pos - prefix_len:start_pos]
                    suffix_len = min(len(context_after), len(plain_content) - start_pos - len(actual_segment))
                    suffix = plain_content[start_pos + len(actual_segment):start_pos + len(actual_segment) + suffix_len]
                    if context_before.endswith(prefix) and context_after.startswith(suffix):
                        html_pos = -1
                        html_end_pos = -1
                        plain_idx = 0
                        for i, char in enumerate(result):
                            if char == '<':
                                tag_end = result.find('>', i)
                                if tag_end != -1:
                                    i = tag_end
                                    continue
                            else:
                                if plain_idx == start_pos:
                                    html_pos = i
                                if plain_idx == start_pos + len(actual_segment) - 1:
                                    html_end_pos = i + 1
                                    break
                                plain_idx += 1
                        if html_pos != -1 and html_end_pos != -1:
                            result = result[:html_pos] + '<s style=\"color:#FF9999;\">' + result[html_pos:html_end_pos] + '</s>' + result[html_end_pos:]
                            print(f"  Applied strikethrough to position {html_pos}-{html_end_pos} in HTML for context-specific segment '{segment_key}'")
                            break
            elif not segment_key.endswith('_1') and not '_' in segment_key:
                if actual_segment in result:
                    new_result = result.replace(actual_segment, f"<s style=\"color:#FF9999;\">{actual_segment}</s>")
                    if new_result != result:
                        print(f"  Applied traditional strikethrough to segment '{actual_segment}' (key: {segment_key})")
                        result = new_result

        # Apply all changes to the text
        if header_html:
            result = f"{header_html}{result}"

        label.setText(result)
        print(f"Updated label text with strikethrough")

        # Complete all processing first
        dialog = self.window()
        if isinstance(dialog, StoryboardDialog):
            dialog.changes_pending = True
            self.mark_storyboard_widget_changes_pending()
            #self.refresh_item_display_and_renumber(annotation_id, with_visual_updates = True)
            # Apply strikethrough display FIRST so the HTML tags are actually there
            self.improve_strikethrough_display(annotation_id, skip_partial_fallback = True)
            
            # THEN do sizing after strikethrough tags are actually applied
            
            # Apply strikethrough display FIRST so the HTML tags are actually there
            
            # THEN do sizing after strikethrough tags are actually applied
            
                # Always use targeted sizing after strikethrough tags are applied
            self._update_all_items_on_resize()

        # Print final state before scheduling changes
        print("\nSTRIKETHROUGH SEGMENTS INVENTORY [FINAL STATE]:")
        print(f"{json.dumps(strikethrough_segments, indent=2)}")
        print("==== ADD STRIKETHROUGH END ====\n")

        # Schedule apply_changes_lite as the very last step with increased delay
        if isinstance(dialog, StoryboardDialog):
            QTimer.singleShot(300, dialog.apply_changes_lite)

    def remove_strikethrough(self, label, annotation_id):
        """
        Remove strikethrough from selected text with a simple, robust approach.
        """
        import re

        print("\n==== REMOVE STRIKETHROUGH START ====")

        # Get current text with HTML tags
        html_text = label.text()

        if not label.hasSelectedText():
            QMessageBox.warning(self, "No Text Selected", "Please select text to remove strikethrough.")
            return

        selected_text = label.selectedText().strip()
        print(f"[DEBUG] Selected text for removing strikethrough: {selected_text}")

        # Get plain versions of text (convert <br> to \n, then remove other HTML tags)
        plain_full_text = html_text.replace('<br>', '\n').replace('<BR>', '\n')
        plain_full_text = re.sub(r'<[^>]+>', '', plain_full_text)
        
        plain_selected_original = selected_text.replace('<br>', '\n').replace('<BR>', '\n')
        plain_selected_original = re.sub(r'<[^>]+>', '', plain_selected_original)
        
        # Keep the original for strikethrough removal, but use partial for location finding
        plain_selected_for_location = plain_selected_original
        
        # If no match, check storyboard text like add_strikethrough does
        if plain_selected_original not in plain_full_text:
            print(f"[DEBUG] Exact match failed. Checking storyboard text...")
            annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
            if annotation and 'storyboard' in annotation and 'text' in annotation['storyboard']:
                storyboard_text = annotation['storyboard']['text']
                
                # Convert storyboard text for comparison (same as add_strikethrough)
                storyboard_for_comparison = re.sub(r'<(?!br>)[^>]+>', '', storyboard_text).replace('<br>', ' ')
                storyboard_normalized = ' '.join(storyboard_for_comparison.split())
                selected_normalized = ' '.join(plain_selected_original.split())
                
                if selected_normalized in storyboard_normalized:
                    print(f"[DEBUG] Found selection in storyboard text!")
                    # Use the original text for both location and strikethrough removal
                    plain_selected_for_location = plain_selected_original
                    # Update the plain_full_text to use storyboard text for consistency
                    plain_full_text = storyboard_normalized
                else:
                    print(f"[DEBUG] Selection not found in storyboard either. Trying fallback...")
                    # Fallback to partial match
                    plain_selected_trimmed = plain_selected_original.strip()
                    if len(plain_selected_trimmed) > 20:
                        test_substring = plain_selected_trimmed[:50]
                        if test_substring in plain_full_text:
                            plain_selected_for_location = test_substring
                            print(f"[DEBUG] Using partial match for location: '{test_substring[:30]}...'")
                        else:
                            print(f"[DEBUG] No match found even with partial search")
            else:
                print(f"[DEBUG] No storyboard text available")
        
        # Use the partial match for location but keep original for strikethrough logic
        plain_selected = plain_selected_for_location

        if not plain_selected:
            QMessageBox.warning(self, "Empty Selection", "The selected text appears to be empty after removing HTML tags.")
            return

        print(f"[DEBUG] Plain selected text: '{plain_selected}'")
        print(f"[DEBUG] Plain full text (first 200 chars): '{plain_full_text[:200]}...'")
        print(f"[DEBUG] Selected text raw: '{selected_text}'")
        print(f"[DEBUG] HTML text (first 200 chars): '{html_text[:200]}...'")
    
        # Locate the selected text in the plain full text
        cursor_pos = label.selectionStart()  # Get the cursor position in the HTML
    
        # Find all instances of the selected text (use the location-finding text)
        instances = []
        pos = 0
        while True:
            pos = plain_full_text.find(plain_selected_for_location, pos)
            if pos == -1:
                break
        
            # Get context around this instance
            context_before = plain_full_text[max(0, pos-15):pos]
            context_after = plain_full_text[pos+len(plain_selected):min(len(plain_full_text), pos+len(plain_selected)+15)]
        
            instances.append({
                "start": pos,
                "end": pos + len(plain_selected),
                "text": plain_selected,
                "context_before": context_before,
                "context_after": context_after
            })
            pos += 1
    
        # If no instances found, show an error
        if not instances:
            QMessageBox.warning(self, "Text Not Found", 
                              "Could not locate the selected text in the document. This might be due to special formatting.")
            return
    
        print(f"[DEBUG] Found {len(instances)} instances of '{plain_selected}'")
    
        # Find the most likely instance based on cursor position
        # Use HTML position to estimate which instance is most likely
        html_plain_ratio = len(plain_full_text) / max(1, len(html_text))
        estimated_plain_pos = int(cursor_pos * html_plain_ratio)
    
        selected_instance = None
        best_distance = float('inf')
    
        for instance in instances:
            # Find the midpoint of this instance
            instance_mid = (instance["start"] + instance["end"]) / 2
            distance = abs(instance_mid - estimated_plain_pos)
        
            if distance < best_distance:
                best_distance = distance
                selected_instance = instance
    
        if not selected_instance:
            selected_instance = instances[0]  # Fallback to first instance
    
        print(f"[DEBUG] Selected instance: {selected_instance['start']}-{selected_instance['end']}")
        print(f"[DEBUG] Context before: '{selected_instance['context_before']}'")
        print(f"[DEBUG] Context after: '{selected_instance['context_after']}'")

        # Get the annotation
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if not annotation:
            print(f"[DEBUG] Annotation with ID {annotation_id} not found.")
            return

        # Get the storyboard data
        storyboard = annotation.setdefault('storyboard', {})
        strikethrough_segments = storyboard.get('strikethrough_segments', {})
        positional_strikethrough = storyboard.get('positional_strikethrough', {})

        print(f"[DEBUG] Current strikethrough segments: {strikethrough_segments}")
        print(f"[DEBUG] Current positional_strikethrough: {positional_strikethrough}")
    
        # Identify segments that overlap with our selected instance
        segments_to_remove = []
    
        for segment_key in list(strikethrough_segments.keys()):
            if not strikethrough_segments[segment_key]:
                continue
            
            # Get the base word (from positional data or segment key)
            base_word = segment_key
            if segment_key in positional_strikethrough and 'base_word' in positional_strikethrough[segment_key]:
                base_word = positional_strikethrough[segment_key]['base_word']
            else:
                # Extract base word if this is a numbered key
                match = re.match(r'^(.+)_\d+$', segment_key)
                if match:
                    base_word = match.group(1)
        
            # Check if this is a context-specific segment
            is_context_specific = False
            segment_positions = []
        
            if segment_key in positional_strikethrough:
                segment_data = positional_strikethrough[segment_key]
                is_context_specific = segment_data.get('is_context_specific', False)
            
                # Get positions if available
                if 'positions' in segment_data:
                    segment_positions = segment_data['positions']
            
                # If context-specific, check if context matches our selected instance
                if is_context_specific:
                    context_before = segment_data.get('context_before', '')
                    context_after = segment_data.get('context_after', '')
                
                    # Check if contexts match
                    sel_context_before = selected_instance['context_before']
                    sel_context_after = selected_instance['context_after']
                
                    # Try different context lengths
                    context_match = False
                
                    # Try with 10-char context
                    req_prefix_10 = context_before[-10:] if len(context_before) >= 10 else context_before
                    req_suffix_10 = context_after[:10] if len(context_after) >= 10 else context_after
                    sel_prefix_10 = sel_context_before[-10:] if len(sel_context_before) >= 10 else sel_context_before
                    sel_suffix_10 = sel_context_after[:10] if len(sel_context_after) >= 10 else sel_context_after
                
                    if (req_prefix_10 in sel_prefix_10 or sel_prefix_10 in req_prefix_10) and \
                       (req_suffix_10 in sel_suffix_10 or sel_suffix_10 in req_suffix_10):
                        context_match = True
                
                    # If contexts match and the base word overlaps with our selection
                    if context_match and base_word in plain_selected or plain_selected in base_word:
                        segments_to_remove.append((segment_key, base_word))
                        continue
        
            # If not context-specific or no positional data, check for text overlap
            # Check if the segment directly overlaps with our selected instance
            if segment_positions:
                for start_pos, end_pos in segment_positions:
                    # Check if any part of the segment overlaps with our selected instance
                    if max(start_pos, selected_instance['start']) < min(end_pos, selected_instance['end']):
                        segments_to_remove.append((segment_key, base_word))
                        break
            else:
                # No positional data - fall back to text-based matching
                # Check if the segment text overlaps with our selected text
                if base_word in plain_selected or plain_selected in base_word:
                    # Use regex with word boundaries to check for exact word match
                    if re.search(r'\b' + re.escape(base_word) + r'\b', plain_selected) or \
                       re.search(r'\b' + re.escape(plain_selected) + r'\b', base_word):
                        segments_to_remove.append((segment_key, base_word))
    
        # If we have segments with the exact same text as our selection,
        # only remove those (ignore partial matches)
        exact_matches = [(k, w) for k, w in segments_to_remove if w == plain_selected]
        if exact_matches:
            segments_to_remove = exact_matches
    
        # If no segments to remove, check if the selection contains any strikethrough tags
        if not segments_to_remove:
            contains_strike_tags = "<s style=\"color:#FF9999;\">" in selected_text or "</s>" in selected_text
        
            if contains_strike_tags:
                # Extract segments that are struck through in the selection
                struck_segments = re.findall(r'<s style=\"color:#FF9999;\">(.*?)</s>', selected_text)
            
                for struck_seg in struck_segments:
                    plain_struck = re.sub(r'<[^>]+>', '', struck_seg)
                    if plain_struck.strip():
                        for segment_key in list(strikethrough_segments.keys()):
                            if not strikethrough_segments[segment_key]:
                                continue
                            
                            base_word = segment_key
                            if segment_key in positional_strikethrough and 'base_word' in positional_strikethrough[segment_key]:
                                base_word = positional_strikethrough[segment_key]['base_word']
                            else:
                                match = re.match(r'^(.+)_\d+$', segment_key)
                                if match:
                                    base_word = match.group(1)
                        
                            # Use word boundary to ensure exact word match
                            if re.search(r'\b' + re.escape(base_word) + r'\b', plain_struck) or \
                               re.search(r'\b' + re.escape(plain_struck) + r'\b', base_word):
                                segments_to_remove.append((segment_key, base_word))
    
        # If no segments found to remove, show a message
        if not segments_to_remove:
            QMessageBox.information(self, "No Strikethrough Found", 
                                  "No strikethrough formatting was found in the selected text.")
            return
    
        print(f"[DEBUG] Segments to remove: {segments_to_remove}")
    
        # Remove the segments
        for segment_key, base_word in segments_to_remove:
            strikethrough_segments.pop(segment_key, None)
            if positional_strikethrough and segment_key in positional_strikethrough:
                positional_strikethrough.pop(segment_key, None)
    
        # Update the storyboard data
        storyboard['strikethrough_segments'] = strikethrough_segments
        storyboard['positional_strikethrough'] = positional_strikethrough
    
        # Clean up storyboard if no segments remain
        if not strikethrough_segments:
            storyboard.pop('strikethrough_segments', None)
            storyboard.pop('positional_strikethrough', None)
            # Remove storyboard if empty
            if not storyboard:
                annotation.pop('storyboard', None)
    
        # Let the improve_strikethrough_display function handle the re-application of strikethroughs
        label.setText(re.sub(r'<s style=\"color:#FF9999;\">|<s style="color:#FF9999;">|</s>', '', html_text))
        self.improve_strikethrough_display(annotation_id, skip_partial_fallback = True)
        self._update_all_items_on_resize()
        print(f"[DEBUG] Updated label text with remaining strikethroughs")

        # Mark changes as pending and apply
        dialog = self.window()
        if isinstance(dialog, StoryboardDialog):
            dialog.changes_pending = True
            self.mark_storyboard_widget_changes_pending()
            QTimer.singleShot(100, dialog.apply_changes_lite)

        print("==== REMOVE STRIKETHROUGH END ====\n")

    def refresh_item_display(self, annotation_id):
        """
        Refresh the display of an item with both standard and context-aware
        strikethrough application for 100% backward compatibility.
        """
        import re
        from bs4 import BeautifulSoup  # Ensure BeautifulSoup is installed
    
        def remove_nested_s_tags(html_text):
            """Remove nested <s> tags by unwrapping any <s> tag that is nested within another <s>."""
            soup = BeautifulSoup(html_text, 'html.parser')
            changed = True
            while changed:
                changed = False
                for s_tag in soup.find_all('s'):
                    if s_tag.find_parent('s'):
                        s_tag.unwrap()
                        changed = True
            return str(soup)
    
        def merge_adjacent_s_tags(html_text):
            """Merge adjacent <s> tags to create cleaner strikethrough text."""
            from bs4 import BeautifulSoup, NavigableString
        
            soup = BeautifulSoup(html_text, 'html.parser')
            changed = True
            merge_count = 0
        
            # Keep merging until no more changes are made
            while changed:
                changed = False
                s_tags = soup.find_all('s')
            
                for s_tag in s_tags:
                    # Check if this tag needs processing (hasn't been merged already)
                    if not s_tag.parent:
                        continue
                    
                    # Get the next element after this <s> tag
                    next_element = s_tag.next_sibling
                
                    # Skip whitespace-only text nodes
                    while isinstance(next_element, NavigableString) and next_element.strip() == '':
                        next_element = next_element.next_sibling
                        if not next_element:
                            break
                
                    # If the next element is another <s> tag, merge them
                    if next_element and next_element.name == 's':
                        # Get truncated text previews for logging
                        s_text = s_tag.get_text()
                        s_preview = s_text[:20] + ('...' if len(s_text) > 20 else '')
                        next_text = next_element.get_text()
                        next_preview = next_text[:20] + ('...' if len(next_text) > 20 else '')
                    
                        print(f"Merging adjacent strikethroughs: '{s_preview}' + '{next_preview}'")
                    
                        # Move the whitespace between tags into the s_tag
                        whitespace = s_tag.next_sibling
                        if isinstance(whitespace, NavigableString):
                            s_tag.append(whitespace.extract())
                    
                        # Move all children from the next <s> tag to this one
                        for child in list(next_element.children):
                            s_tag.append(child.extract())
                    
                        # Remove the now-empty next_element
                        next_element.extract()
                        merge_count += 1
                        changed = True
                        break
        
            if merge_count > 0:
                print(f"LOG: Merged {merge_count} adjacent strikethrough segments")
            return str(soup)
    
        print(f"\n=== REFRESH ITEM DISPLAY START: {annotation_id} ===")

        for i in range(self.count()):
            item = self.item(i)
            if item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
                if annotation:
                    # Get basic text content
                    display_text = annotation.get('text', '')
                    notes = annotation.get('notes', '')

                    print(f"Original text: '{display_text}'")

                    # Get text from storyboard if available
                    if 'storyboard' in annotation:
                        storyboard = annotation['storyboard']
                        if 'text' in storyboard and storyboard['text']:
                            display_text = storyboard['text']
                            print(f"Using storyboard text: '{display_text}'")

                        # Process strikethrough segments
                        strikethrough_segments = storyboard.get('strikethrough_segments', {})
                        # Get positional data if available
                        positional_data = storyboard.get('positional_strikethrough', {})

                        #print(f"LOG: Initial strikethrough_segments: {strikethrough_segments}")
                        #print(f"LOG: Initial positional_data: {positional_data}")

                        # CRITICAL FIX: Remove any empty string segments
                        if '' in strikethrough_segments:
                            print(f"WARNING: Removing invalid empty strikethrough segment")
                            strikethrough_segments.pop('', None)
                            storyboard['strikethrough_segments'] = strikethrough_segments

                        # IMPROVED CLEANING: Remove existing strikethrough tags to avoid nesting
                        clean_text = re.sub(r'<s style=\"color:#FF9999;\">|<s style="color:#FF9999;">|</s>', '', display_text)
                        #print(f"LOG: Clean text after removing strikethrough tags: '{clean_text[:100]}...'")

                        # CRITICAL FIX: Clean segments containing HTML tags
                        cleaned_segments = {}
                        for segment_key, is_struck in list(strikethrough_segments.items()):
                            if '<s style=' in segment_key or '</s>' in segment_key:
                                clean_segment = re.sub(r'<s style=\"color:#FF9999;\">|<s style="color:#FF9999;">|</s>', '', segment_key)
                                strikethrough_segments.pop(segment_key, None)
                                if clean_segment.strip():
                                    cleaned_segments[clean_segment] = is_struck
                                    print(f"Cleaned segment from '{segment_key}' to '{clean_segment}'")
                                    if segment_key in positional_data:
                                        positional_data[clean_segment] = positional_data[segment_key]
                                        positional_data.pop(segment_key, None)
                            # Handle numbered keys by cleaning the base word
                            match = re.match(r'^(.+)_\d+$', segment_key)
                            if match:
                                base_word = match.group(1)
                                if '<' in base_word or '>' in base_word:
                                    clean_base = re.sub(r'<[^>]+>', '', base_word)
                                    if clean_base != base_word:
                                        clean_key = f"{clean_base}_{segment_key.split('_')[-1]}"
                                        cleaned_segments[clean_key] = is_struck
                                        strikethrough_segments.pop(segment_key, None)
                                        print(f"Cleaned numbered segment from '{segment_key}' to '{clean_key}'")
                                        if segment_key in positional_data:
                                            data = positional_data[segment_key].copy()
                                            if 'base_word' in data:
                                                data['base_word'] = clean_base
                                            positional_data[clean_key] = data
                                            positional_data.pop(segment_key, None)
                                        continue
                            cleaned_segments[segment_key] = is_struck

                        # Update annotation with cleaned segments
                        strikethrough_segments = cleaned_segments
                        storyboard['strikethrough_segments'] = strikethrough_segments
                        if positional_data:
                            storyboard['positional_strikethrough'] = positional_data

                        # Extract header if present (to avoid striking through header)
                        header_pattern = r'^(<div><b[^>]*>.*?</b></div>)'
                        header_match = re.search(header_pattern, clean_text, re.DOTALL)
                        header_html = header_match.group(1) if header_match else None
                        #print(f"LOG: Header found: {header_html is not None}")

                        if header_html:
                            remaining_content = re.sub(f'^{re.escape(header_html)}\\s*', '', clean_text)
                            text_to_process = remaining_content
                        else:
                            text_to_process = clean_text

                        #print(f"LOG: Text to process (first 100 chars): '{text_to_process[:100]}...'")

                        processed_text = text_to_process
                        context_processed_segments = set()

                        # Process context-specific segments
                        if positional_data:
                            print("Processing context-aware strikethrough segments")
                            for segment_key, data in positional_data.items():
                                if segment_key not in strikethrough_segments or not strikethrough_segments[segment_key]:
                                    #print(f"LOG: Skipping segment not marked for strikethrough: '{segment_key}'")
                                    continue
                                base_word = data.get('base_word', segment_key)
                                if not base_word or base_word == segment_key:
                                    match = re.match(r'^(.+)_\d+$', segment_key)
                                    base_word = match.group(1) if match else segment_key

                                #print(f"LOG: Evaluating positional segment: '{segment_key}' (base word: '{base_word}')")
                                has_context = 'context_before' in data or 'context_after' in data
                                is_context_specific = data.get('is_context_specific', False)
                                #print(f"LOG: Segment '{segment_key}' has_context={has_context}, is_context_specific={is_context_specific}")

                                if has_context and is_context_specific:
                                    print(f"Processing context-specific segment: '{segment_key}'")
                                    context_before = data.get('context_before', '')
                                    context_after = data.get('context_after', '')
                                    #print(f"LOG: Context before: '{context_before}', Context after: '{context_after}'")
                                    match_found = False
                                    pos = 0
                                    occurrence_counter = 0
                                    while pos < len(processed_text):
                                        idx = processed_text.find(base_word, pos)
                                        if idx == -1:
                                            break
                                        occurrence_counter += 1
                                        #print(f"LOG: Found occurrence #{occurrence_counter} of '{base_word}' at position {idx}")
                                        context_match_before = True
                                        if context_before:
                                            prefix_len = min(len(context_before), idx)
                                            actual_prefix = processed_text[idx-prefix_len:idx]
                                            context_match_before = context_before.endswith(actual_prefix)
                                            #print(f"LOG: Context before match: {context_match_before}")
                                            #print(f"LOG: Expected prefix: '{context_before}', Actual prefix: '{actual_prefix}'")
                                        context_match_after = True
                                        if context_after:
                                            end_idx = idx + len(base_word)
                                            suffix_len = min(len(context_after), len(processed_text) - end_idx)
                                            actual_suffix = processed_text[end_idx:end_idx + suffix_len]
                                            context_match_after = context_after.startswith(actual_suffix)
                                            #print(f"LOG: Context after match: {context_match_after}")
                                            #print(f"LOG: Expected suffix: '{context_after}', Actual suffix: '{actual_suffix}'")
                                        if context_match_before and context_match_after:
                                            print(f"  Found context match at position {idx}")
                                            processed_text = (
                                                processed_text[:idx] +
                                                "<s style=\"color:#FF9999;\">" + base_word + "</s>" +
                                                processed_text[idx + len(base_word):]
                                            )
                                            match_found = True
                                            context_processed_segments.add(segment_key)
                                            #print(f"LOG: Applied strikethrough to '{base_word}' with context match")
                                            pos = idx + len(base_word) + 32  # Length of opening+closing tags
                                            break
                                        pos = idx + 1
                                    if not match_found:
                                        print(f"  WARNING: No context match found for '{base_word}' (key: {segment_key})")

                        #print(f"LOG: After context processing, context_processed_segments: {context_processed_segments}")

                        # Now apply traditional strikethrough for segments not processed with context
                        for segment_key, is_struck in strikethrough_segments.items():
                            if not is_struck or segment_key in context_processed_segments:
                                continue
                            if segment_key in positional_data:
                                base_word = positional_data[segment_key].get('base_word', segment_key)
                            else:
                                match = re.match(r'^(.+)_\d+$', segment_key)
                                base_word = match.group(1) if match else segment_key
                            #print(f"LOG: Processing non-context segment: '{segment_key}' (base word: '{base_word}')")
                            if '<' in base_word or '>' in base_word:
                                clean_segment = re.sub(r'<[^>]+>', '', base_word)
                                if clean_segment != base_word:
                                    print(f"WARNING: Skipping segment with HTML tags: '{base_word}'")
                                    continue
                            occurrences = []
                            start_idx = 0
                            while True:
                                found_idx = processed_text.find(base_word, start_idx)
                                if found_idx == -1:
                                    break
                                occurrences.append((found_idx, found_idx + len(base_word)))
                                start_idx = found_idx + 1
                            #print(f"LOG: Found {len(occurrences)} occurrences of '{base_word}' in text")
                            before_replacement = processed_text
                            processed_text = processed_text.replace(base_word, f"<s style=\"color:#FF9999;\">{base_word}</s>")
                            if processed_text != before_replacement:
                                print(f"LOG: Successfully applied strikethrough to '{base_word}' using replacement")
                            else:
                                print(f"LOG: No changes after replacement for '{base_word}'")

                        # Rebuild full text by combining header (if present) with processed content
                        if header_html:
                            display_text = f"{header_html}\n{processed_text}"
                        else:
                            display_text = processed_text

                        #print(f"LOG: Text with strikethroughs before cleanup: '{display_text[:100]}...'")

                        # FINAL CLEANUP: Remove any nested/redundant <s> tags and merge adjacent ones
                        #print("LOG: Removing nested strikethrough tags")
                        display_text = remove_nested_s_tags(display_text)
                    
                        #print("LOG: Merging adjacent strikethrough tags")
                        display_text = merge_adjacent_s_tags(display_text)
                    
                        #print(f"LOG: Final display text after cleanup: '{display_text[:100]}...'")

                    # Create new widget with processed text
                    widget, label = self.create_item_widget(
                        display_text,
                        annotation_id,
                        i + 1,
                        notes
                    )

                    # Update item
                    item.setSizeHint(widget.sizeHint())
                    self.setItemWidget(item, widget)

                    # Force layout updates
                    widget.adjustSize()
                    self.viewport().update()
                    QTimer.singleShot(10, self.doItemsLayout)

                    print(f"=== REFRESH ITEM DISPLAY END: {annotation_id} ===\n")
                    break

    def refresh_item_display_and_renumber(self, annotation_id, with_visual_updates=True, scroll_value=None):
        """
        Refresh the display of a specific item and then renumber all items while preserving content.
        Defers to improve_strikethrough_display for strikethrough processing.
    
        Args:
            annotation_id: ID of the annotation to refresh
            with_visual_updates: Whether to apply visual updates during renumbering
            scroll_value: Optional saved scroll position to restore
        """
        import re
        from bs4 import BeautifulSoup  # Ensure BeautifulSoup is installed
    
        def remove_nested_s_tags(html_text):
            """Remove nested <s> tags by unwrapping any <s> tag that is nested within another <s>."""
            soup = BeautifulSoup(html_text, 'html.parser')
            changed = True
            while changed:
                changed = False
                for s_tag in soup.find_all('s'):
                    if s_tag.find_parent('s'):
                        s_tag.unwrap()
                        changed = True
            return str(soup)
    
        print(f"\n=== REFRESH AND RENUMBER START: {annotation_id} ===")
    
        # Skip detailed updates during population for renumbering phase
        skip_visual_updates_for_renumber = False
        if hasattr(self, '_in_population') and self._in_population and with_visual_updates:
            print(f"[DEBUG] Will use simplified renumbering during population")
            skip_visual_updates_for_renumber = True
    
        # Use passed-in scroll value if provided; otherwise, capture it
        if scroll_value is None:
            scroll_value = self.verticalScrollBar().value()
        print(f"[DEBUG] Saved scroll position: {scroll_value}")
    
        # PART 1: PERFORM BASIC REFRESH OF THE SPECIFIC ITEM
        item_refreshed = False
        for i in range(self.count()):
            item = self.item(i)
            if item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
                if annotation:
                    # Get basic text content
                    display_text = annotation.get('text', '')
                    notes = annotation.get('notes', '')

                    print(f"Original text: '{display_text}'")

                    # Get text from storyboard if available
                    if 'storyboard' in annotation:
                        storyboard = annotation['storyboard']
                        if 'text' in storyboard and storyboard['text']:
                            display_text = storyboard['text']
                            print(f"Using storyboard text: '{display_text}'")
                    
                        # Instead of processing strikethroughs here, just clean existing tags
                        # for initial display before improve_strikethrough_display is called
                        display_text = re.sub(r'<s style=\"color:#FF9999;\">|<s style="color:#FF9999;">|</s>', '', display_text)
                        print(f"Removed existing strikethrough tags for initial display")

                    # Create new widget with basic text (without strikethroughs)
                    old_widget = self.itemWidget(item)
                    is_checked = False
                    is_favorite = False
                    if old_widget:
                        checkbox = old_widget.findChild(CustomCheckBox)
                        is_checked = checkbox.isChecked() if checkbox else False
                        for child in old_widget.children():
                            if isinstance(child, QLabel) and child.objectName() == "favorite_label":
                                is_favorite = (child.text() == "★")
                                break
                
                    widget, label = self.create_item_widget(
                        display_text,
                        annotation_id,
                        i + 1,  # We'll fix the numbering in the renumber phase
                        notes
                    )
                
                    # Set checkbox and favorite status
                    new_checkbox = widget.findChild(CustomCheckBox)
                    if new_checkbox:
                        new_checkbox.setChecked(is_checked)
                
                    favorite_label = None
                    for child in widget.children():
                        if isinstance(child, QLabel) and child.objectName() == "favorite_label":
                            favorite_label = child
                            break
                    if favorite_label and is_favorite:
                        favorite_label.setText("★")
                        favorite_label.setStyleSheet("font-size: 16px; margin-bottom: 3px; color: gold;")

                    # Update item
                    item.setSizeHint(widget.sizeHint())
                    self.setItemWidget(item, widget)
                    item_refreshed = True
                    print(f"Basic item refresh completed for {annotation_id}")
                    break
    
        if not item_refreshed:
            print(f"WARNING: Item with annotation_id {annotation_id} not found in list")
    
        # PART 2: RENUMBER ALL ITEMS (from renumber_items)
        # Optionally disable updates during renumbering.
        if skip_visual_updates_for_renumber:
            with_visual_updates = False
    
        if not with_visual_updates:
            self.begin_batch_updates()
    
        try:
            number = 1
            updates = []
            for i in range(self.count()):
                item = self.item(i)
                widget = self.itemWidget(item)
                if widget and hasattr(widget, 'is_divider') and widget.is_divider:
                    continue
                anno_id = item.data(Qt.ItemDataRole.UserRole)
                annotation = self._get_annotation(anno_id)
                if annotation:
                    # Get basic text content and notes.
                    display_text = annotation.get('text', '')
                    notes = annotation.get('notes', '')
                    if not notes or annotation.get('storyboard', {}).get('notes') != "":
                        notes = annotation.get('storyboard', {}).get('notes', notes)
    
                    # Get text from storyboard if available.
                    if 'storyboard' in annotation:
                        storyboard = annotation['storyboard']
                        if 'text' in storyboard and storyboard['text']:
                            display_text = storyboard['text']
                
                    # For renumbering, get text as-is from the current widget
                    # This preserves any strikethroughs applied by improve_strikethrough_display
                    current_widget = self.itemWidget(item)
                    if current_widget:
                        for label in current_widget.findChildren(QLabel):
                            if label.objectName() == "main_content_label":
                                display_text = label.text()
                                break

                    # Get current state of widget
                    old_widget = self.itemWidget(item)
                    is_checked = False
                    is_favorite = False
                    if old_widget:
                        checkbox = old_widget.findChild(CustomCheckBox)
                        is_checked = checkbox.isChecked() if checkbox else False
                        for child in old_widget.children():
                            if isinstance(child, QLabel) and child.objectName() == "favorite_label":
                                is_favorite = (child.text() == "★")
                                break
                    updates.append((item, number, display_text, anno_id, notes, is_checked, is_favorite))
                    number += 1
                else:
                    print(f"[WARNING] Annotation with ID {anno_id} not found in annotations.")

            for item, number, text, anno_id, notes, is_checked, is_favorite in updates:
                widget, label = self.create_item_widget(text, anno_id, number, notes)
                new_checkbox = widget.findChild(CustomCheckBox)
                if new_checkbox:
                    new_checkbox.setChecked(is_checked)
                favorite_label = None
                for child in widget.children():
                    if isinstance(child, QLabel) and child.objectName() == "favorite_label":
                        favorite_label = child
                        break
                if favorite_label and is_favorite:
                    favorite_label.setText("★")
                    favorite_label.setStyleSheet("font-size: 16px; margin-bottom: 3px; color: gold;")
                item.setSizeHint(widget.sizeHint())
                self.setItemWidget(item, widget)

        finally:
            def restore_scroll():
                self.verticalScrollBar().setValue(scroll_value)
                print(f"[DEBUG] Restored scroll position to: {scroll_value}")
        
            # Force layout updates from initial item refresh
            QTimer.singleShot(10, self.doItemsLayout)
        
            if not with_visual_updates:
                self.end_batch_updates(150, restore_scroll)
            else:
                QTimer.singleShot(150, restore_scroll)
    
        # NOW call improve_strikethrough_display as the very last step after all renumbering is done
        print(f"Calling improve_strikethrough_display for {annotation_id} AFTER renumbering")
        self.improve_strikethrough_display(annotation_id, skip_partial_fallback=True)
    
        print(f"=== REFRESH AND RENUMBER END: {annotation_id} ===\n")

    def improve_strikethrough_display(self, annotation_id, skip_partial_fallback=False):
        """
        Enhanced version with robust context-based matching for numbered segments,
        using multiple context matching strategies. Includes an optional flag to skip
        partial matching fallback logic.

        Args:
            annotation_id: The ID of the annotation to process.
            skip_partial_fallback: If True, skip the partial matching logic. Defaults to False.
        """
        print("🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟 IMPROVE_STRIKETHROUGH_DISPLAY START 🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟")
        print(f"🌟 annotation_id: {annotation_id}, skip_partial_fallback: {skip_partial_fallback}")
        print("🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟")
        
        # ADD THIS LINE RIGHT AT THE START OF THE FUNCTION
        direct_match_found = False  # Track direct matches across nested loops

        print(f"\n=== IMPROVE STRIKETHROUGH DISPLAY START: {annotation_id} (Skip Partial: {skip_partial_fallback}) ===") # Modified print

        # Find the annotation.
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if not annotation:
            print(f"Annotation not found: {annotation_id}")
            return

        # Locate the corresponding item in the list.
        for i in range(self.count()):
            item = self.item(i)
            if item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                widget = self.itemWidget(item)
                if not widget:
                    continue
                text_label = None
                for label in widget.findChildren(QLabel):
                    if label.objectName() == "main_content_label":
                        text_label = label
                        break
                if not text_label:
                    continue

                current_text = text_label.text()
                print(f"Current text length: {len(current_text)}")

                # FIXED: More thorough cleaning to remove ALL existing strikethrough tags
                # Handle both quote styles and ensure complete removal
                clean_text = re.sub(r'<s style=(?:\"|\')color:#FF9999;(?:\"|\')\>|</s>', '', current_text)
                print(f"Clean text length: {len(clean_text)}")

                # Obtain plain text by stripping any HTML tags.
                plain_text = re.sub(r'<[^>]+>', '', clean_text)

                # Ensure the storyboard exists.
                storyboard = annotation.get('storyboard', {})
                if not storyboard:
                    storyboard = {}
                    annotation['storyboard'] = storyboard

                # Retrieve stored strikethrough data.
                strikethrough_segments = storyboard.get('strikethrough_segments', {})
                positional_strikethrough = storyboard.get('positional_strikethrough', {})
                
                # 🌟 TRACK POSITIONAL STRIKETHROUGH CONTEXT DATA 🌟
                if positional_strikethrough:
                    print("🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟 POSITIONAL STRIKETHROUGH CONTEXT TRACKING 🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟")
                    for segment_key, segment_data in positional_strikethrough.items():
                        context_before = segment_data.get('context_before', '')
                        context_after = segment_data.get('context_after', '')
                        if context_before or context_after:
                            print(f"🌟 SEGMENT '{segment_key}' HAS CONTEXT:")
                            print(f"🌟   CONTEXT_BEFORE: '{context_before}'")
                            print(f"🌟   CONTEXT_AFTER: '{context_after}'")
                        else:
                            print(f"🌟 SEGMENT '{segment_key}' HAS NO CONTEXT (empty context_before/context_after)")
                    print("🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟")
                else:
                    print("💀💀💀💀💀💀💀💀💀💀💀💀 NO POSITIONAL STRIKETHROUGH DATA FOUND 💀💀💀💀💀💀💀💀💀💀💀💀")
                    print(f"💀 annotation_id: {annotation_id}")
                    print("💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀")

                # CRITICAL FIX: Check for and remove the unnumbered "opportunity" key if numbered versions exist
                # This ensures we won't get duplicate strikethroughs
                base_words_with_numbers = {}
                for key in list(strikethrough_segments.keys()):
                    match = re.match(r'^(.+)_(\d+)$', key)
                    if match:
                        base_word = match.group(1)
                        if base_word in strikethrough_segments:
                            print(f"Removing generic key '{base_word}' that has numbered variants")
                            strikethrough_segments.pop(base_word, None)
                            if base_word in positional_strikethrough:
                                positional_strikethrough.pop(base_word, None)

                # Clean any segments that contain HTML strikethrough tags
                cleaned_segments = {}
                for segment_key, is_struck in list(strikethrough_segments.items()):
                    if '<s style=' in segment_key or '</s>' in segment_key:
                        # Clean segment of strikethrough tags
                        cleaned_segment = re.sub(r'<s style=(?:\"|\')color:#FF9999;(?:\"|\')\>|</s>', '', segment_key)
                        # Also remove any other HTML tags
                        cleaned_segment = re.sub(r'<[^>]+>', '', cleaned_segment)
                        if cleaned_segment.strip():
                            cleaned_segments[cleaned_segment] = is_struck
                            print(f"Cleaned segment from '{segment_key}' to '{cleaned_segment}'")

                            # Update positional data if needed
                            if segment_key in positional_strikethrough:
                                positional_strikethrough[cleaned_segment] = positional_strikethrough[segment_key]
                                positional_strikethrough.pop(segment_key, None)
                    else:
                        # Keep already clean segments
                        cleaned_segments[segment_key] = is_struck

                # Replace with cleaned segments
                strikethrough_segments = cleaned_segments

                # Update the annotation with cleaned data
                storyboard['strikethrough_segments'] = strikethrough_segments

                print(f"Retrieved strikethrough_segments: {strikethrough_segments}")
                print(f"Retrieved positional_strikethrough: {positional_strikethrough}")

                if not strikethrough_segments:
                    print("No strikethrough segments found")
                    continue

                # Define helper function for text similarity (no changes needed here)
                def _text_similarity(text1, text2):
                    if not text1 or not text2: return 0
                    chars1 = set(text1.lower())
                    chars2 = set(text2.lower())
                    intersection = len(chars1.intersection(chars2))
                    union = len(chars1.union(chars2))
                    return intersection / union if union > 0 else 0

                # Define helper function for context matching (no changes needed here)
                def find_with_context(base_word, text, context_data):
                    context_before = context_data.get("context_before", "")
                    context_after = context_data.get("context_after", "")
                    context_before = re.sub(r'<[^>]+>', '', context_before)
                    context_after = re.sub(r'<[^>]+>', '', context_after)
                    print(f"  Looking for segment '{base_word}' with cleaned contexts:")
                    print(f"    Context before: '{context_before}'")
                    print(f"    Context after: '{context_after}'")
                    req_prefix_10 = context_before[-10:] if len(context_before) >= 10 else context_before
                    req_suffix_10 = context_after[:10] if len(context_after) >= 10 else context_after
                    req_prefix_6 = context_before[-6:] if len(context_before) >= 6 else context_before
                    req_suffix_6 = context_after[:6] if len(context_after) >= 6 else context_after
                    print(f"  Looking for segment '{base_word}' with these context strategies:")
                    print(f"    Strategy 1: 10-char context before='{req_prefix_10}', after='{req_suffix_10}'")
                    print(f"    Strategy 2: 6-char context before='{req_prefix_6}', after='{req_suffix_6}'")
                    print(f"    Strategy 3: Only 10-char context before='{req_prefix_10}'")
                    print(f"    Strategy 4: Only 10-char context after='{req_suffix_10}'")

                    def find_with_specific_context(req_prefix, req_suffix):
                        pos = 0
                        while True:
                            pos = text.find(base_word, pos)
                            if pos == -1: break
                            has_full_prefix = pos >= len(req_prefix) if req_prefix else True
                            has_full_suffix = (pos + len(base_word) + len(req_suffix) <= len(text)) if req_suffix else True
                            if req_prefix and req_suffix and has_full_prefix and has_full_suffix:
                                actual_prefix = text[pos - len(req_prefix):pos]
                                actual_suffix = text[pos + len(base_word):pos + len(base_word) + len(req_suffix)]
                                if actual_prefix == req_prefix and actual_suffix == req_suffix: return pos, pos + len(base_word)
                                else: pos += 1; continue
                            prefix_ok = True
                            suffix_ok = True
                            if req_prefix:
                                if has_full_prefix: actual_prefix = text[pos - len(req_prefix):pos]; prefix_ok = (actual_prefix == req_prefix)
                                else: start_prefix = max(0, pos - len(req_prefix)); actual_prefix = text[start_prefix:pos]; prefix_ok = req_prefix.endswith(actual_prefix)
                            elif pos > 0 and text[pos-1] not in ".!?\n\r\t ": prefix_ok = False
                            if req_suffix:
                                if has_full_suffix: actual_suffix = text[pos + len(base_word):pos + len(base_word) + len(req_suffix)]; suffix_ok = (actual_suffix == req_suffix)
                                else: end_suffix = min(len(text), pos + len(base_word) + len(req_suffix)); actual_suffix = text[pos + len(base_word):end_suffix]; suffix_ok = req_suffix.startswith(actual_suffix)
                            elif pos + len(base_word) < len(text) and text[pos + len(base_word)] not in ".!?,;:\n\r\t ": suffix_ok = False
                            if prefix_ok and suffix_ok: return pos, pos + len(base_word)
                            pos += 1
                        return None

                    has_sufficient_10_prefix = len(context_before) >= 10
                    has_sufficient_10_suffix = len(context_after) >= 10
                    has_sufficient_6_prefix = len(context_before) >= 6
                    has_sufficient_6_suffix = len(context_after) >= 6

                    if has_sufficient_10_prefix and has_sufficient_10_suffix:
                        match = find_with_specific_context(req_prefix_10, req_suffix_10)
                        if match: return match; print(f"    Found match using Strategy 1 (10-char both contexts)");
                        else: return None; print(f"    Segment failed with 10-char context - strict rejection");
                    elif has_sufficient_6_prefix and has_sufficient_6_suffix:
                        match = find_with_specific_context(req_prefix_6, req_suffix_6)
                        if match: return match; print(f"    Found match using Strategy 2 (6-char both contexts)");
                        else: return None; print(f"    Segment failed with 6-char context - strict rejection");
                    if req_prefix_10:
                        match = find_with_specific_context(req_prefix_10, "")
                        if match: return match; print(f"    Found match using Strategy 3 (only 10-char context before)");
                    if req_suffix_10:
                        match = find_with_specific_context("", req_suffix_10)
                        if match: return match; print(f"    Found match using Strategy 4 (only 10-char context after)");
                    print(f"    No match found with any context strategy")
                    return None

                # NEW APPROACH: Track segments to keep and to remove
                segments_to_keep = {}
                segments_to_remove = set()
                positional_data_to_update = {}
                processed_positions = set()  # To avoid overlapping strikethroughs

                # Process ALL segments regardless of context specificity
                for segment_key, is_struck in list(strikethrough_segments.items()):
                    if not is_struck:
                        continue

                    # Get the base word (either from positional data or key name)
                    base_word = segment_key
                    if segment_key in positional_strikethrough:
                        data = positional_strikethrough.get(segment_key, {})
                        if 'base_word' in data:
                            base_word = data['base_word']

                    # Extract base word from numbered keys if not already set
                    if base_word == segment_key:
                        match = re.match(r'^(.+)_\d+$', segment_key)
                        if match:
                            base_word = match.group(1)

                    print(f"Processing segment: '{segment_key}' (base word: '{base_word}')")

                    # Check if this is a context-specific segment
                    is_context_specific = False
                    context_data = {}
                    if segment_key in positional_strikethrough:
                        data = positional_strikethrough[segment_key]
                        is_context_specific = data.get("is_context_specific", False)
                        if 'context_before' in data or 'context_after' in data:
                            context_data = data

                    # Try to find a match (either with context or exact)
                    found_match = False

                    # 1. Try context match first if available
                    if context_data and (context_data.get('context_before') or context_data.get('context_after')):
                        match = find_with_context(base_word, plain_text, context_data)
                        if match:
                            start, end = match
                            position_key = (start, end)

                            # Check if position already processed
                            if position_key in processed_positions:
                                print(f"  Skipping already processed position: {start}-{end}")
                                continue

                            matched_text = plain_text[start:end]
                            print(f"  Found context match: '{matched_text}' at positions {start}-{end}")

                            # Update position data for this match
                            positional_data_to_update[segment_key] = {
                                "start": start,
                                "end": end,
                                "matched_text": matched_text
                            }

                            # Add to segments to keep
                            segments_to_keep[segment_key] = matched_text
                            found_match = True
                            processed_positions.add(position_key)

                    # CRITICAL: If this is a context-specific segment and no match was found with context,
                    # do NOT proceed with other matching techniques - just mark for removal
                    if is_context_specific and not found_match:
                        print(f"  Context-specific segment with no context match. Marking for removal.")
                        segments_to_remove.add(segment_key)
                        continue

                    # Only proceed with non-context matching methods if this is NOT a context-specific segment
                    if not found_match and not is_context_specific:
                        # 2. If not context-specific, try exact match
                        pos = plain_text.find(base_word)
                        if pos != -1:
                            # Check if position already processed
                            position_key = (pos, pos + len(base_word))
                            if position_key in processed_positions:
                                print(f"  Skipping already processed position: {pos}-{pos + len(base_word)}")
                                # Try find next occurrence
                                next_pos = pos + 1
                                while True:
                                    next_pos = plain_text.find(base_word, next_pos)
                                    if next_pos == -1:
                                        break
                                    next_key = (next_pos, next_pos + len(base_word))
                                    if next_key not in processed_positions:
                                        position_key = next_key
                                        pos = next_pos
                                        found_match = True
                                        break
                                    next_pos += 1

                            if not found_match and position_key not in processed_positions:
                                # At least one exact match found
                                start = pos
                                end = pos + len(base_word)
                                matched_text = plain_text[start:end]
                                print(f"  Found exact match: '{matched_text}' at positions {start}-{end}")

                                # Update position data
                                positional_data_to_update[segment_key] = {
                                    "start": start,
                                    "end": end,
                                    "matched_text": matched_text
                                }

                                # Add to segments to keep
                                segments_to_keep[segment_key] = matched_text
                                found_match = True
                                processed_positions.add(position_key)
                                # CRITICAL: We found an exact match, so skip all other matching techniques
                                continue

                        # --- START OF PARTIAL MATCHING LOGIC ---
                        # Check the flag before attempting partial match
                        if not found_match and not skip_partial_fallback:
                            # 3. If still no match and not context-specific, try partial match
                            print(f"  Attempting partial match with context verification...")

                            # Define the minimum length for a meaningful match
                            min_length = max(5, int(len(base_word) * 0.01))  # At least 40% of original or 5 chars

                            # 🎯 TOP 3 LONGEST MATCHES: Find three longest substrings to handle rhetorical devices
                            print(f"  🎯 TOP 3 LONGEST MATCHES: Finding best 3 candidates for context verification (rhetorical device protection)")
                            
                            # Collect all potential matches first
                            all_candidates = []
                            
                            # Find substrings efficiently - avoid redundant overlapping candidates
                            # Track all positions found across ALL lengths to prevent overlap
                            all_found_ranges = []  # [(start_pos, end_pos, length)]
                            
                            for length in range(len(base_word), min_length - 1, -1):
                                for start in range(0, len(base_word) - length + 1):
                                    substring = base_word[start:start+length]
                                    
                                    if len(substring) < min_length:
                                        continue
                                    
                                    pos = plain_text.find(substring)
                                    if pos != -1:
                                        position_key = (pos, pos + len(substring))
                                        if position_key not in processed_positions:
                                            # Check if this range overlaps with any existing range
                                            current_range = (pos, pos + len(substring))
                                            overlaps_existing = any(
                                                not (current_range[1] <= existing[0] or current_range[0] >= existing[1])
                                                for existing in all_found_ranges
                                            )
                                            
                                            if not overlaps_existing:
                                                all_candidates.append({
                                                    'substring': substring,
                                                    'length': length,
                                                    'pos': pos,
                                                    'position_key': position_key
                                                })
                                                all_found_ranges.append(current_range)
                            
                            # Sort by length (longest first) but ensure top 2 are from DIFFERENT positions
                            all_candidates.sort(key=lambda x: x['length'], reverse=True)
                            
                            # 🎯 POSITION DEDUPLICATION: Find top 3 from different locations
                            top_3_candidates = []
                            used_positions = set()
                            
                            print(f"  🎯 DEDUPLICATING BY POSITION: Ensuring candidates are from different locations")
                            
                            for candidate in all_candidates:
                                candidate_pos = candidate['pos']
                                
                                # Check if this position overlaps with any already selected position
                                position_conflicts = False
                                for used_pos in used_positions:
                                    # Consider overlapping if within the length of either substring
                                    if (candidate_pos <= used_pos < candidate_pos + len(candidate['substring'])) or \
                                       (used_pos <= candidate_pos < used_pos + 35):  # approximate max length
                                        position_conflicts = True
                                        # Only print skips for the first few to reduce noise
                                        if len(top_3_candidates) < 3:
                                            print(f"    🎯 SKIPPING '{candidate['substring']}' at pos {candidate_pos} - overlaps with pos {used_pos}")
                                        break
                                
                                if not position_conflicts:
                                    top_3_candidates.append(candidate)
                                    used_positions.add(candidate_pos)
                                    print(f"    🎯 SELECTED '{candidate['substring']}' at pos {candidate_pos} (length: {candidate['length']})")
                                    
                                    # Stop once we have 3 distinct candidates
                                    if len(top_3_candidates) >= 3:
                                        break
                            
                            print(f"  🎯 Found {len(all_candidates)} total candidates, testing top 3:")
                            for i, candidate in enumerate(top_3_candidates):
                                print(f"  🎯   {i+1}. '{candidate['substring']}' (length: {candidate['length']})")
                            
                            # Test each of the top 3 candidates for context verification
                            best_match = None
                            best_match_start = -1
                            best_match_end = -1
                            found_good_match = False
                            
                            for candidate_num, candidate in enumerate(top_3_candidates, 1):
                                if found_good_match:
                                    break
                                    
                                substring = candidate['substring']
                                pos = candidate['pos']
                                position_key = candidate['position_key']
                                
                                print(f"  🎯 Testing candidate {candidate_num}: '{substring}' at position {pos}")
                                
                                # Context verification for this candidate
                                original_pos = base_word.find(substring)
                                partial_start = pos
                                partial_end = pos + len(substring)
                                
                                is_at_beginning = partial_start == 0
                                is_at_end = partial_end == len(plain_text)
                                
                                has_context_before = partial_start >= 6 or is_at_beginning
                                has_context_after = partial_end + 6 <= len(plain_text) or is_at_end
                                has_original_context_before = original_pos >= 6
                                has_original_context_after = original_pos + len(substring) + 6 <= len(base_word)
                                
                                context_match = True
                                context_comparison_performed = False
                                
                                # Context verification - check context before if applicable
                                if (is_at_end or (not is_at_beginning and has_context_before and has_original_context_before)):
                                    available_length_before = 6 if partial_start >= 6 else partial_start
                                    current_context_before = plain_text[partial_start - available_length_before:partial_start]
                                    
                                    # For end fragments, try stored context data if available
                                    if is_at_end and context_data and 'context_before' in context_data:
                                        original_context_before = context_data['context_before'][-available_length_before:]
                                        print(f"    🎯 Using stored context_before for end fragment: '{original_context_before}'")
                                    else:
                                        original_context_before = base_word[original_pos - available_length_before:original_pos]
                                    
                                    print(f"    🎯 Context before - Current: '{current_context_before}', Original: '{original_context_before}'")
                                    if current_context_before and original_context_before:
                                        if current_context_before != original_context_before:
                                            context_match = False
                                            print(f"    🎯 ❌ Context before mismatch for candidate {candidate_num}")
                                        context_comparison_performed = True
                                
                                # Context verification - check context after if applicable and context still matches
                                if context_match and (is_at_beginning or (not is_at_end and has_context_after and has_original_context_after)):
                                    available_length_after = 6 if partial_end + 6 <= len(plain_text) else len(plain_text) - partial_end
                                    current_context_after = plain_text[partial_end:partial_end + available_length_after]
                                    
                                    # For beginning fragments, try stored context data if available
                                    if is_at_beginning and context_data and 'context_after' in context_data:
                                        original_context_after = context_data['context_after'][:available_length_after]
                                        print(f"    🎯 Using stored context_after for beginning fragment: '{original_context_after}'")
                                    else:
                                        original_context_after = base_word[original_pos + len(substring):original_pos + len(substring) + available_length_after]
                                    
                                    print(f"    🎯 Context after - Current: '{current_context_after}', Original: '{original_context_after}'")
                                    if current_context_after and original_context_after:
                                        if current_context_after != original_context_after:
                                            context_match = False
                                            print(f"    🎯 ❌ Context after mismatch for candidate {candidate_num}")
                                        context_comparison_performed = True
                                
                                # If context verification passed (or couldn't be performed), accept this candidate
                                if context_match and (context_comparison_performed or not (is_at_beginning or is_at_end)):
                                    best_match = substring
                                    best_match_start = partial_start
                                    best_match_end = partial_end
                                    found_good_match = True
                                    print(f"    🎯 ✅ ACCEPTED candidate {candidate_num}: '{substring}' with valid context")
                                    break
                                elif not context_match:
                                    print(f"    🎯 ❌ REJECTED candidate {candidate_num}: '{substring}' due to context mismatch")
                                else:
                                    # Edge case: If TOP candidate (#1) matches the full annotation text, accept it regardless of context
                                    if candidate_num == 1 and len(substring) == len(plain_text) and substring == plain_text:
                                        print(f"    🎯 ✅ ACCEPTED candidate {candidate_num}: '{substring}' - TOP CANDIDATE + FULL ANNOTATION TEXT MATCH (bypassing context verification)")
                                        best_match = substring
                                        best_match_start = pos
                                        best_match_end = pos + len(substring)
                                        found_good_match = True
                                        break
                                    else:
                                        print(f"    🎯 ⚠️ Insufficient context to verify candidate {candidate_num}: '{substring}'")
                            
                            # Process the best match found (if any)
                            if found_good_match and best_match:
                                print(f"  🎯 ✅ FINAL SELECTION: Using '{best_match}' at positions {best_match_start}-{best_match_end}")
                                
                                # Update position data for this match
                                positional_data_to_update[segment_key] = {
                                    "start": best_match_start,
                                    "end": best_match_end,
                                    "matched_text": best_match
                                }
                                
                                # Add to segments to keep
                                segments_to_keep[segment_key] = best_match
                                found_match = True
                                processed_positions.add((best_match_start, best_match_end))
                            else:
                                print(f"  🎯 ❌ NO VALID CANDIDATES: All top 3 matches failed context verification")
                        elif not found_match and skip_partial_fallback:
                             print(f"  Partial matching skipped for '{base_word}' due to flag.")

                    if not found_match:
                        print(f"  No match found for '{base_word}'. Marking for removal.")
                        segments_to_remove.add(segment_key)

                # Clean up the data structures:
                print("\nCleaning up data structures:")
                if segments_to_remove:
                    print(f"  Removing {len(segments_to_remove)} unmatched segments:")
                    for segment_key in segments_to_remove:
                        print(f"    - '{segment_key}'")
                        strikethrough_segments.pop(segment_key, None)
                        positional_strikethrough.pop(segment_key, None)

                # Update segment keys for partial matches and handle positional data
                for old_key, data in positional_data_to_update.items():
                    if "new_key" in data and data["new_key"] != old_key:
                        print(f"  Updating segment from '{old_key}' to '{data['new_key']}' (partial match)")
                        strikethrough_segments[data["new_key"]] = True
                        strikethrough_segments.pop(old_key, None)
                        new_positional_data = positional_strikethrough.get(old_key, {}).copy()
                        new_positional_data["base_word"] = data["matched_text"]
                        new_positional_data["positions"] = [(data["start"], data["end"])]
                        new_positional_data["original_length"] = len(data["matched_text"])
                        if "context_before" in new_positional_data or "context_after" in new_positional_data:
                            context_before = plain_text[max(0, data["start"]-15):data["start"]]
                            context_after = plain_text[data["end"]:min(len(plain_text), data["end"]+15)]
                            new_positional_data["context_before"] = context_before
                            new_positional_data["context_after"] = context_after
                            print(f"    Updated context (HTML-free) - Before: '{context_before}', After: '{context_after}'")
                        positional_strikethrough[data["new_key"]] = new_positional_data
                        positional_strikethrough.pop(old_key, None)
                    else:
                        if old_key in positional_strikethrough:
                            print(f"  Updating position data for '{old_key}'")
                            positional_strikethrough[old_key]["positions"] = [(data["start"], data["end"])]
                            if "context_before" in positional_strikethrough[old_key] or "context_after" in positional_strikethrough[old_key]:
                                context_before = plain_text[max(0, data["start"]-15):data["start"]]
                                context_after = plain_text[data["end"]:min(len(plain_text), data["end"]+15)]
                                if not context_before and data["start"] > 0:
                                    print(f"    Warning: Empty context_before despite non-zero start position. HTML tags may be interfering.")
                                    pass
                                if not context_after and data["end"] < len(plain_text):
                                    print(f"    Warning: Empty context_after despite non-end position. HTML tags may be interfering.")
                                    pass
                                positional_strikethrough[old_key]["context_before"] = context_before
                                positional_strikethrough[old_key]["context_after"] = context_after
                                print(f"    Updated context (HTML-free) - Before: '{context_before}', After: '{context_after}'")

                storyboard['strikethrough_segments'] = strikethrough_segments
                storyboard['positional_strikethrough'] = positional_strikethrough

                print(f"\nAfter cleanup:")
                print(f"  {len(strikethrough_segments)} segments remain in strikethrough_segments")
                print(f"  {len(positional_strikethrough)} entries remain in positional_strikethrough")

                if not strikethrough_segments:
                    storyboard.pop('strikethrough_segments', None)
                if not positional_strikethrough:
                    storyboard.pop('positional_strikethrough', None)

                final_segments = []
                for segment_key, matched_text in segments_to_keep.items():
                    start, end = -1, -1
                    if segment_key in positional_data_to_update:
                        start = positional_data_to_update[segment_key]["start"]
                        end = positional_data_to_update[segment_key]["end"]
                    else:
                        start = plain_text.find(matched_text)
                        if start != -1:
                            end = start + len(matched_text)
                    if start >= 0 and end > start:
                        final_segments.append({
                            "text": matched_text,
                            "start": start,
                            "end": end,
                            "type": "context" if segment_key in positional_strikethrough and
                                           positional_strikethrough[segment_key].get("is_context_specific", False)
                                      else "non-context"
                        })

                final_segments.sort(key=lambda x: x["start"])
                print(f"Final segments to mark: {len(final_segments)}")
                for idx, seg in enumerate(final_segments):
                    print(f"  {idx+1}. '{seg['text']}' at positions {seg['start']}-{seg['end']} (type: {seg['type']})")
                    pass

                print("Detecting and removing nested strikethroughs...")
                segments_to_remove = []
                sorted_segments = sorted(final_segments, key=lambda x: x["end"] - x["start"], reverse=True)
                for i_outer, outer_seg in enumerate(sorted_segments): # Use i_outer
                    outer_start, outer_end = outer_seg["start"], outer_seg["end"]
                    outer_type = outer_seg["type"]
                    for j_inner, inner_seg in enumerate(sorted_segments): # Use j_inner
                        if i_outer == j_inner: # Compare indices
                            continue
                        inner_start, inner_end = inner_seg["start"], inner_seg["end"]
                        inner_type = inner_seg["type"]
                        if outer_start <= inner_start and outer_end >= inner_end:
                            if inner_type == "context" and inner_seg not in segments_to_remove:
                                print(f"  Found nested segment: '{inner_seg['text']}' inside '{outer_seg['text']}'")
                                print(f"  Removing nested context-specific segment to avoid double strikethrough")
                                segments_to_remove.append(inner_seg)
                                for key, is_struck in list(strikethrough_segments.items()):
                                    if key in positional_strikethrough:
                                        data = positional_strikethrough.get(key, {})
                                        if data.get("is_context_specific", False):
                                            if "positions" in data:
                                                pos = data["positions"][0] if data["positions"] else None
                                                if pos and pos[0] == inner_start and pos[1] == inner_end:
                                                    print(f"  Removing '{key}' from strikethrough_segments and positional_strikethrough")
                                                    strikethrough_segments.pop(key, None)
                                                    positional_strikethrough.pop(key, None)
                                                    break

                for seg in segments_to_remove:
                    final_segments.remove(seg)

                print(f"Removed {len(segments_to_remove)} nested segments")
                final_segments.sort(key=lambda x: x["start"])
                print(f"Final segments after nested cleanup: {len(final_segments)}")
                for idx, seg in enumerate(final_segments):
                    print(f"  {idx+1}. '{seg['text']}' at positions {seg['start']}-{seg['end']} (type: {seg['type']})")
                    pass

                storyboard['strikethrough_segments'] = strikethrough_segments
                storyboard['positional_strikethrough'] = positional_strikethrough

                # REMOVED COMPLICATED HTML POSITION MAPPING CODE
                # Replaced with direct text replacement which is much simpler and more reliable

                result_text = clean_text

                # First, handle context-specific segments
                context_specific_segments = []
                for seg in final_segments:
                    if seg["type"] == "context":
                        # Find the segment key in positional_strikethrough to get context
                        for key, data in positional_strikethrough.items():
                            if data.get("is_context_specific", False) and "positions" in data and data["positions"]:
                                if data["positions"][0][0] == seg["start"] and data["positions"][0][1] == seg["end"]:
                                    context_specific_segments.append({
                                        "text": seg["text"],
                                        "context_before": data.get("context_before", ""),
                                        "context_after": data.get("context_after", "")
                                    })
                                    break

                print(f"Processing {len(context_specific_segments)} context-specific segments")

                # Process each context-specific segment with proper context matching
                for seg in context_specific_segments:
                    seg_text = seg["text"]
                    context_before = seg["context_before"]
                    context_after = seg["context_after"]

                    print(f"Looking for segment '{seg_text}' with context before: '{context_before}', after: '{context_after}'")

                    # Search text for occurrences with matching context
                    pos = 0
                    while pos < len(result_text):
                        idx = result_text.find(seg_text, pos)
                        if idx == -1:
                            break

                        # Check context before
                        context_match_before = True
                        if context_before:
                            prefix_len = min(len(context_before), idx)
                            actual_prefix = result_text[idx-prefix_len:idx]
                            context_match_before = context_before.endswith(actual_prefix)

                        # Check context after
                        context_match_after = True
                        if context_after:
                            end_idx = idx + len(seg_text)
                            suffix_len = min(len(context_after), len(result_text) - end_idx)
                            actual_suffix = result_text[end_idx:end_idx + suffix_len]
                            context_match_after = context_after.startswith(actual_suffix)

                        # If both contexts match, apply strikethrough only here
                        if context_match_before and context_match_after:
                            print(f"Found context match for '{seg_text}' at position {idx}")
                            result_text = (
                                result_text[:idx] +
                                f"<s style=\"color:#FF9999;\">{seg_text}</s>" +
                                result_text[idx + len(seg_text):]
                            )
                            # Adjust pos to account for added tags
                            pos = idx + len(seg_text) + 32  # Length of opening+closing tags
                            break
                        else:
                            # Move to next occurrence
                            pos = idx + 1

                # Then apply non-context segments using simple replacement
                non_context_segments = [seg for seg in final_segments if seg["type"] != "context"]
                print(f"Applying {len(non_context_segments)} non-context strikethroughs")

                # Sort by length (longest first) to handle potential nesting
                non_context_segments.sort(key=lambda x: len(x["text"]), reverse=True)

                for seg in non_context_segments:
                    seg_text = seg["text"]
                    if seg_text in result_text:  # Only apply if segment text exists
                        result_text = result_text.replace(
                            seg_text,
                            f"<s style=\"color:#FF9999;\">{seg_text}</s>"
                        )
                        print(f"Applied non-context strikethrough to '{seg_text}'")

                # --- Use BeautifulSoup for final cleanup ---
                from bs4 import BeautifulSoup, NavigableString # Ensure import

                # Define the helper function to merge adjacent strikethrough tags
                def merge_adjacent_s_tags(html_text):
                    soup = BeautifulSoup(html_text, 'html.parser')
                    changed = True
                    while changed:
                        changed = False
                        s_tags = soup.find_all('s')
                        for s_tag in s_tags:
                            if not s_tag.parent: continue
                            next_element = s_tag.next_sibling
                            while isinstance(next_element, NavigableString) and next_element.strip() == '':
                                next_element = next_element.next_sibling
                                if not next_element: break
                            if next_element and next_element.name == 's':
                                print(f"Merging: '{s_tag.get_text()}' + '{next_element.get_text()}'")
                                whitespace = s_tag.next_sibling
                                if isinstance(whitespace, NavigableString): s_tag.append(whitespace.extract())
                                for child in list(next_element.children): s_tag.append(child.extract())
                                next_element.extract()
                                changed = True
                                break
                    return str(soup)

                # Define the helper function for cleanup
                def remove_nested_s_tags(html_text):
                    soup = BeautifulSoup(html_text, 'html.parser')
                    changed = True
                    while changed:
                        changed = False
                        for s_tag in soup.find_all('s'):
                            if s_tag.find_parent('s'):
                                s_tag.unwrap()
                                changed = True
                    return str(soup)
                # --- End of BeautifulSoup setup ---


                # Clean up any nested <s> tags
                result_text = remove_nested_s_tags(result_text)

                # Merge adjacent strikethrough tags for cleaner display
                print("Merging adjacent strikethrough tags")
                result_text = merge_adjacent_s_tags(result_text)

                if result_text != current_text:
                    print("Updating label with corrected strikethroughs")
                    print(f"Original text: {current_text[:100]}...")
                    print(f"New text: {result_text[:100]}...")
                    text_label.setText(result_text)
                    self.update_item_widget_size(item, text_label)
                    dialog = self.window()
                    if isinstance(dialog, StoryboardDialog):
                        dialog.changes_pending = True
                        self.mark_storyboard_widget_changes_pending()
                else:
                    print("No changes needed to label text")
                    pass

                print("🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟 IMPROVE_STRIKETHROUGH_DISPLAY END 🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟")
                print(f"🌟 annotation_id: {annotation_id} - PROCESSING COMPLETE")
                print("🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟")
                print(f"=== IMPROVE STRIKETHROUGH DISPLAY END: {annotation_id} ===\n")
                break # Found the item, exit the loop

    def restore_original_state(self, annotation_id):
        """Restore the original state of the annotation, removing storyboard data."""
        # Find the annotation and reset its storyboard state
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if not annotation:
            QMessageBox.warning(self, "Error", "Annotation not found.")
            return

        # Remove storyboard state
        if 'storyboard' in annotation:
            annotation.pop('storyboard', None)

        # Mark as not deleted
        if 'deleted' in annotation:
            annotation['deleted'] = False

        # Refresh the display of the annotation
        self.refresh_item_display(annotation_id)
        self.renumber_items_optimized(with_visual_updates=False, preserve_states=True)
        # for i in range(self.count()):
        #     item = self.item(i)
        #     if item:
        #         remain_id = item.data(Qt.ItemDataRole.UserRole)
        #         widget = self.itemWidget(item)
        #         if remain_id and widget and not hasattr(widget, 'is_divider'):
        #             self.improve_strikethrough_display(remain_id, skip_partial_fallback = True)
    
        # Use the same comprehensive resize approach
        QTimer.singleShot(50, self._update_all_items_on_resize)

        # Mark changes as pending
        dialog = self.window()
        if isinstance(dialog, StoryboardDialog):
            dialog.changes_pending = True

        # Mark changes as pending and apply changes
        dialog = self.window()
        if isinstance(dialog, StoryboardDialog):
            dialog.changes_pending = True
            self.mark_storyboard_widget_changes_pending()
            QTimer.singleShot(100, dialog.apply_changes_lite)

    def delete_item(self, annotation_id):
        """Delete an item from the list with no flickering."""
        print(f"\n=== DELETE ITEM START ===")
        print(f"Target annotation_id to delete: {annotation_id}")

        # Grab the dialog and ensure it’s the right type
        dialog = self.window()
        if not isinstance(dialog, StoryboardDialog):
            print(f"[ERROR] Parent window is not a StoryboardDialog")
            return False

        # Locate the annotation object in your data model
        anno = None
        for a in dialog.main_window.web_view.annotations:
            if a.get('id') == annotation_id:
                anno = a
                break

        # ——— Confirmation ———
        # If it’s currently marked “used,” show the custom 3‑button dialog.
        if anno and anno.get('used', False):
            print(f"[DEBUG] Annotation {annotation_id} is marked Used; showing custom dialog")
            resp = QMessageBox.question(
                dialog,
                "Mark as Unused and Delete?",
                'This item is marked as "Used." Would you like to mark it as "Unused" after removal from the Script Editor?',
                QMessageBox.StandardButton.Yes
                | QMessageBox.StandardButton.No
                | QMessageBox.StandardButton.Cancel
            )
            if resp == QMessageBox.StandardButton.Cancel:
                # print("[DEBUG] Deletion cancelled by user")
                return False
            mark_unused = (resp == QMessageBox.StandardButton.Yes)
        else:
            # Otherwise fall back to your generic “Are you sure?” confirmation
            print("[DEBUG] Showing generic delete confirmation")
            resp = QMessageBox.question(
                dialog,
                "Confirm Delete",
                "Are you sure you want to delete this item?",
                QMessageBox.StandardButton.Yes
                | QMessageBox.StandardButton.No
            )
            if resp != QMessageBox.StandardButton.Yes:
                # print("[DEBUG] Deletion cancelled by user")
                return False
            mark_unused = False

        # ——— Proceed with silent batch deletion ———
        self.begin_batch_updates()

        try:
            # STEP 0: find the QListWidgetItem
            found_item = None
            found_index = -1
            for i in range(self.count()):
                current_item = self.item(i)
                current_id = current_item.data(Qt.ItemDataRole.UserRole)
                widget = self.itemWidget(current_item)

                if widget and hasattr(widget, 'is_divider'):
                    print(f"[DEBUG] Skipping divider at index {i}")
                    continue

                if current_id == annotation_id:
                    found_item = current_item
                    found_index = i
                    print(f"[DEBUG] Found matching item at index {i}")
                    break

            if not found_item:
                print(f"[DEBUG] No matching item found; aborting")
                self.end_batch_updates(0)
                return False

            # STEP 1: remove it from the UI
            print(f"[DEBUG] Removing item at index {found_index}")
            self.takeItem(found_index)

            # STEP 2: queue for pending deletion
            if not hasattr(dialog, '_pending_deletions'):
                dialog._pending_deletions = set()
            dialog._pending_deletions.add(annotation_id)
            print(f"[DEBUG] Added {annotation_id} to pending deletions")

            # STEP 3: if user chose “Yes,” mark it unused
            if mark_unused and anno:
                anno['used'] = False
                print(f"[DEBUG] Marked annotation {annotation_id} as unused")
    
                # ADD THIS LINE: Update the DOM with the new 'used' status
                main_window = dialog.main_window
                update_payload = {
                    'id': annotation_id,
                    'text': anno.get('text', ''),
                    'used': False,  # Explicitly setting used to False
                    'favorite': anno.get('favorite', False),
                    'notes': anno.get('notes', ''),
                    'notes_html': anno.get('notes_html', ''),
                    'tags': anno.get('tags', []),
                    'secondary_scenes': anno.get('secondary_scenes', [])
                }
                print(f"[DEBUG] Emitting DOM update signal for unused status")
                main_window.web_view.annotation_updated.emit(json.dumps(update_payload))
                
                # Update theme view with targeted approach
                if main_window.theme_view:
                    print(f"[DEBUG] Updating theme view for unused status change")
                    dialog._sync_theme_view_items()
    
                if 'storyboard' in anno and 'order' in anno['storyboard']:
                    anno['storyboard'].pop('order', None)
                    print(f"[DEBUG] Removed 'order' from storyboard for annotation {annotation_id}")

            # STEP 4: flag dialog/main‐window state
            dialog.changes_pending = True
            self.mark_storyboard_widget_changes_pending()
            print("[DEBUG] Changes marked as pending")

            # STEP 5: renumber offscreen
            print("[DEBUG] Renumbering remaining items...")
            self.renumber_items_optimized(with_visual_updates=True, preserve_states=True)

            # STEP 6: apply the original strikethrough logic
            print("[DEBUG] Calling apply_changes_lite for proper strikethrough handling")
            dialog.apply_changes_lite()

            # STEP 7: sync theme view if needed (without full rebuild)
            main_window = dialog.main_window
            if main_window.theme_view:
                print("[DEBUG] Syncing theme view items after storyboard removal")
                dialog._sync_theme_view_items()

            # STEP 8: update word count
            if hasattr(dialog, 'word_counter'):
                print("[DEBUG] Updating word count")
                dialog.word_counter.update_word_count()

            # STEP 9: status bar feedback
            if hasattr(main_window, 'status_bar'):
                main_window.status_bar.showMessage('Item deleted successfully', 3000)

            print("[DEBUG] Deletion processing complete")

            # wrap up batch
            self.end_batch_updates(10)
            # print("[DEBUG] Improving strikethroughs for all remaining items")
            # for i in range(self.count()):
            #     item = self.item(i)
            #     if item:
            #         remain_id = item.data(Qt.ItemDataRole.UserRole)
            #         widget = self.itemWidget(item)
            #         if remain_id and widget and not hasattr(widget, 'is_divider'):
            #             self.improve_strikethrough_display(remain_id, skip_partial_fallback = True)

            return True

        except Exception as e:
            print(f"\nERROR during delete operation: {e}")
            import traceback; traceback.print_exc()
            self.end_batch_updates(0)
            return False

    def delete_multiple_items(self, annotation_ids):
        """Delete multiple items from the list with optimized batch processing."""
        print(f"\n=== BATCH DELETE START ===")
        print(f"Target annotation_ids to delete: {annotation_ids}")
        
        if not annotation_ids:
            return False

        # Grab the dialog and ensure it's the right type
        dialog = self.window()
        if not isinstance(dialog, StoryboardDialog):
            print(f"[ERROR] Parent window is not a StoryboardDialog")
            return False

        # Analyze all annotations to determine used/unused status
        used_annotations = []
        unused_annotations = []
        total_count = len(annotation_ids)
        
        for annotation_id in annotation_ids:
            anno = None
            for a in dialog.main_window.web_view.annotations:
                if a.get('id') == annotation_id:
                    anno = a
                    break
            
            if anno:
                if anno.get('used', False):
                    used_annotations.append((annotation_id, anno))
                else:
                    unused_annotations.append((annotation_id, anno))

        # Show smart confirmation dialog based on used status
        if used_annotations:
            used_count = len(used_annotations)
            message = f"{total_count} items selected"
            if used_count == total_count:
                message += f", all are marked as 'Used'. Mark as 'Unused' and delete all?"
            else:
                message += f", {used_count} are marked as 'Used'. Mark those as 'Unused' and delete all?"
            
            resp = QMessageBox.question(
                dialog,
                "Mark as Unused and Delete?",
                message,
                QMessageBox.StandardButton.Yes
                | QMessageBox.StandardButton.No
                | QMessageBox.StandardButton.Cancel
            )
            if resp == QMessageBox.StandardButton.Cancel:
                return False
            mark_unused = (resp == QMessageBox.StandardButton.Yes)
        else:
            # All items are unused
            resp = QMessageBox.question(
                dialog,
                "Confirm Delete",
                f"Are you sure you want to delete {total_count} selected items?",
                QMessageBox.StandardButton.Yes
                | QMessageBox.StandardButton.No
            )
            if resp != QMessageBox.StandardButton.Yes:
                return False
            mark_unused = False

        # Begin batch processing
        self.begin_batch_updates()
        
        try:
            # Collect items to remove and their indices
            items_to_remove = []
            
            # Find all items to remove
            for annotation_id in annotation_ids:
                for i in range(self.count()):
                    current_item = self.item(i)
                    current_id = current_item.data(Qt.ItemDataRole.UserRole)
                    widget = self.itemWidget(current_item)

                    if widget and hasattr(widget, 'is_divider'):
                        continue

                    if current_id == annotation_id:
                        items_to_remove.append((i, current_item, annotation_id))
                        break

            # Remove items from UI (in reverse order to maintain indices)
            items_to_remove.sort(key=lambda x: x[0], reverse=True)
            for index, item, annotation_id in items_to_remove:
                print(f"[DEBUG] Removing item at index {index}")
                self.takeItem(index)

            # Add all to pending deletions
            if not hasattr(dialog, '_pending_deletions'):
                dialog._pending_deletions = set()
            
            for annotation_id in annotation_ids:
                dialog._pending_deletions.add(annotation_id)
                print(f"[DEBUG] Added {annotation_id} to pending deletions")

            # Process used status changes and storyboard cleanup in batch
            dom_updates = []
            main_window = dialog.main_window
            
            for annotation_id, anno in used_annotations + unused_annotations:
                # Handle used status change
                if mark_unused and anno.get('used', False):
                    anno['used'] = False
                    print(f"[DEBUG] Marked annotation {annotation_id} as unused")
                    
                    # Prepare DOM update
                    update_payload = {
                        'id': annotation_id,
                        'text': anno.get('text', ''),
                        'used': False,
                        'favorite': anno.get('favorite', False),
                        'notes': anno.get('notes', ''),
                        'notes_html': anno.get('notes_html', ''),
                        'tags': anno.get('tags', []),
                        'secondary_scenes': anno.get('secondary_scenes', [])
                    }
                    dom_updates.append(update_payload)

                # Remove storyboard order
                if 'storyboard' in anno and 'order' in anno['storyboard']:
                    anno['storyboard'].pop('order', None)
                    print(f"[DEBUG] Removed 'order' from storyboard for annotation {annotation_id}")

            # Emit batch DOM updates
            if dom_updates:
                print(f"[DEBUG] Emitting batch DOM updates for {len(dom_updates)} items")
                for update in dom_updates:
                    main_window.web_view.annotation_updated.emit(json.dumps(update))

            # Mark changes as pending
            dialog.changes_pending = True
            self.mark_storyboard_widget_changes_pending()
            print("[DEBUG] Changes marked as pending")

            # Single renumber operation
            print("[DEBUG] Renumbering remaining items...")
            self.renumber_items_optimized(with_visual_updates=True, preserve_states=True)

            # Single apply changes
            print("[DEBUG] Calling apply_changes_lite for proper strikethrough handling")
            dialog.apply_changes_lite()

            # Single theme view sync
            if main_window.theme_view:
                print("[DEBUG] Syncing theme view items after batch removal")
                dialog._sync_theme_view_items()

            # Update word count
            if hasattr(dialog, 'word_counter'):
                print("[DEBUG] Updating word count")
                dialog.word_counter.update_word_count()

            # Status bar feedback
            if hasattr(main_window, 'status_bar'):
                main_window.status_bar.showMessage(f'{total_count} items deleted successfully', 3000)

            print("[DEBUG] Batch deletion processing complete")

            # End batch updates
            self.end_batch_updates(10)
            return True

        except Exception as e:
            print(f"\nERROR during batch delete operation: {e}")
            import traceback; traceback.print_exc()
            self.end_batch_updates(0)
            return False

    def mousePressEvent(self, event):
        """Handle mouse press events to enable drag from handle area and capture initial order"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.pre_drag_order = [self.item(i).data(Qt.ItemDataRole.UserRole) for i in range(self.count())]
        
            item = self.itemAt(event.pos())
            if item:
                widget = self.itemWidget(item)
                if widget:
                    item_rect = self.visualItemRect(item)
                    relative_x = event.pos().x() - item_rect.x()
                
                    if relative_x <= 40:
                        super().mousePressEvent(event)
                        return

        super().mousePressEvent(event)

    def startDrag(self, supportedActions):
        """Override startDrag to enable Alt+drag for external copy behavior"""
        print("\n=== START DRAG EVENT ===")
        
        # Check if Alt key is held down
        modifiers = QApplication.keyboardModifiers()
        is_alt_drag = modifiers & Qt.KeyboardModifier.AltModifier
        print(f"Alt key held: {is_alt_drag}")
        
        if is_alt_drag:
            print("*** ALT+DRAG DETECTED - Using CUSTOM drag system ***")
            
            # Store Copy Caption text for external use
            current_item = self.currentItem()
            copy_caption_text = ""
            if current_item:
                widget = self.itemWidget(current_item)
                if widget:
                    main_label = widget.findChild(QLabel, "main_content_label")
                    if main_label:
                        raw_text = main_label.text()
                        print(f"DEBUG ALT: Raw label text: '{raw_text[:100]}...'")
                        copy_caption_text = self.smart_copy_text(raw_text)
                        print(f"DEBUG ALT: Smart copy result: '{copy_caption_text}'")
                        print(f"Prepared Copy Caption text: {copy_caption_text[:50]}...")
            
            # Start custom drag system (bypasses Qt drag entirely)
            self._start_custom_drag(copy_caption_text)
            return  # Don't call super().startDrag()
            
        else:
            print("*** NORMAL DRAG - Custom drag with text preview and drop indicators ***")
            
            # Get the current selected items
            selected_items = self.selectedItems()
            if not selected_items:
                return
            
            # Create drag object and mime data
            drag = QDrag(self)
            mimeData = self.mimeData(selected_items)
            drag.setMimeData(mimeData)
            
            # Get text and number for custom pixmap
            current_item = selected_items[0]
            drag_text = ""
            item_number = ""
            is_divider = False
            
            if current_item:
                # Check if this is a divider by widget attribute
                widget = self.itemWidget(current_item)
                if widget and hasattr(widget, 'is_divider') and widget.is_divider:
                    is_divider = True
                    # Extract actual divider text and color from widget
                    divider_label = widget.findChild(QLabel)
                    divider_color = "#fff4c9"  # default
                    if divider_label:
                        drag_text = divider_label.text().strip()
                        # Extract background color from stylesheet
                        style = divider_label.styleSheet()
                        if "background-color:" in style:
                            import re
                            color_match = re.search(r'background-color:\s*([^;]+)', style)
                            if color_match:
                                divider_color = color_match.group(1).strip()
                    else:
                        drag_text = "Script Divider"
                    print(f"Detected divider item for drag: {drag_text}, color: {divider_color}")
                elif widget:
                    # Regular annotation item
                    main_label = widget.findChild(QLabel, "main_content_label")
                    anno_id_for_pix = current_item.data(Qt.ItemDataRole.UserRole)
                    number_label = None
                    if anno_id_for_pix:
                        number_label = widget.findChild(QLabel, f"number_label_{anno_id_for_pix}")
                    if not number_label:
                        number_label = widget.findChild(QLabel, "number_label")
                        if not number_label:
                            for lbl in widget.findChildren(QLabel):
                                t = lbl.text()
                                if t.endswith(".") and t[:-1].isdigit():
                                    number_label = lbl
                                    break
                    if main_label:
                        drag_text = self.extract_clean_text_for_display(main_label.text())
                        print(f"Normal drag text: {drag_text[:30]}...")
                    if number_label:
                        item_number = number_label.text()
                        print(f"Item number: {item_number}")
            
            # Set custom pixmap with text preview and number
            if drag_text:
                if is_divider:
                    self.create_divider_drag_pixmap(drag, drag_text, divider_color)
                else:
                    self.create_normal_drag_pixmap(drag, drag_text, item_number)
            
            # Enable custom drop indicators during drag
            self._custom_drop_indicators_active = True
            
            # Execute drag with custom drop indicator handling
            result = drag.exec(supportedActions)
            
            # Disable custom drop indicators
            self._custom_drop_indicators_active = False
            self.update()  # Clear any remaining indicators
            
            print(f"Drag completed with result: {result}")
        
        print("=== START DRAG EVENT END ===\n")
    
    def mimeData(self, items):
        """Create MIME data for drag operations"""
        mime = QMimeData()
        
        if items:
            item = items[0]
            annotation_id = item.data(Qt.ItemDataRole.UserRole)
            if annotation_id:
                mime.setData("application/x-annotation-id", QByteArray(str(annotation_id).encode()))
        
        return mime
    
    def trigger_windows_paste(self, text):
        """Copy text to clipboard and send Ctrl+V to Windows"""
        try:
            import ctypes
            from ctypes import wintypes
            
            # Copy text to Windows clipboard
            QApplication.clipboard().setText(text)
            print(f"Copied to clipboard: {text[:50]}...")
            
            # Small delay to ensure clipboard is ready
            QTimer.singleShot(50, lambda: self.send_ctrl_v_from_trigger())
            
        except Exception as e:
            print(f"Error in trigger_windows_paste: {e}")
    
    def send_ctrl_v_from_trigger(self):
        """Send Ctrl+V keystroke to window under cursor on Windows"""
        try:
            import ctypes
            from ctypes import wintypes
            
            # Windows API constants
            KEYEVENTF_KEYUP = 0x0002
            VK_CONTROL = 0x11
            VK_V = 0x56
            
            # Get Windows API functions
            user32 = ctypes.windll.user32
            
            # Get cursor position
            cursor_pos = QCursor.pos()
            print(f"Cursor position: {cursor_pos.x()}, {cursor_pos.y()}")
            
            # Get window under cursor
            point = wintypes.POINT(cursor_pos.x(), cursor_pos.y())
            hwnd = user32.WindowFromPoint(point)
            
            if hwnd:
                print(f"Found window handle: {hwnd}")
                
                # Get window title for debugging
                window_title = ctypes.create_unicode_buffer(256)
                user32.GetWindowTextW(hwnd, window_title, 256)
                print(f"Target window: {window_title.value}")
                
                # First click on the window to ensure focus
                print("Clicking on target window to ensure focus...")
                user32.SetCursorPos(cursor_pos.x(), cursor_pos.y())
                user32.mouse_event(0x0002, 0, 0, 0, 0)  # MOUSEEVENTF_LEFTDOWN
                user32.mouse_event(0x0004, 0, 0, 0, 0)  # MOUSEEVENTF_LEFTUP
                
                # Set focus to the window under cursor
                user32.SetForegroundWindow(hwnd)
                
                # Reduced delay after click and focus
                QTimer.singleShot(50, lambda h=hwnd: self.send_keystrokes(h))
            else:
                print("No window found under cursor")
                
        except Exception as e:
            print(f"Error in send_ctrl_v: {e}")
    
    def send_keystrokes(self, hwnd):
        """Send Ctrl+Shift+F, Ctrl+A, then Ctrl+V sequence"""
        try:
            import ctypes
            
            # Windows API constants
            KEYEVENTF_KEYUP = 0x0002
            VK_CONTROL = 0x11
            VK_SHIFT = 0x10
            VK_F = 0x46
            
            user32 = ctypes.windll.user32
            
            # Send Ctrl+Shift+F to open find/search
            print("Sending Ctrl+Shift+F (open find/search)...")
            user32.keybd_event(VK_CONTROL, 0, 0, 0)          # Press Ctrl
            user32.keybd_event(VK_SHIFT, 0, 0, 0)            # Press Shift
            user32.keybd_event(VK_F, 0, 0, 0)                # Press F
            user32.keybd_event(VK_F, 0, KEYEVENTF_KEYUP, 0)  # Release F
            user32.keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0)  # Release Shift
            user32.keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0)  # Release Ctrl
            print("Ctrl+Shift+F sent, waiting for search dialog...")
            
            # Wait for search box to open and focus
            QTimer.singleShot(50, lambda h=hwnd: self.send_ctrl_a(h))
            
        except Exception as e:
            print(f"Error sending Ctrl+Shift+F: {e}")
    
    def send_ctrl_v_direct(self, hwnd):
        """Send Ctrl+V for direct paste"""
        try:
            import ctypes
            
            KEYEVENTF_KEYUP = 0x0002
            VK_CONTROL = 0x11
            VK_V = 0x56
            
            user32 = ctypes.windll.user32
            
            print("Sending direct Ctrl+V...")
            user32.keybd_event(VK_CONTROL, 0, 0, 0)          # Press Ctrl
            user32.keybd_event(VK_V, 0, 0, 0)                # Press V
            user32.keybd_event(VK_V, 0, KEYEVENTF_KEYUP, 0)  # Release V
            user32.keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0)  # Release Ctrl
            
            print("Direct paste completed! If this didn't work, we'll try Ctrl+F approach next time.")
            
        except Exception as e:
            print(f"Error in direct Ctrl+V: {e}")
    
    def send_ctrl_f_approach(self, hwnd):
        """Fallback: Send Ctrl+Shift+F, Ctrl+A, then Ctrl+V with proper delays"""
        try:
            import ctypes
            
            # Windows API constants
            KEYEVENTF_KEYUP = 0x0002
            VK_CONTROL = 0x11
            VK_SHIFT = 0x10
            VK_F = 0x46
            
            user32 = ctypes.windll.user32
            
            # Send Ctrl+Shift+F to open find/search
            print("Fallback: Sending Ctrl+Shift+F (open find/search)...")
            user32.keybd_event(VK_CONTROL, 0, 0, 0)          # Press Ctrl
            user32.keybd_event(VK_SHIFT, 0, 0, 0)            # Press Shift
            user32.keybd_event(VK_F, 0, 0, 0)                # Press F
            user32.keybd_event(VK_F, 0, KEYEVENTF_KEYUP, 0)  # Release F
            user32.keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0)  # Release Shift
            user32.keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0)  # Release Ctrl
            print("Fallback Ctrl+Shift+F sent, waiting for search dialog...")
            
            # Wait longer for search box to open and focus
            QTimer.singleShot(400, lambda h=hwnd: self.send_ctrl_a(h))
            
        except Exception as e:
            print(f"Error sending fallback Ctrl+Shift+F: {e}")
    
    def send_ctrl_a(self, hwnd):
        """Send Ctrl+A after search dialog is open"""
        try:
            import ctypes
            
            # Windows API constants
            KEYEVENTF_KEYUP = 0x0002
            VK_CONTROL = 0x11
            VK_A = 0x41
            
            user32 = ctypes.windll.user32
            
            print("Sending Ctrl+A (select all)...")
            user32.keybd_event(VK_CONTROL, 0, 0, 0)          # Press Ctrl
            user32.keybd_event(VK_A, 0, 0, 0)                # Press A
            user32.keybd_event(VK_A, 0, KEYEVENTF_KEYUP, 0)  # Release A
            user32.keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0)  # Release Ctrl
            print("Ctrl+A sent, waiting before paste...")
            
            # Wait for selection to complete
            QTimer.singleShot(50, lambda h=hwnd: self.send_ctrl_v(h))
            
        except Exception as e:
            print(f"Error sending Ctrl+A: {e}")
    
    def send_ctrl_v(self, hwnd):
        """Send Ctrl+V to paste the text"""
        try:
            import ctypes
            
            # Windows API constants
            KEYEVENTF_KEYUP = 0x0002
            VK_CONTROL = 0x11
            VK_V = 0x56
            
            user32 = ctypes.windll.user32
            
            print("Sending Ctrl+V (paste)...")
            user32.keybd_event(VK_CONTROL, 0, 0, 0)          # Press Ctrl
            user32.keybd_event(VK_V, 0, 0, 0)                # Press V
            user32.keybd_event(VK_V, 0, KEYEVENTF_KEYUP, 0)  # Release V
            user32.keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0)  # Release Ctrl
            
            print(f"Ctrl+V sent to window handle: {hwnd}")
            print("Keystroke sequence complete!")
            
        except Exception as e:
            print(f"Error sending Ctrl+V: {e}")
    
    def _start_custom_drag(self, copy_caption_text):
        """Start custom drag system that bypasses Qt entirely"""
        print("Starting custom drag system...")
        
        # Cancel any pending timers from previous operations
        if hasattr(self, '_pending_timers'):
            for timer in self._pending_timers:
                if timer.isActive():
                    timer.stop()
        self._pending_timers = []
        
        # Set custom drag state
        self._custom_drag_active = True
        self._custom_drag_text = copy_caption_text
        
        # Create the drag overlay window
        self._create_drag_overlay(copy_caption_text)
        
        # Hide normal cursor and start tracking
        self.setCursor(Qt.CursorShape.BlankCursor)
        self.setMouseTracking(True)
        
        # Use application-wide event filter instead of grabMouse
        QApplication.instance().installEventFilter(self)
        print("Installed application event filter for custom drag")
        
        print("Custom drag system activated")
    
    def _create_drag_overlay(self, copy_caption_text):
        """Create floating overlay window with drag pixmap"""
        try:
            # Create borderless overlay window
            self._drag_overlay = QWidget()
            self._drag_overlay.setWindowFlags(
                Qt.WindowType.FramelessWindowHint | 
                Qt.WindowType.WindowStaysOnTopHint |
                Qt.WindowType.Tool
            )
            self._drag_overlay.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
            self._drag_overlay.setFixedSize(220, 35)
            
            # Create pixmap for the overlay
            preview_text = copy_caption_text[:30] + "..." if len(copy_caption_text) > 30 else copy_caption_text
            
            pixmap = QPixmap(220, 35)
            pixmap.fill(Qt.GlobalColor.transparent)
            
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw a nice rounded background
            painter.setPen(QPen(QColor(100, 100, 100), 1))
            painter.setBrush(QColor(255, 255, 255, 240))
            painter.drawRoundedRect(2, 2, 216, 31, 5, 5)
            
            # Add "ALT" indicator in corner
            painter.setPen(QPen(QColor(0, 120, 0), 1))
            painter.setFont(QFont("Arial", 7, QFont.Weight.Bold))
            painter.drawText(QRect(190, 5, 25, 12), Qt.AlignmentFlag.AlignCenter, "ALT")
            
            # Add a small document icon
            painter.setPen(QPen(QColor(50, 50, 50), 1))
            painter.drawRect(8, 8, 12, 16)
            painter.drawLine(16, 8, 16, 12)
            painter.drawLine(16, 12, 20, 12)
            
            # Draw the text preview
            painter.setPen(QColor(20, 20, 20))
            painter.setFont(QFont("Arial", 9, QFont.Weight.Normal))
            painter.drawText(25, 20, preview_text)
            
            painter.end()
            
            # Set pixmap as overlay background
            label = QLabel(self._drag_overlay)
            label.setPixmap(pixmap)
            label.setGeometry(0, 0, 220, 35)
            
            # Position overlay at cursor
            cursor_pos = QCursor.pos()
            self._drag_overlay.move(cursor_pos.x() - 15, cursor_pos.y() - 17)
            self._drag_overlay.show()
            
            print(f"Created custom drag overlay with text: {preview_text}")
            
        except Exception as e:
            print(f"Error creating drag overlay: {e}")
    
    def mouseMoveEvent(self, event):
        """Override mouse move to handle custom drag"""
        if hasattr(self, '_custom_drag_active') and self._custom_drag_active:
            # Update overlay position
            if hasattr(self, '_drag_overlay') and self._drag_overlay:
                global_pos = self.mapToGlobal(event.pos())
                self._drag_overlay.move(global_pos.x() - 15, global_pos.y() - 17)
            return  # Don't call super() for custom drag
        
        # Normal mouse move behavior
        super().mouseMoveEvent(event)
    
    def mouseReleaseEvent(self, event):
        """Override mouse release to handle custom drag end"""
        if hasattr(self, '_custom_drag_active') and self._custom_drag_active:
            print("Custom drag ended - triggering paste")
            
            # Trigger Windows paste to whatever is under cursor
            if hasattr(self, '_custom_drag_text') and self._custom_drag_text:
                self.trigger_windows_paste(self._custom_drag_text)
            
            # Clean up custom drag
            self._cleanup_custom_drag()
            return  # Don't call super() for custom drag
        
        # Normal mouse release behavior
        super().mouseReleaseEvent(event)
    
    def _cleanup_custom_drag(self):
        """Clean up custom drag state and overlay"""
        print("Cleaning up custom drag system...")
        
        # Remove overlay window
        if hasattr(self, '_drag_overlay') and self._drag_overlay:
            self._drag_overlay.hide()
            self._drag_overlay.deleteLater()
            self._drag_overlay = None
        
        # Restore normal state
        if hasattr(self, '_custom_drag_active'):
            self._custom_drag_active = False
        if hasattr(self, '_custom_drag_text'):
            self._custom_drag_text = ""
        
        # Restore normal cursor and mouse tracking
        self.setCursor(Qt.CursorShape.ArrowCursor)
        self.setMouseTracking(False)
        
        # Remove application event filter
        QApplication.instance().removeEventFilter(self)
        print("Removed application event filter")
        
        print("Custom drag cleanup complete")
    
    def _draw_custom_drop_indicator(self, pos):
        """Draw custom drop indicator at the specified position"""
        try:
            # Find the item at the drop position
            drop_item = self.itemAt(pos)
            drop_index = -1
            
            if drop_item:
                drop_index = self.row(drop_item)
                item_rect = self.visualItemRect(drop_item)
                
                # Determine insertion index based on position
                if pos.y() < item_rect.center().y():
                    # Will insert before this item (drop_index stays same)
                    insertion_index = drop_index
                else:
                    # Will insert after this item
                    insertion_index = drop_index + 1
                
                # ALWAYS show indicator at bottom of the item that will be ABOVE the insertion
                if insertion_index == 0:
                    # Inserting at very beginning - show at top of first item (only exception)
                    self._drop_indicator_y = item_rect.top()
                else:
                    # Show at bottom of the item that will be above the insertion point
                    above_item = self.item(insertion_index - 1)
                    above_rect = self.visualItemRect(above_item)
                    self._drop_indicator_y = above_rect.bottom()
            else:
                # Drop at the end of the list
                if self.count() > 0:
                    last_item = self.item(self.count() - 1)
                    last_rect = self.visualItemRect(last_item)
                    self._drop_indicator_y = last_rect.bottom()
                else:
                    self._drop_indicator_y = 10
            
            # Store the drop index and trigger a repaint
            self._drop_indicator_index = drop_index
            self.update()
            
        except Exception as e:
            print(f"Error drawing custom drop indicator: {e}")
    
    def paintEvent(self, event):
        """Override paint event to draw custom drop indicators and placeholder"""
        # First draw the normal widget
        super().paintEvent(event)
        
        # Draw placeholder text if list is empty
        if self.count() == 0:
            painter = QPainter(self.viewport())
            painter.setFont(self.placeholder_font)
            painter.setPen(self.placeholder_color)
            
            rect = self.viewport().rect()
            painter.drawText(
                rect, 
                Qt.AlignmentFlag.AlignCenter, 
                self.placeholder_text
            )
            painter.end()
            return  # Don't draw drop indicators if showing placeholder
        
        # Then draw custom drop indicator if active
        if (hasattr(self, '_custom_drop_indicators_active') and 
            self._custom_drop_indicators_active and
            hasattr(self, '_drop_indicator_y')):
            
            painter = QPainter(self.viewport())
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw a blue line to indicate drop position
            painter.setPen(QPen(QColor(0, 120, 215), 2))  # Blue line
            viewport_rect = self.viewport().rect()
            y = self._drop_indicator_y
            
            # Draw the drop line across the width
            painter.drawLine(5, y, viewport_rect.width() - 5, y)
            
            # Draw small triangles at the ends
            triangle_size = 4
            # Left triangle
            left_triangle = QPolygon([
                QPoint(5, y),
                QPoint(5 + triangle_size, y - triangle_size),
                QPoint(5 + triangle_size, y + triangle_size)
            ])
            # Right triangle  
            right_triangle = QPolygon([
                QPoint(viewport_rect.width() - 5, y),
                QPoint(viewport_rect.width() - 5 - triangle_size, y - triangle_size),
                QPoint(viewport_rect.width() - 5 - triangle_size, y + triangle_size)
            ])
            
            painter.setBrush(QColor(0, 120, 215))
            painter.drawPolygon(left_triangle)
            painter.drawPolygon(right_triangle)
            
            painter.end()
    
    def create_normal_drag_pixmap(self, drag, annotation_text, item_number=""):
        """Create fixed-size text preview pixmap for normal internal drag operations"""
        try:
            # Ensure text is exactly 60 characters (or show full text if shorter)
            preview_text = annotation_text[:60]
            if len(annotation_text) > 60:
                preview_text += "..."
            if not preview_text:
                preview_text = "Annotation"
            
            # Create a larger pixmap to accommodate number and text
            pixmap = QPixmap(350, 28)
            pixmap.fill(Qt.GlobalColor.transparent)
            
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw a subtle background for normal drag
            painter.setPen(QPen(QColor(120, 120, 120), 1))
            painter.setBrush(QColor(245, 245, 245, 220))
            painter.drawRoundedRect(2, 2, 346, 24, 4, 4)
            
            # Add a small reorder icon (≡ hamburger) at the start
            painter.setPen(QPen(QColor(80, 80, 80), 2))
            painter.drawLine(8, 9, 16, 9)
            painter.drawLine(8, 14, 16, 14)
            painter.drawLine(8, 19, 16, 19)
            
            # Draw the item number in a colored circle/background
            number_start_x = 22
            if item_number:
                painter.setPen(QPen(QColor(0, 120, 215), 1))  # Blue border
                painter.setBrush(QColor(0, 120, 215, 30))     # Light blue background
                
                # Draw number background circle
                number_width = max(20, len(item_number) * 8 + 8)
                painter.drawRoundedRect(number_start_x, 5, number_width, 18, 9, 9)
                
                # Draw the number text
                painter.setPen(QColor(0, 80, 160))  # Dark blue text
                painter.setFont(QFont("Arial", 8, QFont.Weight.Bold))
                painter.drawText(number_start_x + 4, 17, item_number)
                
                number_start_x += number_width + 8  # Move text start position
            
            # Draw the text preview with eliding if too long
            painter.setPen(QColor(40, 40, 40))
            painter.setFont(QFont("Arial", 8, QFont.Weight.Normal))
            
            # Calculate available width for text
            available_width = 346 - number_start_x - 5  # total width - used space - padding
            font_metrics = QFontMetrics(painter.font())
            elided_text = font_metrics.elidedText(preview_text, Qt.TextElideMode.ElideRight, available_width)
            
            painter.drawText(number_start_x, 17, elided_text)
            
            painter.end()
            
            # Set pixmap with appropriate hot spot
            drag.setPixmap(pixmap)
            drag.setHotSpot(QPoint(15, 14))
            print(f"Created normal drag pixmap (350x28): [{item_number}] {elided_text}")
            
        except Exception as e:
            print(f"Error creating normal drag pixmap: {e}")
    
    def create_divider_drag_pixmap(self, drag, divider_text="Script Divider", divider_color="#fff4c9"):
        """Create custom pixmap for divider drag operations"""
        try:
            # Create pixmap for divider
            pixmap = QPixmap(200, 28)
            pixmap.fill(Qt.GlobalColor.transparent)
            
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Parse divider color
            bg_color = QColor(divider_color) if divider_color.startswith('#') else QColor(divider_color)
            if not bg_color.isValid():
                bg_color = QColor("#fff4c9")  # fallback
            
            # Draw background with divider's actual color
            painter.setPen(QPen(bg_color.darker(120), 1))  # Slightly darker border
            painter.setBrush(bg_color)
            painter.drawRoundedRect(2, 2, 196, 24, 4, 4)
            
            # Draw divider text (always black)
            painter.setPen(QColor(0, 0, 0))  # Always black text
            painter.setFont(QFont("Arial", 9, QFont.Weight.Bold))
            # Truncate text if too long to fit in pixmap
            display_text = divider_text[:25] + "..." if len(divider_text) > 25 else divider_text
            painter.drawText(10, 17, display_text)
            
            painter.end()
            
            # Set pixmap with appropriate hot spot
            drag.setPixmap(pixmap)
            drag.setHotSpot(QPoint(15, 14))
            print("Created divider drag pixmap (200x28)")
            
        except Exception as e:
            print(f"Error creating divider drag pixmap: {e}")
    
    def eventFilter(self, obj, event):
        """Application-wide event filter for custom drag system"""
        if hasattr(self, '_custom_drag_active') and self._custom_drag_active:
            if event.type() == QEvent.Type.MouseMove:
                # Update overlay position based on global cursor
                if hasattr(self, '_drag_overlay') and self._drag_overlay:
                    cursor_pos = QCursor.pos()
                    self._drag_overlay.move(cursor_pos.x() - 15, cursor_pos.y() - 17)
                return True  # Event handled
                
            elif event.type() == QEvent.Type.MouseButtonRelease:
                if event.button() == Qt.MouseButton.LeftButton:
                    print("Custom drag ended via event filter - triggering paste")
                    
                    # Trigger Windows paste to whatever is under cursor
                    if hasattr(self, '_custom_drag_text') and self._custom_drag_text:
                        # Small delay to ensure target window is ready
                        drag_text = self._custom_drag_text  # Capture in local variable
                        QTimer.singleShot(50, lambda: self.trigger_windows_paste(drag_text))
                    
                    # Clean up custom drag
                    self._cleanup_custom_drag()
                    return True  # Event handled
        
        # Let other events through normally
        return super().eventFilter(obj, event)
    
    def set_custom_drag_pixmap(self, drag):
        """Set a custom drag pixmap that shows copy operation instead of denied"""
        try:
            # Create a larger, more visible drag pixmap 
            pixmap = QPixmap(48, 32)
            pixmap.fill(Qt.GlobalColor.transparent)
            
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw a document/text icon with a "COPY" indicator
            painter.setPen(QPen(QColor(50, 50, 50), 2))
            painter.setBrush(QColor(255, 255, 255, 240))
            
            # Draw document rectangle with shadow
            painter.setPen(QPen(QColor(150, 150, 150), 1))
            painter.drawRect(9, 7, 16, 20)  # shadow
            painter.setPen(QPen(QColor(50, 50, 50), 2))
            painter.setBrush(QColor(255, 255, 255))
            painter.drawRect(6, 4, 16, 20)  # main doc
            
            # Draw folded corner
            painter.setPen(QPen(QColor(50, 50, 50), 1))
            painter.drawLine(18, 4, 18, 10)
            painter.drawLine(18, 10, 22, 10)
            
            # Draw text lines in document
            painter.setPen(QPen(QColor(100, 100, 100), 1))
            painter.drawLine(9, 9, 16, 9)
            painter.drawLine(9, 12, 16, 12)
            painter.drawLine(9, 15, 16, 15)
            painter.drawLine(9, 18, 13, 18)
            
            # Draw a bright green arrow pointing right to indicate "will paste"
            painter.setBrush(QColor(0, 180, 0))
            painter.setPen(QPen(QColor(0, 180, 0), 2))
            
            # Arrow pointing right
            arrow_points = [
                QPoint(28, 12),  # tip
                QPoint(22, 8),   # top back
                QPoint(25, 11),  # top middle
                QPoint(25, 13),  # bottom middle  
                QPoint(22, 16)   # bottom back
            ]
            painter.drawPolygon(QPolygon(arrow_points))
            
            # Add "COPY" text
            painter.setPen(QPen(QColor(0, 120, 0), 1))
            painter.setFont(QFont("Arial", 7, QFont.Weight.Bold))
            painter.drawText(QRect(26, 18, 20, 10), Qt.AlignmentFlag.AlignLeft, "COPY")
            
            painter.end()
            
            # Set the custom pixmap for drag with hot spot at center
            drag.setPixmap(pixmap)
            drag.setHotSpot(QPoint(24, 16))  # Center of the icon
            print("Set custom drag pixmap (copy icon with arrow)")
            
        except Exception as e:
            print(f"Error setting custom drag pixmap: {e}")

    def mouseReleaseEvent(self, event):
        """Handle mouse release events to restore cursor after any drag operation"""
        print("\n=== MOUSE RELEASE EVENT ===")
    
        # Always restore cursor to default after mouse release
        # This handles all cursor types including OpenHandCursor, ClosedHandCursor, etc.
        self.setCursor(Qt.CursorShape.ArrowCursor)
        print(f"Restored cursor from {self.cursor().shape()} to ArrowCursor")
    
        super().mouseReleaseEvent(event)
        print("=== MOUSE RELEASE EVENT END ===\n")

    def perform_scroll(self):
        """Perform the actual scrolling operation with improved control and safety checks."""
        if self.current_scroll_direction is None or self.is_scrolling:
            self.scroll_timer.stop()
            self.is_scrolling = False
            return
            
        self.is_scrolling = True
        vscroll = self.verticalScrollBar()
        
        try:
            if self.current_scroll_direction == "down":
                if vscroll.value() >= vscroll.maximum():
                    self.scroll_timer.stop()
                    self.is_scrolling = False
                else:
                    new_value = min(vscroll.value() + self.scroll_step, vscroll.maximum())
                    vscroll.setValue(new_value)
            elif self.current_scroll_direction == "up":
                if vscroll.value() <= 0:
                    self.scroll_timer.stop()
                    self.is_scrolling = False
                else:
                    new_value = max(vscroll.value() - self.scroll_step, 0)
                    vscroll.setValue(new_value)
        except Exception as e:
            print(f"Error during scroll operation: {e}")
            self.scroll_timer.stop()
        finally:
            self.is_scrolling = False

    def dragEnterEvent(self, event):
        """Handle drag enter events from both internal and external sources."""
        print("\n=== DRAG ENTER EVENT START ===")
    
        # Accept drag from both internal moves and external sources
        if event.mimeData().hasFormat("application/x-annotation-id"):
            print("Valid annotation ID format detected")
            # Set blue border for external drag hover state
            if event.source() != self:
                print("External drag detected - setting blue border and enabling custom drop indicators")
                self.setProperty("dragHover", "true")
                self.style().unpolish(self)
                self.style().polish(self)
                # Enable custom drop indicators for external drags
                self._custom_drop_indicators_active = True
            event.acceptProposedAction()
        elif event.source() == self:
            print("Internal drag detected")
            event.acceptProposedAction()
        else:
            print("Invalid drag source or format - ignoring")
            event.ignore()
        
        print("=== DRAG ENTER EVENT END ===\n")

    def dragMoveEvent(self, event):
        """Handle drag move events with improved auto-scrolling logic."""
        print("\n=== DRAG MOVE EVENT START ===")
    
        # Check if it's a valid drag
        is_internal = event.source() == self
        has_valid_mime = event.mimeData().hasFormat("application/x-annotation-id")
    
        if is_internal or has_valid_mime:
            # Accept the event
            event.acceptProposedAction()
            
            # If custom drop indicators are active, draw them manually
            if hasattr(self, '_custom_drop_indicators_active') and self._custom_drop_indicators_active:
                self._draw_custom_drop_indicator(event.position().toPoint())
            else:
                # Use Qt's default behavior
                super().dragMoveEvent(event)
        
            # Get the viewport rect and event position
            viewport_rect = self.viewport().rect()
            pos = event.position().toPoint()
        
            # Define scroll regions (increased for better UX)
            margin = 100  # pixels from top/bottom where scrolling starts
            top_region = viewport_rect.top() + margin
            bottom_region = viewport_rect.bottom() - margin
            
            vscroll = self.verticalScrollBar()
            
            # Determine scroll direction with boundary checks
            new_direction = None
            if pos.y() > bottom_region and vscroll.value() < vscroll.maximum():
                new_direction = "down"
            elif pos.y() < top_region and vscroll.value() > 0:
                new_direction = "up"
                
            # If no scroll direction within widget, check if we should scroll parent
            if new_direction is None:
                # Check if cursor is outside widget bounds (above or below)
                widget_global_rect = self.mapToGlobal(self.rect().topLeft())
                widget_rect = QRect(widget_global_rect, self.size())
                cursor_global_pos = QCursor.pos()
                
                if cursor_global_pos.y() < widget_rect.top():
                    new_direction = "up_parent"
                elif cursor_global_pos.y() > widget_rect.bottom():
                    new_direction = "down_parent"
            
            # Update scroll direction and timer state if needed
            if new_direction != self.current_scroll_direction:
                self.current_scroll_direction = new_direction
                if new_direction is None:
                    self.scroll_timer.stop()
                    self.is_scrolling = False
                elif not self.scroll_timer.isActive():
                    self.is_scrolling = False  # Reset scrolling state
                    self.scroll_timer.start()
        
            # Accept the event for both internal and external drags
            event.acceptProposedAction()
            if isinstance(self.parent(), StoryboardDialog):
                self.parent().changes_pending = True
                print("Changes marked as pending")
        else:
            print("Invalid drag - ignoring")
            event.ignore()
        
        print("=== DRAG MOVE EVENT END ===\n")  # -- This method is nested under StoryboardDialog and is the ListWidget subclass for the storyboard
    
    def dragLeaveEvent(self, event):
        """Handle drag leave events - only override cursor for Ctrl+drag."""
        print("\n=== DRAG LEAVE EVENT START ===")
        
        # Reset drag hover styling
        if self.property("dragHover") == "true":
            print("Resetting drag hover styling after drag leave")
            self.setProperty("dragHover", "false")
            self.style().unpolish(self)
            self.style().polish(self)
            # Disable custom drop indicators for external drags
            self._custom_drop_indicators_active = False
            self.update()  # Clear any remaining indicators
        
        # Stop auto-scrolling if active
        if hasattr(self, 'scroll_timer') and self.scroll_timer.isActive():
            self.scroll_timer.stop()
            self.is_scrolling = False
            print("Stopped auto-scrolling due to drag leave")
        
        # Only override cursor if this was an Alt+drag (has _drag_in_progress flag)
        if hasattr(self, '_drag_in_progress') and self._drag_in_progress:
            # Create blank cursor to hide system no-drop overlay for Alt+drag
            blank_pixmap = QPixmap(1, 1)
            blank_pixmap.fill(Qt.GlobalColor.transparent)
            blank_cursor = QCursor(blank_pixmap)
            QApplication.setOverrideCursor(blank_cursor)
            print("Set blank cursor for Alt+drag - hide system no-drop overlay")
        else:
            print("Normal drag leave - no cursor override needed")
        
        # Call parent implementation
        super().dragLeaveEvent(event)
        print("=== DRAG LEAVE EVENT END ===\n")


class StoryboardDialog(QDialog):
    closed = pyqtSignal()  # Signal to indicate closing by 'X'

    @property 
    def changes_pending(self):
        return self._changes_pending

    @changes_pending.setter
    def changes_pending(self, value):
        print(f"[DEBUG] Setting storyboard changes_pending to {value}")
        print("[DEBUG] Stack trace:")
        # import traceback
        # traceback.print_stack()
        self._changes_pending = value

    def __init__(self, main_window, is_temp_for_save=False, delay_population=False):
        super().__init__(None)  # Independent window
        self.is_temp_for_save = is_temp_for_save
        self.main_window = main_window
        self._last_geometry = None  # Initialize the attribute
        self._is_compact_mode = False  # Track compact mode state
        self._is_closing = False
        self.is_manually_hidden = False
        self.is_manually_minimized = False  # New flag to track manual minimization

        # Initialize overlay references to avoid undefined states
        self._loading_overlay = None
        self._dot_timer = None
        self._overlay_cleanup_ready = False

        # Initialize pending deletions as an empty set
        self._pending_deletions = set()
        
        # Track collapsed state for external access
        self._is_collapsed = False
        
        self.setWindowTitle("Script Editor")
        self.setWindowModality(Qt.WindowModality.NonModal)
        # Set the window icon
        icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Img', 'storyboard.ico')
        self.setWindowIcon(QIcon(icon_path))

        # For Windows taskbar icon
        if os.name == 'nt':
            import ctypes
            myappid = 'mycompany.transcriptmanager.storyboard.1'
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)

        # Add window state tracking
        self.closeRequested = False
    
        self.setWindowFlags(
            Qt.WindowType.Window |
            Qt.WindowType.CustomizeWindowHint |
            Qt.WindowType.WindowTitleHint |
            Qt.WindowType.WindowCloseButtonHint |
            Qt.WindowType.WindowMinimizeButtonHint |
            Qt.WindowType.WindowMaximizeButtonHint
        )

        if main_window:
            main_window.window().destroyed.connect(self.close)
            main_window.window().installEventFilter(self)
    
        self.main_window = main_window
        self.annotations = main_window.web_view.annotations
        self.scene_styles = main_window.web_view.scene_styles
        # Initialize the storyboard without marking changes
        self.changes_pending = False
        self.main_window.storyboard_changes_pending = False

        # Define base stylesheet for OrderListWidget with drag hover support
        self.base_stylesheet = """
            QListWidget {
                background: #ffffff;
                border: 1px solid #ADADAD;
                margin-left: 20px;
                margin-right: 20px;
                border-radius: 5px;
                font-size: 16px;
                outline: none;
                padding: 5px;
            }
        
            QListWidget::item {
                background-color: #fafafa;
                border: 1px solid #d0d0d0 !important;
                border-radius: 4px;
                margin: 2px 5px;
                min-height: 20px;
                padding: 0px !important;
            }
        
            QListWidget::item:selected {
                background-color: #e3f2fd;
                border: 1px solid #90caf9 !important;
            }
        
            QListWidget::item:hover:!selected {
                background-color: #f5f5f5;
                border: 1px solid #4a90e2 !important;
            }
            
            QListWidget[dragHover="true"] {
                border: 3px solid #2196F3 !important;
                background-color: rgba(33, 150, 243, 0.05) !important;
            }
        
            QLabel {
                font-size: 14px;
                color: #333;
                selection-background-color: #bbdefb;
                selection-color: #2C4952;
            }
        """

        # Store search state
        self._search_text = ""
        self._current_match_index = -1
        self._search_matches = []

        # **Retrieve the main window's screen**
        if main_window and main_window.windowHandle():
            screen = main_window.windowHandle().screen()
            print("[DEBUG] Retrieved screen from main_window.")
        else:
            print("[DEBUG] No main_window or windowHandle found. Using primary screen.")
            screen = QApplication.primaryScreen()

        if screen:
            print(f"[DEBUG] Current screen: {screen.name()}")
        else:
            print("[DEBUG] No screen associated with the dialog, using primary screen.")
            screen = QApplication.primaryScreen()

        screen_geometry = screen.availableGeometry()
        print(f"[DEBUG] Screen geometry: {screen_geometry}")
        print(f"[DEBUG] Screen width: {screen_geometry.width()}, Screen height: {screen_geometry.height()}")

        # Adjust the height and offset based on the resolution
        if screen_geometry.height() > 1900:
            print("[DEBUG] Screen height is greater than 1900, resizing dialog to height 1250.")
            self.resize(850, 1250)  # Larger height for very high resolution
            offset_x = 800
        elif screen_geometry.height() < 1200:
            print("[DEBUG] Screen height is less than 1200, resizing dialog to height 700.")
            self.resize(850, 800)  # Reduced height for lower resolution
            offset_x = 400
        else:
            print("[DEBUG] Screen height is between 1200 and 1900, resizing dialog to height 1000.")
            self.resize(850, 1000)  # Default height for mid-range resolution
            offset_x = 600

        # Store normal dimensions
        self._normal_width = self.width()
        self._normal_height = self.height()

        # Calculate center-left position with dynamic offset
        center_x = screen_geometry.left() + offset_x
        center_y = screen_geometry.top() + (screen_geometry.height() - self.height()) // 2
        self.move(center_x, center_y)

        self.setStyleSheet("""
            QDialog {
                background-color: #ffffff;
                border: 0px;
            }
    
            /* Add this style block for tooltips: */
            QToolTip {
                background-color: #ffffff;
                color: #000000;
                border: 1px solid #a0a0a0;
                padding: 4px;
                border-radius: 2px;
                font-size: 12px;
            }
            QLabel, QLineEdit {
                font-family: Segoe UI, sans-serif;
                font-size: 13px;
                color: #333;
            }
            QGroupBox {
                border: 0px solid #d0d0d0;
                outline: 0px;
                border-radius: 4px;
                margin-top: 5px;
                background: #ffffff;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top left;
                padding: 4px 10px;
                font-weight: bold;
            }
            QVBoxLayout(self) {
                border: 0px;
                outline: 0px;
            }
            QToolButton {
                background-color: #f5f5f5;
                border: 1px solid #e0e0e0;
                border-radius: 3px;
                color: #555;
                padding: 2px;
            }
            QToolButton:hover {
                background-color: #e5e5e5;
                border: 1px solid #ccc;
                color: #222;
                cursor: pointer;
            }
            QToolButton:pressed {
                background-color: #d0d0d0;
            }
            QToolButton::menu-indicator {
                image: none;
            }
            QMenu {
                background-color: white;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 6px 24px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #e3f2fd;
                color: #2C4952;
            }
            QMenu::separator {
                height: 1px;
                background: #e0e0e0;
                margin: 4px 0;
            }
            QLineEdit {
                padding: 4px 8px;
                padding-right: 54px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: #f5f5f5;
                font-size: 12px;
            }
            QLineEdit:focus {
                background: white;
                border-color: #2196F3;
            }
        """)

        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(5)
        main_layout.setContentsMargins(15, 5, 15, 15)

        right_container = QGroupBox()
        right_layout = QVBoxLayout(right_container)
        right_layout.setSpacing(8)
        right_layout.setContentsMargins(10, 5, 10, 10)

        # Create header layout with title and toolbar at opposite ends
        header_layout = QHBoxLayout()
        header_layout.setSpacing(2)
        header_layout.setContentsMargins(0, 0, 0, 5)  # Add bottom margin

        # Determine the display text based on file_name
        session_display = "New Session"
        if self.main_window.current_session_file:
            session_display = Path(self.main_window.current_session_file).stem

        # File Label (left aligned)
        self.file_label = QLabel(f"{session_display}")
        self.file_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        self.file_label.setStyleSheet("font-weight: bold; margin-left: 20px;")

        # --- MODIFICATION START ---
        # Use Expanding horizontal policy: Can grow, but importantly, CAN SHRINK below sizeHint.
        # Keep vertical policy as Preferred.
        self.file_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        # Add a tooltip to show the full name on hover, especially useful if elided.
        self.file_label.setToolTip(session_display)
        # Optional: Set a minimum width for the label itself if you want to guarantee
        # at least *some* part of it is always visible, though eliding should handle this.
        # self.file_label.setMinimumWidth(100) # Example: guarantee at least 100px
        # --- MODIFICATION END ---

        header_layout.addWidget(self.file_label)

        # Add stretch to push toolbar to the far right
        header_layout.addStretch(1)
    
        # Create compact toolbar container (right aligned)
        toolbar_container = QWidget()
        toolbar_container.setStyleSheet("background: transparent;")
        toolbar_layout = QHBoxLayout(toolbar_container)
        toolbar_layout.setSpacing(3)
        toolbar_layout.setContentsMargins(0, 0, 0, 0)
    
        # Create search container with internal navigation buttons
        search_container = QWidget()
        search_container.setLayout(QHBoxLayout())
        search_container.layout().setContentsMargins(0, 0, 0, 0)
        search_container.layout().setSpacing(0)
    
        # Create wider search bar
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("Search...")
        self.search_bar.setClearButtonEnabled(False)  # We'll add our own clear button
        self.search_bar.returnPressed.connect(self.search_storyboard)
        self.search_bar.setFixedWidth(180)  # Wider width
        self.search_bar.setFixedHeight(28)
        self.search_bar.setStyleSheet("""
            QLineEdit {
                padding: 4px 8px;
                padding-right: 54px;  /* Make room for navigation buttons */
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: #f5f5f5;
                font-size: 12px;
            }
            QLineEdit:focus {
                background: white;
                border-color: #2196F3;
            }
        """)
    
        # Connect text changed signal
        self.search_bar.textChanged.connect(self.on_text_changed)
    
        # Add search bar to container
        search_container.layout().addWidget(self.search_bar)
    
        # Create navigation buttons container that will be overlaid on the search bar
        nav_container = QWidget(self.search_bar)
        nav_container.setFixedSize(54, 26)
        nav_layout = QHBoxLayout(nav_container)
        nav_layout.setContentsMargins(0, 0, 0, 0)
        nav_layout.setSpacing(0)
    
        # Create left/right navigation buttons
        self.prev_button = QToolButton()
        self.prev_button.setText("◀")  # Left arrow
        self.prev_button.setFixedSize(18, 22)
        self.prev_button.setToolTip("Previous Match")
        self.prev_button.clicked.connect(self.search_previous)
        self.prev_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.prev_button.setStyleSheet("""
            QToolButton {
                background-color: transparent;
                border: none;
                color: #777;
                font-size: 10px;
            }
            QToolButton:hover {
                color: #333;
            }
            QToolButton:pressed {
                color: #000;
            }
        """)
    
        self.next_button = QToolButton()
        self.next_button.setText("▶")  # Right arrow
        self.next_button.setFixedSize(18, 22)
        self.next_button.setToolTip("Next Match")
        self.next_button.clicked.connect(self.search_next)
        self.next_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.next_button.setStyleSheet("""
            QToolButton {
                background-color: transparent;
                border: none;
                color: #777;
                font-size: 10px;
            }
            QToolButton:hover {
                color: #333;
            }
            QToolButton:pressed {
                color: #000;
            }
        """)
    
        # Add clear button
        self.clear_button = QToolButton()
        self.clear_button.setText("×")
        self.clear_button.setFixedSize(18, 22)
        self.clear_button.setToolTip("Clear Search")
        self.clear_button.clicked.connect(self.clear_search)
        self.clear_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.clear_button.setStyleSheet("""
            QToolButton {
                background-color: transparent;
                border: none;
                color: #b04040;
                font-size: 14px;
                font-weight: bold;
            }
            QToolButton:hover {
                color: #666;
            }
        """)
        self.clear_button.hide()  # Initially hidden
    
        # Add buttons to navigation layout
        nav_layout.addWidget(self.prev_button)
        nav_layout.addWidget(self.next_button)
        nav_layout.addWidget(self.clear_button)
    
        # Hide navigation buttons initially
        self.prev_button.hide()
        self.next_button.hide()
    
        # Position the navigation container to be inside the search bar at the right edge
        nav_container.move(self.search_bar.width() - nav_container.width() - 2, 1)
    
        # Create a single toolbar button with dropdown menu
        self.toolbar_button = QToolButton()
        self.toolbar_button.setText("☰")  
        self.toolbar_button.setFixedSize(28, 28)
        self.toolbar_button.setToolTip("")  # Clear default tooltip
        self.toolbar_button.installEventFilter(self)
        tooltip_palette = QPalette()
        tooltip_palette.setColor(QPalette.ColorRole.ToolTipBase, QColor("#f5f5f5"))
        tooltip_palette.setColor(QPalette.ColorRole.ToolTipText, QColor("#333333"))
        QToolTip.setPalette(tooltip_palette)


        self.toolbar_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.toolbar_button.setPopupMode(QToolButton.ToolButtonPopupMode.InstantPopup)
        self.toolbar_button.setStyleSheet("""
            QToolButton {
                background-color: #f5f5f5;
                border: 1px solid #e0e0e0;
                border-radius: 3px;
                color: #444;
                font-size: 18px;
                padding: 2px;
            }
            QToolButton:hover {
                background-color: #e8e8e8;
                border: 1px solid #ccc;
                color: #222;
            }
            QToolButton:pressed {
                background-color: #d0d0d0;
            }
            QToolButton::menu-indicator {
                image: none;
            }
        """)
    
        # Create dropdown menu
        self.tools_menu = QMenu(self)
    
        def create_unicode_icon(unicode_char, size=16):
            # Create a transparent pixmap
            pixmap = QPixmap(size, size)
            pixmap.fill(Qt.GlobalColor.transparent)
    
            # Use QPainter to draw the Unicode character
            painter = QPainter(pixmap)
    
            # Set font size proportional to the icon size
            font = QFont()
            font.setPointSize(int(size * 0.8))
            painter.setFont(font)
    
            painter.setPen(QColor('black'))
            # Center the text within the pixmap
            rect = pixmap.rect()
            painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, unicode_char)
            painter.end()
            return QIcon(pixmap)

        # Create PDF icon
        pdf_icon = create_unicode_icon("📄", 16)  # Document icon for PDF export

        # Add the PDF export action
        self.export_pdf_action = QAction(pdf_icon, "Export as PDF", self)
        self.export_pdf_action.triggered.connect(self.export_to_pdf)
        self.tools_menu.addAction(self.export_pdf_action)

        # The PDF export action should be placed before the clear action
        # So the menu order would be:
        # 1. Resize (Compact) 
        # 2. Create Divider
        # 3. Mark All Used
        # 4. Mark All Unused
        # 5. Export as PDF (new)
        # 6. Clear Script Editor

        # You can remove the existing menu creation and replace with this complete sequence:
        self.tools_menu = QMenu(self)

        # Create Unicode icons for the actions
        resize_icon = create_unicode_icon("\u2194", 20)         # ↔ for Resize
        refresh_icon = create_unicode_icon("↻", 18)             # ↻ for Refresh List
        divider_icon = create_unicode_icon("⎶", 18)            # ⎶ for Create Divider
        pdf_icon = create_unicode_icon("📄", 16)               # 📄 for Export as PDF
        clear_icon = create_unicode_icon("🗑", 16)              # 🗑 for Clear Script Editor

        # Create actions with the generated icons
        self.resize_action = QAction(resize_icon, "Resize (Compact)", self)
        self.resize_action.triggered.connect(self.toggle_compact_mode)
        self.tools_menu.addAction(self.resize_action)

        # Add the Refresh List action
        self.refresh_list_action = QAction(refresh_icon, "Refresh List", self)
        self.refresh_list_action.triggered.connect(self.refresh_order_list)
        self.tools_menu.addAction(self.refresh_list_action)

        # Add a separator between Refresh and Create Divider
        self.tools_menu.addSeparator()

        self.add_divider_action = QAction(divider_icon, "Create Divider", self)
        self.add_divider_action.triggered.connect(self.on_add_divider_clicked)
        self.tools_menu.addAction(self.add_divider_action)

        # Create filled and empty square icons for Mark All Used/Unused
        filled_icon = self.create_filled_green_square_icon(16)
        empty_icon = self.create_empty_square_outline_icon(16)

        # Add Mark All Used/Unused actions
        self.check_all_used_action = QAction(filled_icon, "Mark All Used", self)
        self.check_all_used_action.triggered.connect(lambda: self.set_all_used(True))
        self.tools_menu.addAction(self.check_all_used_action)

        self.uncheck_all_used_action = QAction(empty_icon, "Mark All Unused", self)
        self.uncheck_all_used_action.triggered.connect(lambda: self.set_all_used(False))
        self.tools_menu.addAction(self.uncheck_all_used_action)

        # Add a separator before TTS action
        self.tools_menu.addSeparator()

        # Add the new PDF export action
        self.export_pdf_action = QAction(pdf_icon, "Export as PDF", self)
        self.export_pdf_action.triggered.connect(self.export_to_pdf)
        self.tools_menu.addAction(self.export_pdf_action)

        # Add Copy Script Text action
        copy_script_icon = create_unicode_icon("📋", 16)  # Clipboard icon
        self.copy_script_text_action = QAction(copy_script_icon, "Copy Script Text", self)
        self.copy_script_text_action.triggered.connect(self.copy_script_text)
        self.tools_menu.addAction(self.copy_script_text_action)


        # This will hold the playback controls widget once created
        #self.tts_controls = None
        #self._current_tts_file = None

        # Ensure you already have self.tools_menu. If not, create it. 
        # Then add the new TTS action:
        #self.add_tts_action()

        # Add the Clear Script Editor action
        self.clear_action = QAction(clear_icon, "Clear Script Editor", self)
        self.clear_action.triggered.connect(self.clear_final_order)
        self.tools_menu.addAction(self.clear_action)

        # # Add test strikethrough action
        # self.test_strikethrough_action = QAction("Test Strikethrough Improvements", self)
        # self.test_strikethrough_action.triggered.connect(self.test_strikethrough_improvements)
        # self.tools_menu.addAction(self.test_strikethrough_action)

        # # Add the new refresh item display test action
        # self.test_refresh_action = QAction("Test Refresh Item Display", self)
        # self.test_refresh_action.triggered.connect(self.test_refresh_item_display)
        # self.tools_menu.addAction(self.test_refresh_action)

        # self.test_renumber_items_action = QAction("Test Renumber Items", self)
        # self.test_renumber_items_action.triggered.connect(self.test_renumber_items)
        # self.tools_menu.addAction(self.test_renumber_items_action)

        self.order_list = OrderListWidget(self.annotations, self)

        # Set the menu on the toolbar button
        self.toolbar_button.setMenu(self.tools_menu)

        # Create collapse button
        class CollapseIconButton(QPushButton):
            def __init__(self, normal_text="🟢", hover_text="🟡", parent=None):
                super().__init__(normal_text, parent)
                self.normal_text = normal_text
                self.hover_text = hover_text
                self.setObjectName("collapseButton")
                self.setFixedSize(28, 28)
                self.setToolTip("")
                self.setCursor(Qt.CursorShape.PointingHandCursor)
                self.setStyleSheet("""
                    QPushButton#collapseButton {
                        background-color: transparent;
                        border: none;
                        font-size: 18px;
                        padding: 0px;
                        margin: 0px;
                    }
                    QPushButton#collapseButton:hover {
                        background-color: rgba(0, 0, 0, 0.1);
                        border-radius: 14px;
                    }
                """)

            def enterEvent(self, event):
                self.setText(self.hover_text)
                super().enterEvent(event)

            def leaveEvent(self, event):
                self.setText(self.normal_text)
                super().leaveEvent(event)

        # Create collapse button instance
        self.collapse_button = CollapseIconButton()
        self.collapse_button.clicked.connect(self.collapse_to_widget)

        # Add widgets to toolbar layout
        toolbar_layout.addWidget(search_container)
        toolbar_layout.addSpacing(8)
        toolbar_layout.addWidget(self.toolbar_button)
        toolbar_layout.addSpacing(5)  # Small spacing between buttons
        toolbar_layout.addWidget(self.collapse_button)
    
        # Add the toolbar container to the header layout
        header_layout.addWidget(toolbar_container)
    
        # Add header layout to the main layout
        right_layout.addLayout(header_layout)

        # Create and add the OrderListWidget
        self.order_list.search_requested.connect(
            lambda text: self.main_window.handle_theme_search(text)
        )
        right_layout.addWidget(self.order_list, 1)
        
        # Set the base stylesheet with drag hover support after it's defined
        self.order_list.base_stylesheet = self.base_stylesheet
        self.order_list.setStyleSheet(self.base_stylesheet)

        main_layout.addWidget(right_container, 1)

        # Add shortcut for Ctrl+S to save and Ctrl+F to focus search
        self.save_shortcut = QShortcut(QKeySequence("Ctrl+S"), self)
        self.save_shortcut.activated.connect(self.handle_save_shortcut)
    
        self.search_shortcut = QShortcut(QKeySequence("Ctrl+F"), self)
        self.search_shortcut.activated.connect(lambda: self.search_bar.setFocus())

        # Add event filter for the entire dialog
        self.installEventFilter(self)
    
        # Add event filter to reposition navigation controls when search bar resizes
        self.search_bar.installEventFilter(self)

        # --- ADD MINIMUM SIZE ---
        # Set the minimum size for the dialog in its default state
        self.setMinimumSize(550, 550)
        print(f"[DEBUG] Initial minimum size set to 550x550")
        # --- END MINIMUM SIZE ---


        # Populate the order list
        self.populate_order_list_skip_partial_fallback()
    
        # Create the word count timer
        self.word_counter = WordCountTimer(self)
    
        # Configure search functionality and hook into existing methods
        self.setup_search_functionality()
        
        # Connect to annotation updates from theme view for sync
        if hasattr(self.main_window, 'web_view') and hasattr(self.main_window.web_view, 'annotation_updated'):
            self.main_window.web_view.annotation_updated.connect(self.handle_external_annotation_update)

    def _apply_visual_state(self, is_compact):
        """Applies visual settings (size, styles, labels) based on compact state."""
        print(f"[DEBUG] Applying visual state: is_compact={is_compact}")
        self._is_compact_mode = is_compact
        self.setUpdatesEnabled(False) # Prevent flicker during setup

        session_display = "New Session"
        if self.main_window.current_session_file:
            session_display = Path(self.main_window.current_session_file).stem

        if self._is_compact_mode:
            target_width = 550
            target_height = 550
            self.setMinimumSize(target_width, target_height)
            self.setMaximumSize(16777215, 16777215) # Unlock max

            truncated_display = session_display[:40] + ('...' if len(session_display) > 40 else '')
            self.file_label.setText(truncated_display)
            self.file_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.file_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            self.file_label.setToolTip(session_display)

            # Apply compact stylesheet for the list
            compact_stylesheet = """
                QListWidget {
                    background: #ffffff; border: 1px solid #ADADAD;
                    margin-left: 8px; margin-right: 8px; border-radius: 5px;
                    font-size: 16px; outline: none; padding: 5px; }
                QListWidget::item { background-color: #fafafa; border: 1px solid #e9ecef;
                    border-radius: 4px; margin: 2px 3px; min-height: 20px; }
                 /* Add selected/hover styles if needed */
                QListWidget::item:selected { background-color: #e3f2fd; border: 1px solid #90caf9; }
                QListWidget::item:hover:!selected { background-color: #f5f5f5; }
                QListWidget[dragHover="true"] {
                    border: 3px solid #2196F3 !important;
                    background-color: rgba(33, 150, 243, 0.05) !important;
                }
            """
            if hasattr(self.order_list, 'setStyleSheet'): # Ensure list exists
                self.order_list.setStyleSheet(compact_stylesheet)

            self.resize_action.setText("Resize (Default)")
            # Explicitly resize *after* setting constraints
            self.resize(target_width, target_height)

        else: # Apply Normal Mode state
            self.setMinimumSize(550, 550) # Normal minimum
            self.setMaximumSize(16777215, 16777215) # Unlock max

            self.file_label.setText(f"{session_display}")
            self.file_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
            self.file_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            self.file_label.setToolTip(session_display)

            # Restore the base stylesheet for the order list
            if hasattr(self.order_list, 'base_stylesheet') and hasattr(self.order_list, 'setStyleSheet'):
                 self.order_list.setStyleSheet(self.order_list.base_stylesheet)

            self.resize_action.setText("Resize (Compact)")
            # Let restored geometry handle the actual size, just ensure constraints are right

        QApplication.processEvents() # Process events before re-enabling updates
        self.setUpdatesEnabled(True)
        # Schedule layout updates to finalize appearance before showing
        QTimer.singleShot(50, self._update_layout_after_resize)
        QTimer.singleShot(100, self._verify_final_size)

    def refresh_order_list(self):
        """Completely destroy and recreate the storyboard dialog with minimal visual disruption."""
        print("\n--- Starting Storyboard Refresh ---")

        # Store the current dialog geometry and state for the new instance
        current_geometry = self.geometry()
        window_state = self.windowState()

        # Store any other important state variables
        is_compact_mode = getattr(self, '_is_compact_mode', False)
        print(f"[DEBUG] Stored state: Compact={is_compact_mode}, Geometry={current_geometry}, State={window_state}")

        # --- Prepare for closing the old dialog ---
        # Tell the main window we're closing but will recreate (to potentially skip save prompts)
        self.main_window.storyboard_recreating = True
        print("[DEBUG] storyboard_recreating flag SET")

        # Close the current dialog (this will clean up resources)
        print("[DEBUG] Closing old dialog instance...")
        self.close() # Relies on closeEvent handling the flag

        # --- Create and Prepare the NEW dialog ---
        print("[DEBUG] Creating new dialog instance...")
        # Pass delay_population=True to prevent automatic population in __init__
        new_dialog = StoryboardDialog(self.main_window, delay_population=True)
        print("[DEBUG] New dialog created.")

        # Restore geometry and state BEFORE showing
        print(f"[DEBUG] Applying geometry: {current_geometry}")
        new_dialog.setGeometry(current_geometry)
        print(f"[DEBUG] Applying window state: {window_state}")
        new_dialog.setWindowState(window_state)

        # Apply the correct visual style (compact or normal) BEFORE showing
        print(f"[DEBUG] Applying visual state (compact={is_compact_mode})...")
        new_dialog._apply_visual_state(is_compact_mode)

        # Populate the list in the new dialog BEFORE showing
        print("[DEBUG] Populating new dialog...")
        # Ensure the population method itself handles updates/overlay correctly
        new_dialog.populate_order_list_skip_partial_fallback()
        print("[DEBUG] Population complete.")

        # --- Finalize and Show ---
        # Replace the old dialog reference in the main window
        print("[DEBUG] Updating main window reference...")
        self.main_window.storyboard_dialog = new_dialog

        # Reset the recreating flag
        print("[DEBUG] Resetting storyboard_recreating flag.")
        self.main_window.storyboard_recreating = False

        # Show the fully prepared dialog
        print("[DEBUG] Showing new dialog...")
        new_dialog.show()
        new_dialog.raise_()
        new_dialog.activateWindow()
        print("[DEBUG] New dialog shown and activated.")

        # Show a brief status message
        self.main_window.status_bar.showMessage('Script Editor refreshed', 1000)
        print("--- Storyboard Refresh Complete ---\n")

        # Return the new dialog instance for any follow-up operations
        return new_dialog

    def test_renumber_items(self):
        """
        A simple test method that calls the renumber_items method on the OrderListWidget.
        After renumbering, it shows a message box reporting success and the total number
        of items in the list.
        """
        try:
            count_before = self.order_list.count()
            self.order_list.renumber_items_optimized(with_visual_updates=True, preserve_states=True)
            count_after = self.order_list.count()
            QMessageBox.information(
                self,
                "Test Renumber Items",
                f"Renumbered {count_after} items (was {count_before})."
            )
        except Exception as e:
            QMessageBox.critical(self, "Test Renumber Items", f"Error during test: {e}")


    def create_unicode_icon(self, unicode_char, size=16):
        # Create a transparent pixmap
        pixmap = QPixmap(size, size)
        pixmap.fill(Qt.GlobalColor.transparent)
    
        # Use QPainter to draw the Unicode character
        painter = QPainter(pixmap)
    
        # Set font size proportional to the icon size
        font = QFont()
        font.setPointSize(int(size * 0.8))
        painter.setFont(font)
    
        painter.setPen(QColor('black'))
        # Center the text within the pixmap
        rect = pixmap.rect()
        painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, unicode_char)
        painter.end()
        return QIcon(pixmap)


    def create_filled_green_square_icon(self,size=16):
        # Create a transparent pixmap
        pixmap = QPixmap(size, size)
        pixmap.fill(Qt.GlobalColor.transparent)
    
        # Draw a filled green square
        painter = QPainter(pixmap)
        painter.setBrush(QColor('green'))
        painter.setPen(Qt.PenStyle.NoPen)
        painter.drawRect(0, 0, size - 1, size - 1)
        painter.end()
        return QIcon(pixmap)

    def create_empty_square_outline_icon(self,size=16):
        # Create a transparent pixmap
        pixmap = QPixmap(size, size)
        pixmap.fill(Qt.GlobalColor.transparent)
    
        # Draw an empty square outline
        painter = QPainter(pixmap)
        pen = QPen(QColor('black'))
        pen.setWidth(1)  # Adjust the border width as needed
        painter.setPen(pen)
        painter.setBrush(Qt.BrushStyle.NoBrush)
        painter.drawRect(0, 0, size - 1, size - 1)
        painter.end()
        return QIcon(pixmap)

    def set_all_used(self, value):
        """
        Iterate over all non-divider items in the storyboard and set their used checkbox
        to True (if value is True) or False (if value is False), updating the underlying annotation.
        """
        # Track all affected annotation IDs
        updated_annotations = []
    
        # First pass: update checkboxes and collect annotation info
        for i in range(self.order_list.count()):
            item = self.order_list.item(i)
            widget = self.order_list.itemWidget(item)
            # Skip divider items
            if widget and hasattr(widget, 'is_divider') and widget.is_divider:
                continue
            if widget:
                used_checkbox = widget.findChild(CustomCheckBox)
                if used_checkbox:
                    used_checkbox.setChecked(value)
                    # Get annotation ID and update local data structure
                    annotation_id = item.data(Qt.ItemDataRole.UserRole)
                
                    # Find the annotation in our data model
                    annotation = None
                    for anno in self.main_window.web_view.annotations:
                        if anno.get('id') == annotation_id:
                            annotation = anno
                            # Update the annotation in the Python data structure
                            annotation['used'] = value
                            updated_annotations.append(annotation)
                            break
    
        # Emit update signals for all affected annotations
        for annotation in updated_annotations:
            annotation_id = annotation.get('id')
            update_payload = {
                'id': annotation_id,
                'text': annotation.get('text', ''),
                'used': value,  # The new used status
                'favorite': annotation.get('favorite', False),
                'notes': annotation.get('notes', ''),
                'notes_html': annotation.get('notes_html', ''),
                'tags': annotation.get('tags', []),
                'secondary_scenes': annotation.get('secondary_scenes', [])
            }
            print(f"DEBUG set_all_used: Emitting update payload for annotation {annotation_id}")
            self.main_window.web_view.annotation_updated.emit(json.dumps(update_payload))
            
            # Update visual state in storyboard dialog
            self.update_annotation_visual_state(annotation_id, "used", value, skip_theme_sync=True)
            print(f"DEBUG set_all_used: Updated visual state for {annotation_id} used={value}")
    
        # Force visual refresh of the order list
        self.order_list.update()
        print(f"DEBUG set_all_used: Triggered order list visual refresh")
    
        # Mark changes as pending globally
        self.changes_pending = True
        self.main_window.mark_changes_pending()
    
        # Apply changes to update any other states
        QTimer.singleShot(100, self.apply_changes_lite)
        
        # Trigger full filter refresh in DOM after bulk operation
        if hasattr(self.main_window.web_view, 'page'):
            refresh_js = """
            (function() {
                console.log('[DEBUG] Triggering filter refresh after Mark All Used/Unused');
                // Check if the sticky header filters are active
                if (typeof applyCombinedFilters === 'function') {
                    applyCombinedFilters();
                    console.log('[DEBUG] Applied combined filters after bulk used status change');
                } else if (typeof window.applyStickyHeaderFilters === 'function') {
                    window.applyStickyHeaderFilters();
                    console.log('[DEBUG] Applied sticky header filters after bulk used status change');
                } else {
                    console.log('[DEBUG] No filter refresh function found');
                }
            })();
            """
            self.main_window.web_view.page().runJavaScript(refresh_js)
    
        # Report success to the user
        action_text = "marked as used" if value else "marked as unused"
        self.main_window.status_bar.showMessage(f'All annotations {action_text}', 3000)


    def _ms_to_mins_secs(self, ms: int) -> str:
        """
        Convert milliseconds to a formatted timecode (MM:SS or H:MM:SS).
        """
        secs = ms // 1000
        s = secs % 60
        m = (secs // 60) % 60
        h = secs // 3600
        if h > 0:
            return f"{h:d}:{m:02d}:{s:02d}"
        else:
            return f"{m:02d}:{s:02d}"

    def reset_state(self):
        """Reset all state variables to ensure clean repopulation."""
        # Clear all lists and dictionaries
        self._search_text = ""
        self._current_match_index = -1
        self._search_matches = []
    
        # Clear any pending operations or flags
        if hasattr(self, '_is_closing'):
            self._is_closing = False
        if hasattr(self, '_in_critical_ui_update'):
            self._in_critical_ui_update = False
        if hasattr(self, '_population_in_progress'):
            self._population_in_progress = False
    
        # Reset OrderListWidget flags
        if hasattr(self, 'order_list'):
            if hasattr(self.order_list, '_in_population'):
                self.order_list._in_population = False
            if hasattr(self.order_list, '_suppress_resize_handling'):
                self.order_list._suppress_resize_handling = False
    
        # Reset overlay flags
        if hasattr(self, '_overlay_cleanup_ready'):
            self._overlay_cleanup_ready = True
    
        # # Reset other flags
        # self.changes_pending = False
    
        # Clear pending deletions
        if hasattr(self, '_pending_deletions'):
            self._pending_deletions.clear()
    
        # Clean up any existing overlay
        self._cleanup_existing_overlay(process_events=False)
        QApplication.processEvents()

# Inside class StoryboardDialog(QDialog):

    def toggle_compact_mode(self):
        """Toggle between normal and compact mode with resizable windows in both modes."""
        # Check if window is currently maximized
        is_maximized = bool(self.windowState() & Qt.WindowState.WindowMaximized)

        # Always determine the current screen first
        if is_maximized:
            # ... (screen detection logic when maximized - kept for brevity) ...
            current_screen = QApplication.screenAt(QCursor.pos()) # Simplified for example
            if not current_screen: current_screen = QApplication.primaryScreen()
            self._pre_unmaximize_screen = current_screen
            self.setWindowState(Qt.WindowState.WindowNoState)
            QApplication.processEvents()
        else:
            current_screen = QApplication.screenAt(self.geometry().center())
            if not current_screen: current_screen = QApplication.primaryScreen()
            self._pre_unmaximize_screen = current_screen

        screen_geometry = self._pre_unmaximize_screen.availableGeometry()

        # Toggle compact mode flag
        self._is_compact_mode = not self._is_compact_mode

        # Get session display info
        session_display = "New Session"
        if self.main_window.current_session_file:
            session_display = Path(self.main_window.current_session_file).stem

        if self._is_compact_mode:
            # --- Switch TO Compact Mode ---
            print("[DEBUG] Switching TO Compact Mode")
            self.setUpdatesEnabled(False)
            target_width = 550
            target_height = 550

            # Set minimum size FOR compact mode
            self.setMinimumSize(target_width, target_height)
            self.setMaximumSize(16777215, 16777215) # Unlock maximum size

            # Truncate the label (visual change for compact)
            truncated_display = session_display[:40] + ('...' if len(session_display) > 40 else '')
            self.file_label.setText(truncated_display)
            self.file_label.setAlignment(Qt.AlignmentFlag.AlignCenter) # Center in compact
            # Apply the Expanding policy FOR compact mode too, so it doesn't prevent shrinking
            self.file_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            self.file_label.setToolTip(session_display) # Ensure tooltip is set

            # Position calculation...
            if is_maximized:
                 new_x = screen_geometry.left() + (screen_geometry.width() - target_width) // 2
                 new_y = screen_geometry.top() + (screen_geometry.height() - target_height) // 2
            else:
                 # Adjust current position...
                 current_pos = self.geometry().topLeft(); new_x = current_pos.x(); new_y = current_pos.y()
                 if new_x + target_width > screen_geometry.right(): new_x = screen_geometry.right() - target_width
                 if new_x < screen_geometry.left(): new_x = screen_geometry.left()
                 if new_y + target_height > screen_geometry.bottom(): new_y = screen_geometry.bottom() - target_height
                 if new_y < screen_geometry.top(): new_y = screen_geometry.top()

            self.setGeometry(new_x, new_y, target_width, target_height)

            # Apply compact stylesheet for the list
            compact_stylesheet = """
                QListWidget {
                    background: #ffffff; border: 1px solid #ADADAD;
                    margin-left: 8px; margin-right: 8px; border-radius: 5px;
                    font-size: 16px; outline: none; padding: 5px; }
                QListWidget::item { background-color: #fafafa; border: 1px solid #e9ecef;
                    border-radius: 4px; margin: 2px 3px; min-height: 20px; }
                QListWidget::item:selected {
                    background-color: #e3f2fd;
                    border: 1px solid #90caf9;
                }
                QListWidget::item:hover:!selected {
                    background-color: #f5f5f5;
                }
                QListWidget[dragHover="true"] {
                    border: 3px solid #2196F3 !important;
                    background-color: rgba(33, 150, 243, 0.05) !important;
                }
                QLabel {
                    font-size: 14px;
                    color: #333;
                    selection-background-color: #bbdefb;
                    selection-color: #2C4952;
                }
            """
            self.order_list.setStyleSheet(compact_stylesheet)

            self.resize_action.setText("Resize (Default)")
            self.setUpdatesEnabled(True)
            print(f"[DEBUG] Switched to resizable compact mode.")

        else:
            # --- Switch BACK TO Normal Mode ---
            print("[DEBUG] Switching TO Normal Mode")
            self.setUpdatesEnabled(False)

            # Set the minimum size FOR normal mode
            self.setMinimumSize(550, 550) # <<< --- Set Normal Minimum Size
            self.setMaximumSize(16777215, 16777215) # Unlock maximum size
            QApplication.processEvents()

            # Determine the height based on screen resolution
            if screen_geometry.height() > 1900: new_height = 1250
            elif screen_geometry.height() < 1200: new_height = 800
            else: new_height = 1000
            new_width = 850

            # Restore the full label text and alignment
            self.file_label.setText(f"{session_display}")
            self.file_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter) # Align left

            # --- MODIFICATION START ---
            # Re-apply the Expanding policy FOR normal mode
            self.file_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            self.file_label.setToolTip(session_display) # Ensure tooltip is set
            # --- MODIFICATION END ---


            # Position calculation...
            if is_maximized: # If it *was* maximized before toggle
                new_x = screen_geometry.left() + (screen_geometry.width() - new_width) // 2
                new_y = screen_geometry.top() + (screen_geometry.height() - new_height) // 2
            else: # If it was normal, adjust current position...
                 current_pos = self.geometry().topLeft(); new_x = current_pos.x(); new_y = current_pos.y()
                 if new_x + new_width > screen_geometry.right(): new_x = screen_geometry.right() - new_width
                 if new_x < screen_geometry.left(): new_x = screen_geometry.left()
                 if new_y + new_height > screen_geometry.bottom(): new_y = screen_geometry.bottom() - new_height
                 if new_y < screen_geometry.top(): new_y = screen_geometry.top()

            self.setGeometry(new_x, new_y, new_width, new_height)

            # Restore the base stylesheet for the order list
            if hasattr(self.order_list, 'base_stylesheet'):
                 self.order_list.setStyleSheet(self.order_list.base_stylesheet)

            self.resize_action.setText("Resize (Compact)")
            self.setUpdatesEnabled(True)
            print(f"[DEBUG] Switched to normal mode.")

        # Force layout update after resize
        QTimer.singleShot(50, self._update_layout_after_resize)
        QTimer.singleShot(100, self._verify_final_size) # Keep verification

    def _verify_final_size(self):
        """Verify the final size and make corrections if needed, without fixing the size."""
        if self._is_compact_mode:
            # Define target dimensions for compact mode
            target_width = 550
            target_height = 550
            # Use a small tolerance in case of minor OS window manager variations
            tolerance = 5

            # Check if the current size deviates significantly from the target
            if abs(self.width() - target_width) > tolerance or abs(self.height() - target_height) > tolerance:
                print(f"[DEBUG] Compact size verification failed. Current: {self.width()}x{self.height()}, Target: {target_width}x{target_height}")

                # Use resize() to set the dimensions
                self.resize(target_width, target_height)

                # Ensure minimum size constraints are appropriate for compact mode
                # (toggle_compact_mode should have already set these, but reinforcing here is safe)
                self.setMinimumSize(target_width, target_height)

                # Ensure maximum size is unlocked to allow user resizing *larger*
                self.setMaximumSize(16777215, 16777215) # Qt's QWIDGETSIZE_MAX

                QApplication.processEvents() # Allow resize event to process
                print(f"[DEBUG] Resized to compact target: {self.width()}x{self.height()}")
            # Ensure min/max constraints are correct even if size was already okay
            else:
                 self.setMinimumSize(target_width, target_height)
                 self.setMaximumSize(16777215, 16777215)

        else:
            # For normal mode, ensure constraints allow resizing freely.
            # toggle_compact_mode handles setting these when switching *to* normal.
            # Just ensure the maximum size is unlocked here.
            self.setMaximumSize(16777215, 16777215)
            # Minimum size for normal mode could be 0,0 or a sensible default.
            # Relying on toggle_compact_mode to set minimums when switching is cleaner.
            # Optional: Set a reasonable minimum if needed: self.setMinimumSize(550, 550)

    def _enforce_target_size(self):
        """Enforce the target size after layout updates."""
        if hasattr(self, '_target_width') and hasattr(self, '_target_height'):
            current_width = self.width()
            current_height = self.height()
        
            if current_width != self._target_width or current_height != self._target_height:
                print(f"[DEBUG] Size mismatch after layout update. Current: {current_width}x{current_height}, Target: {self._target_width}x{self._target_height}")
            
                # For compact mode, use more aggressive measures
                if self._is_compact_mode:
                    # Clear any constraints that might be preventing resize
                    self.setMinimumSize(0, 0)
                    # Set fixed size to force the dimensions
                    self.setFixedSize(self._target_width, self._target_height)
                    print(f"[DEBUG] Applied fixed size: {self._target_width}x{self._target_height}")
                else:
                    # For normal mode, just apply the resize
                    self.resize(self._target_width, self._target_height)
                    # Remove any fixed size constraints - use Qt's maximum widget size constant
                    self.setFixedSize(16777215, 16777215)  # Qt's QWIDGETSIZE_MAX
                    print(f"[DEBUG] Applied normal resize: {self._target_width}x{self._target_height}")
                
                # Give a moment for resize to take effect
                QApplication.processEvents()
            
                # Final verification
                print(f"[DEBUG] Final size after enforcement: {self.width()}x{self.height()}")

    def _update_layout_after_resize(self):
        """Update layouts and resize text widgets after resize."""
        # Force layout update
        if self.layout():
            self.layout().invalidate()
            self.layout().activate()
        
        # Update OrderListWidget
        if hasattr(self, 'order_list') and self.order_list:
            self.order_list.updateGeometry()
            self.order_list.doItemsLayout()
            if hasattr(self.order_list, '_update_all_items_on_resize'):
                self.order_list._update_all_items_on_resize()

    def on_add_divider_clicked(self):
        """Handle the add divider button click."""
        self.order_list.add_divider_interactive()

    def clear_search(self):
        """Clear the search input and reset search state"""
        self.search_bar.clear()
        self._search_text = ""
        self._search_matches = []
        self._current_match_index = -1
        self.clear_button.hide()
        self.prev_button.hide()
        self.next_button.hide()
        self.order_list.clearSelection()

    def on_text_changed(self, text):
        """Handle search text changes"""
        self.current_search_text = text
        self.clear_button.setVisible(bool(text))
    
        # Show/hide navigation buttons based on search text
        nav_buttons_visible = bool(text)
        self.prev_button.setVisible(nav_buttons_visible)
        self.next_button.setVisible(nav_buttons_visible)
    
        # If text is empty, clear search results
        if not text:
            self._search_matches = []
            self._current_match_index = -1
            self.order_list.clearSelection()
    
        # If typing, queue a search after a brief delay
        if text:
            QTimer.singleShot(300, self.search_storyboard)

    def test_refresh_item_display(self):
        """Test the refresh_item_display method on selected items or all items."""
        # Get selected items
        selected_items = []
        for i in range(self.order_list.count()):
            item = self.order_list.item(i)
            if item.isSelected():
                selected_items.append(item)
    
        # Store current scroll position for restoration
        current_scroll_position = self.order_list.verticalScrollBar().value()
        print(f"[DEBUG] Current scroll position: {current_scroll_position}")
    
        # If no items selected, ask whether to process all items
        if not selected_items:
            reply = QMessageBox.question(
                self,
                'Test Refresh Item Display',
                'No items selected. Would you like to test refresh on all items?',
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
        
            if reply == QMessageBox.StandardButton.Yes:
                # Process all items
                items_processed = 0
                for i in range(self.order_list.count()):
                    item = self.order_list.item(i)
                    widget = self.order_list.itemWidget(item)
                
                    # Skip dividers
                    if widget and hasattr(widget, 'is_divider') and widget.is_divider:
                        continue
                    
                    # Process the item
                    anno_id = item.data(Qt.ItemDataRole.UserRole)
                    if anno_id:
                        print(f"\nProcessing item {i+1} with ID: {anno_id}")
                        self.order_list.refresh_item_display(anno_id)
                        items_processed += 1
            
                # Restore scroll position
                self.order_list.verticalScrollBar().setValue(current_scroll_position)
            
                QMessageBox.information(
                    self,
                    'Test Complete',
                    f'Refreshed display for {items_processed} items.'
                )
            else:
                # User chose not to process all items
                return
        else:
            # Process only selected items
            items_processed = 0
            for item in selected_items:
                widget = self.order_list.itemWidget(item)
            
                # Skip dividers
                if widget and hasattr(widget, 'is_divider') and widget.is_divider:
                    continue
                
                # Process the item
                anno_id = item.data(Qt.ItemDataRole.UserRole)
                if anno_id:
                    print(f"\nProcessing selected item with ID: {anno_id}")
                    self.order_list.refresh_item_display(anno_id)
                    items_processed += 1
        
            # Restore scroll position
            self.order_list.verticalScrollBar().setValue(current_scroll_position)
        
            QMessageBox.information(
                self,
                'Test Complete',
                f'Refreshed display for {items_processed} selected items.'
            )

    def search_storyboard(self):
        """Search for text in the storyboard items."""
        search_text = self.search_bar.text().strip().lower()
        self._search_text = search_text
    
        if not search_text:
            self._search_matches = []
            self._current_match_index = -1
            self.order_list.clearSelection()
            return
        
        # Find all matching items
        self._search_matches = []
        for i in range(self.order_list.count()):
            item = self.order_list.item(i)
            widget = self.order_list.itemWidget(item)
            if not widget:
                continue
            
            # Skip dividers
            if hasattr(widget, 'is_divider') and widget.is_divider:
                continue
            
            # Find the text label
            for label in widget.findChildren(QLabel):
                if label.objectName() == "main_content_label":
                    # Convert to plain text for comparison
                    text = label.text()
                    plain_text = re.sub(r'<[^>]+>', '', text).lower()
                
                    if search_text in plain_text:
                        self._search_matches.append((i, item))
                    break
    
        # Handle match results
        if self._search_matches:
            self._current_match_index = 0
            self._highlight_current_match()
            print(f"[DEBUG] Found {len(self._search_matches)} matches for '{search_text}'")
        else:
            self._current_match_index = -1
            self.order_list.clearSelection()
            print(f"[DEBUG] No matches found for '{search_text}'")

    def search_next(self):
        """Go to the next search match."""
        if not self._search_matches:
            return
        
        if self._current_match_index < len(self._search_matches) - 1:
            self._current_match_index += 1
        else:
            # Wrap around to the first match
            self._current_match_index = 0
        
        self._highlight_current_match()

    def test_strikethrough_improvements(self):
        """Simple test method to improve strikethroughs on all items."""
        print("\n=== TESTING STRIKETHROUGH IMPROVEMENTS ===")
    
        # Get current scroll position for later restoration
        current_scroll_position = self.order_list.verticalScrollBar().value()
        print(f"[DEBUG] Current scroll position: {current_scroll_position}")
    
        # Show a simple message box to indicate test is starting
        QMessageBox.information(
            self,
            "Strikethrough Test",
            "Testing strikethrough improvements on all items.\nCheck console for detailed output."
        )
    
        # Process all items
        total_items = self.order_list.count()
        items_processed = 0
    
        for i in range(total_items):
            item = self.order_list.item(i)
            if not item:
                continue
            
            widget = self.order_list.itemWidget(item)
            # Skip dividers
            if widget and hasattr(widget, 'is_divider') and widget.is_divider:
                continue
            
            annotation_id = item.data(Qt.ItemDataRole.UserRole)
            if annotation_id:
                print(f"\nProcessing item {i+1}/{total_items} with ID: {annotation_id}")
                self.order_list.improve_strikethrough_display(annotation_id)
                items_processed += 1
            
        # Restore scroll position
        self.order_list.verticalScrollBar().setValue(current_scroll_position)
    
        # Show results
        QMessageBox.information(
            self,
            "Strikethrough Test Complete",
            f"Processed {items_processed} of {total_items} items.\nCheck console for detailed output."
        )
    
        print(f"=== STRIKETHROUGH TEST COMPLETE: Processed {items_processed}/{total_items} items ===\n")

    def search_previous(self):
        """Go to the previous search match."""
        if not self._search_matches:
            return
        
        if self._current_match_index > 0:
            self._current_match_index -= 1
        else:
            # Wrap around to the last match
            self._current_match_index = len(self._search_matches) - 1
        
        self._highlight_current_match()

    def _highlight_current_match(self):
        """Select and scroll to the current search match."""
        if not self._search_matches or self._current_match_index < 0:
            return
        
        # Get the current match
        _, item = self._search_matches[self._current_match_index]
    
        # Clear current selection
        self.order_list.clearSelection()
    
        # Select and scroll to the item
        item.setSelected(True)
        self.order_list.scrollToItem(item, QAbstractItemView.ScrollHint.PositionAtCenter)

    def setup_search_functionality(self):
        """Configure search functionality and hook into existing methods."""
        # Hook into key methods that change content
        if hasattr(self.order_list, 'add_strikethrough'):
            original_add_strikethrough = self.order_list.add_strikethrough
        
            def add_strikethrough_with_search_update(*args, **kwargs):
                result = original_add_strikethrough(*args, **kwargs)
                # Update search if active
                if self._search_text:
                    QTimer.singleShot(100, self.search_storyboard)
                return result
        
            self.order_list.add_strikethrough = add_strikethrough_with_search_update
        
        # Similarly, hook into other content-changing methods
        if hasattr(self.order_list, 'save_text'):
            original_save_text = self.order_list.save_text
        
            def save_text_with_search_update(*args, **kwargs):
                result = original_save_text(*args, **kwargs)
                # Update search if active
                if self._search_text:
                    QTimer.singleShot(100, self.search_storyboard)
                return result
        
            self.order_list.save_text = save_text_with_search_update

    def initialize_word_count_timer(self):
        """Initialize the word count timer in StoryboardDialog."""
        self.word_counter = WordCountTimer(self)

    # Add the word counter update call to key methods that modify content
    def update_word_counter_hooks(self):
        """Add calls to update the word counter to key methods."""
        # Store original methods
        original_apply_changes = self.apply_changes
        original_apply_changes_lite = self.apply_changes_lite
    
        # Wrapper for apply_changes
        def apply_changes_with_word_count(*args, **kwargs):
            result = original_apply_changes(*args, **kwargs)
            if hasattr(self, 'word_counter'):
                self.word_counter.update_word_count()
            return result
    
        # Wrapper for apply_changes_lite
        def apply_changes_lite_with_word_count(*args, **kwargs):
            result = original_apply_changes_lite(*args, **kwargs)
            if hasattr(self, 'word_counter'):
                self.word_counter.update_word_count()
            return result
    
        # Replace the methods
        self.apply_changes = apply_changes_with_word_count
        self.apply_changes_lite = apply_changes_lite_with_word_count

    def handle_save_shortcut(self):
        """Handle Ctrl+S shortcut by saving the session"""
        print("Save shortcut triggered from StoryboardDialog")
        if hasattr(self.main_window, 'save_session'):
            self.main_window.save_session()
        else:
            print("Warning: save_session method not found on main window")

    def changeEvent(self, event):
        if self.is_temp_for_save:
            return  # Skip all event processing for temporary dialogs
        
        """Handle window state changes with proper monitor tracking"""
        if event.type() == QEvent.Type.WindowStateChange:
            # Skip processing if the dialog isn't fully visible
            if not self.isVisible():
                super().changeEvent(event)
                return
            
            old_state = event.oldState()
            new_state = self.windowState()
        
            # Check if main window is minimized to determine if this is a manual action
            main_window_minimized = False
            if hasattr(self, 'main_window') and self.main_window:
                main_window_minimized = bool(self.main_window.windowState() & Qt.WindowState.WindowMinimized)
        
            # CASE 1: Window is being minimized
            if (new_state & Qt.WindowState.WindowMinimized) and not (old_state & Qt.WindowState.WindowMinimized):
                # If main window is not minimized, this is a manual minimize by the user
                if not main_window_minimized:
                    print("[DEBUG] Storyboard dialog is being MANUALLY minimized by user")
                    self.is_manually_minimized = True
                else:
                    print("[DEBUG] Storyboard dialog is being auto-minimized with main window")
                
                # Store current window info before minimizing
                self._was_maximized_before_minimize = bool(old_state & Qt.WindowState.WindowMaximized)
            
                # Save screen information along with geometry
                self._pre_minimize_screen = QApplication.screenAt(self.geometry().center())
                if not self._pre_minimize_screen:
                    self._pre_minimize_screen = QApplication.primaryScreen()
            
                # Save geometry (for normal state restoration)
                if not self._was_maximized_before_minimize:
                    self._normal_geometry = self.geometry()
        
            # CASE 2: Window is being restored from minimized
            elif (old_state & Qt.WindowState.WindowMinimized) and not (new_state & Qt.WindowState.WindowMinimized):
                # If this was manually minimized and now being manually restored
                if self.is_manually_minimized:
                    print("[DEBUG] Storyboard dialog is being manually restored from minimized state")
                    self.is_manually_minimized = False  # Reset the flag
            
                # Make it invisible immediately but don't prevent default restoration
                self.setWindowOpacity(0.0)
            
                # Use custom restoration that preserves screen
                self._custom_restore_from_minimized()
            
        super().changeEvent(event)

    def _custom_restore_from_minimized(self):
        """Special handler for restoring from minimized with monitor awareness"""
        # Skip if dialog isn't fully initialized or visible
        if not self.isVisible():
            return
        
        # We're already invisible thanks to the opacity setting
        # Schedule the restore operation
        QTimer.singleShot(10, self._perform_restore_from_minimized)


    def _perform_restore_from_minimized(self):
        """Handle the actual state restoration after minimized with enhanced debugging"""
        # Skip if dialog isn't fully initialized or visible
        if not self.isVisible():
            return
        
        # Add flag to suppress resize handling during restoration
        self._suppress_resize_handling = True
        print("\n=== START RESTORE FROM MINIMIZED ===")
    
        try:
            # Get the target screen from saved info or use current screen
            target_screen = getattr(self, '_pre_minimize_screen', None)
            if not target_screen:
                target_screen = QApplication.screenAt(self.geometry().center())
            if not target_screen:
                target_screen = QApplication.primaryScreen()
        
            # Get screen geometry
            screen_geometry = target_screen.availableGeometry()
        
            # Check if we were maximized before minimizing
            was_maximized = getattr(self, '_was_maximized_before_minimize', False)
        
            # Now handle the restore based on previous state
            if was_maximized:
                # First, ensure we're in normal state
                self.showNormal()
                QApplication.processEvents()
            
                # Move to the target screen with a specific position
                normal_rect = QRect(
                    screen_geometry.x() + 100,  # Position on target screen
                    screen_geometry.y() + 100,
                    800,  # Use fixed size to avoid layout issues
                    600
                )
            
                self.setGeometry(normal_rect)
                QApplication.processEvents()
            
                # Then maximize
                self.setWindowState(Qt.WindowState.WindowMaximized)
                QApplication.processEvents()
            
            elif hasattr(self, '_normal_geometry') and self._normal_geometry.isValid():
                # Show normal first
                self.showNormal()
                QApplication.processEvents()
            
                # Get saved geometry
                saved_geom = self._normal_geometry
            
                # Ensure it's on the correct screen
                if not screen_geometry.contains(saved_geom.center()):
                    # Move to target screen while maintaining size
                    saved_geom = QRect(
                        screen_geometry.x() + (screen_geometry.width() - saved_geom.width()) // 2,
                        screen_geometry.y() + (screen_geometry.height() - saved_geom.height()) // 2,
                        saved_geom.width(),
                        saved_geom.height()
                    )
            
                # Apply the geometry
                self.setGeometry(saved_geom)
                QApplication.processEvents()
            else:
                # Show normal first
                self.showNormal()
                QApplication.processEvents()
            
                # Center on screen with current size
                default_geom = QRect(
                    screen_geometry.x() + (screen_geometry.width() - self.width()) // 2,
                    screen_geometry.y() + (screen_geometry.height() - self.height()) // 2,
                    self.width(),
                    self.height()
                )
                self.setGeometry(default_geom)
                QApplication.processEvents()
        
            # Schedule layout update after state is restored
            QTimer.singleShot(150, self._finalize_restore)
        except Exception as e:
            print(f"ERROR during restore: {e}")
            import traceback
            print(traceback.format_exc())
            # Ensure we clear the suppression flag even if there's an error
            QTimer.singleShot(300, self._clear_suppression)
            # Make the window visible again even if there's an error
            self.setWindowOpacity(1.0)
    
        print("=== END RESTORE FROM MINIMIZED ===\n")

    def _apply_delayed_height_adjustment(self):
        """Apply height adjustment after window state has settled."""
        if hasattr(self, '_adjusted_height_after_restore'):
            new_height = self._adjusted_height_after_restore
            print(f"[DEBUG] Applying delayed height adjustment to {new_height}")
        
            # Only resize if not maximized
            if not (self.windowState() & Qt.WindowState.WindowMaximized):
                self.resize(self.width(), new_height)
            
            # Clean up
            delattr(self, '_adjusted_height_after_restore')
        
            # Make sure OrderListWidget updates properly
            if hasattr(self, 'order_list') and self.order_list:
                QTimer.singleShot(50, self.order_list._update_all_items_on_resize)

    def _safe_maximize(self):
        """Safely maximize window and ensure it actually fills the screen"""
        # Skip if dialog isn't fully initialized or visible
        if not self.isVisible():
            return
        
        print("Performing safe maximize")
        try:
            # First, get the target screen again
            target_screen = QApplication.screenAt(self.geometry().center())
            if not target_screen:
                target_screen = QApplication.primaryScreen()
        
            print(f"Maximizing on screen: {target_screen.name()}")
        
            # Force the window to maximize properly using different approach
            # First clear any window state
            self.setWindowState(Qt.WindowState.WindowNoState)
            QApplication.processEvents()
        
            # Then explicitly set the maximized state
            self.setWindowState(Qt.WindowState.WindowMaximized)
            QApplication.processEvents()
        
            # Double-check if maximized correctly
            if not (self.windowState() & Qt.WindowState.WindowMaximized):
                print("Fallback: Using showMaximized()")
                self.showMaximized()
                QApplication.processEvents()
        
            # Verify the result
            is_maximized = bool(self.windowState() & Qt.WindowState.WindowMaximized)
            screen_size = target_screen.availableGeometry()
            window_size = self.geometry()
            print(f"Is window state maximized: {is_maximized}")
            print(f"Screen size: {screen_size.width()}x{screen_size.height()}")
            print(f"Window size: {window_size.width()}x{window_size.height()}")
        
            # If window still isn't properly maximized, try once more with geometry
            if is_maximized and (window_size.width() < screen_size.width() * 0.9 or 
                                window_size.height() < screen_size.height() * 0.9):
                print("Window appears to be in maximized state but not properly sized!")
                print("Forcing proper maximization...")
            
                # Remove maximize state temporarily
                self.setWindowState(Qt.WindowState.WindowNoState)
                QApplication.processEvents()
            
                # Move to center of screen first
                self.setGeometry(
                    screen_size.x(),
                    screen_size.y(),
                    screen_size.width(),
                    screen_size.height()
                )
                QApplication.processEvents()
            
                # Now maximize again
                self.setWindowState(Qt.WindowState.WindowMaximized)
                QApplication.processEvents()
        except Exception as e:
            print(f"Error during safe maximize: {e}")
            import traceback
            print(traceback.format_exc())

    def export_to_pdf(self):
        """Export the Script Editor content to a PDF file and then open it in the PDF Cropper."""
        # Import all required modules at the beginning to avoid scope issues
        import os
        import re
        import shutil
        import tempfile
        default_filename = "Script_Editor_Export.pdf"
        if hasattr(self.main_window, 'current_session_file') and self.main_window.current_session_file:
            base_name = os.path.splitext(os.path.basename(self.main_window.current_session_file))[0]
            default_filename = f"{base_name}_Script.pdf"

        # Get the user's documents directory or home directory as a safer default
        # Get the user's documents directory or home directory as a safer default
        try:
            # Use standard os.path instead of pathlib
            import os
            if os.name == 'nt':  # Windows
                import winreg
                with winreg.OpenKey(winreg.HKEY_CURRENT_USER, 
                                   r"Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders") as key:
                    documents_dir = winreg.QueryValueEx(key, "Personal")[0]
            else:  # macOS, Linux, etc.
                documents_dir = os.path.join(os.path.expanduser("~"), "Documents")
    
            # Make sure it exists
            if not os.path.isdir(documents_dir):
                documents_dir = os.path.expanduser("~")  # Fall back to home directory
        except:
            # Fall back to current directory
            documents_dir = os.getcwd()

        # Ask user to select DPI
        dpi_dialog = QDialog(self)
        dpi_dialog.setWindowTitle("Select PDF Resolution")
        dpi_dialog.setFixedWidth(300)
    
        layout = QVBoxLayout(dpi_dialog)
    
        # Create radio buttons for DPI options
        label = QLabel("Select PDF resolution (DPI):")
        layout.addWidget(label)
    
        dpi_72 = QRadioButton("72 DPI (Standard, smaller file)")
        dpi_96 = QRadioButton("96 DPI (Better quality)")
        dpi_150 = QRadioButton("150 DPI (High quality, larger file)")
    
        # Set 72 DPI as default
        dpi_72.setChecked(True)
    
        layout.addWidget(dpi_72)
        layout.addWidget(dpi_96)
        #layout.addWidget(dpi_150)
    
        # Add buttons
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        button_box.accepted.connect(dpi_dialog.accept)
        button_box.rejected.connect(dpi_dialog.reject)
        layout.addWidget(button_box)
    
        # Show dialog
        if dpi_dialog.exec() != QDialog.DialogCode.Accepted:
            return  # User canceled
    
        # Get selected DPI
        selected_dpi = 72  # Default
        if dpi_96.isChecked():
            selected_dpi = 96
        elif dpi_150.isChecked():
            selected_dpi = 150

        # Open a file dialog to select where to save the PDF
        while True:  # Loop to allow retry with different location
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Export as PDF",
                os.path.join(documents_dir, default_filename),
                "PDF Files (*.pdf)"
            )

            if not file_path:
                return  # User canceled the dialog

            # Add .pdf extension if not present
            if not file_path.lower().endswith('.pdf'):
                file_path += '.pdf'
    
            # Check directory permissions
            save_dir = os.path.dirname(file_path)
            if not os.access(save_dir, os.W_OK):
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Icon.Warning)
                msg.setWindowTitle("Permission Error")
                msg.setText(f"Cannot write to the selected directory: {save_dir}")
                msg.setInformativeText("Would you like to select a different location?")
                msg.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
                if msg.exec() == QMessageBox.StandardButton.Yes:
                    continue  # Try again with a different location
                else:
                    return  # User decided to cancel
    
            # If directory is writable, break out of the retry loop
            break

        # Create a temporary file path
        temp_file = None
        try:
            # Create a temporary file for the PDF
            fd, temp_path = tempfile.mkstemp(suffix='.pdf')
            os.close(fd)  # Close the file descriptor immediately
            temp_file = temp_path
    
            # Create a printer object set to generate a PDF to the temporary file
            printer = QPrinter()
            printer.setOutputFormat(QPrinter.OutputFormat.PdfFormat)
            printer.setOutputFileName(temp_path)

            # Set smaller margins to maximize space (in points - 72 points = 1 inch)
            printer.setPageMargins(QMarginsF(10, 10, 10, 10))
    
            # Set paper size and orientation
            printer.setPageSize(QPageSize(QPageSize.PageSizeId.A4))
    
            # Always use portrait orientation
            page_layout = printer.pageLayout()
            page_layout.setOrientation(QPageLayout.Orientation.Portrait)
            printer.setPageLayout(page_layout)
    
            # Set to the selected DPI
            printer.setResolution(selected_dpi)
    
            # Create and set up the document
            document = QTextDocument()
            document.setDocumentMargin(0)
    
            # Make the document use the full page
            page_rect = printer.pageRect(QPrinter.Unit.Point)
            document.setPageSize(QSizeF(page_rect.width(), page_rect.height()))
    
            # Set default font and size (slightly smaller for better fit)
            # Changed from Arial to Helvetica for better Adobe Acrobat compatibility
            default_font = QFont("Helvetica", 10)
            document.setDefaultFont(default_font)
    
            # Create a cursor to build the document content
            cursor = QTextCursor(document)
    
            # Center alignment for title and dividers, but annotations will be left-aligned
            default_block_format = QTextBlockFormat()
            default_block_format.setAlignment(Qt.AlignmentFlag.AlignCenter)
            cursor.setBlockFormat(default_block_format)
    
            # Add a title
            title_format = QTextBlockFormat()
            title_format.setAlignment(Qt.AlignmentFlag.AlignCenter)
            cursor.insertBlock(title_format)
    
            title_char_format = QTextCharFormat()
            title_char_format.setFont(QFont("Helvetica", 14, QFont.Weight.Bold))  # Changed from Arial
            cursor.insertText("Scriptoria Export", title_char_format)
    
            # Add session name if available
            if hasattr(self.main_window, 'current_session_file') and self.main_window.current_session_file:
                cursor.insertBlock(title_format)
                session_name = os.path.splitext(os.path.basename(self.main_window.current_session_file))[0]
                subtitle_char_format = QTextCharFormat()
                subtitle_char_format.setFont(QFont("Helvetica", 12))  # Changed from Arial
                cursor.insertText(f"Session: {session_name}", subtitle_char_format)
    
            cursor.insertBlock()  # Add spacing, but only one line

    
            # Create standard paragraph format - center aligned with smaller margins
            para_format = QTextBlockFormat()
            para_format.setTextIndent(0)
            para_format.setAlignment(Qt.AlignmentFlag.AlignCenter)
            para_format.setTopMargin(4)
            para_format.setBottomMargin(4)
    
            # Get an initial count of items to process
            total_items = self.order_list.count()
    
            # Process each item in the order list
            items_processed = 0
            for i in range(self.order_list.count()):
                item = self.order_list.item(i)
                widget = self.order_list.itemWidget(item)
        
                if not widget:
                    continue
        
                items_processed += 1
        
                # Handle dividers
                if hasattr(widget, 'is_divider') and widget.is_divider:
                    cursor.insertBlock()
            
                    # Get divider text and color
                    divider_label = widget.findChild(QLabel)
                    divider_text = divider_label.text() if divider_label else "DIVIDER"
            
                    # Get color from stylesheet
                    color = QColor("#fff4c9")  # Default yellow
                    if divider_label:
                        stylesheet = divider_label.styleSheet()
                        match = re.search(r"background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);", stylesheet)
                        if match:
                            color = QColor(match.group(1))
            
                    # Create a block format for the divider - centered
                    divider_format = QTextBlockFormat()
                    divider_format.setAlignment(Qt.AlignmentFlag.AlignCenter)
                    divider_format.setBackground(color)
                    # Reduced margins between dividers
                    divider_format.setTopMargin(4)  # Reduced from 8
                    divider_format.setBottomMargin(4)  # Reduced from 8
            
                    # Use minimal margins
                    divider_format.setLeftMargin(10)  # Reduced from 20
                    divider_format.setRightMargin(10)  # Reduced from 20
            
                    cursor.insertBlock(divider_format)
            
                    # Create a character format for the divider text
                    divider_char_format = QTextCharFormat()
                    divider_char_format.setFont(QFont("Helvetica", 12, QFont.Weight.Bold))  # Changed from Arial
                    divider_char_format.setForeground(QColor("black"))
            
                    cursor.insertText(divider_text, divider_char_format)
                    cursor.insertBlock(para_format)  # Add spacing after divider
                    continue
        
                # For regular annotation items
                text_label = None
                for label in widget.findChildren(QLabel):
                    if label.objectName() == "main_content_label":
                        text_label = label
                        break
            
                if not text_label:
                    continue
        
                # Get item number
                number_label = None
                for label in widget.findChildren(QLabel):
                    if label.text().endswith(".") and label.text()[:-1].isdigit():
                        number_label = label
                        break
            
                item_number = number_label.text() if number_label else f"{i+1}."
        
                # Check if "used" is checked
                used_checkbox = widget.findChild(CustomCheckBox)
                is_used = used_checkbox.isChecked() if used_checkbox else False
        
                # Check if item is favorite
                favorite_label = None
                for child in widget.children():
                    if isinstance(child, QLabel) and child.objectName() == "favorite_label":
                        favorite_label = child
                        break
                is_favorite = favorite_label.text() == "★" if favorite_label else False
        
                # Create a block format for the annotation item - left aligned
                annotation_format = QTextBlockFormat()
                annotation_format.setAlignment(Qt.AlignmentFlag.AlignLeft)
                annotation_format.setLeftMargin(15)
                annotation_format.setRightMargin(15)
                cursor.insertBlock(annotation_format)
        
                # Create the annotation header
                header_text = f"{item_number} "
                if is_favorite:
                    header_text += "★ "
        
                # Format for the header
                header_char_format = QTextCharFormat()
                header_char_format.setFont(QFont("Helvetica", 10, QFont.Weight.Bold))  # Changed from Arial
                cursor.insertText(header_text, header_char_format)
        
                # Get the HTML content
                html_content = text_label.text()
        
                # Handle strikethrough formatting
                has_strikethrough = '<s style=\"color:#FF9999;\">' in html_content
                if has_strikethrough:
                    # Find all strikethrough segments
                    clean_html = re.sub(r'<s style=(?:\"|\')color:#FF9999;(?:\"|\')\>|</s>', '', html_content)
                    strike_positions = []

                    for match in re.finditer(r'<s style=\"color:#FF9999;\">(.*?)</s>', html_content, re.DOTALL):
                        strike_text = match.group(1)
                        clean_text = re.sub(r'<[^>]+>', '', clean_html)
    
                        for pos in range(len(clean_text)):
                            if pos + len(strike_text) <= len(clean_text) and clean_text[pos:pos+len(strike_text)] == strike_text:
                                strike_positions.append((pos, pos+len(strike_text)))

                    # Insert content with strikethrough
                    plain_text = re.sub(r'<[^>]+>', '', html_content)

                    for i, char in enumerate(plain_text):
                        is_strike = any(start <= i < end for start, end in strike_positions)
    
                        char_format = QTextCharFormat()
                        char_format.setFont(QFont("Helvetica", 10))  # Changed from Arial
    
                        if is_strike:
                            char_format.setFontStrikeOut(True)
                            char_format.setForeground(QColor("#FF7F7F"))  # Make strikethrough text red
    
                        cursor.insertText(char, char_format)
                else:
                    # No strikethrough, insert plain text
                    plain_text = re.sub(r'<[^>]+>', '', html_content)
                    content_format = QTextCharFormat()
                    content_format.setFont(QFont("Helvetica", 10))  # Changed from Arial
                    cursor.insertText(plain_text, content_format)
        
                # Add less spacing after each item
                cursor.insertBlock(para_format)
    
            # Set document text width to match page width minus margins
            document.setTextWidth(page_rect.width())
    
            # Auto-scale content to fit on one page if needed
            # First check if content would exceed one page
            doc_size = document.size().height()
            page_height = page_rect.height()
    
            if doc_size > page_height:
                # Calculate scale factor needed
                scale_factor = page_height / doc_size * 0.95  # 5% safety margin
        
                # Create a new document with scaled content
                scaled_document = QTextDocument()
                scaled_document.setDocumentMargin(0)
                scaled_document.setPageSize(QSizeF(page_rect.width(), page_rect.height()))
        
                # Apply scaling transformation
                painter = QPainter()
                if painter.begin(printer):
                    painter.scale(scale_factor, scale_factor)
                    document.drawContents(painter)
                    painter.end()
                else:
                    # If scaling fails, proceed with normal rendering
                    print("Warning: Could not apply scaling. Document may exceed one page.")
                    document.setTextWidth(page_rect.width())
    
            # Print debug info
            print(f"Processing PDF export with {items_processed} items")
            print(f"Page size: {page_rect.width()}x{page_rect.height()} points")
            print(f"Orientation: Portrait")
            print(f"Resolution: {selected_dpi} DPI")
            print(f"PDF will be initially saved to temporary file: {temp_path}")
    
            # Use QPainter to render the document
            painter = QPainter()
            success = painter.begin(printer)
    
            if not success:
                raise Exception("QPainter failed to begin painting on the printer")
    
            try:
                # Draw the document contents to fill the entire page
                document.drawContents(painter)
        
                # End the painter
                painter.end()
        
                # Check if temporary file was created successfully
                if not os.path.exists(temp_path) or os.path.getsize(temp_path) == 0:
                    raise Exception("Temporary PDF file was not created or is empty")
            
                # Try to copy the temporary file to the final location
                try:
                    shutil.copy2(temp_path, file_path)
                    print(f"PDF successfully copied from {temp_path} to {file_path}")
                    self.main_window.status_bar.showMessage(f'PDF exported successfully to {file_path}', 5000)
    
                    # Define a callback to open the PDF automatically when the cropper finishes
                    def on_cropper_finish(saved_path):
                        """Called when the PDF Cropper finishes and closes"""
                        if not saved_path or not os.path.exists(saved_path):
                            return
            
                        # Open the PDF directly with the system's default PDF viewer
                        try:
                            # Use platform-specific method to open the PDF
                            import platform
                            import subprocess
            
                            if platform.system() == 'Windows':
                                os.startfile(saved_path)
                            elif platform.system() == 'Darwin':  # macOS
                                subprocess.call(('open', saved_path))
                            else:  # Linux and others
                                subprocess.call(('xdg-open', saved_path))
                        except Exception as e:
                            print(f"Error opening PDF with default viewer: {e}")
                            QMessageBox.warning(
                                self,
                                "Open Error",
                                f"Could not open the PDF with the default viewer: {str(e)}"
                            )
    
                    # Just open the cropper directly without asking
                    try:
                        # Import the required modules if not already imported
                        import fitz  # PyMuPDF
        
                        # Create the PDF Cropper as an independent window with callback
                        self.pdf_cropper = SimplePDFCropper(on_finish_callback=on_cropper_finish)
        
                        # --- Start: Positioning Logic ---
                        # Get the screen the StoryboardDialog is currently on
                        storyboard_center_global = self.mapToGlobal(self.rect().center())
                        target_screen = QApplication.screenAt(storyboard_center_global)
                        if not target_screen:
                            print("[DEBUG] Could not determine screen from storyboard center, using primary screen.")
                            target_screen = QApplication.primaryScreen()

                        print(f"[DEBUG] Target screen for cropper: {target_screen.name()}")

                        # Get the available geometry of the target screen
                        screen_geometry = target_screen.availableGeometry()
                        print(f"[DEBUG] Target screen available geometry: {screen_geometry}")

                        # Get the cropper's intended size (using its default geometry from init_ui)
                        cropper_width = 1000 # Default width from SimplePDFCropper.setGeometry
                        cropper_height = 900 # Default height from SimplePDFCropper.setGeometry
                        print(f"[DEBUG] Cropper intended size: {cropper_width}x{cropper_height}")

                        # Calculate the top-left position for centering
                        center_x = screen_geometry.left() + (screen_geometry.width() - cropper_width) // 2
                        center_y = screen_geometry.top() + (screen_geometry.height() - cropper_height) // 2
                        # Ensure it's not positioned off-screen (e.g., if cropper is larger than screen)
                        center_x = max(screen_geometry.left(), center_x)
                        center_y = max(screen_geometry.top(), center_y)
                        print(f"[DEBUG] Calculated center position for cropper: ({center_x}, {center_y})")

                        # Move the cropper to the calculated position BEFORE showing it
                        self.pdf_cropper.move(center_x, center_y)
                        # --- End: Positioning Logic ---

                        # Set proper window flags (ensure this is done if not in SimplePDFCropper.__init__)
                        self.pdf_cropper.setWindowFlags(
                             Qt.WindowType.Window |
                             Qt.WindowType.WindowSystemMenuHint |
                             Qt.WindowType.WindowMinMaxButtonsHint |
                             Qt.WindowType.WindowCloseButtonHint
                        )

                        # Show the cropper
                        self.pdf_cropper.show()
                        self.pdf_cropper.raise_()
                        self.pdf_cropper.activateWindow() # Ensure it gets focus

                        # Open the PDF file that was just saved
                        # Use a QTimer to ensure the cropper window is fully initialized before loading
                        QTimer.singleShot(200, lambda: self.pdf_cropper.open_pdf_file(file_path)) # Slightly increased delay

        
                    except ImportError as e:
                        QMessageBox.warning(
                            self, 
                            "Module Missing",
                            f"Could not open PDF Cropper: {str(e)}\n\n"
                            f"Make sure that PyMuPDF (fitz) is installed."
                        )
                    except Exception as e:
                        QMessageBox.warning(
                            self, 
                            "PDF Cropper Error",
                            f"Could not open PDF in the cropper: {str(e)}"
                        )
                except Exception as e:
                    raise Exception(f"Failed to copy PDF to final location: {str(e)}")
            
            except Exception as e:
                # Make sure to end the painter if an error occurs
                if painter.isActive():
                    painter.end()
                raise e
        
        except Exception as e:
            print(f"PDF export error: {str(e)}")
            QMessageBox.critical(
                self, 
                "PDF Export Error",
                f"Failed to create PDF: {str(e)}\n\n"
                f"If this is a permission error, try saving to a different location such as your Documents folder."
            )
    
        finally:
            # Clean up the temporary file
            if temp_file and os.path.exists(temp_file):
                try:
                    os.remove(temp_file)
                    print(f"Temporary file {temp_file} removed")
                except:
                    print(f"Warning: Could not remove temporary file {temp_file}")

    def copy_script_text(self):
        """Copy script text with filtering rules: exclude number labels, notes, 
        strikethrough text, bold/highlighted text (headers), and replace dividers with line breaks."""
        try:
            script_text_parts = []
            current_paragraph = []
            
            for i in range(self.order_list.count()):
                item = self.order_list.item(i)
                widget = self.order_list.itemWidget(item)
                
                if not widget:
                    continue
                
                # Handle dividers - replace with line break to separate paragraphs
                if hasattr(widget, 'is_divider') and widget.is_divider:
                    if current_paragraph:
                        # Join current paragraph and add to script_text_parts
                        paragraph_text = ' '.join(current_paragraph).strip()
                        if paragraph_text:
                            script_text_parts.append(paragraph_text)
                        current_paragraph = []
                    continue
                
                # Get the text directly from the QLabel widget (which contains the formatted HTML with strikethrough)
                text_label = widget.findChild(QLabel, "main_content_label")
                if not text_label:
                    continue
                
                # Get the HTML text directly from the QLabel (this includes strikethrough formatting)
                display_text = text_label.text()
                
                if not display_text:
                    continue
                
                # Get the annotation ID for reference (but don't use annotation data for text)
                annotation_id = item.data(Qt.ItemDataRole.UserRole)
                
                # Process the text according to filtering rules
                processed_text = self._process_text_for_copy(display_text, annotation_id)
                
                if processed_text.strip():
                    current_paragraph.append(processed_text.strip())
            
            # Don't forget the last paragraph
            if current_paragraph:
                paragraph_text = ' '.join(current_paragraph).strip()
                if paragraph_text:
                    script_text_parts.append(paragraph_text)
            
            # Join all paragraphs with double line breaks
            final_script_text = '\n\n'.join(script_text_parts)
            
            if final_script_text.strip():
                # Copy to clipboard
                clipboard = QApplication.clipboard()
                clipboard.setText(final_script_text)
                
                # Show confirmation dialog
                word_count = len(final_script_text.split())
                char_count = len(final_script_text)
                
                confirmation_msg = QMessageBox(self)
                confirmation_msg.setWindowTitle("Script Text Copied")
                confirmation_msg.setIcon(QMessageBox.Icon.Information)
                confirmation_msg.setText("Script text has been successfully copied to clipboard!")
                confirmation_msg.setInformativeText(f"• {word_count} words\n• {char_count} characters\n\nThe text is ready to paste in other applications.")
                confirmation_msg.setStandardButtons(QMessageBox.StandardButton.Ok)
                confirmation_msg.exec()
                
                # Also show in status bar
                self.main_window.status_bar.showMessage(f"Script text copied to clipboard ({word_count} words)", 5000)
                print("Script text copied to clipboard successfully")
            else:
                # Show warning if no text to copy
                QMessageBox.information(self, "Copy Script Text", "No text available to copy after applying filters.")
                
        except Exception as e:
            print(f"Error copying script text: {e}")
            QMessageBox.warning(self, "Copy Error", f"Failed to copy script text: {str(e)}")
    
    def _process_text_for_copy(self, text, annotation_id):
        """Process text according to filtering rules:
        - Remove strikethrough text
        - Remove bold/highlighted text (headers)
        - Convert HTML to plain text
        """
        import re
        
        processed_text = text
        
        # Remove strikethrough text with smart spacing and punctuation handling
        def replace_strikethrough_with_spacing(match):
            # Get the text before and after the strikethrough
            start_pos = match.start()
            end_pos = match.end()
            
            char_before = processed_text[start_pos - 1] if start_pos > 0 else ''
            char_after = processed_text[end_pos] if end_pos < len(processed_text) else ''
            
            # If there's no space between strikethrough and next non-whitespace character, add one
            if (char_before and not char_before.isspace() and 
                char_after and not char_after.isspace() and 
                char_after not in '.,!?;:'):
                return ' '
            return ''
        
        # Apply strikethrough removal with spacing logic
        processed_text = re.sub(r'<s style="color:#FF9999;">.*?</s>', replace_strikethrough_with_spacing, processed_text, flags=re.DOTALL)
        processed_text = re.sub(r"<s style='color:#FF9999;'>.*?</s>", replace_strikethrough_with_spacing, processed_text, flags=re.DOTALL)
        processed_text = re.sub(r'<s[^>]*>.*?</s>', replace_strikethrough_with_spacing, processed_text, flags=re.DOTALL)
        
        # Remove header text (bold text) - look for various bold patterns
        # Remove <b> tags and their content
        processed_text = re.sub(r'<b[^>]*>.*?</b>', '', processed_text, flags=re.DOTALL)
        # Remove <strong> tags and their content  
        processed_text = re.sub(r'<strong[^>]*>.*?</strong>', '', processed_text, flags=re.DOTALL)
        # Remove text with bold styling
        processed_text = re.sub(r'<[^>]*font-weight:\s*bold[^>]*>.*?</[^>]*>', '', processed_text, flags=re.DOTALL)
        
        # Remove highlighted text (text with background colors or highlighting)
        processed_text = re.sub(r'<[^>]*background-color[^>]*>.*?</[^>]*>', '', processed_text, flags=re.DOTALL)
        processed_text = re.sub(r'<mark[^>]*>.*?</mark>', '', processed_text, flags=re.DOTALL)
        
        # Remove any remaining HTML tags to get plain text
        processed_text = re.sub(r'<[^>]+>', '', processed_text)
        
        # Clean up double punctuation marks
        # Handle periods, commas, semicolons, colons, exclamation marks, question marks
        processed_text = re.sub(r'\.{2,}', '.', processed_text)  # Multiple periods to single
        processed_text = re.sub(r',{2,}', ',', processed_text)   # Multiple commas to single
        processed_text = re.sub(r';{2,}', ';', processed_text)   # Multiple semicolons to single
        processed_text = re.sub(r':{2,}', ':', processed_text)   # Multiple colons to single
        processed_text = re.sub(r'!{2,}', '!', processed_text)   # Multiple exclamation marks to single
        processed_text = re.sub(r'\?{2,}', '?', processed_text)  # Multiple question marks to single
        
        # Handle mixed punctuation combinations
        processed_text = re.sub(r'[.,;:!?]{3,}', '.', processed_text)  # Multiple mixed punctuation to single period
        processed_text = re.sub(r'([.,;:!?])\s*\1+', r'\1', processed_text)  # Remove duplicate punctuation with spaces
        
        # Clean up extra whitespace
        processed_text = re.sub(r'\s+', ' ', processed_text)
        processed_text = processed_text.strip()
        
        return processed_text

    def _refresh_all_strikethroughs(self):
        """Ensure all strikethroughs are properly displayed after window state changes"""
        # Temporarily clear the _is_closing flag if it was incorrectly set
        was_closing = getattr(self, '_is_closing', False)
        self._is_closing = False
    
        try:
            # Process all items in the order list
            for i in range(self.order_list.count()):
                item = self.order_list.item(i)
                if item:
                    annotation_id = item.data(Qt.ItemDataRole.UserRole)
                    if annotation_id:
                        self.order_list.improve_strikethrough_display(annotation_id, skip_partial_fallback=True)
        finally:
            # Restore the flag to its previous state
            self._is_closing = was_closing

    def _finalize_restore(self):
        """Complete the restoration process after window states have settled"""
        # Skip if dialog isn't fully initialized or visible
        if not self.isVisible():
            return
        
        print("\n=== FINALIZING RESTORE ===")
        try:
            # Update layouts
            if self.layout():
                self.layout().invalidate()
                self.layout().activate()
        
            # Update OrderListWidget
            if hasattr(self, 'order_list') and self.order_list:
                print("Updating OrderListWidget layout")
                self.order_list.updateGeometry()
                self.order_list.doItemsLayout()
                if hasattr(self.order_list, '_update_all_items_on_resize'):
                    self.order_list._update_all_items_on_resize()
        
            # Force a repaint
            self.update()
        
            # CRITICAL: Make the window visible again!
            print("Making window visible again")
            self.setWindowOpacity(1.0)
        
            # Important: Ensure the window is properly raised to foreground
            self.activateWindow()
            self.raise_()
        except Exception as e:
            print(f"Error finalizing restore: {e}")
            # Make the window visible again even if there's an error
            self.setWindowOpacity(1.0)
        finally:
            # Finally clear the suppression flag
            QTimer.singleShot(50, self._clear_suppression)
            print("=== END FINALIZING RESTORE ===\n")

    def _make_window_visible(self):
        """Make the window visible again after all layout updates are complete"""
        print("Making window visible")
        self.clearMask()  # Remove the mask
        self.setWindowOpacity(1.0)  # Restore opacity
        self.update()  # Final update

    def _clear_suppression(self):
        """Clear the resize suppression flag"""
        print("Clearing resize suppression flag")
        self._suppress_resize_handling = False

    def _ensure_proper_layout(self):
        """Make sure the window layout is properly updated"""
        # Force layout updates
        if self.layout():
            self.layout().invalidate()
            self.layout().activate()
    
        # Update OrderListWidget
        if hasattr(self, 'order_list') and self.order_list:
            self.order_list.updateGeometry()
            self.order_list.doItemsLayout()
        
            # Ensure items are properly sized
            if hasattr(self.order_list, '_update_all_items_on_resize'):
                self.order_list._update_all_items_on_resize()
    
        # Force a repaint
        self.update()

    def ensure_visible_on_screen(self, screen_geometry):
        """Ensure the window is fully visible on the current screen."""
        # Skip if dialog isn't fully initialized or visible
        if not self.isVisible():
            return
        
        window_geometry = self.geometry()
    
        # Check if window is outside screen bounds
        if not screen_geometry.contains(window_geometry.center()):
            print("[DEBUG] Window not fully visible on screen, adjusting position")
        
            # Center on screen if completely outside
            if (window_geometry.right() < screen_geometry.left() or 
                window_geometry.left() > screen_geometry.right() or
                window_geometry.bottom() < screen_geometry.top() or
                window_geometry.top() > screen_geometry.bottom()):
            
                new_x = screen_geometry.x() + (screen_geometry.width() - window_geometry.width()) // 2
                new_y = screen_geometry.y() + (screen_geometry.height() - window_geometry.height()) // 2
                self.move(new_x, new_y)
                print(f"[DEBUG] Centered window at ({new_x}, {new_y})")
            else:
                # Just adjust position to keep window fully visible
                adjusted_x = max(screen_geometry.left(), min(window_geometry.x(), 
                                screen_geometry.right() - window_geometry.width()))
                adjusted_y = max(screen_geometry.top(), min(window_geometry.y(), 
                                screen_geometry.bottom() - window_geometry.height()))
            
                if adjusted_x != window_geometry.x() or adjusted_y != window_geometry.y():
                    self.move(adjusted_x, adjusted_y)
                    print(f"[DEBUG] Adjusted window position to ({adjusted_x}, {adjusted_y})")

    def moveEvent(self, event):
        """Handle window movement, including when moving between monitors, with refined resizing logic."""
        super().moveEvent(event)

        # Skip if window is maximized, minimized, being manually hidden,
        # not visible, or if dialog was created temporarily for saving
        if (self.windowState() & (Qt.WindowState.WindowMaximized | Qt.WindowState.WindowMinimized) or
                getattr(self, 'is_manually_hidden', False) or
                not self.isVisible()):
            return

        # Get the current screen - safely handle potential None
        current_screen = QApplication.screenAt(self.geometry().center())
        if not current_screen:
            return

        # Get screen geometry early
        screen_geometry = current_screen.availableGeometry()

        # Check if screen has changed
        if hasattr(self, '_last_screen') and self._last_screen == current_screen:
             # Even if screen didn't change, ensure visibility
             self.ensure_visible_on_screen(screen_geometry)
             return # Return if same screen

        # Store the new screen
        self._last_screen = current_screen
        print(f"[DEBUG] Moved to new screen: {current_screen.name()}")
        print(f"[DEBUG] New screen geometry: {screen_geometry}")
        current_width = self.width()
        current_height = self.height()
        print(f"[DEBUG] Current window dimensions: {current_width}x{current_height}")

        # --- Height Adjustment Logic (Only runs if NOT in compact mode) ---
        # Determine potential new height based on resolution
        potential_new_height = current_height # Default to current height
        if screen_geometry.height() > 1900:
            potential_new_height = 1250
        elif screen_geometry.height() < 1200:
            potential_new_height = 800
        else:
            potential_new_height = 1000

        # --- Apply New Resizing Conditions ---
        should_resize = False
        final_new_height = current_height # Start assuming no resize needed

        if potential_new_height == 800:
            if current_height > 800:
                should_resize = True
                final_new_height = 800
                print(f"[DEBUG] Condition Met: Target 800, Current > 800. Resizing down.")
            else:
                print(f"[DEBUG] Condition Skip: Target 800, Current <= 800. No resize.")
        elif potential_new_height == 1000:
            if current_height >= 800:
                 # Only resize if the height is actually different
                 if current_height != 1000:
                     should_resize = True
                     final_new_height = 1000
                     print(f"[DEBUG] Condition Met: Target 1000, Current >= 800. Resizing.")
                 else:
                     print(f"[DEBUG] Condition Skip: Target 1000, Current is already 1000. No resize.")
            else: # current_height < 800
                print(f"[DEBUG] Condition Skip: Target 1000, Current < 800. No resize.")
        elif potential_new_height == 1250:
             # Apply similar logic: only resize up if current height is >= 1000
             if current_height >= 1000:
                 # Only resize if the height is actually different
                 if current_height != 1250:
                     should_resize = True
                     final_new_height = 1250
                     print(f"[DEBUG] Condition Met: Target 1250, Current >= 1000. Resizing.")
                 else:
                     print(f"[DEBUG] Condition Skip: Target 1250, Current is already 1250. No resize.")
             else: # current_height < 1000
                print(f"[DEBUG] Condition Skip: Target 1250, Current < 1000. No resize.")
        else:
             # If potential_new_height is somehow the same as current, no need to resize
             if potential_new_height == current_height:
                 print(f"[DEBUG] Condition Skip: Target height ({potential_new_height}) is same as current. No resize.")
             else:
                 # This case shouldn't normally be hit with the current logic, but acts as a fallback
                 should_resize = True
                 final_new_height = potential_new_height
                 print(f"[DEBUG] Condition Fallback: Target {potential_new_height}, resizing.")


        # --- Perform Resize (if needed) ---
        if should_resize:
            print(f"[DEBUG] Attempting to resize window to {current_width}x{final_new_height}")
            self.setUpdatesEnabled(False)
            # Use the final_new_height determined by the conditions
            QTimer.singleShot(0, lambda height=final_new_height: self._force_resize(current_width, height))
            QTimer.singleShot(100, lambda height=final_new_height: self._verify_resize(height))
        # --- End of Height Adjustment Logic ---

        # Ensure window is fully visible on the new screen (runs regardless of resize decision)
        self.ensure_visible_on_screen(screen_geometry)

    def _force_resize(self, width, height):
        """Force resize with multiple approaches to ensure it takes effect."""
        # Skip if dialog isn't fully initialized or visible
        if not self.isVisible():
            return
        
        # First try standard resize
        self.resize(width, height)
    
        # Then try with fixed size temporarily
        self.setMinimumHeight(height)
        self.setMaximumHeight(height)
    
        # Force layout update
        if self.layout():
            self.layout().invalidate()
            self.layout().activate()
    
        # Update order list if it exists
        if hasattr(self, 'order_list') and self.order_list:
            self.order_list.updateGeometry()
            self.order_list.doItemsLayout()
    
        # Force repaint
        self.update()
    
        # Reset constraints after short delay
        QTimer.singleShot(50, lambda: self._reset_size_constraints())
    
        # Re-enable updates
        self.setUpdatesEnabled(True)
    
        print(f"[DEBUG] Applied resize: current size is {self.width()}x{self.height()}")

    def _reset_size_constraints(self):
        """Reset minimum and maximum size constraints."""
        self.setMinimumHeight(100)  # Set to a reasonable minimum
        self.setMaximumHeight(16777215)  # QWIDGETSIZE_MAX
        print(f"[DEBUG] Size constraints reset")

    def _verify_resize(self, target_height):
        """Verify the resize operation worked correctly."""
        # Skip if dialog isn't fully initialized or visible
        if not self.isVisible():
            return
        
        current_height = self.height()
        print(f"[DEBUG] Resize verification: target={target_height}, actual={current_height}")
    
        if abs(current_height - target_height) > 5:  # Allow small margin of error
            print(f"[DEBUG] Resize didn't take effect properly, trying again")
            self._force_resize(self.width(), target_height)

    def mousePressEvent(self, event):
        """Handle mouse press events and deselect if no specific child widget is clicked."""
        print("[DEBUG] StoryboardDialog mousePressEvent triggered")

        # Check if the click is inside the OrderListWidget
        if self.order_list.geometry().contains(self.mapFromGlobal(event.globalPosition().toPoint())):
            print("[DEBUG] Click inside OrderListWidget")
        
            # Find the clicked position relative to OrderListWidget
            clicked_position = self.order_list.mapFromGlobal(event.globalPosition().toPoint())
            clicked_item = self.order_list.itemAt(clicked_position)
            if clicked_item:
                print(f"[DEBUG] Clicked on item: {clicked_item.text() or '<No Text>'}")
            
                # Check for specific child widgets within the item's widget
                item_widget = self.order_list.itemWidget(clicked_item)
                if item_widget:
                    print("[DEBUG] Clicked item's widget details:")
                    found_child = False
                    for child in item_widget.findChildren(QWidget):
                        child_rect = child.geometry()
                        if child_rect.contains(clicked_position - item_widget.pos()):
                            print(f"- Clicked on child widget: {type(child).__name__}, Geometry: {child_rect}")
                            found_child = True
                            break
                    if not found_child:
                        print("[DEBUG] No specific child widget clicked within the item's widget. Clearing selection...")
                        self.order_list.clearSelection()
                else:
                    print("[DEBUG] Clicked item has no associated widget. Clearing selection...")
                    self.order_list.clearSelection()
            else:
                print("[DEBUG] Click was not on an item in OrderListWidget. Clearing selection...")
                self.order_list.clearSelection()
        else:
            print("[DEBUG] Click outside OrderListWidget. Clearing selection...")
            self.order_list.clearSelection()

        super().mousePressEvent(event)

    def eventFilter(self, source, event):
        # Skip complex event filtering operations if not visible
        if not self.isVisible() and hasattr(event, 'type') and event.type() in [
            QEvent.Type.MouseButtonPress, QEvent.Type.WindowActivate,
            QEvent.Type.Move, QEvent.Type.Resize
        ]:
            return super().eventFilter(source, event)
    
        # Add custom tooltip handling for toolbar button (Action Menu)
        if source == self.toolbar_button:
            if event.type() == QEvent.Type.Enter:
                # Create tooltip label if it doesn't exist
                if not hasattr(self, 'custom_tooltip'):
                    self.custom_tooltip = QLabel(self)
                    self.custom_tooltip.setText("Action Menu")
                    self.custom_tooltip.setStyleSheet("""
                        background-color: #f5f5f5;
                        color: #333333;
                        border: 1px solid #a0a0a0;
                        border-radius: 2px;
                        padding: 2px 4px;  /* Reduced padding */
                        font-size: 10px;   /* Smaller font size */
                    """)
                    self.custom_tooltip.adjustSize()
            
                # Position tooltip near the button
                button_pos = self.toolbar_button.mapToGlobal(QPoint(0, 0))
                tooltip_x = button_pos.x() - self.custom_tooltip.width() // 2 + self.toolbar_button.width() // 2
                tooltip_y = button_pos.y() + self.toolbar_button.height() + 3  # Reduced offset
                self.custom_tooltip.move(self.mapFromGlobal(QPoint(tooltip_x, tooltip_y)))
                self.custom_tooltip.show()
        
            elif event.type() == QEvent.Type.Leave:
                # Hide tooltip when mouse leaves
                if hasattr(self, 'custom_tooltip'):
                    self.custom_tooltip.hide()

        # Handle search bar resize to reposition navigation controls
        if source == self.search_bar and event.type() == QEvent.Type.Resize:
            nav_container = None
            for child in self.search_bar.children():
                if isinstance(child, QWidget) and child.layout() and child.layout().count() == 3:
                    nav_container = child
                    break
    
            if nav_container:
                nav_container.move(self.search_bar.width() - nav_container.width() - 2, 1)

        # Handle mouse clicks for deselection
        if event.type() == QEvent.Type.MouseButtonPress:
            if not self.order_list.geometry().contains(self.mapFromGlobal(event.globalPosition().toPoint())):
                self.order_list.clearSelection()

        # Handle main window activation
        if source == self.main_window and event.type() == QEvent.Type.WindowActivate:
            self.raise_()
    
        return super().eventFilter(source, event)


    def get_ordered_annotations(self):
        """Get annotations with their storyboard states, order, and include dividers."""
        ordered_annotations = []
        for i in range(self.order_list.count()):
            item = self.order_list.item(i)
            anno_id = item.data(Qt.ItemDataRole.UserRole)

            # Find the original annotation
            annotation = next((a for a in self.annotations if a.get('id') == anno_id), None)
        
            # Check if the item is a divider
            widget = self.order_list.itemWidget(item)
            if widget and hasattr(widget, 'is_divider') and widget.is_divider:
                label = widget.findChild(QLabel)
                if label:
                    # Extract text and color from the divider
                    text = label.text()
                    color = "yellow"  # Default color
                    stylesheet = label.styleSheet()
                    match = re.search(r"background-color: (#[a-fA-F0-9]{6}|[a-zA-Z]+);", stylesheet)
                    if match:
                        color = match.group(1)
                
                    # Add the divider to the ordered list
                    ordered_annotations.append({
                        "id": anno_id or str(uuid.uuid4()),  # Ensure unique ID
                        "text": text,
                        "color": color,
                        "divider": True,
                        "order": i
                    })
                continue  # Skip further processing for dividers

            if annotation:
                # Copy the annotation to avoid modifying the original
                anno_copy = annotation.copy()
        
                # Get text and notes from the widget
                if widget:
                    # Find the text label (not the drag handle)
                    text_label = None
                    notes_label = None
                    labels = widget.findChildren(QLabel)
                    if len(labels) > 1:  # First is drag handle, second is text
                        text_label = labels[1]
                        if len(labels) > 2:  # Last one might be notes
                            notes_label = labels[-1]
            
                    if text_label:
                        current_text = text_label.text()
                        current_notes = ""
                        if notes_label and notes_label.text().startswith("Note: "):
                            current_notes = notes_label.text()[6:]  # Remove "Note: " prefix
                    
                        # Get strikethrough state
                        is_strikethrough = text_label.font().strikeOut()
                    
                        # Only create storyboard state if needed
                        needs_storyboard = (
                            current_text != annotation['text'] or 
                            current_notes != annotation.get('notes', '') or
                            is_strikethrough
                        )
                    
                        if needs_storyboard:
                            anno_copy['storyboard'] = {
                                'text': current_text,
                                'notes': current_notes,
                                'order': i,
                                'strikethrough': is_strikethrough
                            }
                        elif 'storyboard' in anno_copy:
                            # Remove storyboard state if not needed
                            del anno_copy['storyboard']
                
                ordered_annotations.append(anno_copy)

        return ordered_annotations


    def clear_final_order(self):
        reply = QMessageBox.question(
            self,
            'Clear Script Editor',
            'Are you sure you want to delete all items in the Script Editor?',
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.order_list.clear()
            dialog = self.window()
            if isinstance(dialog, StoryboardDialog):
                print("Setting changes_pending after external drop")  # Debug
                dialog.changes_pending = True
                QTimer.singleShot(100, self.apply_changes_lite)

    # Modify the populate_order_list method to preserve scroll position

    def _trigger_tags_positioning(self):
        """Trigger tags positioning and truncation for all items after population"""
        try:
            # Process all items in the order list to position tags correctly
            for i in range(self.order_list.count()):
                item = self.order_list.item(i)
                widget = self.order_list.itemWidget(item)
                if not widget:
                    continue
                if hasattr(widget, 'is_divider') and widget.is_divider:
                    continue
                
                # Run the same tags positioning logic as in resizeEvent
                available_width = self.order_list.get_available_text_width()
                for child in widget.children():
                    if isinstance(child, QLabel) and child.property('is_tags_widget'):
                        # Check if there's a speech title that would reduce available space for tags
                        speech_title_width = 0
                        for sibling in widget.children():
                            if isinstance(sibling, QWidget) and sibling != child:
                                # Look for speech title container widget (contains the speech title label)
                                if hasattr(sibling, 'layout') and sibling.layout():
                                    for j in range(sibling.layout().count()):
                                        layout_item = sibling.layout().itemAt(j)
                                        if layout_item and layout_item.widget():
                                            potential_label = layout_item.widget()
                                            if isinstance(potential_label, QLabel) and potential_label.text() and potential_label.text() != "add tags" and not potential_label.property('is_tags_widget'):
                                                # This looks like a speech title label
                                                speech_title_width = sibling.sizeHint().width() + 20  # Use container width + padding
                                                break
                                    if speech_title_width > 0:
                                        break
                        
                        # Calculate maximum width for tags (90% of available width, minus speech title width)
                        base_tags_width = int(available_width * 0.90)
                        max_tags_width = max(100, base_tags_width - speech_title_width)  # Ensure minimum width
                        
                        # Get the original tags from stored property, fallback to current text
                        original_tags_text = child.property('original_tags_text')
                        if not original_tags_text:
                            # If no stored original, use current text and store it
                            original_tags_text = child.text()
                            child.setProperty('original_tags_text', original_tags_text)
                        
                        # Always start from the original full tags text
                        child.setText(original_tags_text)
                        child.adjustSize()
                        tags_width = child.sizeHint().width()
                        tags_height = child.sizeHint().height()
                        
                        # Truncate tags if they exceed 90% of available width
                        if tags_width > max_tags_width:
                            font_metrics = child.fontMetrics()
                            
                            # Parse tags from the original text (remove # prefix and split by comma)
                            tags_list = [tag.strip().lstrip('#') for tag in original_tags_text.split(',')]
                            
                            # Find how many tags fit within the available width
                            truncated_text = ""
                            visible_count = 0
                            
                            for j, tag in enumerate(tags_list):
                                tag_text = f"#{tag}"
                                if j == 0:
                                    test_text = tag_text
                                else:
                                    test_text = f"{truncated_text}, {tag_text}"
                                
                                # Reserve space for "...(X)" if needed
                                remaining_tags = len(tags_list) - j - 1
                                if remaining_tags > 0:
                                    ellipsis_text = f"...({remaining_tags})"
                                    test_width = font_metrics.boundingRect(test_text + ellipsis_text).width()
                                else:
                                    test_width = font_metrics.boundingRect(test_text).width()
                                
                                if test_width <= max_tags_width:
                                    truncated_text = test_text
                                    visible_count = j + 1
                                else:
                                    break
                            
                            # Add "...(X)" if there are hidden tags
                            hidden_count = len(tags_list) - visible_count
                            if hidden_count > 0:
                                final_text = f"{truncated_text}...({hidden_count})"
                            else:
                                final_text = truncated_text
                            
                            child.setText(final_text)
                            
                            # Set tooltip with full tags if truncated
                            if hidden_count > 0:
                                child.setToolTip(f"Tags: {original_tags_text}")
                            
                            # Recalculate size after truncation
                            child.adjustSize()
                            tags_width = child.sizeHint().width()
                        else:
                            # Clear tooltip if no truncation needed
                            child.setToolTip(f"Tags: {original_tags_text}")
                        
                        # Position at top right corner of widget
                        tags_x = available_width - tags_width + 60  # Right edge minus tags width plus extra push
                        child.move(tags_x, 5)
                        child.show()
                        break
        except Exception as e:
            print(f"[DEBUG] Error in _trigger_tags_positioning: {e}")

    def populate_order_list(self):
        """Populate the order list with annotations."""
#         print("-----WE ARE POPULAAAATING THAT ORDER LIST----")  
        # Guard against multiple calls - more robust version
        if hasattr(self, '_population_in_progress') and self._population_in_progress:
            print("[DEBUG] Population already in progress, ignoring duplicate call")
            return

        print("[DEBUG] Starting populate_order_list")

        # Set flags at the beginning
        self._population_in_progress = True
        self.order_list._in_population = True
    
        # Store the actual current visual scroll position
        current_scroll = self.order_list.verticalScrollBar().value()
        self._original_scroll_position = current_scroll
        print(f"[DEBUG] populate_order_list - Capturing actual scroll position: {current_scroll}")

        # Clean up any existing overlay first - CRITICAL for preventing endless overlays
        if hasattr(self, '_loading_overlay') and self._loading_overlay:
            try:
                self._loading_overlay.hide()
                self._loading_overlay.deleteLater()
                self._loading_overlay = None
            except:
                print("[DEBUG] Error cleaning up existing overlay")
            
        # Stop any existing timers
        if hasattr(self, '_dot_timer') and self._dot_timer:
            try:
                if self._dot_timer.isActive():
                    self._dot_timer.stop()
                self._dot_timer = None
            except:
                print("[DEBUG] Error stopping existing timer")

        # Create loading overlay
        loading_overlay = QWidget(self.order_list)
        loading_overlay.setObjectName("loading_overlay")
        loading_overlay.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        loading_overlay.setGeometry(self.order_list.rect())
        loading_overlay.setStyleSheet("""
            #loading_overlay {
                background-color: rgba(255, 255, 255, 0.95);
                border-radius: 8px;
            }
        """)

        # Loading card design
        loading_card = QFrame(loading_overlay)
        loading_card.setObjectName("loading_card")
        loading_card.setStyleSheet("""
            #loading_card {
                background-color: white;
                border-radius: 12px;
                min-width: 180px;
                min-height: 80px;
                border: 1px solid #e0e0e0;
            }
        """)

        # Layout for card
        card_layout = QVBoxLayout(loading_card)
        card_layout.setContentsMargins(20, 20, 20, 20)
        card_layout.setSpacing(12)

        # Loading label
        loading_label = QLabel("Updating", loading_card)
        loading_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        loading_label.setStyleSheet("""
            font-size: 18px;
            font-weight: 500;
            color: #2C3E50;
            font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        """)
        card_layout.addWidget(loading_label)

        # Dot container
        dot_container = QWidget(loading_card)
        dot_layout = QHBoxLayout(dot_container)
        dot_layout.setContentsMargins(0, 0, 0, 0)
        dot_layout.setSpacing(8)
        dot_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Dots
        dot_labels = []
        for i in range(3):
            dot = QLabel("•", dot_container)
            dot.setStyleSheet("""
                font-size: 24px;
                color: #3498DB;
                margin: 0 2px;
                font-weight: bold;
            """)
            dot.setAlignment(Qt.AlignmentFlag.AlignCenter)
            dot_layout.addWidget(dot)
            dot_labels.append(dot)

        card_layout.addWidget(dot_container)

        # Center card in overlay
        overlay_layout = QVBoxLayout(loading_overlay)
        overlay_layout.addStretch()
        overlay_layout.addWidget(loading_card, 0, Qt.AlignmentFlag.AlignCenter)
        overlay_layout.addStretch()

        # Animation setup
        dot_timer = QTimer(loading_overlay)
        animation_step = 0

        def update_dots():
            nonlocal animation_step
            animation_step = (animation_step + 1) % 4

            # Reset all dots
            for dot in dot_labels:
                dot.setStyleSheet("""
                    font-size: 24px;
                    color: #BDC3C7;
                    margin: 0 2px;
                    font-weight: bold;
                """)

            # Highlight active dots
            active_dots = min(animation_step + 1, 3)
            for i in range(active_dots):
                dot_labels[i].setStyleSheet("""
                    font-size: 24px;
                    color: #3498DB;
                    margin: 0 2px;
                    font-weight: bold;
                """)

        # Start animation
        dot_timer.timeout.connect(update_dots)
        dot_timer.start(100)

        # Store references for cleanup
        self._loading_overlay = loading_overlay
        self._dot_timer = dot_timer

        # Show overlay and make sure it's visible
        loading_overlay.raise_()
        loading_overlay.show()

        # Block updates to the order list to prevent flickering
        self.order_list.setUpdatesEnabled(False)

        # A single processEvents call to ensure overlay is shown
        QApplication.processEvents()

        # Define a robust cleanup function with debugging
        def remove_overlay_completely():
            if hasattr(self, '_dot_timer') and self._dot_timer:
                try:
                    if self._dot_timer.isActive():
                        self._dot_timer.stop()
                    self._dot_timer = None
                    print("[DEBUG] Dot timer stopped")
                except Exception as e:
                    print(f"[DEBUG] Error stopping timer: {e}")
        
            if hasattr(self, '_loading_overlay') and self._loading_overlay:
                try:
                    self._loading_overlay.hide()
                    self._loading_overlay.deleteLater()
                    self._loading_overlay = None
                    print("[DEBUG] Overlay removed")
                except Exception as e:
                    print(f"[DEBUG] Error removing overlay: {e}")

        try:
            # Clear the current list
            self.order_list.clear()
            # Process annotations in correct order - USING STRICT FILTERING
            # ONLY include annotations with explicit order values
            sorted_annotations = sorted(
                [a for a in self.annotations if not a.get('deleted', False) and a.get('order') is not None],
                key=lambda x: x['order']
            )

            # Track scene styles for color coding
            if hasattr(self, 'scene_styles'):
                self.order_list.scene_styles = self.scene_styles

            # Keep track of the current scene for dividers
            current_scene = None

            # Add items to the list with MINIMAL event processing
            for i, annotation in enumerate(sorted_annotations):
                # Only process events once at the beginning - minimize during item creation
                if i == 0 and i % 100 == 0:
                    QApplication.processEvents()
            
                # Check if this is a divider
                if annotation.get('divider', False):
                    label = annotation.get('text', 'Divider')
                    color = annotation.get('color', 'yellow')
                    self.order_list.add_divider(label, color)
                    continue
        
                # Handle scene dividers if enabled
                if hasattr(self, 'group_by_scene') and self.group_by_scene and 'scene' in annotation:
                    scene = annotation.get('scene')
                    if scene != current_scene:
                        current_scene = scene
                        self.order_list.add_divider(f"{scene}", self.scene_styles.get(scene, "yellow"))
        
                # Create item for annotation
                item = QListWidgetItem()
                item.setData(Qt.ItemDataRole.UserRole, annotation.get('id'))
        
                # Get text for display (either storyboard version or original)
                display_text = annotation.get('text', '')
                if 'storyboard' in annotation and 'text' in annotation['storyboard']:
                    display_text = annotation['storyboard']['text']
        
                # Get notes
                notes = annotation.get('notes', '')
        
                # # Handle strikethrough if present
                # strikethrough_segments = annotation.get('storyboard', {}).get('strikethrough_segments', {})
                # if strikethrough_segments:
                #     # First remove any existing strikethrough tags
                #     clean_text = re.sub(r'<s style=(?:\"|\')color:#FF9999;(?:\"|\')\>|</s>', '', display_text)
            
                #     # Apply all strikethrough segments
                #     for segment, is_struck in strikethrough_segments.items():
                #         if is_struck:
                #             clean_text = clean_text.replace(segment, f"<s style=\"color:#FF9999;\">{segment}</s>")
            
                #     display_text = clean_text
        
                # Create widget for the item
                widget, label = self.order_list.create_item_widget(
                    display_text,
                    annotation.get('id'),
                    self.order_list.count() + 1,  # Item number
                    notes,
                    annotation.get('tags', []),  # tags parameter
                    annotation.get('speech_title', '')  # speech_title parameter
                )
        
                # Set item size and widget
                item.setSizeHint(widget.sizeHint())
                self.order_list.addItem(item)
                self.order_list.setItemWidget(item, widget)
        
                # # Debug output for word count tracking
                # word_count = len(display_text.split())
                # strikethrough_count = sum(len(s.split()) for s, v in strikethrough_segments.items() if v)
                # header_count = 0  # Count words in headers if needed
                # final_count = word_count - strikethrough_count - header_count
                # print(f"Item {self.order_list.count()}: Total words={word_count}, Strikethrough={strikethrough_count}, Headers={header_count}, Final count={final_count}")

            # Process events only once after all items are added
            QApplication.processEvents()

            #  Improve strikethroughs
            # print("\n=== IMPROVING STRIKETHROUGHS FROM POP ORDER LIST ===")
            # self.order_list._saved_scroll_position = self._original_scroll_position
            # print(f"[DEBUG] Saving scroll position in improve_strikethroughs: {self._original_scroll_position}")

            #print(f"Processed {processed_count} items for strikethrough improvements")

            # Renumber items with the stored scroll position
            print("[DEBUG] Renumbering items with preserved scroll position")
            self.order_list.renumber_items_optimized(with_visual_updates=False, scroll_value=self._original_scroll_position, resize_all_items=True, preserve_states=True)

            # Process all annotations for improved strikethrough display
            # processed_count = 0
            # for i in range(self.order_list.count()):
            #     item = self.order_list.item(i)
            #     if item:
            #         annotation_id = item.data(Qt.ItemDataRole.UserRole)
            #         widget = self.order_list.itemWidget(item)
            #         if widget and not hasattr(widget, 'is_divider'):
            #             self.order_list.improve_strikethrough_display(annotation_id)
            #             processed_count += 1
                
            #     # Process events very infrequently during strikethrough processing
            #     if i % 100 == 0 and i > 0:
            #         QApplication.processEvents()
    
            # Restore scroll position
            print(f"[DEBUG] Restoring scroll position to originally captured value: {self._original_scroll_position}")
            self.order_list.verticalScrollBar().setValue(self._original_scroll_position)
    
            # Define a single completion function that does everything in the right order
            def complete_update():
                print("[DEBUG] Starting complete_update")
                try:
                    # Re-enable updates
                    self.order_list.setUpdatesEnabled(True)
   
                    self.apply_changes_lite()
                
                    # IMPORTANT: Clear flags AFTER applying changes
                    print("[DEBUG] Clearing population flags")
                    self.order_list._in_population = False
                    self._population_in_progress = False
                
                    # Mark changes as not pending
                    self.changes_pending = False
                
                    print("[DEBUG] Update completed successfully")
                    
                    # Trigger initial tags positioning after population and visual updates are restored
                    self._trigger_tags_positioning()
                    
                    # Handle selection of newly created annotations from reassignment
                    self._handle_pending_selection()
                
                    # Clean up the overlay directly
                    remove_overlay_completely()
                except Exception as e:
                    print(f"[ERROR] Exception in complete_update: {e}")
                    import traceback
                    traceback.print_exc()
                
                    # Force cleanup in case of error
                    self.order_list.setUpdatesEnabled(True)
                    self.order_list._in_population = False
                    self._population_in_progress = False
                    remove_overlay_completely()
        
            # Schedule the completion with a short delay
            print("[DEBUG] Scheduling completion callback")
            QTimer.singleShot(200, complete_update)
        
        except Exception as e:
            print(f"[ERROR] Exception during population: {e}")
            import traceback
            traceback.print_exc()
        
            # Force cleanup in case of exception
            self.order_list.setUpdatesEnabled(True)
            self.order_list._in_population = False
            self._population_in_progress = False
        
            # Add a backup cleanup call
            QTimer.singleShot(500, remove_overlay_completely)
    
        # Add a guaranteed cleanup that runs regardless of other errors
        # This is critical to prevent permanent overlays
        QTimer.singleShot(3000, remove_overlay_completely)
    
        print("[DEBUG] populate_order_list setup completed")

    def populate_order_list_skip_partial_fallback(self):
        """Populate the order list with annotations."""
#         print("-----WE ARE POPULAAAATING THAT ORDER LIST----")  
        # Guard against multiple calls - more robust version
        if hasattr(self, '_population_in_progress') and self._population_in_progress:
            print("[DEBUG] Population already in progress, ignoring duplicate call")
            return

        print("[DEBUG] Starting populate_order_list")

        # Set flags at the beginning
        self._population_in_progress = True
        self.order_list._in_population = True
    
        # Store the actual current visual scroll position
        current_scroll = self.order_list.verticalScrollBar().value()
        self._original_scroll_position = current_scroll
        print(f"[DEBUG] populate_order_list - Capturing actual scroll position: {current_scroll}")

        # Clean up any existing overlay first - CRITICAL for preventing endless overlays
        if hasattr(self, '_loading_overlay') and self._loading_overlay:
            try:
                self._loading_overlay.hide()
                self._loading_overlay.deleteLater()
                self._loading_overlay = None
            except:
                print("[DEBUG] Error cleaning up existing overlay")
            
        # Stop any existing timers
        if hasattr(self, '_dot_timer') and self._dot_timer:
            try:
                if self._dot_timer.isActive():
                    self._dot_timer.stop()
                self._dot_timer = None
            except:
                print("[DEBUG] Error stopping existing timer")

        # Create loading overlay
        loading_overlay = QWidget(self.order_list)
        loading_overlay.setObjectName("loading_overlay")
        loading_overlay.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        loading_overlay.setGeometry(self.order_list.rect())
        loading_overlay.setStyleSheet("""
            #loading_overlay {
                background-color: rgba(255, 255, 255, 0.95);
                border-radius: 8px;
            }
        """)

        # Loading card design
        loading_card = QFrame(loading_overlay)
        loading_card.setObjectName("loading_card")
        loading_card.setStyleSheet("""
            #loading_card {
                background-color: white;
                border-radius: 12px;
                min-width: 180px;
                min-height: 80px;
                border: 1px solid #e0e0e0;
            }
        """)

        # Layout for card
        card_layout = QVBoxLayout(loading_card)
        card_layout.setContentsMargins(20, 20, 20, 20)
        card_layout.setSpacing(12)

        # Loading label
        loading_label = QLabel("Updating", loading_card)
        loading_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        loading_label.setStyleSheet("""
            font-size: 18px;
            font-weight: 500;
            color: #2C3E50;
            font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        """)
        card_layout.addWidget(loading_label)

        # Dot container
        dot_container = QWidget(loading_card)
        dot_layout = QHBoxLayout(dot_container)
        dot_layout.setContentsMargins(0, 0, 0, 0)
        dot_layout.setSpacing(8)
        dot_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Dots
        dot_labels = []
        for i in range(3):
            dot = QLabel("•", dot_container)
            dot.setStyleSheet("""
                font-size: 24px;
                color: #3498DB;
                margin: 0 2px;
                font-weight: bold;
            """)
            dot.setAlignment(Qt.AlignmentFlag.AlignCenter)
            dot_layout.addWidget(dot)
            dot_labels.append(dot)

        card_layout.addWidget(dot_container)

        # Center card in overlay
        overlay_layout = QVBoxLayout(loading_overlay)
        overlay_layout.addStretch()
        overlay_layout.addWidget(loading_card, 0, Qt.AlignmentFlag.AlignCenter)
        overlay_layout.addStretch()

        # Animation setup
        dot_timer = QTimer(loading_overlay)
        animation_step = 0

        def update_dots():
            nonlocal animation_step
            animation_step = (animation_step + 1) % 4

            # Reset all dots
            for dot in dot_labels:
                dot.setStyleSheet("""
                    font-size: 24px;
                    color: #BDC3C7;
                    margin: 0 2px;
                    font-weight: bold;
                """)

            # Highlight active dots
            active_dots = min(animation_step + 1, 3)
            for i in range(active_dots):
                dot_labels[i].setStyleSheet("""
                    font-size: 24px;
                    color: #3498DB;
                    margin: 0 2px;
                    font-weight: bold;
                """)

        # Start animation
        dot_timer.timeout.connect(update_dots)
        dot_timer.start(100)

        # Store references for cleanup
        self._loading_overlay = loading_overlay
        self._dot_timer = dot_timer

        # Show overlay and make sure it's visible
        loading_overlay.raise_()
        loading_overlay.show()

        # Block updates to the order list to prevent flickering
        self.order_list.setUpdatesEnabled(False)

        # A single processEvents call to ensure overlay is shown
        QApplication.processEvents()

        # Define a robust cleanup function with debugging
        def remove_overlay_completely():
            if hasattr(self, '_dot_timer') and self._dot_timer:
                try:
                    if self._dot_timer.isActive():
                        self._dot_timer.stop()
                    self._dot_timer = None
                    print("[DEBUG] Dot timer stopped")
                except Exception as e:
                    print(f"[DEBUG] Error stopping timer: {e}")
        
            if hasattr(self, '_loading_overlay') and self._loading_overlay:
                try:
                    self._loading_overlay.hide()
                    self._loading_overlay.deleteLater()
                    self._loading_overlay = None
                    print("[DEBUG] Overlay removed")
                except Exception as e:
                    print(f"[DEBUG] Error removing overlay: {e}")

        try:
            # Clear the current list
            self.order_list.clear()
            # Process annotations in correct order - USING STRICT FILTERING
            # ONLY include annotations with explicit order values
            sorted_annotations = sorted(
                [a for a in self.annotations if not a.get('deleted', False) and a.get('order') is not None],
                key=lambda x: x['order']
            )

            # Track scene styles for color coding
            if hasattr(self, 'scene_styles'):
                self.order_list.scene_styles = self.scene_styles

            # Keep track of the current scene for dividers
            current_scene = None

            # Add items to the list with MINIMAL event processing
            for i, annotation in enumerate(sorted_annotations):
                # Only process events once at the beginning - minimize during item creation
                if i == 0 and i % 100 == 0:
                    QApplication.processEvents()
            
                # Check if this is a divider
                if annotation.get('divider', False):
                    label = annotation.get('text', 'Divider')
                    color = annotation.get('color', 'yellow')
                    self.order_list.add_divider(label, color)
                    continue
        
                # Handle scene dividers if enabled
                if hasattr(self, 'group_by_scene') and self.group_by_scene and 'scene' in annotation:
                    scene = annotation.get('scene')
                    if scene != current_scene:
                        current_scene = scene
                        self.order_list.add_divider(f"{scene}", self.scene_styles.get(scene, "yellow"))
        
                # Create item for annotation
                item = QListWidgetItem()
                item.setData(Qt.ItemDataRole.UserRole, annotation.get('id'))
        
                # Get text for display (either storyboard version or original)
                display_text = annotation.get('text', '')
                if 'storyboard' in annotation and 'text' in annotation['storyboard']:
                    display_text = annotation['storyboard']['text']
        
                # Get notes
                notes = annotation.get('notes', '')
        
                # # Handle strikethrough if present
                # strikethrough_segments = annotation.get('storyboard', {}).get('strikethrough_segments', {})
                # if strikethrough_segments:
                #     # First remove any existing strikethrough tags
                #     clean_text = re.sub(r'<s style=(?:\"|\')color:#FF9999;(?:\"|\')\>|</s>', '', display_text)
            
                #     # Apply all strikethrough segments
                #     for segment, is_struck in strikethrough_segments.items():
                #         if is_struck:
                #             clean_text = clean_text.replace(segment, f"<s style=\"color:#FF9999;\">{segment}</s>")
            
                #     display_text = clean_text
        
                # Create widget for the item
                widget, label = self.order_list.create_item_widget(
                    display_text,
                    annotation.get('id'),
                    self.order_list.count() + 1,  # Item number
                    notes,
                    annotation.get('tags', []),  # tags parameter
                    annotation.get('speech_title', '')  # speech_title parameter
                )
        
                # Set item size and widget
                item.setSizeHint(widget.sizeHint())
                self.order_list.addItem(item)
                self.order_list.setItemWidget(item, widget)
        
                # # Debug output for word count tracking
                # word_count = len(display_text.split())
                # strikethrough_count = sum(len(s.split()) for s, v in strikethrough_segments.items() if v)
                # header_count = 0  # Count words in headers if needed
                # final_count = word_count - strikethrough_count - header_count
                # print(f"Item {self.order_list.count()}: Total words={word_count}, Strikethrough={strikethrough_count}, Headers={header_count}, Final count={final_count}")

            # Process events only once after all items are added
            QApplication.processEvents()

            #  Improve strikethroughs
            # print("\n=== IMPROVING STRIKETHROUGHS FROM POP ORDER LIST ===")
            # self.order_list._saved_scroll_position = self._original_scroll_position
            # print(f"[DEBUG] Saving scroll position in improve_strikethroughs: {self._original_scroll_position}")

            # print(f"Processed {processed_count} items for strikethrough improvements")

            # Renumber items with the stored scroll position
            print("[DEBUG] Renumbering items with preserved scroll position")
            self.order_list.renumber_items_optimized(with_visual_updates=False, scroll_value=self._original_scroll_position, resize_all_items=True, preserve_states=True)
            # Process all annotations for improved strikethrough display
            processed_count = 0
            for i in range(self.order_list.count()):
                item = self.order_list.item(i)
                if item:
                    annotation_id = item.data(Qt.ItemDataRole.UserRole)
                    widget = self.order_list.itemWidget(item)
                    if widget and not hasattr(widget, 'is_divider'):
                        self.order_list.improve_strikethrough_display(annotation_id, skip_partial_fallback=True)
                        processed_count += 1
                
                # Process events very infrequently during strikethrough processing
                if i % 100 == 0 and i > 0:
                    QApplication.processEvents()
    
            # Restore scroll position
            print(f"[DEBUG] Restoring scroll position to originally captured value: {self._original_scroll_position}")
            self.order_list.verticalScrollBar().setValue(self._original_scroll_position)
    
            # Define a single completion function that does everything in the right order
            def complete_update():
                print("[DEBUG] Starting complete_update")
                try:
                    # Re-enable updates
                    self.order_list.setUpdatesEnabled(True)
   
                    self.apply_changes_lite()
                
                    # IMPORTANT: Clear flags AFTER applying changes
                    print("[DEBUG] Clearing population flags")
                    self.order_list._in_population = False
                    self._population_in_progress = False
                
                    # Mark changes as not pending
                    self.changes_pending = False
                
                    print("[DEBUG] Update completed successfully")
                    
                    # Trigger initial tags positioning after population and visual updates are restored
                    self._trigger_tags_positioning()
                    
                    # Handle selection of newly created annotations from reassignment
                    self._handle_pending_selection()
                
                    # Clean up the overlay directly
                    remove_overlay_completely()
                except Exception as e:
                    print(f"[ERROR] Exception in complete_update: {e}")
                    import traceback
                    traceback.print_exc()
                
                    # Force cleanup in case of error
                    self.order_list.setUpdatesEnabled(True)
                    self.order_list._in_population = False
                    self._population_in_progress = False
                    remove_overlay_completely()
        
            # Schedule the completion with a short delay
            print("[DEBUG] Scheduling completion callback")
            QTimer.singleShot(200, complete_update)
        
        except Exception as e:
            print(f"[ERROR] Exception during population: {e}")
            import traceback
            traceback.print_exc()
        
            # Force cleanup in case of exception
            self.order_list.setUpdatesEnabled(True)
            self.order_list._in_population = False
            self._population_in_progress = False
        
            # Add a backup cleanup call
            QTimer.singleShot(500, remove_overlay_completely)
    
        # Add a guaranteed cleanup that runs regardless of other errors
        # This is critical to prevent permanent overlays
        QTimer.singleShot(3000, remove_overlay_completely)
    
        print("[DEBUG] populate_order_list setup completed")

    def _handle_pending_selection(self):
        """
        Handle selection of newly created annotations from reassignment.
        This method is called after populate_order_list completes to visually 
        select the annotation items that were created during reassignment.
        """
        if not hasattr(self, '_pending_selection_ids') or not self._pending_selection_ids:
            print("[DEBUG] No pending selection IDs to handle")
            return
            
        print(f"[DEBUG] Handling pending selection for {len(self._pending_selection_ids)} annotation IDs: {self._pending_selection_ids}")
        
        try:
            # Clear any existing selections first
            self.order_list.clearSelection()
            print("[DEBUG] Cleared existing selections")
            
            selected_count = 0
            
            # Find and select items matching the pending annotation IDs
            for i in range(self.order_list.count()):
                item = self.order_list.item(i)
                if item and hasattr(item, 'data') and item.data(Qt.ItemDataRole.UserRole):
                    item_annotation_id = item.data(Qt.ItemDataRole.UserRole)
                    if item_annotation_id in self._pending_selection_ids:
                        item.setSelected(True)
                        selected_count += 1
                        print(f"[DEBUG] Selected item for annotation ID: {item_annotation_id}")
                        
                        # Scroll to first selected item
                        if selected_count == 1:
                            self.order_list.scrollToItem(item, QAbstractItemView.ScrollHint.PositionAtCenter)
                            print(f"[DEBUG] Scrolled to first selected item: {item_annotation_id}")
            
            print(f"[DEBUG] Successfully selected {selected_count} items out of {len(self._pending_selection_ids)} pending IDs")
            
        except Exception as e:
            print(f"[ERROR] Exception in _handle_pending_selection: {e}")
            import traceback
            traceback.print_exc()
        finally:
            # Clear the pending selection IDs regardless of success/failure
            self._pending_selection_ids = []
            print("[DEBUG] Cleared pending selection IDs")

    def populate_order_list_and_improve_strikethroughs(self):
        """Populate the order list with annotations."""
        print("🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪 POPULATE_ORDER_LIST_AND_IMPROVE_STRIKETHROUGHS START 🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪")
        print("🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪🎪")
        print("-----WE ARE POPULAAAATING THAT ORDER LIST----")  
        # Guard against multiple calls - more robust version

        self.populate_order_list()
        #Improve strikethroughs
#         print("\n=== IMPROVING STRIKETHROUGHS FROM POP ORDER LIST ===")
        self.order_list._saved_scroll_position = self._original_scroll_position
        print(f"[DEBUG] Saving scroll position in improve_strikethroughs: {self._original_scroll_position}")

        # Process all annotations for improved strikethrough display
        processed_count = 0
        for i in range(self.order_list.count()):
            item = self.order_list.item(i)
            if item:
                annotation_id = item.data(Qt.ItemDataRole.UserRole)
                widget = self.order_list.itemWidget(item)
                if widget and not hasattr(widget, 'is_divider'):
                    self.order_list.improve_strikethrough_display(annotation_id)
                    processed_count += 1
            
            # Process events very infrequently during strikethrough processing
            if i % 100 == 0 and i > 0:
                QApplication.processEvents()
        
        # Apply changes after all strikethrough processing is complete
        print("[DEBUG] Calling apply_changes_lite after strikethrough processing complete")
        self.apply_changes_lite()
        
        print("[DEBUG] populate_order_list setup completed")

    def _cleanup_existing_overlay(self, process_events=True):
        """Clean up any existing overlay."""
        existing_overlay = self.order_list.findChild(QWidget, "loading_overlay")
        if existing_overlay:
            try:
                existing_overlay.hide()  # Hide before deleting to prevent flicker
                existing_overlay.deleteLater()
            
                # Check if this is the same as our stored overlay
                if hasattr(self, '_loading_overlay') and self._loading_overlay == existing_overlay:
                    self._loading_overlay = None
            except RuntimeError:
                print("[DEBUG] Existing overlay widget has already been deleted")
    
        # Also clean up any timers
        if hasattr(self, '_dot_timer') and self._dot_timer:
            self._dot_timer.stop()
            self._dot_timer = None
        
        # Process events only if requested
        if process_events:
            QApplication.processEvents()

    def _cleanup_overlay(self):
        """Clean up the loading overlay properly."""
        print("[DEBUG] Cleaning up overlay")
    
        # Check if we're ready to clean up overlay
        if hasattr(self, '_overlay_cleanup_ready') and not self._overlay_cleanup_ready:
            print("[DEBUG] Overlay cleanup not ready yet, rescheduling")
            QTimer.singleShot(100, self._cleanup_overlay)
            return
    
        # Check for ongoing operations
        if hasattr(self, '_in_critical_ui_update') and self._in_critical_ui_update:
            print("[DEBUG] Postponing overlay cleanup due to critical UI operation")
            QTimer.singleShot(100, self._cleanup_overlay)
            return
        
        # Stop the animation timer first
        if hasattr(self, '_dot_timer') and self._dot_timer:
            self._dot_timer.stop()
            self._dot_timer = None
    
        # Then handle the overlay widget
        if hasattr(self, '_loading_overlay') and self._loading_overlay:
            try:
                # Check if the widget is still valid before trying to hide it
                if self._loading_overlay.isVisible():
                    self._loading_overlay.hide()
            
                # Schedule deletion for later to ensure it's out of the event cycle
                self._loading_overlay.deleteLater()
            except RuntimeError:
                # Handle the case where the C++ object has been deleted
                print("[DEBUG] Loading overlay widget has already been deleted")
            finally:
                # Always set to None regardless of any errors
                self._loading_overlay = None
        
            # Clear overlay cleanup ready flag
            if hasattr(self, '_overlay_cleanup_ready'):
                delattr(self, '_overlay_cleanup_ready')

    def merge_strikethrough_segments(self, annotation, input_merged_segments, input_positional_data): # Use input_* names
        """
        Clean up strikethrough segments by merging overlapping/duplicate segments and removing redundancies.
        Prioritizes context-specific and numbered variants over generic ones. Returns cleaned dictionaries.
        """
#         print("[DEBUG] Starting merge_strikethrough_segments")

        # --- Work on copies to avoid modifying originals directly until the end ---
        current_merged_segments = input_merged_segments.copy()
        current_positional_data = input_positional_data.copy()
        # --- End copies ---


        # Get the base text for position calculations
        base_text = ""
        if 'storyboard' in annotation and 'text' in annotation['storyboard']:
            base_text = annotation['storyboard']['text']
        else:
            base_text = annotation.get('text', '')

        # Remove any existing strikethrough tags FROM THE BASE TEXT USED FOR POSITIONS
        plain_base_text = re.sub(r'<s style=(?:\"|\')color:#FF9999;(?:\"|\')\>|</s>', '', base_text)

#         print(f"[DEBUG] Plain base text length: {len(plain_base_text)}")

        # Create a mapping of positions to segment keys for deduplication
        position_map = {}  # Maps (start, end) tuple to list of segment keys

        # First gather all segments by their positions FROM THE INPUT COPIES
        for segment_key, is_struck in list(current_merged_segments.items()): # Use list() for safe iteration if modifying
            if not is_struck:
                continue

            # Ensure positional data exists before accessing positions
            segment_pos_data = current_positional_data.get(segment_key)
            if segment_pos_data and 'positions' in segment_pos_data:
                # Ensure positions list is not empty
                if segment_pos_data['positions']:
                    # Use the first position found for grouping (assuming non-overlapping identical keys for now)
                    # A more robust approach might handle multiple positions per key if that's possible
                    start, end = segment_pos_data['positions'][0]
                    position_tuple = (start, end)
                    if position_tuple not in position_map:
                        position_map[position_tuple] = []
                    # Avoid adding duplicates to the list for a given position
                    if segment_key not in position_map[position_tuple]:
                        position_map[position_tuple].append(segment_key)
                else:
                     print(f"[DEBUG] Warning: Segment '{segment_key}' has empty positions list.")
                     # Optionally remove this inconsistent segment
                     # current_merged_segments.pop(segment_key, None)
                     # current_positional_data.pop(segment_key, None)

            # Handle cases where segment exists but has no positional data (fallback?)
            elif segment_key not in current_positional_data:
                 print(f"[DEBUG] Warning: Segment '{segment_key}' found but has no positional data. Attempting fallback find.")
                 # Fallback: find the first occurrence in plain text
                 start = plain_base_text.find(segment_key) # Assuming key is the text
                 if start != -1:
                     end = start + len(segment_key)
                     position_tuple = (start, end)
                     if position_tuple not in position_map:
                        position_map[position_tuple] = []
                     if segment_key not in position_map[position_tuple]:
                        position_map[position_tuple].append(segment_key)
                     # Add minimal positional data if found
                     current_positional_data[segment_key] = {
                         "positions": [(start, end)],
                         "original_length": end - start,
                         "is_context_specific": False,
                         "base_word": segment_key
                     }
                     print(f"[DEBUG] Fallback found '{segment_key}' at {position_tuple}. Added basic positional data.")
                 else:
                     print(f"[DEBUG] Fallback failed to find '{segment_key}'. Removing segment.")
                     current_merged_segments.pop(segment_key, None) # Remove inconsistent segment


#         print(f"[DEBUG] Found {len(position_map)} unique position ranges after grouping.")

        # Track segments to keep and remove
        segments_to_remove = set()
        # Use dictionary to store the final chosen segment for each position range
        final_segments_for_position = {} # Maps position tuple to the chosen segment_key

        # --- Stage 1: Choose the best segment for each EXACT position ---
        for position, segments in position_map.items():
            if len(segments) <= 1:
                # Only one segment for this position, mark it as final for now
                final_segments_for_position[position] = segments[0]
                continue

#             print(f"[DEBUG] Resolving conflict for position {position}: {segments}")

            # Score each segment
            best_segment = None
            best_score = -1
            for segment_key in segments:
                # Ensure positional data exists before scoring
                if segment_key not in current_positional_data:
#                      print(f"[DEBUG] Warning: Missing positional data for scoring segment '{segment_key}'. Skipping.")
                     continue

                score = 0
                pos_data = current_positional_data[segment_key] # Use current_positional_data
                if pos_data.get('is_context_specific', False): score += 100
                if '_' in segment_key and re.match(r'^.+_\d+$', segment_key): score += 50
                score += len(segment_key) * 0.1 # Slight preference for longer keys

                if score > best_score:
                    best_score = score
                    best_segment = segment_key

            # Keep only the best segment for this position
            if best_segment:
                final_segments_for_position[position] = best_segment
                # Mark all others sharing this exact position for removal
                for segment in segments:
                    if segment != best_segment:
                        segments_to_remove.add(segment)
#                 print(f"[DEBUG] Keeping segment '{best_segment}' (Score: {best_score}) for position {position}. Marked others for removal.")
            else:
#                  print(f"[DEBUG] Warning: Could not determine best segment for position {position}. Keeping first? ({segments[0]})")
                 final_segments_for_position[position] = segments[0] # Fallback? Or skip?

        # --- Stage 2: Check for overlaps among the initially chosen segments ---
        # Create a list of (start, end, key) from the segments chosen so far
        chosen_segments_list = []
        for position, key in final_segments_for_position.items():
             if key not in segments_to_remove: # Only consider those not already marked for removal
                  chosen_segments_list.append((position[0], position[1], key))

        chosen_segments_list.sort(key=lambda x: (x[0], -x[1])) # Sort by start, then reverse end

        # Iterate through sorted chosen segments to find overlaps
        i = 0
        while i < len(chosen_segments_list):
            curr_start, curr_end, curr_key = chosen_segments_list[i]
            if curr_key in segments_to_remove: # Skip if already marked by previous iteration
                i += 1
                continue

            j = i + 1
            while j < len(chosen_segments_list):
                other_start, other_end, other_key = chosen_segments_list[j]
                if other_key in segments_to_remove:
                    j += 1
                    continue

                # Check for overlap (other starts before current ends)
                if other_start < curr_end:
#                     print(f"[DEBUG] Overlap detected between '{curr_key}' ({curr_start}-{curr_end}) and '{other_key}' ({other_start}-{other_end})")

                    # Determine which segment to keep based on score (again)
                    curr_score = 0
                    if curr_key in current_positional_data:
                         pos_data = current_positional_data[curr_key]
                         if pos_data.get('is_context_specific', False): curr_score += 100
                         if '_' in curr_key and re.match(r'^.+_\d+$', curr_key): curr_score += 50

                    other_score = 0
                    if other_key in current_positional_data:
                         pos_data = current_positional_data[other_key]
                         if pos_data.get('is_context_specific', False): other_score += 100
                         if '_' in other_key and re.match(r'^.+_\d+$', other_key): other_score += 50

                    # Remove the lower-scoring segment
                    if curr_score >= other_score:
                        segments_to_remove.add(other_key)
#                         print(f"[DEBUG] Removing overlapping segment '{other_key}' (lower score)")
                        # Remove from list to avoid re-checking
                        chosen_segments_list.pop(j)
                        # Do not increment j, as the next element shifted into the current j index
                    else:
                        segments_to_remove.add(curr_key)
#                         print(f"[DEBUG] Removing overlapping segment '{curr_key}' (lower score)")
                        # Remove from list and break inner loop to re-evaluate outer loop
                        chosen_segments_list.pop(i)
                        i -= 1 # Adjust outer loop index since we removed the current item
                        break # Break inner loop
                else:
                    # No overlap with this one, move to next potential overlap
                    j += 1
            # Move to next segment in outer loop
            i += 1


        # --- Stage 3: Final Cleanup and Data Preparation ---
        final_merged_segments = {}
        final_positional_data = {}

        # Populate final dictionaries ONLY with segments that survived
        final_kept_keys = set(final_segments_for_position.values()) - segments_to_remove

        for segment_key in final_kept_keys:
             if segment_key in current_merged_segments and segment_key in current_positional_data:
                final_merged_segments[segment_key] = True
                final_positional_data[segment_key] = current_positional_data[segment_key]
                # Optionally recalculate context based on plain_base_text here if needed
                # pos_data = final_positional_data[segment_key]
                # if 'positions' in pos_data and pos_data['positions']:
                #      start, end = pos_data['positions'][0]
                #      context_start = max(0, start - 15)
                #      context_end = min(len(plain_base_text), end + 15)
                #      pos_data['context_before'] = plain_base_text[context_start:start]
                #      pos_data['context_after'] = plain_base_text[end:context_end]

#         print(f"[DEBUG] Final kept segments count: {len(final_merged_segments)}")
#         print(f"[DEBUG] Final positional data count: {len(final_positional_data)}")
#         print("[DEBUG] Completed merge_strikethrough_segments")

        return final_merged_segments, final_positional_data # Return the cleaned dictionaries

    def update_annotation_visual_state(self, annotation_id, key, value, skip_theme_sync=False):
        """Update only the visual state of a specific annotation without rebuilding the entire storyboard"""
        print(f"[DEBUG] Updating visual state for annotation {annotation_id}: {key}={value}, skip_theme_sync={skip_theme_sync}")
        
        # Find the item in the order list
        for i in range(self.order_list.count()):
            item = self.order_list.item(i)
            if not item:
                continue
                
            item_annotation_id = item.data(Qt.ItemDataRole.UserRole)
            if item_annotation_id == annotation_id:
                widget = self.order_list.itemWidget(item)
                if widget:
                    # Update the specific widget property
                    if key == "favorite":
                        # Find and update favorite button
                        favorite_labels = widget.findChildren(QLabel, "favorite_label")
                        for label in favorite_labels:
                            label.setText("★" if value else "☆")
                            # Update style to match favorite state
                            color = "#FFD700" if value else "#888888"
                            label.setStyleSheet(f"QLabel {{ color: {color}; font-size: 18px; font-weight: bold; }}")
                    
                    elif key == "used":
                        # Find and update used checkbox
                        used_checkboxes = widget.findChildren(CustomCheckBox)
                        for checkbox in used_checkboxes:
                            if checkbox.toolTip() == "Mark as Used":
                                checkbox.blockSignals(True)  # Prevent recursive calls
                                checkbox.setChecked(value)
                                checkbox.blockSignals(False)
                    
                    elif key == "notes":
                        # Find and update notes label
                        labels = widget.findChildren(QLabel)
                        for label in labels:
                            if label.styleSheet() and "font-style: italic" in label.styleSheet():  # This is the notes label
                                truncated_notes = value[:80] + "..." if len(value) > 80 else value
                                label.setText(truncated_notes)
                                if len(value) > 80:
                                    label.setToolTip(value)
                                else:
                                    label.setToolTip("")
                                print(f"[DEBUG] Updated notes label for {annotation_id}")
                                break
                    
                    elif key == "tags":
                        # Update cached tags data and rebuild secondary row
                        print(f"[DEBUG] Updating tags for annotation {annotation_id}: {value}")
                        
                        # Update cached tags data
                        if value:
                            tags_text = ", ".join([f"#{tag}" for tag in value])
                            widget.setProperty('cached_tags_data', {
                                'tags': value,
                                'annotation_id': annotation_id,
                                'tags_text': tags_text,
                                'tooltip': f"Tags: {tags_text}",
                                'has_tags': True
                            })
                        else:
                            widget.setProperty('cached_tags_data', {
                                'tags': [],
                                'annotation_id': annotation_id,
                                'tags_text': 'add tags',
                                'tooltip': 'Click to add tags',
                                'has_tags': False
                            })
                        
                        # Remove existing secondary row and rebuild it
                        for child in widget.findChildren(QWidget):
                            if child.property('is_secondary_row'):
                                child.setParent(None)
                                child.deleteLater()
                                break
                        
                        # Rebuild secondary row with updated tags
                        self._build_secondary_row_for_item(widget, annotation_id, force_recalc=True)
                        print(f"[DEBUG] Rebuilt secondary row with new tags for {annotation_id}")
                    
                    print(f"[DEBUG] Visual state updated for {key}")
                    
                    # Also sync with theme view (unless we're updating from theme view)
                    if not skip_theme_sync:
                        main_window = self.main_window
                        if main_window.theme_view:
                            print(f"[DEBUG] Syncing theme view after storyboard {key} update")
                            # Use the same sync method as favorite toggle (which works)
                            self._sync_theme_view_items()
                    return
        
        print(f"[DEBUG] Warning: Could not find annotation {annotation_id} in storyboard for visual update")
    
    def apply_changes_lite(self):
        """Apply changes to local and main window data structures with minimal visual impact and preserving context information."""
        
        # Skip if we're in reassignment context - will be called later by wrapper
        if getattr(self, '_in_reassignment_context', False):
            print("🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈")
            print("🌈🌈🌈🌈🌈🌈🌈 SKIPPING APPLY_CHANGES_LITE - REASSIGNMENT CONTEXT ACTIVE 🌈🌈🌈🌈🌈🌈🌈")
            print("🌈🌈🌈🌈🌈🌈🌈🌈🌈 PROTECTING POSITIONAL STRIKETHROUGH CONTEXT DATA 🌈🌈🌈🌈🌈🌈🌈🌈🌈")
            print("🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈 WILL BE CALLED AFTER STRIKETHROUGH PROCESSING 🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈")
            print("🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈🌈")
            return
        
#         print("\n=== APPLY CHANGES LITE START ===") # Added newline for clarity
        # Debug flags for header preservation
        header_debug_enabled = True
        headers_found = 0
        headers_preserved = 0

        try:
            # Process pending deletions: remove only the 'order' key for matching annotations
            if hasattr(self, '_pending_deletions') and self._pending_deletions:
                print(f"[DEBUG apply_changes_lite] Processing {len(self._pending_deletions)} pending deletions.")
                for annotation_id in self._pending_deletions:
                    found_anno_for_delete = False
                    for anno in self.main_window.web_view.annotations:
                        if anno.get('id') == annotation_id:
                            # Remove root-level order
                            anno.pop('order', None)
                            # Also remove order from storyboard if it exists
                            if 'storyboard' in anno and 'order' in anno['storyboard']:
                                anno['storyboard'].pop('order', None)
                            print(f"  Removed order for deleted annotation {annotation_id}")
                            found_anno_for_delete = True
                            break
                    if not found_anno_for_delete:
                        print(f"  Warning: Annotation {annotation_id} marked for deletion not found in main list.")
                self._pending_deletions.clear()
                print("[DEBUG apply_changes_lite] Pending deletions processed.")

            # Reset orders for all annotations - Prepare for re-ordering based on list
            print("[DEBUG apply_changes_lite] Resetting 'order' for all annotations.")
            for annotation in self.main_window.web_view.annotations:
                annotation.pop('order', None)

            print("[DEBUG apply_changes_lite] Processing items in OrderListWidget...")
            # Update order and status for each item in the order list
            for i in range(self.order_list.count()):
                item = self.order_list.item(i)
                if not item: # Safety check
#                     print(f"  Warning: Null item found at index {i}")
                    continue
                anno_id = item.data(Qt.ItemDataRole.UserRole)
                widget = self.order_list.itemWidget(item)

                if not widget: # Safety check
#                     print(f"  Warning: No widget found for item at index {i} (ID: {anno_id})")
                    continue

#                 print(f"  Processing item {i}: ID={anno_id}")

                if hasattr(widget, 'is_divider') and widget.is_divider:
#                     print(f"    Item {i} is a divider.")
                    # Process divider items
                    label = widget.findChild(QLabel)
                    text = label.text() if label else ""
                    color = "yellow"
                    if label:
                        stylesheet = label.styleSheet()
                        match = re.search(r"background-color:\s*(#[a-fA-F0-9]{6}|[a-zA-Z]+);", stylesheet) # Added \s*
                        if match:
                            color = match.group(1)
                    # Try to find existing divider by ID first, then by text content as fallback
                    existing_divider = next(
                        (a for a in self.main_window.web_view.annotations if a.get('id') == anno_id),
                        None
                    )
                    if not existing_divider: # Fallback to text match if ID match failed
                        existing_divider = next(
                            (a for a in self.main_window.web_view.annotations if a.get('divider') and a.get('text') == text),
                            None
                        )

                    if existing_divider:
#                         print(f"    Updating existing divider (ID: {existing_divider.get('id')}) at order {i}")
                        existing_divider.update({"text": text, "color": color, "order": i, "divider": True})
                    else:
                        new_divider_id = anno_id or str(uuid.uuid4()) # Ensure it has an ID
#                         print(f"    Adding new divider (ID: {new_divider_id}) at order {i}")
                        self.main_window.web_view.annotations.append({
                            "id": new_divider_id,
                            "text": text,
                            "color": color,
                            "divider": True,
                            "order": i
                        })
                else:
                    # For regular annotation items, find the main content label
                    text_label = None
                    for label in widget.findChildren(QLabel):
                        if label.objectName() == "main_content_label":
                            text_label = label
                            break

                    if not text_label:
#                         print(f"    Warning: Could not find main_content_label for item {i} (ID: {anno_id})")
                        continue

                    # Get the text with any HTML tags from the UI
                    current_text = text_label.text()
#                     print(f"    UI Text (start): {current_text[:50]}...")

                    # --- Extract strikethrough info from CURRENT UI text ---
                    strikethrough_segments = {}
                    positional_strikes = {} # Stores positions relative to UI plain text

                    # Remove any <s...> tags to get the clean base text from UI for position calculation
                    # We need this *before* calculating positions
                    clean_text_for_positions = re.sub(r'<s style=(?:\"|\')color:#FF9999;(?:\"|\')\>|</s>', '', current_text)
                    ui_plain_text = re.sub(r'<[^>]+>', '', clean_text_for_positions)

                    # Find all <s...> tags and their contents in the current UI text
                    # Robust matching for both quote styles
                    for match in re.finditer(r'<s style=(?:\"|\')color:#FF9999;(?:\"|\')\>(.*?)</s>', current_text, re.DOTALL):
                        raw_segment = match.group(1)
                        # IMPORTANT: Clean any HTML tags (including nested <s> tags) from the segment itself
                        cleaned_segment = re.sub(r'<[^>]+>', '', raw_segment) # More aggressive cleaning

                        if not cleaned_segment.strip():
                            print(f"    Skipping empty/whitespace-only segment found in UI.")
                            continue

                        # Store in regular structure with clean segment as key
                        strikethrough_segments[cleaned_segment] = True

                        # Calculate the actual position in the plain text by accounting for HTML tags before this match
                        plain_start = -1
                        # Search for the cleaned segment in the ui_plain_text to find its start position
                        temp_pos = 0
                        current_occurrence = 0
                        target_occurrence = -1

                        # Count how many times this exact segment content appears *before* the current match in the HTML
                        html_occurrence_index = current_text[:match.start()].count(f'<s style="color:#FF9999;">{raw_segment}</s>') \
                                               + current_text[:match.start()].count(f"<s style='color:#FF9999;'>{raw_segment}</s>")
                        target_occurrence = html_occurrence_index

                        # Find the correct occurrence in the plain text
                        occurrence_count_in_plain = 0
                        search_start_plain = 0
                        while True:
                            found_pos_plain = ui_plain_text.find(cleaned_segment, search_start_plain)
                            if found_pos_plain == -1:
                                break # Segment not found (should not happen if derived correctly)
                            if occurrence_count_in_plain == target_occurrence:
                                plain_start = found_pos_plain
                                break
                            occurrence_count_in_plain += 1
                            search_start_plain = found_pos_plain + 1


                        if plain_start != -1:
                            plain_end = plain_start + len(cleaned_segment)
                            # Store in positional structure with clean segment as key
                            if cleaned_segment not in positional_strikes:
                                positional_strikes[cleaned_segment] = {"positions": []}
                            positional_strikes[cleaned_segment]["positions"].append((plain_start, plain_end))
                            positional_strikes[cleaned_segment]["original_length"] = len(cleaned_segment)
#                             print(f"      Found UI segment '{cleaned_segment}' at plain pos {plain_start}-{plain_end}")
                        else:
                             print(f"      Warning: Could not reliably map UI segment '{cleaned_segment}' to plain text position.")


                    # Get the clean text after removing strikethrough tags (used for storyboard text)
                    clean_text = re.sub(r'<s style=(?:\"|\')color:#FF9999;(?:\"|\')\>|</s>', '', current_text)
#                     print(f"    Clean Text (no s tags): {clean_text[:50]}...")

                    # Find the corresponding annotation in the main data
                    annotation = next((a for a in self.main_window.web_view.annotations if a.get('id') == anno_id), None)
                    if annotation:
#                         print(f"    Found matching annotation in main data.")
                        # Check for header in the existing storyboard text
                        has_header = False
                        header_html = None
                        existing_storyboard_text = annotation.get('storyboard', {}).get('text', '')
                        if existing_storyboard_text:
                            # Use more robust header extraction
                            existing_header_match = re.search(r'^(<div><b[^>]*>.*?</b></div>)', existing_storyboard_text, re.DOTALL)
                            if existing_header_match:
                                has_header = True
                                header_html = existing_header_match.group(1)
                                headers_found += 1
                                if header_debug_enabled:
                                    print(f"    DEBUG: Header found in stored storyboard: {header_html}")

                        # Ensure storyboard dictionary exists
                        if 'storyboard' not in annotation:
                            annotation['storyboard'] = {}

                        # Apply header to clean_text if necessary (preserve from stored state)
                        ui_header_match = re.search(r'^(<div><b[^>]*>.*?</b></div>)', clean_text, re.DOTALL)
                        ui_has_header = bool(ui_header_match)
                        if has_header and header_html and not ui_has_header:
                            print(f"    Applying stored header to UI text before saving.")
                            clean_text = header_html + "\n" + clean_text # Assume newline separator
                            headers_preserved += 1

                        # Store the potentially header-adjusted clean text
                        annotation['storyboard']['text'] = clean_text.replace('\n', '<br>')
#                         print(f"    Stored storyboard text: {clean_text[:50]}...")

                        # --- Handle Strikethrough Segments ---
                        # Get existing segments (cleaned)
                        existing_segments = annotation.get('storyboard', {}).get('strikethrough_segments', {})
                        cleaned_existing_segments = {}
                        if existing_segments:
#                             print(f"    Cleaning {len(existing_segments)} existing segments...")
                            for segment, value in existing_segments.items():
                                if '<s style=' in segment or '</s>' in segment or '<' in segment or '>' in segment: # Clean any HTML
                                    cleaned_segment = re.sub(r'<[^>]+>', '', segment)
                                    if cleaned_segment.strip():
                                        cleaned_existing_segments[cleaned_segment] = value
                                        # print(f"      Cleaned existing segment from '{segment}' to '{cleaned_segment}'")
                                else:
                                    cleaned_existing_segments[segment] = value
                            existing_segments = cleaned_existing_segments
#                         print(f"    Existing segments count after cleaning: {len(existing_segments)}")

                        # Get existing positional data (cleaned)
                        existing_positional = annotation.get('storyboard', {}).get('positional_strikethrough', {})
                        cleaned_existing_positional = {}
                        if existing_positional:
#                             print(f"    Cleaning {len(existing_positional)} existing positional entries...")
                            for segment, data in existing_positional.items():
                                # Clean segment key
                                cleaned_key = re.sub(r'<[^>]+>', '', segment)
                                if not cleaned_key.strip(): continue

                                # Clean base_word if present
                                if 'base_word' in data:
                                    cleaned_base_word = re.sub(r'<[^>]+>', '', data['base_word'])
                                    if cleaned_base_word.strip():
                                        data['base_word'] = cleaned_base_word
                                    else: # If base_word becomes empty, remove positional entry? Or use key?
                                        print(f"      Warning: Positional base_word for '{cleaned_key}' became empty after cleaning.")
                                        continue # Skip this entry

                                cleaned_existing_positional[cleaned_key] = data # Store with cleaned key
                                if cleaned_key != segment:
                                     print(f"      Cleaned positional key from '{segment}' to '{cleaned_key}'")

                            existing_positional = cleaned_existing_positional
#                         print(f"    Existing positional count after cleaning: {len(existing_positional)}")

                        # Merge UI segments with existing ones
                        merged_segments = existing_segments.copy()
#                         print(f"    Merging {len(strikethrough_segments)} UI segments...")
                        for ui_segment, ui_data in positional_strikes.items(): # Use positional_strikes as source of UI segments
                            # Prioritize numbered/context specific from existing data if base matches
                            base_word_match = ui_segment # Assuming key is base word for now
                            found_specific_existing = False
                            for existing_key, existing_value in existing_segments.items():
                                # Check if existing key is a numbered/specific version of ui_segment
                                if existing_key.startswith(base_word_match + '_') or \
                                   (existing_key in existing_positional and existing_positional[existing_key].get('is_context_specific')):
                                    if existing_key in merged_segments: # Ensure it wasn't removed already
                                       # print(f"      Found specific variant '{existing_key}' for UI segment '{ui_segment}', prioritizing existing.")
                                       found_specific_existing = True
                                       break
                            if not found_specific_existing:
                                merged_segments[ui_segment] = True # Add or overwrite with UI version

                        # Merge positional data
                        merged_positional = existing_positional.copy()
                        for segment, data in positional_strikes.items():
                             # Always update positions from UI, but preserve context/specificity if exists
                             if segment in merged_positional:
                                 merged_positional[segment]["positions"] = data["positions"]
                                 merged_positional[segment]["original_length"] = data["original_length"] # Update length too
                                 # Keep existing context/specificity/base_word if present
                                 if "base_word" not in merged_positional[segment] or not merged_positional[segment]["base_word"]:
                                     merged_positional[segment]["base_word"] = segment # Add base_word if missing
                             else:
                                 # Add new positional data from UI (will lack context initially)
                                 merged_positional[segment] = {
                                     "positions": data["positions"],
                                     "original_length": data["original_length"],
                                     "is_context_specific": False, # Default for new UI finds
                                     "base_word": segment
                                 }
#                         print(f"    Total positional entries after UI merge: {len(merged_positional)}")


                        # Call merge_strikethrough_segments for cleanup and overlap resolution
#                         print("    Calling merge_strikethrough_segments for cleanup...")
                        final_merged_segments, final_positional_data = self.merge_strikethrough_segments(
                            annotation, merged_segments, merged_positional
                        )
#                         print(f"    Merge result: {len(final_merged_segments)} segments, {len(final_positional_data)} positional entries.")


                        # --- START: Calculate and Store Context (THE FIX) ---
#                         print(f"    Calculating/Updating context for {len(final_positional_data)} final segments...")
                        # We need the plain text derived from the UI label *without any s tags*
                        # ui_plain_text was calculated earlier based on clean_text_for_positions

                        for segment_key, data in final_positional_data.items():
                            if data and 'positions' in data and data['positions']:
                                try:
                                    # Use the first position pair for context calculation
                                    start, end = data['positions'][0]
                                    # Calculate context based on the UI's plain text
                                    context_before = ui_plain_text[max(0, start - 15) : start]
                                    context_after = ui_plain_text[end : min(len(ui_plain_text), end + 15)]

                                    # Update the data dictionary directly (it's a reference)
                                    data['context_before'] = context_before
                                    data['context_after'] = context_after
                                    # print(f"      Updated context for '{segment_key}': Before='{context_before}', After='{context_after}'") # Verbose log
                                except IndexError:
                                     print(f"      Warning: Could not access position data for segment '{segment_key}' during context calculation.")
                                except Exception as e:
                                     print(f"      Error calculating context for segment '{segment_key}': {e}")
                            else:
                                 print(f"      Warning: Missing/empty position data for segment '{segment_key}' - cannot calculate context.")
#                         print(f"    Context calculation complete.")
                        # --- END: Calculate and Store Context ---

                        # Store the final cleaned and context-updated data
                        if final_merged_segments:
                             annotation['storyboard']['strikethrough_segments'] = final_merged_segments
                        else: # Remove key if empty
                             annotation['storyboard'].pop('strikethrough_segments', None)

                        if final_positional_data:
                             annotation['storyboard']['positional_strikethrough'] = final_positional_data
                        else: # Remove key if empty
                             annotation['storyboard'].pop('positional_strikethrough', None)

                        # --- End Strikethrough ---

                        # Update order
                        annotation['order'] = i
#                         print(f"    Set order to {i}")

                        # Update the used status from the checkbox
                        used_checkbox = widget.findChild(CustomCheckBox)
                        if used_checkbox:
                            annotation['used'] = used_checkbox.isChecked()
#                             print(f"    Set used status to {annotation['used']}")

                        # Update favorite status from the favorite label
                        favorite_label = None
                        for child in widget.children():
                            if isinstance(child, QLabel) and child.objectName() == "favorite_label":
                                favorite_label = child
                                break
                        if favorite_label:
                            annotation['favorite'] = (favorite_label.text() == "★")
#                             print(f"    Set favorite status to {annotation['favorite']}")

                        # If storyboard becomes empty (only has order), remove it
                        if 'storyboard' in annotation and list(annotation['storyboard'].keys()) == ['text','order']:
                             if not annotation['storyboard'].get('strikethrough_segments') and \
                                not annotation['storyboard'].get('positional_strikethrough'):
                                     # Compare clean storyboard text with original annotation text
                                     clean_storyboard_text = re.sub(r'<[^>]+>', '', annotation['storyboard'].get('text', ''))
                                     clean_original_text = re.sub(r'<[^>]+>', '', annotation.get('text', ''))
                                     if clean_storyboard_text == clean_original_text:
                                         print(f"    Removing empty storyboard for {anno_id} as text matches original.")
                                         annotation.pop('storyboard', None)

                    else:
                         print(f"    Warning: Annotation {anno_id} not found in main data.")


            # Sort annotations based on the new order AFTER processing all items
            print("[DEBUG apply_changes_lite] Sorting annotations based on final order.")
            self.main_window.web_view.annotations.sort(key=lambda x: x.get('order', float('inf')))

            # Emit the signal to update scenes and show a status message
            print("[DEBUG apply_changes_lite] Emitting scenes_updated signal.")
            self.main_window.web_view.scenes_updated.emit()
            self.main_window.status_bar.showMessage('Changes applied successfully', 3000)

#             print("=== APPLY CHANGES LITE COMPLETE ===")

            # Optionally update word count
            if hasattr(self, 'word_counter'):
                self.word_counter.update_word_count()

            # # Mark changes as no longer pending
            self.changes_pending = False
            self.main_window.storyboard_changes_pending = False
            # # Clear asterisk from main window title if present
            # if self.main_window.current_session_file:
            #      current_title = self.main_window.windowTitle()
            #      if current_title.startswith('*'):
            #          self.main_window.setWindowTitle(current_title[1:])

            return True

        except Exception as e:
            print(f"Error applying changes lite: {e}")
            import traceback
            traceback.print_exc()
            self.changes_pending = True # Ensure changes remain pending on error
            self.main_window.storyboard_changes_pending = True
            return False

        # finally: # This block seemed to interfere with the return value logic
        #     # This check is misleading here as 'changes_pending' might be True due to an error above
        #     # if not self.changes_pending:
        #     #     print("Changes applied successfully in lite mode")
        #     pass


    def restore_scroll_position(self, pos, delay=150):
        """
        Helper method to restore the OrderListWidget's vertical scroll position
        after a given delay (in milliseconds) so that any layout updates
        have already finished.
        """
        print(f"[DEBUG] Scheduling scroll restoration to position: {pos} with delay: {delay}ms")
    
        # Define a restoration function that logs before and after
        def do_scroll_restore():
            before = self.order_list.verticalScrollBar().value()
            print(f"[DEBUG] Restoring scroll from {before} to {pos}")
            self.order_list.verticalScrollBar().setValue(pos)
            after = self.order_list.verticalScrollBar().value()
            if after != pos:
                print(f"[DEBUG] WARNING: Scroll restoration may have failed! Position is {after}, expected {pos}")
    
        # Use single-shot timer to delay restoration
        QTimer.singleShot(delay, do_scroll_restore)


    # Modify OrderListWidget.end_batch_updates to accept a callback
    def end_batch_updates(self, delay_before_show=10, callback=None):
        """
        Re-enable visual updates after sizing calculations are complete.

        Args:
            delay_before_show: Milliseconds to wait before showing changes
            callback: Optional function to call after updates are enabled
        """
        # Process any pending events before starting
        QApplication.processEvents()

        def restore_updates():
            # First calculate all sizes while updates are still disabled
            self.doItemsLayout()
    
            # Do the detailed sizing work while still invisible
            for i in range(self.count()):
                item = self.item(i)
                widget = self.itemWidget(item)
                if not widget:
                    continue
            
                if hasattr(widget, 'is_divider') and widget.is_divider:
                    continue  # Skip dividers
            
                text_label = None
                for label in widget.findChildren(QLabel):
                    if label.objectName() == "main_content_label":
                        text_label = label
                        break
                
                if text_label:
                    # Calculate sizing while invisible
                    available_width = self.get_available_text_width()
                    self._resize_text_label(text_label, available_width)
                    widget.adjustSize()
                    item.setSizeHint(widget.sizeHint())
    
            # Final layout update while still invisible
            self.doItemsLayout()
            QApplication.processEvents()
    
            # Now re-enable everything in the right order
            self.setAutoScroll(True)
            self.blockSignals(False)
    
            # Make visible - AFTER all sizing work is done
            self.viewport().setUpdatesEnabled(True)
            self.setUpdatesEnabled(True)
    
            # Restore scroll position
            if hasattr(self, '_saved_scroll_position'):
                self.verticalScrollBar().setValue(self._saved_scroll_position)
    
            # Final viewport update
            self.viewport().update()
    
            # Execute callback if provided
            if callback:
                QTimer.singleShot(10, callback)

        # Schedule with minimal delay
        QTimer.singleShot(delay_before_show, restore_updates)

    # Updated refresh_preserved_headers method with scroll position preservation
    def refresh_preserved_headers(self, scroll_position=None):
        """Refresh preserved headers after operations that might reset them."""
        # Use provided position or current position
        if scroll_position is None:
            scroll_position = getattr(self, '_original_scroll_position', 
                                   self.order_list.verticalScrollBar().value())
    
        print(f"[DEBUG] Saving scroll position in refresh_preserved_headers: {scroll_position}")
    
        try:
            # Initialize as an empty list (THIS IS THE KEY FIX)
            items_with_headers = []
        
            # Find items with headers and add them to our list
            for i in range(self.order_list.count()):
                item = self.order_list.item(i)
                if not item:
                    continue
                
                anno_id = item.data(Qt.ItemDataRole.UserRole)
                widget = self.order_list.itemWidget(item)
            
                # Skip dividers
                if widget and hasattr(widget, 'is_divider') and widget.is_divider:
                    continue
                
                # Check if this item has a header
                annotation = next((a for a in self.annotations if a.get('id') == anno_id), None)
                if not annotation:
                    continue
                
                # Check for header in storyboard text
                has_header = False
                if 'storyboard' in annotation and 'text' in annotation['storyboard']:
                    text = annotation['storyboard']['text']
                    if '<div><b' in text or '<b>' in text:
                        has_header = True
                    
                if has_header:
                    items_with_headers.append((item, anno_id))
        
            # Now it's safe to iterate
            for item, anno_id in items_with_headers:
                # Process each item with a header
                self.order_list.refresh_item_display(anno_id)
            
        except Exception as e:
            print(f"[ERROR] Error in refresh_preserved_headers: {e}")
            import traceback
            traceback.print_exc()
    
        finally:
            # Always restore the scroll position at the end, once
            QTimer.singleShot(10, lambda: self.order_list.verticalScrollBar().setValue(scroll_position))

    # Add this new method to the StoryboardDialog class
    def improve_strikethroughs_and_apply_changes(self):
        """
        Improve strikethrough display IF VISIBLE, and always apply changes
        to persist the updated strikethrough segments and order.
        """
        # # Abort if closing.
        # if hasattr(self, '_is_closing') and self._is_closing:
        #     print("[DEBUG] Skipping strikethrough improvements - dialog is closing")
        #     return

        print("\n=== IMPROVING STRIKETHROUGHS / APPLYING CHANGES ===")
        is_visible = self.isVisible() # Check visibility *once* at the start
        print(f"[DEBUG] Dialog visibility: {is_visible}")

        # Capture the current scroll position.
        current_scroll_position = getattr(self, '_original_scroll_position',
                                        self.order_list.verticalScrollBar().value())
        print(f"[DEBUG] Using saved scroll position: {current_scroll_position}")

        # Begin batch updates (important for apply_changes_lite too)
        # Pass the scroll position to preserve it during the entire operation.
        self.order_list.begin_batch_updates(saved_scroll_position=current_scroll_position)

        try:
            items_processed_visual = 0
            # --- Visual Update Part (Conditional) ---
            if is_visible:
                print("[DEBUG] Dialog is visible, performing visual strikethrough improvements.")
                # Process all non-divider items for visual update
                for i in range(self.order_list.count()):
                    item = self.order_list.item(i)
                    widget = self.order_list.itemWidget(item)
                    if widget and hasattr(widget, 'is_divider') and widget.is_divider:
                        continue # Skip dividers
                    if item:
                        annotation_id = item.data(Qt.ItemDataRole.UserRole)
                        if annotation_id:
                            # Call the visual update method
                            self.order_list.improve_strikethrough_display(annotation_id, skip_partial_fallback=True) # Added skip_partial_fallback based on your context
                            items_processed_visual += 1
                print(f"Processed {items_processed_visual} items for VISUAL strikethrough improvements")
            else:
                print("[DEBUG] Dialog is not visible, skipping visual strikethrough improvements.")
            # --- End Visual Update Part ---

            # --- Data Sync Part (Unconditional) ---
            print("[DEBUG] Applying changes (data sync) to persist updates.")
            # Apply changes directly within the batch update context
            success = self.apply_changes_lite() # This updates the main data structures
            if success:
                 print("[DEBUG] apply_changes_lite successful.")
            else:
                 print("[WARN] apply_changes_lite failed.")
            # --- End Data Sync Part ---

            # Refresh preserved headers (pass scroll position)
            # This also likely involves UI updates, so ideally check visibility,
            # but it might be less intensive than the full strikethrough refresh.
            # If header refresh causes issues when hidden, wrap it in `if is_visible:` too.
            # print("[DEBUG] Refreshing preserved headers.") # Optional debug
            # self.refresh_preserved_headers(current_scroll_position) # Pass position

        except Exception as e:
            print(f"Error in improve_strikethroughs_and_apply_changes: {e}")
            import traceback
            traceback.print_exc()
        finally:
            # End batch updates, ensuring scroll position is restored via the callback mechanism
            # within end_batch_updates. The callback restores the position passed to begin_batch_updates.
            print("[DEBUG] Ending batch updates for strikethrough/apply.")
            self.order_list.end_batch_updates(150) # Use a suitable delay
            print("=== STRIKETHROUGH IMPROVEMENT AND/OR CHANGES APPLIED ===\n")


    def apply_changes(self):
        """Apply changes to local and main window data structures with minimal visual impact and preserving context information."""
        # Use the original scroll position if available
        self.apply_changes_lite()
     

        # Emit updates
        self.main_window.web_view.scenes_updated.emit()
        
        # Update theme view items that may have changed in the storyboard (targeted approach)
        if self.main_window.theme_view:
            # Sync any annotation changes from storyboard to theme view
            if hasattr(self, '_sync_theme_view_items'):
                print("[DEBUG] Syncing theme view items with storyboard changes")
                self._sync_theme_view_items()
            else:
                print("[DEBUG] Fallback to full theme view update")
                self.main_window.update_theme_view()

        self.main_window.status_bar.showMessage('Changes applied successfully', 3000)
        print("=== APPLY CHANGES END ===")

        # Optionally update word count
        if hasattr(self, 'word_counter'):
            self.word_counter.update_word_count()
        return True

    def _sync_single_theme_view_item(self, annotation_id):
        """Sync a single annotation change from storyboard to theme view without full rebuild"""
        print(f"[DEBUG] Starting single item theme view sync for {annotation_id}")
        
        # Find the annotation in our data
        annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
        if not annotation:
            print(f"[DEBUG] Warning: Annotation {annotation_id} not found for sync")
            return
            
        scene = annotation.get('scene', '')
        scene_tabs = self.main_window.scene_tabs
        
        # Find the corresponding item in theme view
        found_tab = False
        found_item = False
        
        print(f"[DEBUG] Looking for annotation {annotation_id} in scene '{scene}'")
        for i in range(scene_tabs.count()):
            tab_name = scene_tabs.tabText(i)
            print(f"[DEBUG] Checking tab {i}: '{tab_name}'")
            if tab_name == scene:
                found_tab = True
                print(f"[DEBUG] Found matching tab: '{scene}'")
                list_widget = scene_tabs.widget(i)
                if isinstance(list_widget, AnnotationListWidget):
                    print(f"[DEBUG] Tab has {list_widget.count()} items")
                    # Find the specific item with this annotation ID
                    for j in range(list_widget.count()):
                        item = list_widget.item(j)
                        if item:
                            item_id = item.data(Qt.ItemDataRole.UserRole)
                            print(f"[DEBUG] Item {j} has ID: {item_id}")
                            if item_id == annotation_id:
                                found_item = True
                            widget = list_widget.itemWidget(item)
                            if widget:
                                # Update favorite star
                                favorite_button = widget.property('cached_star_button')
                                if favorite_button:
                                    is_favorite = annotation.get('favorite', False)
                                    favorite_button.setChecked(is_favorite)
                                
                                # Update used checkbox
                                checkbox = widget.property('cached_checkbox')
                                if checkbox:
                                    is_used = annotation.get('used', False)
                                    checkbox.blockSignals(True)  # Prevent recursive callbacks
                                    checkbox.setChecked(is_used)
                                    checkbox.blockSignals(False)
                                
                                print(f"[DEBUG] Synced single item {annotation_id} in scene {scene}")
                                return
                        break
                break
        
        if not found_tab:
            print(f"[DEBUG] ERROR: Could not find tab for scene '{scene}'")
        elif not found_item:
            print(f"[DEBUG] ERROR: Found tab '{scene}' but could not find item with ID {annotation_id}")
        
        print(f"[DEBUG] Warning: Could not find theme view item for {annotation_id}")

    def handle_external_annotation_update(self, annotation_json):
        """Handle annotation updates from theme view to sync storyboard without expensive rebuilds"""
        try:
            import json
            annotation_data = json.loads(annotation_json)
            annotation_id = annotation_data.get('id')
            
            if not annotation_id:
                print("[DEBUG] No annotation ID in external update")
                return
                
            print(f"[DEBUG] Storyboard received external annotation update for {annotation_id}")
            
            # First, update our local annotation data to stay in sync
            annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
            if annotation:
                if 'used' in annotation_data:
                    annotation['used'] = annotation_data['used']
                if 'favorite' in annotation_data:
                    annotation['favorite'] = annotation_data['favorite']
                if 'notes' in annotation_data:
                    annotation['notes'] = annotation_data['notes']
                if 'notes_html' in annotation_data:
                    annotation['notes_html'] = annotation_data['notes_html']
                if 'tags' in annotation_data:
                    annotation['tags'] = annotation_data['tags']
                    print(f"[DEBUG] Updated tags for annotation {annotation_id}: {annotation_data['tags']}")
                print(f"[DEBUG] Updated storyboard data for annotation {annotation_id}")
            
            # Then update visual state for all properties (skip theme sync since this came from theme view)
            if 'used' in annotation_data:
                self.update_annotation_visual_state(annotation_id, 'used', annotation_data['used'], skip_theme_sync=True)
            if 'favorite' in annotation_data:
                self.update_annotation_visual_state(annotation_id, 'favorite', annotation_data['favorite'], skip_theme_sync=True)
            if 'notes' in annotation_data:
                self.update_annotation_visual_state(annotation_id, 'notes', annotation_data['notes'], skip_theme_sync=True)
            if 'tags' in annotation_data:
                # Tags are handled by the existing refresh_annotation_display method
                # which is called by auto_apply_annotation_tag - no additional action needed
                print(f"[DEBUG] Tags update will be handled by refresh_annotation_display for {annotation_id}")
                
        except Exception as e:
            print(f"[DEBUG] Error handling external annotation update: {e}")

    def _sync_theme_view_items(self):
        """Sync annotation changes from storyboard to theme view without full rebuild"""
        print("[DEBUG] Starting targeted theme view sync")
        
        # Get all changed annotations that might need visual updates in theme view
        scene_tabs = self.main_window.scene_tabs
        
        # Go through each annotation in our storyboard data
        for annotation in self.annotations:
            annotation_id = annotation.get('id')
            if not annotation_id:
                continue
                
            scene = annotation.get('scene', '')
            
            # Find the corresponding item in theme view
            for i in range(scene_tabs.count()):
                if scene_tabs.tabText(i) == scene:
                    list_widget = scene_tabs.widget(i)
                    if isinstance(list_widget, AnnotationListWidget):
                        # Find the specific item with this annotation ID
                        for j in range(list_widget.count()):
                            item = list_widget.item(j)
                            if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                                widget = list_widget.itemWidget(item)
                                if widget:
                                    # Update favorite star
                                    favorite_button = widget.property('cached_star_button')
                                    if favorite_button:
                                        is_favorite = annotation.get('favorite', False)
                                        favorite_button.setChecked(is_favorite)
                                    
                                    # Update used checkbox
                                    checkbox = widget.property('cached_checkbox')
                                    if checkbox:
                                        is_used = annotation.get('used', False)
                                        checkbox.blockSignals(True)  # Prevent recursive callbacks
                                        checkbox.setChecked(is_used)
                                        checkbox.blockSignals(False)
                                    
                                    print(f"[DEBUG] Synced item {annotation_id} in scene {scene}")
                                break
                    break


    def handle_close(self):
        """Handle the close button click"""
        print("Handle close called, changes_pending:", self.changes_pending)  # Debug
        if self.changes_pending:
            print("Showing save dialog")  # Debug
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle('Save Changes')
            msg_box.setText('You have unsaved changes. What would you like to do?')

            # Create custom buttons with fixed width
            apply_save_button = QPushButton("Apply and Save")
            discard_button = QPushButton("Discard Changes")
            cancel_button = QPushButton("Cancel")

            # Set fixed width for all buttons
            button_width = 110
            apply_save_button.setFixedWidth(button_width)
            discard_button.setFixedWidth(button_width)
            cancel_button.setFixedWidth(button_width)

            # Add buttons to message box
            msg_box.addButton(apply_save_button, QMessageBox.ButtonRole.AcceptRole)
            msg_box.addButton(discard_button, QMessageBox.ButtonRole.DestructiveRole)
            msg_box.addButton(cancel_button, QMessageBox.ButtonRole.RejectRole)

            # Set minimum width for message box
            msg_box.setMinimumWidth(400)

            ret = msg_box.exec()
            print("Dialog returned:", ret)  # Debug
            clicked_button = msg_box.clickedButton()

            if clicked_button == apply_save_button:
                print("Apply and Save clicked")  # Debug
                # First apply changes
                success = self.apply_changes()
                if success:
                    print("Changes applied successfully")
                    self.changes_pending = False
                    self.main_window.storyboard_changes_pending = False
                
                    # Hide immediately instead of minimizing
                    self.hide()
                
                    # Then initiate save on the main window
                    self.main_window.save_session()
                else:
                    print("Failed to apply changes")
                    self.changes_pending = True
                    self.main_window.storyboard_changes_pending = True
                    return  # Don't hide if changes failed to apply
        
            elif clicked_button == discard_button:
                print("Discard clicked")  # Debug
                self.changes_pending = False
                self.main_window.storyboard_changes_pending = False
                self.populate_order_list_skip_partial_fallback()  # Revert to last saved state
                self.hide()  # Hide instead of minimize
            else:
                print("Cancel clicked or dialog closed")  # Debug
                return
        else:
            print("No changes pending, closing normally")  # Debug
            self.changes_pending = False
            self.main_window.storyboard_changes_pending = False
            self.hide()  # Hide instead of minimize

    # 1. Add a method to cancel pending timers in StoryboardDialog class
    def cancel_pending_operations(self):
        """Cancel any pending operations when the dialog is being closed."""
        print("[DEBUG] Cancelling all pending storyboard operations")
    
        # Find and cancel any pending timers attached to this dialog
        for child in self.children():
            if isinstance(child, QTimer) and child.isActive():
                print(f"[DEBUG] Stopping active timer: {child}")
                child.stop()
    
        # Also check for global QTimers with lambdas pointing to this object
        # (This is a best effort approach since we can't directly access all QTimers)
    
        # Set a flag to prevent any scheduled operations from executing
        self._is_closing = True
    
        # Block signals to prevent any unexpected callbacks
        self.blockSignals(True)
    
        print("[DEBUG] All pending operations cancelled")

    # ──────────────────────────────────────────────────────────────────────────────
    # Collapse / Expand widget‑mode logic
    # ──────────────────────────────────────────────────────────────────────────────

    def collapse_to_widget(self):
        """Shrink the Script Editor window into the floating pill."""
        print("Starting collapse_to_widget for Script Editor...")
        
        # ── remember size / state (but *not* position) ────────────────
        if not hasattr(self, "saved_window_state"):
            self.saved_window_state = {}
        self.saved_window_state["size"]         = self.size()
        self.saved_window_state["window_state"] = self.windowState()
        print(f"Saved window size: {self.saved_window_state['size']}")

        # ── record frame‑border offsets (title‑bar etc.) once ─────────
        geo, frame = self.geometry(), self.frameGeometry()
        self._border_dx = geo.x() - frame.x()   # left border width
        self._border_dy = geo.y() - frame.y()   # title bar + top border
        print(f"Window geometry: {geo}, frame: {frame}")

        # ── create pill widget the first time ─────────────────────────
        if not hasattr(self, "collapsible_widget") or self.collapsible_widget is None:
            print("Creating new CollapsibleWidget for Script Editor...")
            self.collapsible_widget = CollapsibleWidget()
            self.collapsible_widget.expandClicked.connect(self.expand_from_widget)
            self.collapsible_widget.restoreMainWindow.connect(self.expand_from_widget)
            print("Connected restoreMainWindow signal to expand_from_widget")

        pill = self.collapsible_widget

        # ── place pill in top‑right corner of current frame ───────────
        margin = 10
        pill_x = frame.right() - pill.width() - margin
        pill_y = frame.top() + margin
        print(f"Positioning pill at: ({pill_x}, {pill_y})")
        pill.move(pill_x, pill_y)

        # ── swap visibility ───────────────────────────────────────────
        print("Showing pill and hiding Script Editor window...")
        pill.show()
        pill.raise_()
        pill.activateWindow()
        self.hide()
        
        # Update collapsed state
        self._is_collapsed = True
        print("Collapse completed.")

    def expand_from_widget(self):
        """Restore the Script Editor window exactly beside the pill—no cumulative drift."""
        print("Starting expand_from_widget for Script Editor...")
        pill = getattr(self, "collapsible_widget", None)
        if pill is None:
            print("No collapsible widget found!")
            return

        # ── hide pill while we show the main window ───────────────────
        pill_pos = pill.pos()         # current pill position in global coords
        print(f"Pill position: {pill_pos}")
        pill.hide()

        # ── retrieve stored window size / state ───────────────────────
        size  = self.saved_window_state.get("size", QSize(550, 550))
        flags = self.saved_window_state.get("window_state", Qt.WindowState.WindowNoState)
        win_w, win_h = size.width(), size.height()
        print(f"Restoring window size: {win_w}x{win_h}")

        # ── calculate new top‑left in *client* coords ─────────────────
        margin  = 10
        border_x = getattr(self, "_border_dx", 0)
        border_y = getattr(self, "_border_dy", 0)

        new_x = pill_pos.x() + pill.width() + margin - win_w + border_x
        new_y = pill_pos.y()               - margin     + border_y

        # clamp into the virtual desktop rectangle
        desktop = QApplication.primaryScreen().virtualGeometry()
        new_x = max(desktop.left(),  min(new_x, desktop.right()  - win_w))
        new_y = max(desktop.top(),   min(new_y, desktop.bottom() - win_h))
        print(f"Positioning Script Editor window at: ({new_x}, {new_y})")

        # ── show main window in that spot ─────────────────────────────
        self.setGeometry(new_x, new_y, win_w, win_h)
        self.setWindowState(flags)
        self.show()
        self.raise_()
        self.activateWindow()
        
        # Update collapsed state
        self._is_collapsed = False
        print("Script Editor window restored.")

    def is_collapsed(self):
        """Check if the Script Editor is currently in collapsed (floating widget) mode."""
        return getattr(self, '_is_collapsed', False)
    
    def ensure_visible(self):
        """Ensure the Script Editor is visible (expand if collapsed)."""
        if self.is_collapsed():
            print("Script Editor is collapsed, expanding for external access...")
            self.expand_from_widget()
        elif not self.isVisible():
            print("Script Editor is hidden, showing window...")
            self.show()
            self.raise_()
            self.activateWindow()
    
    def focus_for_operation(self):
        """Bring Script Editor to focus for operations that require visibility."""
        if self.is_collapsed():
            # Don't auto-expand, but ensure the floating widget is visible and focused
            if hasattr(self, 'collapsible_widget') and self.collapsible_widget:
                self.collapsible_widget.raise_()
                self.collapsible_widget.activateWindow()
                print("Script Editor is collapsed - floating widget brought to front")
        else:
            # Normal window - bring to front
            self.raise_()
            self.activateWindow()
            print("Script Editor window brought to front")
    
    def hide_completely(self):
        """Hide both the main window and floating widget (for toggle off)."""
        if self.is_collapsed():
            print("[DEBUG] Hiding floating widget completely")
            if hasattr(self, 'collapsible_widget') and self.collapsible_widget:
                self.collapsible_widget.hide()
            # Reset collapsed state since widget is hidden
            self._is_collapsed = False
        else:
            print("[DEBUG] Hiding main Script Editor window")
            self.hide()

    # 2. Modify StoryboardDialog's closeEvent method to ensure proper cleanup
    def closeEvent(self, event):
        """Handle window close event (X button click)"""
        print("\n=== STORYBOARD CLOSEEVENT START ===")
        print(f"[DEBUG] At the start of closeEvent, changes_pending = {self.changes_pending}")

        # Cancel any pending operations first
        self.cancel_pending_operations()
    
        # Reset state for clean reopening later
        self.reset_state()

        # Always attempt to apply changes
        print("[DEBUG] Attempting to apply changes...")

        # First hide the dialog but don't close it immediately
        self.hide()
        event.ignore()  # Prevent immediate close
        print("[DEBUG] Dialog hidden, close event ignored temporarily")

        try:
            # Apply changes directly
            if hasattr(self, 'apply_changes'):
                print("[DEBUG] Starting apply_changes...")
                success = self.apply_changes_lite()
                print(f"[DEBUG] After apply_changes, changes_pending = {self.changes_pending}")

                if success:
                    print("[DEBUG] Changes applied successfully, syncing state...")
                    QTimer.singleShot(100, lambda: self.complete_close(event))
                else:
                    print("[DEBUG] Failed to apply changes, showing dialog again")
                    self.show()
            else:
                print("[DEBUG] Error: apply_changes method not found; re-showing dialog")
                self.show()

        except Exception as e:
            print(f"\n[DEBUG] ERROR during close process: {e}")
            print("[DEBUG] Showing dialog again due to error")
            self.show()

    # 3. Modify the complete_close method to ensure proper cleanup
    def complete_close(self, event):
        print("\n[DEBUG] === COMPLETING STORYBOARD CLOSE ===")
        print("[DEBUG] Clearing changes_pending flag")
    
        # Ensure the dialog is properly marked as closing
        self._is_closing = True
    
        print("[DEBUG] Emitting closed signal")
        self.closed.emit()

        print("[DEBUG] Resetting storyboard button")
        if hasattr(self.main_window, 'storyboard_button'):
            self.main_window.storyboard_button.setChecked(False)

        # Close the collapsible widget if it exists
        print("[DEBUG] Cleaning up collapsible widget")
        if hasattr(self, 'collapsible_widget') and self.collapsible_widget is not None:
            self.collapsible_widget.close()

        print("[DEBUG] Calling parent closeEvent")
        super().closeEvent(event)
        print("=== STORYBOARD CLOSE COMPLETE ===\n")


class AnnotationNoteDialog(QDialog):
    def __init__(self, parent=None, note_text="", anchor_widget=None, main_window=None):
        super().__init__(parent, Qt.WindowType.Popup | Qt.WindowType.FramelessWindowHint)
        self.setFixedWidth(500)
        
        # Store initial text and convert to HTML if it's plain text
        self.initial_text = note_text

        # Main Layout
        layout = QVBoxLayout(self)
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Main Frame
        frame = QFrame(self)
        frame.setObjectName("noteFrame")
        frame_layout = QVBoxLayout(frame)
        frame_layout.setSpacing(3)
        frame_layout.setContentsMargins(15, 15, 15, 15)
        
        # Header
        header_widget = QWidget()
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(10)
        
        header = QLabel("Edit Commentary")
        header.setObjectName("dialogHeader")
        header_layout.addWidget(header)

        # Add formatting toolbar
        toolbar = QToolBar()
        toolbar.setStyleSheet("""
            QToolBar {
                spacing: 2px;
                background: transparent;
                border: none;
            }
            QToolButton {
                border: 1px solid transparent;
                border-radius: 4px;
                padding: 3px;
            }
            QToolButton:hover {
                background-color: #f0f0f0;
                border: 1px solid #ddd;
            }
        """)

        # Add formatting actions
        bold_action = QAction("B", self)
        bold_action.setCheckable(True)
        bold_action.triggered.connect(lambda: self.format_text('bold'))
        toolbar.addAction(bold_action)

        italic_action = QAction("I", self)
        italic_action.setCheckable(True)
        italic_action.triggered.connect(lambda: self.format_text('italic'))
        toolbar.addAction(italic_action)

        underline_action = QAction("U", self)
        underline_action.setCheckable(True)
        underline_action.triggered.connect(lambda: self.format_text('underline'))
        toolbar.addAction(underline_action)

        header_layout.addWidget(toolbar)
        
        # Add spacer to push buttons to the right
        header_layout.addStretch()
        
        # Add expand button (to the left of close button)
        self.expand_button = QPushButton("⤢")
        self.expand_button.setObjectName("expandButton")
        self.expand_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.expand_button.setToolTip("Expand dialog")
        self.expand_button.clicked.connect(self.toggle_expand)
        self.is_expanded = False
        self.original_size = None
        self.original_pos = None
        header_layout.addWidget(self.expand_button)
        
        close_button = QPushButton("❌")
        close_button.setObjectName("closeButton")
        close_button.setCursor(Qt.CursorShape.PointingHandCursor)
        close_button.clicked.connect(self.close)
        header_layout.addWidget(close_button)
        
        frame_layout.addWidget(header_widget)
        
        # Note Text Edit with HTML support
        self.note_edit = QTextEdit()
        self.note_edit.setPlaceholderText("Enter detailed commentary...")
        self.note_edit.setObjectName("noteEdit")
        # Simply set the HTML directly
        self.note_edit.setHtml(self.initial_text if self.initial_text else "")
        self.note_edit.setMinimumHeight(500)
        self.note_edit.setAcceptRichText(True)
        frame_layout.addWidget(self.note_edit)

        # Context menu for tags
        self.note_edit.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.note_edit.customContextMenuRequested.connect(self.show_note_context_menu)
        
        # Enhanced styling for rich text
        self.setStyleSheet("""
            QDialog {
                background: #ffffff;
                border: 1px solid #e0e0e0;
                border-radius: 8px;
            }
            #noteFrame {
                background-color: #ffffff;
                border: none;
                border-radius: 8px;
            }
            #dialogHeader {
                color: #2C4952;
                font-size: 16px;
                font-weight: bold;
            }
            #closeButton {
                background: transparent;
                border: none;
                color: #666;
                font-size: 14px;
                padding: 0px 4px;
                margin: 0;
                min-width: 20px;
                min-height: 20px;
            }
            #closeButton:hover {
                background: #f0f0f0;
                border-radius: 4px;
                color: #333;
            }
            #expandButton {
                background: transparent;
                border: none;
                color: #666;
                font-size: 18px;
                padding: 0px 4px;
                margin: 0;
                min-width: 20px;
                min-height: 20px;
            }
            #expandButton:hover {
                background: #f0f0f0;
                border-radius: 4px;
                color: #333;
            }
            #noteEdit {
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 8px;
                font-size: 13px;
                background: white;
            }
            #noteEdit:focus {
                border-color: #2196F3;
            }
            QToolButton {
                font-weight: bold;
                min-width: 24px;
            }
        """)
        
        # Add shadow effect
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(15)
        shadow.setColor(QColor(0, 0, 0, 40))
        shadow.setOffset(0, 2)
        self.setGraphicsEffect(shadow)
        
        if anchor_widget:
            self.position_dialog(anchor_widget)
        
        self.installEventFilter(self)
        layout.addWidget(frame)
        self.main_window = main_window

    def ensure_html_format(self, text):
        """Convert plain text to HTML if necessary"""
        if not text.strip().startswith('<'):
            # Escape special characters and convert newlines to <br>
            text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
            text = text.replace('\n', '<br>')
            text = f'<p>{text}</p>'
        return text

    def format_text(self, format_type):
        """Apply formatting to selected text"""
        cursor = self.note_edit.textCursor()
        if cursor.hasSelection():
            if format_type == 'bold':
                self.note_edit.setFontWeight(
                    QFont.Weight.Normal 
                    if self.note_edit.fontWeight() == QFont.Weight.Bold 
                    else QFont.Weight.Bold
                )
            elif format_type == 'italic':
                self.note_edit.setFontItalic(not self.note_edit.fontItalic())
            elif format_type == 'underline':
                self.note_edit.setFontUnderline(not self.note_edit.fontUnderline())

    def show_note_context_menu(self, pos):
        """Show custom context menu with formatting options and tags"""
        # Create standard context menu first (includes Cut, Copy, Paste, etc.)
        menu = self.note_edit.createStandardContextMenu()
        
        menu.addSeparator()
        
        # Add formatting options
        format_menu = menu.addMenu("Format")
        bold_action = format_menu.addAction("Bold")
        bold_action.triggered.connect(lambda: self.format_text('bold'))
        italic_action = format_menu.addAction("Italic")
        italic_action.triggered.connect(lambda: self.format_text('italic'))
        underline_action = format_menu.addAction("Underline")
        underline_action.triggered.connect(lambda: self.format_text('underline'))
        
        # Add tags submenu
        if self.main_window and hasattr(self.main_window, 'tags') and self.main_window.tags:
            tags_menu = menu.addMenu("Insert Tag")
            for tag in self.main_window.tags:
                action = tags_menu.addAction(tag)
                action.triggered.connect(lambda checked, t=tag: self.insert_tag(t))
        
        menu.exec(self.note_edit.mapToGlobal(pos))

    def insert_tag(self, tag):
        """Insert the selected tag at cursor position"""
        cursor = self.note_edit.textCursor()
        cursor.insertText(tag)

    def position_dialog(self, anchor_widget):
        """Position the dialog relative to the anchor widget with smart boundary detection"""
        # Force layout calculation and proper sizing
        self.layout().activate()
        self.adjustSize()
        
        # If height is still 0, use a reasonable default
        if self.height() == 0:
            self.resize(500, 600)  # Set reasonable default size
            print(f"[DEBUG] Dialog height was 0, using default size: 500x600")
        
        anchor_rect = anchor_widget.rect()
        global_pos = anchor_widget.mapToGlobal(anchor_rect.topLeft())
        screen = QApplication.primaryScreen().availableGeometry()
        
        print(f"[DEBUG] Positioning dialog:")
        print(f"  Dialog size: {self.width()}x{self.height()}")
        print(f"  Anchor rect: {anchor_rect}")
        print(f"  Anchor global pos: {global_pos}")
        print(f"  Screen geometry: {screen}")
        
        # Preferred position: to the left of anchor
        preferred_x = global_pos.x() - self.width() - 10
        preferred_y = global_pos.y()
        
        # Try different positions in order of preference
        positions_to_try = [
            # 1. Left of anchor (preferred)
            (preferred_x, preferred_y),
            # 2. Right of anchor 
            (global_pos.x() + anchor_rect.width() + 10, preferred_y),
            # 3. Above anchor (centered)
            (global_pos.x() + (anchor_rect.width() - self.width()) // 2, global_pos.y() - self.height() - 10),
            # 4. Below anchor (centered)
            (global_pos.x() + (anchor_rect.width() - self.width()) // 2, global_pos.y() + anchor_rect.height() + 10),
            # 5. Centered on screen (fallback)
            (screen.center().x() - self.width() // 2, screen.center().y() - self.height() // 2)
        ]
        
        # Find the first position that fits completely on screen
        final_pos = None
        for x, y in positions_to_try:
            dialog_rect = QRect(x, y, self.width(), self.height())
            if screen.contains(dialog_rect):
                final_pos = QPoint(x, y)
                break
        
        # If no position fits completely, use smart clamping
        if final_pos is None:
            # Use the preferred position but clamp to screen boundaries
            x = max(screen.left() + 10, min(preferred_x, screen.right() - self.width() - 10))
            y = max(screen.top() + 10, min(preferred_y, screen.bottom() - self.height() - 10))
            final_pos = QPoint(x, y)
            print(f"[DEBUG] Using clamped position: {final_pos}")
        else:
            print(f"[DEBUG] Using fitted position: {final_pos}")
        
        self.move(final_pos)
        print(f"[DEBUG] Dialog positioned at: {self.pos()}")

    def toggle_expand(self):
        """Toggle between normal and expanded dialog size"""
        if not self.is_expanded:
            # Expanding: save current state and expand
            self.original_size = self.size()
            self.original_pos = self.pos()
            
            # Get screen geometry for centering
            screen = QApplication.primaryScreen().availableGeometry()
            
            # Calculate new size (double the dimensions)
            new_width = min(self.width() * 2, screen.width() - 100)  # Cap at screen width minus margin
            new_height = min(self.height() * 2, screen.height() - 100)  # Cap at screen height minus margin
            
            # Center on screen
            new_x = screen.center().x() - new_width // 2
            new_y = screen.center().y() - new_height // 2
            
            # Remove fixed width constraint and apply new size
            self.setMinimumWidth(0)
            self.setMaximumWidth(16777215)  # Qt's maximum width
            self.resize(new_width, new_height)
            self.move(new_x, new_y)
            
            # Update button appearance
            self.expand_button.setText("⤡")
            self.expand_button.setToolTip("Restore dialog")
            self.is_expanded = True
            
            print(f"[DEBUG] Expanded dialog to {new_width}x{new_height} at ({new_x}, {new_y})")
            
        else:
            # Collapsing: restore original state
            if self.original_size and self.original_pos:
                # Restore fixed width constraint
                self.setFixedWidth(500)
                self.resize(self.original_size)
                self.move(self.original_pos)
            
            # Update button appearance
            self.expand_button.setText("⤢")
            self.expand_button.setToolTip("Expand dialog")
            self.is_expanded = False
            
            print(f"[DEBUG] Restored dialog to original size and position")

    def eventFilter(self, obj, event):
        """Handle click-away closing"""
        if event.type() == QEvent.Type.MouseButtonPress:
            global_click_pos = event.globalPosition().toPoint()
            if not self.geometry().contains(global_click_pos):
                self.close()
                return True
        return super().eventFilter(obj, event)

    # In AnnotationNoteDialog, update get_html_text:
    def get_html_text(self):
        """Get the current note text as HTML for storage.
        Returns an empty string if no meaningful text is present."""
        html = self.note_edit.toHtml() or ""
        if self.get_plain_text().strip() == "":
            return ""
        return html


    def get_note_text(self):
        """Get the current note text as plain text for display"""
        return self.note_edit.toPlainText()

    def get_plain_text(self):
        """Get the current note text as plain text for display"""
        return self.note_edit.toPlainText().strip()

    def closeEvent(self, event):
        """Override close event to always accept changes"""
        super().closeEvent(event)
        self.accept() # -- this is the HTML notes

class ItemSizeWorker(QRunnable):
    """Worker for calculating item sizes in background thread"""
    
    def __init__(self, list_widget, item, widget, force_full_calculation=False, override_width=None):
        super().__init__()
        self.list_widget = list_widget
        self.item = item
        self.widget = widget
        self.force_full_calculation = force_full_calculation
        self.override_width = override_width
        self.item_id = item.data(Qt.ItemDataRole.UserRole) if item else "Unknown"
        
    def run(self):
        """Calculate dimensions in background thread"""
        try:
            # Cache viewport width to avoid repeated calculations
            if not hasattr(self.list_widget, '_sizing_constants'):
                return  # Widget not ready
                
            # Use override width if provided, otherwise use cached viewport width
            current_width = self.override_width if self.override_width else self.list_widget._last_viewport_width
            available_width = max(100, current_width - 40)
            
            # Check if we already calculated dimensions for this width
            cached_dimensions = self.widget.property('cached_dimensions')
            if cached_dimensions and cached_dimensions.get('viewport_width') == current_width and not self.force_full_calculation:
                # Use cached dimensions - emit signal to apply on main thread
                QMetaObject.invokeMethod(self.list_widget, "_apply_cached_dimensions",
                                       Qt.ConnectionType.QueuedConnection,
                                       Q_ARG(object, self.item),
                                       Q_ARG(object, self.widget),
                                       Q_ARG(object, cached_dimensions))
                return
            
            # Check visibility for optimization
            is_item_visible = QMetaObject.invokeMethod(self.list_widget, "isItemVisible",
                                                     Qt.ConnectionType.BlockingQueuedConnection,
                                                     Q_RETURN_ARG(bool),
                                                     Q_ARG(object, self.item))
            
            # Check if tab is visible
            parent_widget = self.list_widget.parent()
            is_tab_visible = True
            if hasattr(parent_widget, 'indexOf') and hasattr(parent_widget, 'currentIndex'):
                tab_index = parent_widget.indexOf(self.list_widget)
                current_index = parent_widget.currentIndex()
                is_tab_visible = (tab_index == current_index)
            
            is_truly_visible = is_item_visible and is_tab_visible
            
            if self.force_full_calculation or is_truly_visible:
                # Calculate full dimensions
                dimensions = self._calculate_full_dimensions(available_width, current_width)
                # Apply on main thread
                QMetaObject.invokeMethod(self.list_widget, "_apply_full_dimensions",
                                       Qt.ConnectionType.QueuedConnection,
                                       Q_ARG(object, self.item),
                                       Q_ARG(object, self.widget),
                                       Q_ARG(object, dimensions))
            else:
                # Use placeholder dimensions
                placeholder_height = self.list_widget._sizing_constants['PLACEHOLDER_HEIGHT']
                placeholder_dims = {
                    'viewport_width': current_width,
                    'width': available_width,
                    'height': placeholder_height,
                    'is_placeholder': True
                }
                QMetaObject.invokeMethod(self.list_widget, "_apply_placeholder_dimensions",
                                       Qt.ConnectionType.QueuedConnection,
                                       Q_ARG(object, self.item),
                                       Q_ARG(object, self.widget),
                                       Q_ARG(object, placeholder_dims))
        except Exception as e:
            print(f"Error in ItemSizeWorker: {e}")
    
    def _calculate_full_dimensions(self, available_width, current_width):
        """Calculate full item dimensions (safe for background thread)"""
        try:
            # Get cached label (should be thread-safe property access)
            label = self.widget.property('cached_label')
            if not label:
                # Need to get label on main thread
                return None
                
            label_width = available_width - self.list_widget._sizing_constants['CHECKBOX_WIDTH'] - self.list_widget._sizing_constants['PADDING_WIDTH']
            
            # Get or create cached metrics bundle
            metrics_bundle = self.widget.property('metrics_bundle')
            if not metrics_bundle or metrics_bundle.get('width') != label_width:
                font_metrics = self.widget.property('cached_font_metrics')
                text = self.widget.property('cached_text')
                
                if font_metrics and text:
                    # Calculate text rectangle
                    text_rect = font_metrics.boundingRect(
                        QRect(0, 0, label_width, 2000),
                        Qt.TextFlag.TextWordWrap,
                        text
                    )
                    
                    metrics_bundle = {
                        'width': label_width,
                        'text_height': text_rect.height() + 10
                    }
                else:
                    return None
            
            # Calculate final dimensions
            notes_edit = self.widget.property('cached_notes_edit')
            notes_height = 0
            if notes_edit:
                # Get size hint safely
                try:
                    notes_height = notes_edit.sizeHint().height() + 12
                except:
                    notes_height = 30  # fallback
            
            total_height = metrics_bundle['text_height'] + notes_height + 32
            total_height = max(total_height, self.list_widget._sizing_constants['MIN_HEIGHT'])
            
            return {
                'viewport_width': current_width,
                'width': available_width,
                'height': total_height,
                'metrics_bundle': metrics_bundle,
                'is_placeholder': False
            }
        except Exception as e:
            print(f"Error calculating dimensions: {e}")
            return None

class AnnotationListWidget(QListWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Remove default item borders and styling
        self.setStyleSheet("""
            QListWidget::item {
                border: none;
                outline: none;
                background: transparent;
            }
            QListWidget::item:selected {
                border: none;
                outline: none;
                background: rgba(0, 123, 255, 0.1);
            }
            QListWidget::item:focus {
                border: none;
                outline: none;
            }
        """)
        
        # Initialize last note update dictionary - **MODIFIED**
        self._last_note_update = {
            'text': None,
            'annotation_id': None,
            'notes': None,          # Plain text
            'notes_html': None      # HTML formatted
        }
        # Add a timer for debounced updates
        self._notes_update_timer = QTimer()
        self._notes_update_timer.setSingleShot(True)
        self._notes_update_timer.setInterval(500)  # 2 seconds
        self._notes_update_timer.timeout.connect(self._handle_delayed_notes_update)
        
        # Initialize thread pool for background size calculations
        self._size_thread_pool = QThreadPool()
        self._size_thread_pool.setMaxThreadCount(2)  # Limit to 2 threads for UI responsiveness
        self._pending_size_updates = set()  # Track pending updates to avoid duplicates
        self._threading_optimized = True  # Flag to enable immediate resize processing

        # Cache all fonts at initialization
        self._star_font = QFont()
        self._star_font.setPointSize(18)
        
        self._label_font = QFont("Segoe UI", 13)
        self._label_font_metrics = QFontMetrics(self._label_font)
        
        self._notes_font = QFont("Segoe UI", weight=QFont.Weight.Bold)
        
        # Cache icons at initialization
        base_path = os.path.dirname(os.path.abspath(__file__))
        self._cached_icons = {
            'notes': {
                'normal': QIcon(os.path.join(base_path, "Img", "Icons", "Notes.png")),
                'hover': QIcon(os.path.join(base_path, "Img", "Icons", "Notes-hover.png")),
                'active': QIcon(os.path.join(base_path, "Img", "Icons", "Notes-active.png"))
            }
        }

        self.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDropIndicatorShown(True)
        self.setDefaultDropAction(Qt.DropAction.MoveAction)
        self.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)
        self.setWordWrap(True)
        self.setSpacing(4)
        self.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)
        
        self.itemDoubleClicked.connect(self.scroll_to_annotation)
        
        # Connect scroll bar changes to trigger visual updates for newly visible items
        self.verticalScrollBar().valueChanged.connect(self._onScrollValueChanged)
        
        # Apply widget stylesheet
        self.setStyleSheet("""
            QListWidget {
                background-color: white;
                border: none;
                border-radius: 5px;
                padding: 5px;
                font-size: 12px;
                line-height: 1.8;
                outline: none;
            }
            QListWidget::item {
                background-color: #f8f9fa;
                border: 1px solid #e9ecef;
                border-radius: 4px;
                padding: 0px;
                margin-bottom: 2px;
            }
            QListWidget::item:selected {
                background-color: #e3f2fd;
                border: 1px solid #90caf9;
                color: #2C4952;
            }
            QListWidget::item:hover:!selected {
                background-color: #f5f5f5;
            }
            QListWidget::item:focus {
                outline: none;
            }

            /* Modern and Slick Scrollbar Styling */
            QScrollBar:vertical {
                width: 8px;
                margin: 4px 0;
                background: transparent;
                border-radius: 10px;
            }

            QScrollBar::handle:vertical {
                background: rgba(100, 100, 100, 0.7); /* Subtle gray for a modern touch */
                min-height: 40px;
                border-radius: 10px;
                margin: 2px;
                border: 1px solid rgba(255, 255, 255, 0.6); /* Soft border for definition */
            }

            QScrollBar::handle:vertical:hover {
                background: rgba(80, 80, 80, 0.9); /* Darker gray with slightly stronger contrast */
            }

            QScrollBar::add-line:vertical,
            QScrollBar::sub-line:vertical {
                height: 0px;
            }

            QScrollBar::add-page:vertical,
            QScrollBar::sub-page:vertical {
                background: none;
            }

            QCheckBox {
                margin: 1px;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
                margin-top: 2px;
            }
            QCheckBox::indicator:checked {
                background-color: #4CAF50;
                border: 2px solid #4CAF50;
                border-radius: 3px;
            }
            QCheckBox::indicator:unchecked {
                background-color: white;
                border: 2px solid #BDBDBD;
                border-radius: 3px;
            }
            QLabel {
                padding: 2px 4px;
                font-size: 13px;
                line-height: 1.5;
                color: #333;
            }
            QLineEdit {
                border: 1px solid #e0e0e0;
                border-radius: 3px;
                padding: 2px 4px;
                background-color: #f8f9fa;
                font-size: 12px;
                color: #666;
                margin-top: 2px;
                min-height: 20px;
                max-height: 20px;
            }
            QLineEdit::placeholder {
                color: #999;
                font-style: italic;
            }
        """)
        
    def keyPressEvent(self, event):
        """Handle keyboard shortcuts for annotations"""
        if event.key() == Qt.Key.Key_T and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            # Ctrl+T: Open tag context menu for selected annotation
            current_item = self.currentItem()
            if current_item:
                annotation_id = current_item.data(Qt.ItemDataRole.UserRole)
                if annotation_id:
                    # Get item widget position to show menu
                    item_widget = self.itemWidget(current_item)
                    if item_widget:
                        # Show menu at widget center
                        widget_rect = item_widget.geometry()
                        global_pos = self.mapToGlobal(widget_rect.center())
                        self.show_tags_context_menu(annotation_id, global_pos)
                        return
        
        # Pass other key events to parent
        super().keyPressEvent(event)

    def mousePressEvent(self, event):
        """Handle mouse press events to clear selections across all tabs when clicking empty space"""
        if event.button() == Qt.MouseButton.LeftButton:
            # Check if the click hit an actual item
            clicked_item = self.itemAt(event.pos())
            
            if not clicked_item:
                # Clicked on empty space - clear selections across ALL tabs
                main_window = self.window()
                if hasattr(main_window, 'clear_all_tab_selections'):
                    main_window.clear_all_tab_selections()
                    print("DEBUG: Cleared selections across all tabs due to empty space click")
                else:
                    # Fallback to just clearing this tab's selection
                    self.clearSelection()
                    print("DEBUG: Cleared selection on current tab only (fallback)")
        
        # Let the parent handle the event normally
        super().mousePressEvent(event)

    def _onScrollValueChanged(self, value):
        """Handle scroll bar value changes to trigger visual updates"""
        # Use timer to debounce rapid scroll events
        if not hasattr(self, '_scroll_update_timer'):
            self._scroll_update_timer = QTimer()
            self._scroll_update_timer.setSingleShot(True)
            self._scroll_update_timer.timeout.connect(self.processVisibleItemUpdates)
        
        self._scroll_update_timer.start(100)  # 100ms delay

    def mimeTypes(self):
        return ["application/x-annotation-id"]

    def wheelEvent(self, event):
        """Override wheel event to reduce scrolling speed and trigger visual updates"""
        reduced_delta = event.angleDelta() / 3  # Divide by 6 to make scrolling slower
        modified_event = QWheelEvent(
            event.position(),
            event.globalPosition(),
            event.pixelDelta(),
            reduced_delta,
            event.buttons(),
            event.modifiers(),
            event.phase(),
            event.inverted()
        )
        super().wheelEvent(modified_event)
        
        # Schedule visual updates for newly visible items
        QTimer.singleShot(50, self.processVisibleItemUpdates)

    def mimeData(self, items):
        mime = QMimeData()
        if items:
            item = items[0]
            anno_id = item.data(Qt.ItemDataRole.UserRole)
            if anno_id:
                mime.setData("application/x-annotation-id", anno_id.encode('utf-8'))
        return mime

    def dropEvent(self, event):
        source_item = self.currentItem()
        if not source_item and event.source() == self:
            return

        old_index = self.row(source_item) if source_item else None
        super().dropEvent(event)

        if source_item and old_index is not None:
            new_index = self.row(source_item)
            if old_index != new_index:
                main_window = self.window()
                if isinstance(main_window, ScriptoriaMain):
                    current_scene = None
                    for i in range(main_window.scene_tabs.count()):
                        if main_window.scene_tabs.widget(i) == self:
                            current_scene = main_window.scene_tabs.tabText(i)
                            break
                
                    if current_scene:
                        try:
                            scene_annotations = []
                            for i in range(self.count()):
                                item = self.item(i)
                                anno_id = item.data(Qt.ItemDataRole.UserRole)
                                for anno in main_window.web_view.annotations:
                                    # Skip if annotation is a divider
                                    if anno.get('id') == anno_id and not anno.get('divider'):
                                        scene_annotations.append(anno)
                                        break
                        
                            new_annotations = []
                            used_ids = set()
                        
                            # Add back annotations from other scenes
                            for anno in main_window.web_view.annotations:
                                if anno.get('scene') != current_scene:
                                    new_annotations.append(anno)
                                    used_ids.add(anno.get('id'))

                            # Add annotations from the current scene, in the new order
                            for anno in scene_annotations:
                                if anno.get('id') not in used_ids:
                                    new_annotations.append(anno)
                                    used_ids.add(anno.get('id'))

                            main_window.web_view.annotations = new_annotations
                            main_window.mark_changes_pending()  # Added here
                            #main_window.web_view.page().toHtml(main_window.update_preview_content)

                        except KeyError as e:
                            print(f"KeyError in dropEvent: {e}")
                            print(f"Annotation causing the error: {anno}")  # Print the annotation
                        except Exception as e:
                            print(f"An unexpected error occurred in dropEvent: {e}")

    def isItemVisible(self, item):
        """Check if an item is currently visible in the viewport"""
        if not item:
            return False
        
        item_rect = self.visualItemRect(item)
        viewport_rect = self.viewport().rect()
        
        # Add small buffer for items just outside viewport
        buffer = 50
        expanded_viewport = viewport_rect.adjusted(-buffer, -buffer, buffer, buffer)
        
        return expanded_viewport.intersects(item_rect)
    
    def getVisibleItemRange(self):
        """Get the range of visible items for batch processing"""
        visible_items = []
        for i in range(self.count()):
            item = self.item(i)
            if self.isItemVisible(item):
                visible_items.append(i)
        
        if not visible_items:
            return None, None
        
        return min(visible_items), max(visible_items)

    def clearItemCache(self, annotation_id):
        """Clear cache for a specific item when its text/content changes externally"""
        print(f"DEBUG CACHE: Clearing cache for annotation {annotation_id}")
        for i in range(self.count()):
            item = self.item(i)
            if item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                widget = self.itemWidget(item)
                if widget:
                    # **SELECTIVE CACHE CLEARING**: Only clear visual cache, preserve storyboard-related data
                    old_text = widget.property('cached_text')
                    print(f"DEBUG CACHE: Clearing cached text '{old_text[:50] if old_text else 'None'}...'")
                    
                    # Clear only visual layout cache - don't touch storyboard-related properties
                    widget.setProperty('cached_text', None)
                    widget.setProperty('cached_dimensions', None)
                    widget.setProperty('metrics_bundle', None)
                    widget.setProperty('needs_visual_update', True)
                    
                    # **PRESERVE STORYBOARD DATA**: Don't clear notes_html, notes, or other metadata
                    # These might be used by storyboard conflict detection
                    
                    # Force immediate update if visible
                    if self.isItemVisible(item):
                        self.updateItemSize(item, widget, force_full_calculation=True)
                        print(f"DEBUG CACHE: Forced visual update for visible annotation {annotation_id}")
                break

    def processVisibleItemUpdates(self):
        """Process visual updates for items that became visible and need full calculation"""
        for i in range(self.count()):
            item = self.item(i)
            widget = self.itemWidget(item)
            
            if widget and widget.property('needs_visual_update') and self.isItemVisible(item):
                # Force full calculation for newly visible items
                self.updateItemSize(item, widget, force_full_calculation=True)
    
    def scheduleBackgroundUpdates(self):
        """Schedule background processing of invisible items with visual update needs"""
        if not hasattr(self, '_background_timer'):
            self._background_timer = QTimer()
            self._background_timer.setSingleShot(True)
            self._background_timer.timeout.connect(self._processBackgroundUpdates)
        
        # Schedule with short delay to avoid blocking UI
        self._background_timer.start(100)
    
    def _processBackgroundUpdates(self):
        """Background processing of items that need visual updates (in small batches)"""
        batch_count = 0
        max_batch_size = 5  # Process only 5 items at a time to keep UI responsive
        
        for i in range(self.count()):
            if batch_count >= max_batch_size:
                # Schedule next batch
                self.scheduleBackgroundUpdates()
                break
                
            item = self.item(i)
            widget = self.itemWidget(item)
            
            if (widget and 
                widget.property('needs_visual_update') and 
                not self.isItemVisible(item)):
                
                # Process invisible items with low priority
                self.updateItemSize(item, widget, force_full_calculation=True)
                batch_count += 1

    def updateItemSize(self, item, widget, force_full_calculation=False, override_width=None):
        """Calculate item size - preserved original logic but with threading for heavy operations"""
        # DEBUG: Add logging to see what's happening
        item_id = item.data(Qt.ItemDataRole.UserRole) if item else "Unknown"
        print(f"DEBUG updateItemSize: item_id={item_id[:8]}, force_full={force_full_calculation}, override_width={override_width}")
    
        # DEBUG: Track call stack to see what's calling this
        import traceback
        stack = traceback.extract_stack()
        caller = stack[-2].name if len(stack) >= 2 else "unknown"
        print(f"DEBUG CALLER: {caller}")

        # Cache viewport width to avoid repeated calculations
        if not hasattr(self, '_sizing_constants'):
            self._sizing_constants = {
                'CHECKBOX_WIDTH': 40,
                'PADDING_WIDTH': 20,
                'MIN_HEIGHT': 70,
                'PLACEHOLDER_HEIGHT': 50  # Minimal height for invisible items
            }
            self._last_viewport_width = self.viewport().width()
            self._last_available_width = max(100, self._last_viewport_width - 40)

        # FIXED: Use override width if provided, otherwise use own viewport width
        current_width = override_width if override_width else self.viewport().width()
        print(f"DEBUG: Using width: {current_width} (override: {override_width is not None})")
    
        # Update cached widths if changed
        if current_width != getattr(self, '_last_viewport_width', 0):
            self._last_viewport_width = current_width
            self._last_available_width = max(100, current_width - 40)

        # Check if we already calculated dimensions for this width
        cached_dimensions = widget.property('cached_dimensions')
        if cached_dimensions and cached_dimensions.get('viewport_width') == current_width and not force_full_calculation:
            print(f"DEBUG: Using cached dimensions for {item_id[:8]}")
            # Reuse cached dimensions
            widget.setFixedWidth(cached_dimensions['width'])
            widget.setFixedHeight(cached_dimensions['height'])
            item.setSizeHint(QSize(cached_dimensions['width'], cached_dimensions['height']))
            return

        available_width = self._last_available_width
        widget.setFixedWidth(available_width)

        # DEBUG: Check visibility and force_full logic
        is_item_visible = self.isItemVisible(item)

        # FIXED: Check if this tab is currently active/visible
        parent_widget = self.parent()
        is_tab_visible = True
        if hasattr(parent_widget, 'indexOf') and hasattr(parent_widget, 'currentIndex'):
            tab_index = parent_widget.indexOf(self)
            current_index = parent_widget.currentIndex()
            is_tab_visible = (tab_index == current_index)

        # Item is truly visible only if both the item AND the tab are visible
        is_truly_visible = is_item_visible and is_tab_visible

        print(f"DEBUG: item_id={item_id[:8]}, item_visible={is_item_visible}, tab_visible={is_tab_visible}, truly_visible={is_truly_visible}, force_full={force_full_calculation}")

        # FIXED: Force full calculation bypasses all optimizations
        # Only use placeholder dimensions for truly invisible items when NOT forcing calculation
        if force_full_calculation or is_truly_visible:
            print(f"DEBUG: FULL CALCULATION for {item_id[:8]}")
            
            # For visible items or forced calculations, check if we should use threading
            if not is_truly_visible and not force_full_calculation:
                # Use background thread for non-visible items
                self._queue_background_calculation(item, widget, force_full_calculation, override_width)
            else:
                # Do immediate calculation for visible items
                self._do_full_calculation(item, widget, current_width, available_width)
        else:
            print(f"DEBUG: PLACEHOLDER for {item_id[:8]}")
            # LAZY VISUAL OPTIMIZATION: Use placeholder dimensions only for truly invisible items
            # This block only executes when force_full_calculation=False AND item is not visible
            placeholder_height = self._sizing_constants['PLACEHOLDER_HEIGHT']

            # Mark for later visual update when item becomes visible
            widget.setProperty('needs_visual_update', True)
            widget.setProperty('placeholder_dimensions', {
                'viewport_width': current_width,
                'width': available_width,
                'height': placeholder_height
            })

            # Apply minimal dimensions
            widget.setFixedWidth(available_width)
            widget.setFixedHeight(placeholder_height)
            item.setSizeHint(QSize(available_width, placeholder_height))

    def _queue_background_calculation(self, item, widget, force_full_calculation, override_width):
        """Queue calculation for background thread - only for non-visible items"""
        item_id = item.data(Qt.ItemDataRole.UserRole) if item else "Unknown"
        
        # Check if this item is already being processed
        if item_id in self._pending_size_updates:
            print(f"DEBUG: Skipping duplicate background update for {item_id[:8]}")
            return
            
        # Cache essential widget properties for thread safety
        self._cache_widget_properties(widget)
        
        # Add to pending updates
        self._pending_size_updates.add(item_id)
        
        # Create worker and submit to thread pool
        worker = ItemSizeWorker(self, item, widget, force_full_calculation, override_width)
        self._size_thread_pool.start(worker)
        print(f"DEBUG: Queued background processing for {item_id[:8]}")

    def _do_full_calculation(self, item, widget, current_width, available_width):
        """Do full synchronous calculation with all original logic"""
        item_id = item.data(Qt.ItemDataRole.UserRole) if item else "Unknown"
        print(f"DEBUG: FULL CALCULATION for {item_id[:8]}")
        
        # Use cached label
        label = widget.property('cached_label')
        if not label:
            label = widget.findChild(QLabel)
            widget.setProperty('cached_label', label)

        if label:
            label_width = available_width - self._sizing_constants['CHECKBOX_WIDTH'] - self._sizing_constants['PADDING_WIDTH']
            label.setFixedWidth(label_width)  # Critical: Must set label width

            # Get or create cached metrics bundle
            metrics_bundle = widget.property('metrics_bundle')
            if not metrics_bundle or metrics_bundle.get('width') != label_width:
                font_metrics = widget.property('cached_font_metrics')
                if not font_metrics:
                    font_metrics = label.fontMetrics()
                    widget.setProperty('cached_font_metrics', font_metrics)

                text = widget.property('cached_text')
                if not text:
                    text = label.text()
                    widget.setProperty('cached_text', text)

                # Calculate text rectangle
                text_rect = font_metrics.boundingRect(
                    QRect(0, 0, label_width, 2000),
                    Qt.TextFlag.TextWordWrap,
                    text
                )

                # Cache the metrics bundle
                metrics_bundle = {
                    'width': label_width,
                    'text_height': text_rect.height() + 10
                }
                widget.setProperty('metrics_bundle', metrics_bundle)

            # Use cached notes edit
            notes_edit = widget.property('cached_notes_edit')
            if not notes_edit:
                notes_edit = widget.findChild(QLineEdit)
                widget.setProperty('cached_notes_edit', notes_edit)

            # Calculate final dimensions
            notes_height = notes_edit.sizeHint().height() + 12 if notes_edit else 0

            # Account for secondary themes row height if present
            sec_row_height = 0
            try:
                for child in widget.findChildren(QWidget):
                    if child.property('is_secondary_row'):
                        # Use sizeHint with a minimum height fallback
                        sec_row_height = max(sec_row_height, child.sizeHint().height() + 6)
                        break
            except Exception as _e:
                print(f"🧩⚠️ [SEC-ROW] Failed to measure secondary row height: {_e}")

            total_height = metrics_bundle['text_height'] + notes_height + sec_row_height + 32
            total_height = max(total_height, self._sizing_constants['MIN_HEIGHT'])
    
            print(f"DEBUG: Calculated height for {item_id[:8]}: {total_height} (text: {metrics_bundle['text_height']}, notes: {notes_height}, sec_row: {sec_row_height}, padding: 32)")

            # Cache the final dimensions
            widget.setProperty('cached_dimensions', {
                'viewport_width': current_width,
                'width': available_width,
                'height': total_height
            })

            # Clear visual update flag since we've done full calculation
            widget.setProperty('needs_visual_update', False)

            # Apply dimensions
            widget.setFixedWidth(available_width)
            widget.setFixedHeight(total_height)
            item.setSizeHint(QSize(available_width, total_height))
    
            # DEBUG: Check if sizes were actually applied
            actual_width = widget.width()
            actual_height = widget.height()
            print(f"DEBUG APPLIED: {item_id[:8]} - calculated: {available_width}x{total_height}, actual: {actual_width}x{actual_height}")
    
            # Force immediate visual update
            widget.update()
            widget.updateGeometry()
            
            # Position tags overlay at top right corner after dimensions are set
            self._position_tags_overlay_full(widget, available_width)

    def _position_tags_overlay_full(self, widget, available_width):
        """Full tags positioning logic from original implementation"""
        for child in widget.children():
            if isinstance(child, QLabel) and child.property('is_tags_widget'):
                # Check if there's a speech title that would reduce available space for tags
                speech_title_width = 0
                for sibling in widget.children():
                    if isinstance(sibling, QWidget) and sibling != child:
                        # Look for speech title container widget (contains the speech title label)
                        if hasattr(sibling, 'layout') and sibling.layout():
                            for i in range(sibling.layout().count()):
                                layout_item = sibling.layout().itemAt(i)
                                if layout_item and layout_item.widget():
                                    potential_label = layout_item.widget()
                                    if isinstance(potential_label, QLabel) and potential_label.text() and potential_label.text() != "add tags" and not potential_label.property('is_tags_widget'):
                                        # This looks like a speech title label
                                        speech_title_width = sibling.sizeHint().width() + 20  # Use container width + padding
                                        break
                            if speech_title_width > 0:
                                break
                
                # Calculate maximum width for tags (90% of available width, minus speech title width)
                base_tags_width = int(available_width * 0.90)
                max_tags_width = max(100, base_tags_width - speech_title_width)  # Ensure minimum width
                
                # Get the original tags from stored property, fallback to current text
                original_tags_text = child.property('original_tags_text')
                if not original_tags_text:
                    # If no stored original, use current text and store it
                    original_tags_text = child.text()
                    child.setProperty('original_tags_text', original_tags_text)
                
                # Always start from the original full tags text
                child.setText(original_tags_text)
                child.adjustSize()
                tags_width = child.sizeHint().width()
                tags_height = child.sizeHint().height()
                
                # Truncate tags if they exceed 75% of available width
                if tags_width > max_tags_width:
                    font_metrics = child.fontMetrics()
                    
                    # Parse tags from the original text (remove # prefix and split by comma)
                    tags_list = [tag.strip().lstrip('#') for tag in original_tags_text.split(',')]
                    
                    # Find how many tags fit within the available width
                    truncated_text = ""
                    visible_count = 0
                    
                    for i, tag in enumerate(tags_list):
                        tag_text = f"#{tag}"
                        if i == 0:
                            test_text = tag_text
                        else:
                            test_text = f"{truncated_text}, {tag_text}"
                        
                        # Reserve space for "...(X)" if needed
                        remaining_tags = len(tags_list) - i - 1
                        if remaining_tags > 0:
                            ellipsis_text = f"...({remaining_tags})"
                            test_width = font_metrics.boundingRect(test_text + ellipsis_text).width()
                        else:
                            test_width = font_metrics.boundingRect(test_text).width()
                        
                        if test_width <= max_tags_width:
                            truncated_text = test_text
                            visible_count = i + 1
                        else:
                            break
                    
                    # Add "...(X)" if there are hidden tags
                    hidden_count = len(tags_list) - visible_count
                    if hidden_count > 0:
                        final_text = f"{truncated_text}...({hidden_count})"
                    else:
                        final_text = truncated_text
                    
                    child.setText(final_text)
                    
                    # Set tooltip with full tags if truncated
                    if hidden_count > 0:
                        child.setToolTip(f"Tags: {original_tags_text}")
                    
                    # Recalculate size after truncation
                    child.adjustSize()
                    tags_width = child.sizeHint().width()
                else:
                    # Clear tooltip if no truncation needed
                    child.setToolTip(f"Tags: {original_tags_text}")
                
                # Set explicit size
                child.resize(tags_width, tags_height)
                # Position at top right corner of widget
                tags_x = available_width - tags_width - 5  # Right edge minus tags width minus padding
                child.move(tags_x, 5)
                child.show()  # Ensure visibility
                break

    def _cache_widget_properties(self, widget):
        """Cache widget properties needed for background processing"""
        try:
            # Cache label reference
            if not widget.property('cached_label'):
                label = widget.findChild(QLabel)
                if label:
                    widget.setProperty('cached_label', label)
                    widget.setProperty('cached_font_metrics', label.fontMetrics())
                    widget.setProperty('cached_text', label.text())
            
            # Cache notes edit reference
            if not widget.property('cached_notes_edit'):
                notes_edit = widget.findChild(QLineEdit)
                if notes_edit:
                    widget.setProperty('cached_notes_edit', notes_edit)
        except Exception as e:
            print(f"Error caching widget properties: {e}")

    def _process_item_size_sync(self, item, widget, force_full_calculation=False, override_width=None):
        """Synchronous processing for critical visible items"""
        try:
            item_id = item.data(Qt.ItemDataRole.UserRole) if item else "Unknown"
            current_width = override_width if override_width else self._last_viewport_width
            available_width = max(100, current_width - 40)
            
            # Quick cache check
            cached_dimensions = widget.property('cached_dimensions')
            if cached_dimensions and cached_dimensions.get('viewport_width') == current_width and not force_full_calculation:
                widget.setFixedWidth(cached_dimensions['width'])
                widget.setFixedHeight(cached_dimensions['height'])
                item.setSizeHint(QSize(cached_dimensions['width'], cached_dimensions['height']))
                return

            # Cache properties if needed
            self._cache_widget_properties(widget)
            
            # Do minimal calculation for immediate display
            widget.setFixedWidth(available_width)
            
            # Set temporary height while background calculation happens
            temp_height = self._sizing_constants['MIN_HEIGHT']
            widget.setFixedHeight(temp_height)
            item.setSizeHint(QSize(available_width, temp_height))
            
            # Queue for proper background calculation
            if item_id not in self._pending_size_updates:
                self._pending_size_updates.add(item_id)
                worker = ItemSizeWorker(self, item, widget, True, override_width)  # Force full calculation
                self._size_thread_pool.start(worker)
                
        except Exception as e:
            print(f"Error in sync processing: {e}")

    def cleanup_thread_pool(self):
        """Clean up the thread pool when widget is destroyed"""
        try:
            if hasattr(self, '_size_thread_pool'):
                self._size_thread_pool.clear()
                self._size_thread_pool.waitForDone(3000)  # Wait max 3 seconds
        except Exception as e:
            print(f"Error cleaning up thread pool: {e}")

    def updateItemSizesBatch(self, items_with_options, override_width=None):
        """Efficiently batch update multiple items with threading optimization"""
        if not items_with_options:
            return
            
        print(f"DEBUG: Starting batch update for {len(items_with_options)} items")
        
        # Initialize constants if needed
        if not hasattr(self, '_sizing_constants'):
            self._sizing_constants = {
                'CHECKBOX_WIDTH': 40,
                'PADDING_WIDTH': 20,
                'MIN_HEIGHT': 70,
                'PLACEHOLDER_HEIGHT': 50
            }
            self._last_viewport_width = self.viewport().width()
            self._last_available_width = max(100, self._last_viewport_width - 40)

        # Update cached viewport width
        current_width = override_width if override_width else self.viewport().width()
        if current_width != getattr(self, '_last_viewport_width', 0):
            self._last_viewport_width = current_width
            self._last_available_width = max(100, current_width - 40)

        # Separate visible and non-visible items for different processing strategies
        visible_items = []
        background_items = []
        cache_hits = 0
        
        for item, widget, force_full in items_with_options:
            item_id = item.data(Qt.ItemDataRole.UserRole) if item else "Unknown"
            
            # Skip if already being processed
            if item_id in self._pending_size_updates:
                continue
                
            # Check cache first
            cached_dimensions = widget.property('cached_dimensions')
            if cached_dimensions and cached_dimensions.get('viewport_width') == current_width and not force_full:
                # Apply cached dimensions immediately
                widget.setFixedWidth(cached_dimensions['width'])
                widget.setFixedHeight(cached_dimensions['height'])
                item.setSizeHint(QSize(cached_dimensions['width'], cached_dimensions['height']))
                cache_hits += 1
                continue
            
            # Set width immediately to prevent layout issues
            available_width = self._last_available_width
            widget.setFixedWidth(available_width)
            
            # Determine processing strategy
            is_visible = self.isItemVisible(item)
            if is_visible or force_full:
                visible_items.append((item, widget, force_full))
            else:
                background_items.append((item, widget, force_full))
        
        print(f"DEBUG: Batch processing - {cache_hits} cache hits, {len(visible_items)} visible items, {len(background_items)} background items")
        
        # Process visible items immediately (small batches to stay responsive)
        if visible_items:
            self._process_visible_items_batch(visible_items, current_width)
        
        # Queue background items for threading
        if background_items:
            self._queue_background_items_batch(background_items, override_width)

    def _process_visible_items_batch(self, visible_items, current_width):
        """Process visible items in small synchronous batches"""
        batch_size = 5  # Small batches to maintain responsiveness
        available_width = self._last_available_width
        
        for i in range(0, len(visible_items), batch_size):
            batch = visible_items[i:i + batch_size]
            for item, widget, force_full in batch:
                try:
                    self._do_full_calculation(item, widget, current_width, available_width)
                except Exception as e:
                    print(f"Error in visible batch processing: {e}")
            
            # Allow UI to breathe between batches
            if i + batch_size < len(visible_items):
                QApplication.processEvents()

    def _queue_background_items_batch(self, background_items, override_width):
        """Queue multiple items for background processing"""
        for item, widget, force_full in background_items:
            item_id = item.data(Qt.ItemDataRole.UserRole) if item else "Unknown"
            
            # Cache essential widget properties for thread safety
            self._cache_widget_properties(widget)
            
            # Add to pending updates
            self._pending_size_updates.add(item_id)
            
            # Create worker and submit to thread pool
            worker = ItemSizeWorker(self, item, widget, force_full, override_width)
            self._size_thread_pool.start(worker)
        
        print(f"DEBUG: Queued {len(background_items)} items for background processing")

    def clearPendingSizeUpdates(self):
        """Clear the pending size updates set - useful for cleanup"""
        if hasattr(self, '_pending_size_updates'):
            self._pending_size_updates.clear()
            print("DEBUG: Cleared pending size updates")

    @pyqtSlot(object, object, object)
    def _apply_cached_dimensions(self, item, widget, cached_dimensions):
        """Apply cached dimensions on main thread"""
        try:
            widget.setFixedWidth(cached_dimensions['width'])
            widget.setFixedHeight(cached_dimensions['height'])
            item.setSizeHint(QSize(cached_dimensions['width'], cached_dimensions['height']))
            
            # Remove from pending updates
            item_id = item.data(Qt.ItemDataRole.UserRole) if item else "Unknown"
            self._pending_size_updates.discard(item_id)
        except Exception as e:
            print(f"Error applying cached dimensions: {e}")

    @pyqtSlot(object, object, object)
    def _apply_full_dimensions(self, item, widget, dimensions):
        """Apply full calculated dimensions on main thread"""
        try:
            if not dimensions:
                return
                
            # Cache the dimensions
            widget.setProperty('cached_dimensions', {
                'viewport_width': dimensions['viewport_width'],
                'width': dimensions['width'],
                'height': dimensions['height']
            })
            
            # Cache metrics bundle if provided
            if 'metrics_bundle' in dimensions:
                widget.setProperty('metrics_bundle', dimensions['metrics_bundle'])
            
            # Clear visual update flag
            widget.setProperty('needs_visual_update', False)
            
            # Apply dimensions
            widget.setFixedWidth(dimensions['width'])
            widget.setFixedHeight(dimensions['height'])
            item.setSizeHint(QSize(dimensions['width'], dimensions['height']))
            
            # Force visual update
            widget.update()
            widget.updateGeometry()
            
            # Handle tags positioning (main thread only)
            self._position_tags_overlay(widget, dimensions['width'])
            
            # Remove from pending updates
            item_id = item.data(Qt.ItemDataRole.UserRole) if item else "Unknown"
            self._pending_size_updates.discard(item_id)
            
        except Exception as e:
            print(f"Error applying full dimensions: {e}")

    @pyqtSlot(object, object, object)
    def _apply_placeholder_dimensions(self, item, widget, dimensions):
        """Apply placeholder dimensions on main thread"""
        try:
            # Mark for later visual update
            widget.setProperty('needs_visual_update', True)
            widget.setProperty('placeholder_dimensions', dimensions)
            
            # Apply minimal dimensions
            widget.setFixedWidth(dimensions['width'])
            widget.setFixedHeight(dimensions['height'])
            item.setSizeHint(QSize(dimensions['width'], dimensions['height']))
            
            # Remove from pending updates
            item_id = item.data(Qt.ItemDataRole.UserRole) if item else "Unknown"
            self._pending_size_updates.discard(item_id)
            
        except Exception as e:
            print(f"Error applying placeholder dimensions: {e}")

    def _position_tags_overlay(self, widget, available_width):
        """Position tags overlay - must run on main thread"""
        try:
            for child in widget.children():
                if isinstance(child, QLabel) and child.property('is_tags_widget'):
                    # Simplified tags positioning logic
                    child.adjustSize()
                    tags_width = child.sizeHint().width()
                    tags_height = child.sizeHint().height()
                    
                    # Position at top right corner
                    tags_x = available_width - tags_width - 5
                    child.move(tags_x, 5)
                    child.show()
                    break
        except Exception as e:
            print(f"Error positioning tags overlay: {e}")

    def add_item_with_checkbox(self, text, annotation_id, is_used=False, notes="", notes_html="", is_favorite=False, tags=None, speech_title="", secondary_scenes=None):
        # Create the main widget for the list item.
        item_widget = QWidget()
        item_widget.setStyleSheet("border: none; outline: none;")
        layout = QVBoxLayout(item_widget)
        layout.setContentsMargins(5, 10, 5, 2)  # Reduced bottom margin to 2 for ultra compact layout
        layout.setSpacing(1)  # Reduced from 2 to 1 for minimal vertical spacing
   
        # Top layout: left column (star and checkbox) and label.
        top_layout = QHBoxLayout()
        top_layout.setSpacing(10)
   
        # Left column layout with adjusted positioning (up 9px, left 13px total)
        left_col_layout = QVBoxLayout()
        left_col_layout.setContentsMargins(-18, -9, 0, 0)  # Move left 13px and up 9px
        left_col_layout.setSpacing(1)
   
        # Custom star button with paint events
        star_button = CustomStarButton()
        star_button.setChecked(is_favorite)
   
        def toggle_favorite():
            current_state = star_button.isChecked()
            self.on_favorite_changed(text, annotation_id, current_state)
   
        star_button.clicked.connect(toggle_favorite)
        item_widget.setProperty('cached_star_button', star_button)
   
        # Custom checkbox with paint events
        checkbox = CustomCheckBox()
        checkbox.setChecked(is_used)
        checkbox.stateChanged.connect(
            lambda state, t=text, aid=annotation_id: self.on_checkbox_changed(t, aid, state)
        )
        item_widget.setProperty('cached_checkbox', checkbox)
   
        left_col_layout.addWidget(star_button, 0, Qt.AlignmentFlag.AlignHCenter)
        left_col_layout.addWidget(checkbox, 0, Qt.AlignmentFlag.AlignHCenter)
        left_col_layout.addStretch(1)

        # Speech title widget (positioned in top-left, overlaid like tags)
        speech_title_container = None
        print(f"DEBUG add_item_with_checkbox: speech_title='{speech_title}', stripped='{speech_title.strip() if speech_title else 'None'}'")
        if speech_title and speech_title.strip():
            # Truncate speech title to 125 characters
            truncated_title = speech_title.strip()
            if len(truncated_title) > 125:
                truncated_title = truncated_title[:125] + "..."
            speech_title_widget = QLabel(truncated_title)
            # Set tooltip to show full title if it was truncated
            if len(speech_title.strip()) > 125:
                speech_title_widget.setToolTip(speech_title.strip())
            print(f"DEBUG: Created speech_title_widget with text: '{truncated_title}'")
            speech_title_widget.setStyleSheet("""
                QLabel {
                    color: #333;
                    font-size: 10px;
                    font-weight: bold;
                    padding: 2px 4px;
                    background: transparent;
                }
            """)
            speech_title_widget.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
            speech_title_widget.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Minimum)
            speech_title_widget.setWordWrap(False)
            
            # Create transparent container for speech title (constrained to content size)
            speech_title_container = QWidget()
            speech_title_container_layout = QHBoxLayout(speech_title_container)
            speech_title_container_layout.setContentsMargins(0, 0, 0, 0)
            speech_title_container_layout.addWidget(speech_title_widget)
            # Remove addStretch() to constrain container to content size
            
            # Set size policy to constrain container to its content
            speech_title_container.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Minimum)
            speech_title_container.adjustSize()  # Fit to content
   
        # Label for the annotation text.
        label = QLabel(text)
        label.setObjectName("main_content_label")  # Add this for drag pixmap compatibility
        label.setWordWrap(True)
        label.setTextFormat(Qt.TextFormat.PlainText)
        label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)
        label.setStyleSheet("QLabel { padding: 20px 0px 0px 0px; line-height: 1.4; }")
        label.setFont(self._label_font)
   
        item_widget.setProperty('cached_label', label)
        item_widget.setProperty('cached_text', text)
        item_widget.setProperty('cached_normalized_text', text.lower())
   
        # Tags display in top-right corner
        tags_widget = None
        print(f"DEBUG: add_item_with_checkbox for {annotation_id[:8]} - tags parameter: {tags}")
        if tags:
            # Create single label with all tags (hover on entire area)
            tags_widget = QLabel()
            
            # Create tags text with # prefix (no character limit here - will be truncated by width in updateItemSize)
            tags_text = ", ".join([f"#{tag}" for tag in tags])
            tags_widget.setText(tags_text)
            
            # Enable text elision (automatic truncation with ...) when text doesn't fit
            tags_widget.setWordWrap(False)  # Ensure single line
            tags_widget.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)  # Prevent text selection issues with elision
            
            # Set tooltip with original full tags 
            original_tags_text = ", ".join([f"#{tag}" for tag in tags])
            tags_widget.setToolTip(f"Tags: {original_tags_text}")
            
            # Store the original tags text for dynamic truncation on resize
            tags_widget.setProperty('original_tags_text', tags_text)
            
            tags_widget.setStyleSheet("""
                QLabel {
                    color: #2196F3;
                    font-size: 10px;
                    font-weight: bold;
                    padding: 2px 4px;
                    background: transparent;
                    margin-left: 4px;
                    /* text-overflow and overflow removed - not supported in Qt stylesheets */
                }
                QLabel:hover {
                    color: #1976D2;
                }
            """)
            tags_widget.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignTop)  # Right align so it gets cut off on the right side
            tags_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)  # Allow horizontal expansion
            tags_widget.setCursor(Qt.CursorShape.PointingHandCursor)
            tags_widget.mousePressEvent = lambda event: self.show_tags_context_menu(annotation_id, event.globalPosition().toPoint())
        else:
            # Show "add tags" label when no tags exist
            tags_widget = QLabel("add tags")
            tags_widget.setStyleSheet("""
                QLabel {
                    color: #888;
                    font-size: 10px;
                    font-style: italic;
                    padding: 2px 4px;
                    background: transparent;
                    margin-left: 4px;
                }
                QLabel:hover {
                    color: #666;
                }
            """)
            tags_widget.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignTop)
            tags_widget.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Minimum)
            tags_widget.setCursor(Qt.CursorShape.PointingHandCursor)
            tags_widget.setToolTip("Click to add tags")
            tags_widget.mousePressEvent = lambda event: self.show_tags_context_menu(annotation_id, event.globalPosition().toPoint())
            
        top_layout.addLayout(left_col_layout, 0)
        top_layout.addWidget(label, 1)
        layout.addLayout(top_layout)
        
        # Add speech title as an overlay (not part of the flow layout)
        if speech_title_container:
            # Position the speech title overlay on top of the main content area
            speech_title_container.setParent(item_widget)
            speech_title_container.move(55, 5)  # Position after star/checkbox, aligned with main text (moved right 15px total)
            # Lower the overlay so it doesn't block clicks on tags
            speech_title_container.lower()
            
        # Store tags data for use in secondary row instead of overlay
        if tags_widget:
            # Store the tags data and styling info instead of the widget itself
            item_widget.setProperty('cached_tags_data', {
                'tags': tags or [],
                'annotation_id': annotation_id,
                'tags_text': tags_widget.text() if hasattr(tags_widget, 'text') else '',
                'tooltip': tags_widget.toolTip() if hasattr(tags_widget, 'toolTip') else '',
                'has_tags': bool(tags)
            })
        else:
            item_widget.setProperty('cached_tags_data', {
                'tags': [],
                'annotation_id': annotation_id,
                'tags_text': 'add tags',
                'tooltip': 'Click to add tags',
                'has_tags': False
            })

   
        # --- Notes Section ---
        notes_container = QWidget()
        notes_layout = QHBoxLayout(notes_container)
        notes_layout.setContentsMargins(2, 0, 0, 0)
        notes_layout.setSpacing(4)
   
        # Helper: check if the HTML note contains any visible text.
        def is_notes_empty(notes_html_str: str) -> bool:
            doc = QTextDocument()
            doc.setHtml(notes_html_str)
            return doc.toPlainText().strip() == ""
   
        # Notes button.
        edit_notes_btn = QPushButton()
        edit_notes_btn.setObjectName("editNotesButton")
        edit_notes_btn.setFixedSize(22, 22)
        edit_notes_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        edit_notes_btn.setToolTip("Commentary")
        edit_notes_btn.setFlat(True)
        # Instead of a simple .strip() check, use our helper.
        if notes_html and not is_notes_empty(notes_html):
            edit_notes_btn.setIcon(self._cached_icons['notes']['active'])
        else:
            edit_notes_btn.setIcon(self._cached_icons['notes']['normal'])
        edit_notes_btn.setIconSize(QSize(22, 22))
        edit_notes_btn.setStyleSheet(EDIT_NOTES_BUTTON_STYLE)
        edit_notes_btn.setAttribute(Qt.WidgetAttribute.WA_Hover)
        edit_notes_btn.setMouseTracking(True)
   
        # QLineEdit for plain-text notes.
        notes_edit = QLineEdit()
        notes_edit.setPlaceholderText("Add footnote...")
        notes_edit.setText(notes)
        notes_edit.setMinimumHeight(28)
        notes_edit.setCursorPosition(0)
        notes_edit.setFont(self._notes_font)
        notes_edit.setStyleSheet(NOTES_EDIT_STYLE)
   
        # Store both versions.
        item_widget.setProperty('notes_html', notes_html)
        item_widget.setProperty('notes', notes)
        item_widget.setProperty('tags', tags or [])
        # Removed cached_tags_label - no longer needed since layout handles tags spacing
   
        notes_layout.addWidget(edit_notes_btn)
        notes_layout.addWidget(notes_edit)
        layout.addWidget(notes_container)

        # Secondary themes row (compact chips) below notes controls.
        # Build immediately if data is ready, otherwise schedule retries.
        try:
            built = self._build_secondary_row_for_item(item_widget, annotation_id)
            if not built:
                # Defer and retry a few times until web_view is ready
                attempts = item_widget.property('sec_row_attempts') or 0
                if attempts < 10:
                    item_widget.setProperty('sec_row_attempts', attempts + 1)
                    print(f"🧩⏳ [SEC-ROW] Deferring build (attempt {attempts+1}/10) for {annotation_id}")
                    QTimer.singleShot(300, lambda iw=item_widget, aid=annotation_id: self._build_secondary_row_for_item(iw, aid, force_recalc=True))
                else:
                    print(f"🧩🚫 [SEC-ROW] Max defers reached, skipping for {annotation_id}")
        except Exception as _e:
            print(f"🧩💥 [SEC-ROW] Failed to schedule secondary themes row: {_e}")
   
        # Local mutable container for the note editor dialog.
        note_dialog = [None]
   
        # Function to open the note editor dialog.
        def open_note_editor():
            if note_dialog[0] is not None and note_dialog[0].isVisible():
                note_dialog[0].activateWindow()
                return
   
            # Set the icon to "active" as the editor opens.
            edit_notes_btn.setIcon(self._cached_icons['notes']['active'])
   
            main_window = self.window()
            if isinstance(main_window, ScriptoriaMain):
                ann_id = None
                # Locate the annotation ID for this widget.
                for i in range(self.count()):
                    current_item = self.item(i)
                    if self.itemWidget(current_item) == item_widget:
                        ann_id = current_item.data(Qt.ItemDataRole.UserRole)
                        break
   
                if not ann_id:
                    print("Warning: Could not find annotation ID for the widget")
                    return
   
                # Retrieve the stored HTML notes.
                current_html = ""
                for anno in main_window.web_view.annotations:
                    if anno.get('id') == ann_id:
                        current_html = anno.get('notes_html', '')
                        break
                if not current_html:
                    current_html = item_widget.property('notes_html') or ""
   
                # Create the note editor dialog.
                dialog = AnnotationNoteDialog(
                    self,
                    current_html,
                    edit_notes_btn,  # Use the actual button as anchor instead of item_widget
                    main_window=main_window
                )
                note_dialog[0] = dialog
   
                def on_dialog_finished():
                    final_html = dialog.get_html_text()
                    if is_notes_empty(final_html):
                        edit_notes_btn.setIcon(self._cached_icons['notes']['normal'])
                    else:
                        edit_notes_btn.setIcon(self._cached_icons['notes']['active'])
                    note_dialog[0] = None
   
                def on_text_changed():
                    if dialog.isVisible():
                        html_text = dialog.get_html_text()
                        item_widget.setProperty('notes_html', html_text)
        
                        # Get the current plain notes to preserve it
                        plain_notes = item_widget.property('notes') or ""
        
                        if is_notes_empty(html_text):
                            edit_notes_btn.setIcon(self._cached_icons['notes']['normal'])
                        else:
                            edit_notes_btn.setIcon(self._cached_icons['notes']['active'])
        
                        # Pass both values to ensure neither is lost
                        self.on_notes_changed(text, ann_id, notes=plain_notes, html_notes=html_text)
   
                dialog.finished.connect(on_dialog_finished)
                dialog.note_edit.textChanged.connect(on_text_changed)
                dialog.show()
   
        # Connect the note editor to the notes button.
        edit_notes_btn.clicked.connect(open_note_editor)
   
        # Direct edit of plain text notes.
        def handle_direct_edit():
            current_text = notes_edit.text()
            item_widget.setProperty('notes', current_text)
    
            # Get the current notes_html to preserve it
            current_html = item_widget.property('notes_html') or ""
    
            # Pass both values to ensure neither is lost
            self.on_notes_changed(text, annotation_id, notes=current_text, html_notes=current_html)
   
        notes_edit.textChanged.connect(handle_direct_edit)
        notes_edit.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        notes_edit.customContextMenuRequested.connect(
            lambda pos, edit=notes_edit: self.show_notes_context_menu(edit, pos)
        )
        
        # Add Ctrl+T shortcut to open context menu
        def handle_key_press(event):
            if event.modifiers() == Qt.KeyboardModifier.ControlModifier and event.key() == Qt.Key.Key_T:
                # Open context menu at current cursor position
                cursor_pos = notes_edit.cursorPositionAt(QPoint(notes_edit.width() // 2, notes_edit.height() // 2))
                global_pos = notes_edit.mapToGlobal(QPoint(notes_edit.width() // 2, notes_edit.height() // 2))
                self.show_notes_context_menu(notes_edit, notes_edit.mapFromGlobal(global_pos))
                event.accept()
            else:
                # Call the original keyPressEvent
                QLineEdit.keyPressEvent(notes_edit, event)
        
        notes_edit.keyPressEvent = handle_key_press
   
        # Create the QListWidgetItem and add the widget.
        item = QListWidgetItem(self)
        item.setData(Qt.ItemDataRole.UserRole, annotation_id)
        self.setItemWidget(item, item_widget)
        
        # Apply border to the QListWidget::item directly
        current_style = self.styleSheet() or ""
        border_style = """
            QListWidget::item {
                border: 1px solid #d0d0d0 !important;
                padding: 0px !important;
                margin: 0px !important;
            }
            QListWidget::item:hover {
                border: 1px solid #4a90e2 !important;
            }
        """
        self.setStyleSheet(current_style + border_style)
        
        self.updateItemSize(item, item_widget)
   
        return item

    def _build_secondary_row_for_item(self, item_widget: QWidget, annotation_id: str, force_recalc: bool=False) -> bool:
        """Try to append a secondary themes chip row to an existing item widget. Returns True if built, False if data not ready yet."""
        try:
            # Avoid duplicates
            for child in item_widget.findChildren(QWidget):
                if child.property('is_secondary_row'):
                    print(f"🧩🔁 [SEC-ROW] Row already exists for {annotation_id}")
                    return True

            main_window = self.window()
            web_view = getattr(main_window, 'web_view', None) if main_window else None
            if not (web_view and hasattr(web_view, 'annotations')):
                print("🧩⚠️ [SEC-ROW] web_view/annotations not ready; will retry")
                return False

            # Lookup model annotation
            model_ann = next((a for a in web_view.annotations if a and a.get('id') == annotation_id), None)
            if not model_ann:
                print(f"🧩❌ [SEC-ROW] No model annotation for {annotation_id}")
                return False

            sec = model_ann.get('secondary_scenes')
            tags_data = item_widget.property('cached_tags_data')
            has_tags = tags_data and tags_data.get('has_tags', False)
            
            if (not isinstance(sec, list) or not sec) and not tags_data:
                print(f"🧩ℹ️ [SEC-ROW] No secondary scenes or tags for {annotation_id}")
                return True  # nothing to render, but not a retry condition

            primary_scene = model_ann.get('scene')
            styles = getattr(web_view, 'scene_styles', {}) or {}
            valid = set(styles.keys())
            sec_list = [s for s in sec if isinstance(s, str) and s.strip() and (not valid or s in valid) and s != primary_scene] if isinstance(sec, list) else []
            if not sec_list and not tags_data:
                print(f"🧩ℹ️ [SEC-ROW] Secondary scenes filtered out/empty and no tags for {annotation_id}")
                return True

            # Build row
            print(f"🧩✅ [SEC-ROW] Rendering {len(sec_list)} chips and tags for {annotation_id}: {sec_list}")
            secondary_row = QWidget(item_widget)
            secondary_row.setProperty('is_secondary_row', True)
            secondary_layout = QHBoxLayout(secondary_row)
            secondary_layout.setContentsMargins(30, 0, 0, 0)  # Keep left margin for alignment with main content
            secondary_layout.setSpacing(3)  # Reduced from 6 to 3 for more compact layout
            
            # Create new tags widget on the left side with intelligent truncation
            if tags_data:
                new_tags_widget = self._create_truncated_tags_widget(tags_data, sec_list, secondary_layout)
                if new_tags_widget:
                    secondary_layout.addWidget(new_tags_widget)

            def _bg(scene_name: str) -> str:
                try:
                    m = re.search(r'background-color:\s*([^;]+)', styles.get(scene_name, ''))
                    return m.group(1) if m else '#FFFFFF'
                except Exception:
                    return '#FFFFFF'

            # Add stretch to separate tags (left) from secondary scene chips (right)
            if tags_data and sec_list:
                secondary_layout.addStretch(1)
            elif not tags_data and sec_list:
                # No tags, so push chips to the right
                secondary_layout.addStretch(1)

            for s in sec_list:
                chip = QLabel(secondary_row)
                chip.setFixedSize(10, 10)
                chip.setToolTip(s)
                chip.setStyleSheet(f"QLabel {{ background-color: {_bg(s)}; border: 1px solid #2C3333; border-radius: 5px; }} QLabel:hover {{ border: 2px solid #1F2933; }}")
                # Hover grow effect
                def _enterEventFactory(lbl: QLabel):
                    def _enterEvent(_e):
                        lbl.setFixedSize(12, 12)
                    return _enterEvent
                def _leaveEventFactory(lbl: QLabel):
                    def _leaveEvent(_e):
                        lbl.setFixedSize(10, 10)
                    return _leaveEvent
                chip.enterEvent = _enterEventFactory(chip)
                chip.leaveEvent = _leaveEventFactory(chip)
                secondary_layout.addWidget(chip)

            # Append to main layout
            main_layout = item_widget.layout()
            if main_layout:
                main_layout.addWidget(secondary_row)
                print(f"🧩🎯 [SEC-ROW] Row appended for {annotation_id}")
                # Recalc size if requested
                if force_recalc:
                    for i in range(self.count()):
                        it = self.item(i)
                        if self.itemWidget(it) == item_widget:
                            self.updateItemSize(it, item_widget, force_full_calculation=True)
                            break
                return True
            else:
                print(f"🧩💥 [SEC-ROW] Missing main layout on item widget for {annotation_id}")
                return True
        except Exception as e:
            print(f"🧩💥 [SEC-ROW] Error building row for {annotation_id}: {e}")
            return True
    
    def _create_truncated_tags_widget(self, tags_data, sec_list, secondary_layout):
        """Create a tags widget that truncates when it would collide with secondary scene chips"""
        if not tags_data:
            return None
            
        # Calculate available width for tags
        # Get the parent widget width (approximate)
        try:
            # Estimate available width: container width - left margin - space for chips - padding
            container_width = self.viewport().width() - 40  # Account for scrollbar and margins
            left_margin = 30  # The left margin we set
            
            # Estimate space needed for secondary scene chips
            chips_space = 0
            if sec_list:
                chips_space = len(sec_list) * 10 + (len(sec_list) - 1) * 3 + 10  # chip width + spacing + small padding
            
            # Available width for tags (reduced buffer)
            available_width = container_width - left_margin - chips_space - 20  # Smaller buffer
            
            print(f"[DEBUG] Tags width calculation: container={container_width}, chips_space={chips_space}, available={available_width}")
            
            # If we have very little space, show minimal tags
            if available_width < 150:
                available_width = 150  # Increased minimum
                print(f"[DEBUG] Using minimum width: {available_width}")
                
        except Exception:
            # Fallback to a reasonable default
            available_width = 200
            
        # Create the tags widget
        new_tags_widget = QLabel()
        
        if tags_data['has_tags']:
            tags = tags_data['tags']
            
            # Try to fit as many tags as possible
            fitted_tags = []
            remaining_count = 0
            current_width = 0
            
            # More accurate character width estimation for 10px bold font
            char_width = 5  # Reduced from 6 to 5 pixels per character
            
            for i, tag in enumerate(tags):
                tag_text = f"#{tag}"
                tag_width = len(tag_text) * char_width + 8  # Add padding
                
                # Add separator if not first tag
                if fitted_tags:
                    tag_width += len(", ") * char_width
                    
                # Check if adding this tag would exceed available width
                # Reserve space for "...(X)" if we have more tags
                remaining_tags = len(tags) - i
                truncation_text = f"...({remaining_tags})" if remaining_tags > 0 else ""
                truncation_width = len(truncation_text) * char_width
                
                if current_width + tag_width + truncation_width > available_width and fitted_tags:
                    # We can't fit this tag, calculate remaining count
                    remaining_count = len(tags) - len(fitted_tags)
                    break
                else:
                    fitted_tags.append(tag)
                    current_width += tag_width
            
            # Build the display text
            if fitted_tags:
                display_text = ", ".join([f"#{tag}" for tag in fitted_tags])
                if remaining_count > 0:
                    display_text += f"...({remaining_count})"
            else:
                # Can't fit any tags, show count only
                display_text = f"({len(tags)} tags)"
                
            new_tags_widget.setText(display_text)
            
            # Tooltip shows all tags
            all_tags_text = ", ".join([f"#{tag}" for tag in tags])
            new_tags_widget.setToolTip(f"Tags: {all_tags_text}")
            
            # Style for existing tags
            new_tags_widget.setStyleSheet("""
                QLabel {
                    color: #2196F3;
                    font-size: 10px;
                    font-weight: bold;
                    padding: 2px 4px;
                    background: transparent;
                    margin-left: 4px;
                }
                QLabel:hover {
                    color: #1976D2;
                }
            """)
        else:
            # "add tags" label
            new_tags_widget.setText("add tags")
            new_tags_widget.setToolTip("Click to add tags")
            
            # Style for "add tags" label
            new_tags_widget.setStyleSheet("""
                QLabel {
                    color: #888;
                    font-size: 10px;
                    font-style: italic;
                    padding: 2px 4px;
                    background: transparent;
                    margin-left: 4px;
                }
                QLabel:hover {
                    color: #666;
                }
            """)
        
        new_tags_widget.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
        new_tags_widget.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Minimum)
        new_tags_widget.setCursor(Qt.CursorShape.PointingHandCursor)
        new_tags_widget.mousePressEvent = lambda event: self.show_tags_context_menu(tags_data['annotation_id'], event.globalPosition().toPoint())
        
        return new_tags_widget

    def setup_annotation_signals(self):
        self.web_view.annotation_updated.connect(self.handle_annotation_update)

    def _update_storyboard_if_visible(self):
        """Helper method to update storyboard if it's accessible and visible - NO LONGER NEEDED"""
        # This method used to trigger expensive populate_order_list rebuilds
        # Now storyboard handles its own updates via targeted methods through annotation_updated signals
        print("[DEBUG] _update_storyboard_if_visible called but using targeted approach instead")

    def _handle_delayed_notes_update(self):
        """Handle the delayed notes update after the timer expires"""
        if hasattr(self, '_last_note_update'):
            last_update = self._last_note_update
            # Check if EITHER 'notes' OR 'notes_html' is in the update
            if 'text' in last_update and 'annotation_id' in last_update and ('notes' in last_update or 'notes_html' in last_update):
                main_window = self.window()
                if isinstance(main_window, ScriptoriaMain):
                    # Use targeted update instead of expensive populate_order_list
                    if hasattr(main_window, 'storyboard_dialog') and main_window.storyboard_dialog:
                        # Notes updates don't need visual state changes, just data sync
                        print("[DEBUG] Notes updated - using targeted approach instead of populate_order_list")

    def on_notes_changed(self, text, annotation_id, notes=None, html_notes=None):
        """Handle changes to notes or notes_html independently"""
        # Find the current annotation to get existing values
        main_window = self.window()
        current_anno = None
        if isinstance(main_window, ScriptoriaMain):
            for anno in main_window.web_view.annotations:
                if anno.get('id') == annotation_id:
                    current_anno = anno
                    break
        
        # MIGRATION: Extract tags from notes if tags field doesn't exist
        if current_anno and notes is not None and 'tags' not in current_anno:
            import re
            # Extract hashtags from notes
            hashtags = re.findall(r'#([A-Za-z0-9_]+)', notes)
            if hashtags:
                current_anno['tags'] = hashtags
                # Remove hashtags from notes to keep them separate
                clean_notes = re.sub(r'\s*#[A-Za-z0-9_]+', '', notes).strip()
                notes = clean_notes
    
        update_dict = {
            'text': text,
            'annotation_id': annotation_id,
        }
    
        # If only one value is provided, preserve the other
        if notes is not None:
            update_dict['notes'] = notes
        elif current_anno:
            # Preserve existing notes if not provided
            update_dict['notes'] = current_anno.get('notes', '')
    
        if html_notes is not None:
            update_dict['notes_html'] = html_notes
        elif current_anno:
            # Preserve existing notes_html if not provided
            update_dict['notes_html'] = current_anno.get('notes_html', '')

        self._last_note_update.update(update_dict)

        self._notes_update_timer.stop()
        self._notes_update_timer.start()

        if current_anno:
            # Update annotation with both values
            if notes is not None:
                current_anno['notes'] = notes
            if html_notes is not None:
                current_anno['notes_html'] = html_notes

            # Construct payload with BOTH values
            update_payload = {
                'id': annotation_id,
                'text': text,
                'favorite': current_anno.get('favorite', False),
                'used': current_anno.get('used', False),
                'notes': current_anno.get('notes', ''),
                'notes_html': current_anno.get('notes_html', ''),
                'tags': current_anno.get('tags', []),
                'secondary_scenes': current_anno.get('secondary_scenes', [])
            }

            main_window.web_view.annotation_updated.emit(json.dumps(update_payload))
            main_window.mark_changes_pending()

    # Add this method to AnnotationListWidget class
    def show_notes_context_menu(self, edit, pos):
          """Show standard context menu for notes editing"""
          menu = edit.createStandardContextMenu()
          menu.exec(edit.mapToGlobal(pos))

    def apply_selected_tags(self, edit, tag_checkboxes, menu):
        """Apply selected tags to the notes field"""
        # Get current notes text
        current_notes = edit.text()
        
        # Extract existing tags
        import re
        existing_tags = set(re.findall(r'#([A-Za-z0-9_]+)', current_notes))
        
        # Get selected tags from checkboxes
        selected_tags = set()
        for tag, checkbox in tag_checkboxes.items():
            if checkbox.isChecked():
                selected_tags.add(tag)
        
        # Remove unchecked tags that were previously in the notes
        tags_to_remove = existing_tags - selected_tags
        for tag in tags_to_remove:
            # Remove the tag and any surrounding spaces
            current_notes = re.sub(rf'\s*#{re.escape(tag)}\s*', ' ', current_notes)
        
        # Add newly selected tags
        tags_to_add = selected_tags - existing_tags
        if tags_to_add:
            # Add tags at the end, ensuring proper spacing
            current_notes = current_notes.rstrip()
            if current_notes and not current_notes.endswith(','):
                current_notes += ','
            if current_notes:
                current_notes += ' '
            current_notes += ', '.join(f"#{tag}" for tag in sorted(tags_to_add))
        
        # Clean up multiple spaces and commas
        current_notes = re.sub(r'\s+', ' ', current_notes)
        current_notes = re.sub(r',\s*,', ',', current_notes)
        current_notes = current_notes.strip()
        
        # Update the notes field
        edit.setText(current_notes)
        
        # Close the menu
        menu.close()

    def select_all_tags(self, tag_checkboxes, checked):
        """Select or deselect all tags"""
        for checkbox in tag_checkboxes.values():
            checkbox.setChecked(checked)
    
    def auto_apply_tag(self, edit, tag, is_checked):
        """Automatically apply or remove a tag when checkbox is clicked"""
        current_text = edit.text()
        tag_with_hash = f"#{tag}"
        
        if is_checked:
            # Add tag if it's not already present
            if tag_with_hash not in current_text:
                if current_text and not current_text.endswith(' '):
                    current_text += ' '
                current_text += tag_with_hash
        else:
            # Remove tag
            import re
            # Remove the tag with optional surrounding spaces
            pattern = r'\s*#' + re.escape(tag) + r'(?=\s|$)'
            current_text = re.sub(pattern, '', current_text)
            # Clean up multiple spaces
            current_text = re.sub(r'\s+', ' ', current_text).strip()
        
        edit.setText(current_text)
    
    def select_filtered_tags(self, search_field, tag_checkboxes, filter_func):
        """Select all currently visible (filtered) tags and clear search"""
        search_text = search_field.text().strip()
        if not search_text:
            return  # Do nothing if search is empty
        
        # Parse comma-separated search terms
        search_terms = [term.strip().lower().replace('#', '') for term in search_text.split(',') if term.strip()]
        
        # Select all tags that match the search terms
        for tag, checkbox in tag_checkboxes.items():
            tag_text = tag.lower().replace('#', '')
            # Check if tag matches any of the search terms
            matches = any(search_term in tag_text for search_term in search_terms)
            if matches:
                checkbox.setChecked(True)
        
        # Clear the search field
        search_field.clear()
        # Trigger filter update to show all tags again
        filter_func("")

    def show_tags_context_menu(self, annotation_id, pos):
        """Show context menu for editing tags (separate from notes)"""
        menu = QMenu(self)

        # Set menu styling with improved appearance
        menu.setStyleSheet("""
            QMenu {
                background-color: white;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 8px 24px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #e3f2fd;
                color: #2C4952;
            }
            QMenu::separator {
                height: 1px;
                background: #e0e0e0;
                margin: 4px 0;
            }
        """)

        # Create a header widget for the title
        header_action = QWidgetAction(menu)
        header_widget = QWidget(menu)
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(8, 4, 8, 4)

        header_label = QLabel("Edit Tags")
        header_label.setStyleSheet("""
            font-weight: bold;
            color: #2C4952;
            padding: 4px 16px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #e0e0e0;
        """)
        header_layout.addWidget(header_label)

        header_action.setDefaultWidget(header_widget)
        menu.addAction(header_action)

        # Add search bar widget
        search_action = QWidgetAction(menu)
        search_widget = QWidget(menu)
        search_layout = QVBoxLayout(search_widget)
        search_layout.setContentsMargins(8, 4, 8, 4)
        
        # Create search input
        tag_search = QLineEdit()
        tag_search.setPlaceholderText("Search tags...")
        tag_search.setFixedHeight(24)
        tag_search.setStyleSheet("""
            QLineEdit {
                padding: 4px 8px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: white;
                font-size: 11px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
        """)
        search_layout.addWidget(tag_search)
        
        search_action.setDefaultWidget(search_widget)
        menu.addAction(search_action)
        
        # Add separator after search bar
        menu.addSeparator()
        
        # Store tag actions for filtering
        tag_actions = []
        tag_checkboxes = {}
        
        # Get current tags for this annotation
        main_window = self.window()
        current_tags = set()
        if isinstance(main_window, ScriptoriaMain):
            for anno in main_window.web_view.annotations:
                if anno.get('id') == annotation_id:
                    current_tags = set(anno.get('tags', []))
                    break

        # Get ALL tags from main window tag list
        if hasattr(main_window, 'tags') and main_window.tags:
            # Normalize tags by removing # symbols
            normalized_tags = [tag.lstrip('#') for tag in main_window.tags]
            print(f"[DEBUG] Tags context menu showing {len(normalized_tags)} total tags: {normalized_tags}")
            
            # Decide whether to use single column or two columns
            if len(normalized_tags) > 12:
                print(f"[DEBUG] Using two-column layout for {len(normalized_tags)} tags")
                # Create two-column layout
                grid_action = QWidgetAction(menu)
                # Create scroll area for the grid
                scroll_area = QScrollArea()
                scroll_area.setMinimumWidth(320)  # Account for scrollbar
                scroll_area.setMaximumHeight(400)
                scroll_area.setWidgetResizable(True)
                scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
                scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
                
                grid_container = QWidget()
                grid_container.setMinimumWidth(300)
                grid_layout = QGridLayout(grid_container)
                grid_layout.setContentsMargins(8, 6, 8, 6)
                grid_layout.setHorizontalSpacing(12)
                grid_layout.setVerticalSpacing(6)
                grid_layout.setColumnStretch(0, 1)
                grid_layout.setColumnStretch(1, 1)
                
                # Calculate rows per column
                rows_per_column = (len(normalized_tags) + 1) // 2  # Divide evenly
                
                for i, tag in enumerate(normalized_tags):
                    # Determine position in grid
                    if i < rows_per_column:
                        row, col = i, 0  # First column
                    else:
                        row, col = i - rows_per_column, 1  # Second column
                    
                    checkbox = QCheckBox(tag)
                    checkbox.setChecked(tag in current_tags)
                    checkbox.setFixedHeight(20)
                    checkbox.setStyleSheet("""
                        QCheckBox {
                            font-size: 11px;
                            padding: 2px;
                            spacing: 4px;
                        }
                        QCheckBox::indicator {
                            width: 12px;
                            height: 12px;
                        }
                        QCheckBox:hover {
                            background-color: #e3f2fd;
                            border-radius: 2px;
                        }
                    """)
                    checkbox.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
                    
                    # Auto-apply tags when checkbox is clicked
                    checkbox.stateChanged.connect(lambda state, t=tag: self.auto_apply_annotation_tag(annotation_id, t, state == 2))
                    
                    grid_layout.addWidget(checkbox, row, col)
                    tag_checkboxes[tag] = checkbox
                
                # Set the grid container as the scroll area's widget
                scroll_area.setWidget(grid_container)
                grid_action.setDefaultWidget(scroll_area)
                menu.addAction(grid_action)
                menu.addSeparator()  # Add separator after grid
                tag_actions.append(grid_action)
                
            else:
                print(f"[DEBUG] Using single-column layout for {len(normalized_tags)} tags")
                # Single column layout for 12 or fewer tags
                tag_checkbox_actions = []  # Store just the checkbox actions for filtering
                for tag in normalized_tags:
                    action = QWidgetAction(menu)
                    
                    # Create checkbox widget
                    checkbox_widget = QWidget()
                    checkbox_layout = QHBoxLayout(checkbox_widget)
                    checkbox_layout.setContentsMargins(4, 2, 4, 2)
                    checkbox_layout.setSpacing(2)
                    
                    checkbox = QCheckBox(tag)
                    checkbox.setChecked(tag in current_tags)  # Check if tag is already in annotation
                    checkbox.setFixedHeight(20)  # Compact height
                    checkbox.setStyleSheet("""
                        QCheckBox {
                            font-size: 11px;
                            padding: 2px;
                            spacing: 4px;
                        }
                        QCheckBox::indicator {
                            width: 12px;
                            height: 12px;
                        }
                        QCheckBox:hover {
                            background-color: #e3f2fd;
                            border-radius: 2px;
                        }
                    """)
                    
                    # Auto-apply tags when checkbox is clicked
                    checkbox.stateChanged.connect(lambda state, t=tag: self.auto_apply_annotation_tag(annotation_id, t, state == 2))
                    
                    checkbox_layout.addWidget(checkbox)
                    action.setDefaultWidget(checkbox_widget)
                    menu.addAction(action)
                    
                    tag_actions.append(action)
                    tag_checkbox_actions.append(action)  # Store for filtering
                    tag_checkboxes[tag] = checkbox
        else:
            # Show placeholder if no tags
            placeholder = menu.addAction("No tags available")
            placeholder.setEnabled(False)
            tag_actions.append(placeholder)
            
        # Connect search functionality
        def filter_tags(search_text):
            search_text = search_text.strip()
            if not search_text:
                # Show all tags when search is empty
                visible_count = len(tag_checkboxes)
                if len(normalized_tags) > 12:
                    for checkbox in tag_checkboxes.values():
                        checkbox.setVisible(True)
                else:
                    for action in tag_checkbox_actions:
                        action.setVisible(True)
            else:
                # Parse comma-separated search terms
                search_terms = [term.strip().lower().replace('#', '') for term in search_text.split(',') if term.strip()]
                visible_count = 0
                
                if len(normalized_tags) > 12:
                    # For grid layout, show/hide individual checkboxes
                    for tag, checkbox in tag_checkboxes.items():
                        tag_text = tag.lower().replace('#', '')  # Remove # from tag text
                        # Check if tag matches any of the search terms
                        matches = any(search_term in tag_text for search_term in search_terms)
                        if matches:
                            checkbox.setVisible(True)
                            visible_count += 1
                        else:
                            checkbox.setVisible(False)
                else:
                    # For single column layout, show/hide actions
                    for i, (tag, checkbox) in enumerate(tag_checkboxes.items()):
                        tag_text = tag.lower().replace('#', '')  # Remove # from tag text
                        action = tag_checkbox_actions[i]  # Get the corresponding checkbox action
                        # Check if tag matches any of the search terms
                        matches = any(search_term in tag_text for search_term in search_terms)
                        if matches:
                            action.setVisible(True)
                            visible_count += 1
                        else:
                            action.setVisible(False)
            
            # Show/hide "no results" message
            if visible_count == 0 and search_text and tag_checkboxes:
                if not hasattr(menu, '_no_results_action'):
                    menu._no_results_action = menu.addAction("No matching tags")
                    menu._no_results_action.setEnabled(False)
                menu._no_results_action.setVisible(True)
            elif hasattr(menu, '_no_results_action'):
                menu._no_results_action.setVisible(False)
                
        if tag_checkboxes:  # Only connect if we have tags
            tag_search.textChanged.connect(filter_tags)
            # Connect Enter key to select filtered tags
            tag_search.returnPressed.connect(lambda: self.select_filtered_annotation_tags(tag_search, tag_checkboxes, filter_tags, annotation_id))

        # Select/Deselect All buttons
        if tag_checkboxes:
            menu.addSeparator()
            
            # Create button widget to prevent menu from closing
            button_action = QWidgetAction(menu)
            button_widget = QWidget()
            button_layout = QHBoxLayout(button_widget)
            button_layout.setContentsMargins(8, 4, 8, 4)
            button_layout.setSpacing(4)
            
            select_all_btn = QPushButton("Select All")
            select_all_btn.setFixedHeight(24)
            select_all_btn.setStyleSheet("""
                QPushButton {
                    font-size: 11px;
                    padding: 2px 8px;
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    background: #f9f9f9;
                }
                QPushButton:hover {
                    background: #e3f2fd;
                }
                QPushButton:pressed {
                    background: #bbdefb;
                }
            """)
            select_all_btn.clicked.connect(lambda: self.select_all_annotation_tags(tag_checkboxes, True))
            
            deselect_all_btn = QPushButton("Deselect All")
            deselect_all_btn.setFixedHeight(24)
            deselect_all_btn.setStyleSheet("""
                QPushButton {
                    font-size: 11px;
                    padding: 2px 8px;
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    background: #f9f9f9;
                }
                QPushButton:hover {
                    background: #e3f2fd;
                }
                QPushButton:pressed {
                    background: #bbdefb;
                }
            """)
            deselect_all_btn.clicked.connect(lambda: self.select_all_annotation_tags(tag_checkboxes, False))
            
            button_layout.addWidget(select_all_btn)
            button_layout.addWidget(deselect_all_btn)
            button_action.setDefaultWidget(button_widget)
            menu.addAction(button_action)
            
        # Create new tag option
        menu.addSeparator()
        add_tag_action = menu.addAction("Create new tag...")
        add_tag_action.triggered.connect(lambda: self.open_tag_list_dialog_for_annotation(annotation_id))

        # Show the menu at cursor position (15px lower) and focus the search bar
        # Adjust position to be 15px lower
        adjusted_pos = QPoint(pos.x(), pos.y() + 15)
        
        # Set focus immediately before showing menu
        tag_search.setFocus()
        # Also try multiple approaches to ensure focus works
        QTimer.singleShot(1, tag_search.setFocus)
        QTimer.singleShot(5, tag_search.setFocus)
        QTimer.singleShot(10, tag_search.setFocus)
        menu.exec(adjusted_pos)
    
    def auto_apply_annotation_tag(self, annotation_id, tag, is_checked):
        """Automatically apply or remove a tag from an annotation when checkbox is clicked"""
        main_window = self.window()
        if not isinstance(main_window, ScriptoriaMain):
            return
            
        # Find the annotation and update its tags
        for anno in main_window.web_view.annotations:
            if anno.get('id') == annotation_id:
                current_tags = set(anno.get('tags', []))
                
                if is_checked:
                    # Add tag if not already present
                    current_tags.add(tag)
                else:
                    # Remove tag
                    current_tags.discard(tag)
                
                # Update annotation tags
                anno['tags'] = list(current_tags)
                print(f"DEBUG: Updated annotation {annotation_id} tags to: {anno['tags']}")
                
                # Sync with storyboard if this annotation exists there
                self._sync_tags_with_storyboard(annotation_id, list(current_tags), anno)
                
                # Emit signal to update DOM data attributes
                main_window.web_view.annotation_updated.emit(json.dumps(anno))
                print(f"DEBUG: Emitted annotation_updated signal for {annotation_id}")
                
                # Apply targeted filtering after DOM attributes are updated
                scene = anno.get('scene', '')
                if scene and hasattr(main_window.web_view, '_apply_filters_to_annotation'):
                    # Small delay to ensure DOM attributes are updated first
                    def apply_targeted_filter():
                        print(f"[DEBUG] Applying targeted filtering after tag change: {annotation_id}")
                        main_window.web_view._apply_filters_to_annotation(annotation_id, scene, anno)
                    QTimer.singleShot(50, apply_targeted_filter)
                
                # Update the UI display to reflect the change
                self.refresh_annotation_display(annotation_id)
                
                # Mark changes as pending
                main_window.mark_changes_pending()
                break

    def _sync_tags_with_storyboard(self, annotation_id, new_tags, annotation_data):
        """Sync tag changes with storyboard if the annotation exists there"""
        main_window = self.window()
        if not isinstance(main_window, ScriptoriaMain):
            return
            
        # Check if storyboard dialog exists and has this annotation
        if hasattr(main_window, 'storyboard_dialog') and main_window.storyboard_dialog:
            storyboard = main_window.storyboard_dialog
            
            # Find the annotation in storyboard and update its tags
            for i in range(storyboard.order_list.count()):
                item = storyboard.order_list.item(i)
                if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                    widget = storyboard.order_list.itemWidget(item)
                    if widget:
                        # Update the widget's tags property
                        widget.setProperty('tags', new_tags)
                        
                        # Find and update the tags display in the storyboard
                        for child in widget.children():
                            if isinstance(child, QLabel) and child.property('is_tags_widget'):
                                if new_tags:
                                    tags_text = ", ".join([f"#{tag}" for tag in new_tags])
                                    child.setProperty('original_tags_text', tags_text)
                                    # The visual update will happen through the existing positioning logic
                                else:
                                    child.setText("add tags")
                                    child.setProperty('original_tags_text', "add tags")
                                break
                        
                        # Trigger tag positioning update in storyboard
                        storyboard._trigger_tags_positioning()
                        
                        print(f"DEBUG: Synced tags with storyboard for annotation {annotation_id}")
                    break

    def select_all_annotation_tags(self, tag_checkboxes, checked):
        """Select or deselect all annotation tags"""
        for checkbox in tag_checkboxes.values():
            checkbox.setChecked(checked)

    def select_filtered_annotation_tags(self, search_field, tag_checkboxes, filter_func, annotation_id):
        """Select all currently visible (filtered) tags and clear search"""
        search_text = search_field.text().strip()
        if not search_text:
            return  # Do nothing if search is empty
        
        # Parse comma-separated search terms
        search_terms = [term.strip().lower().replace('#', '') for term in search_text.split(',') if term.strip()]
        
        # Select all tags that match the search terms
        for tag, checkbox in tag_checkboxes.items():
            tag_text = tag.lower().replace('#', '')
            # Check if tag matches any of the search terms
            matches = any(search_term in tag_text for search_term in search_terms)
            if matches:
                checkbox.setChecked(True)
        
        # Clear the search field
        search_field.clear()
        # Trigger filter update to show all tags again
        filter_func("")

    def open_tag_list_dialog_for_annotation(self, annotation_id):
        """Open the TagListDialog for creating new tags (annotation context)"""
        main_window = self.window()
        if isinstance(main_window, ScriptoriaMain):
            # Get existing tags
            tags = main_window.tags if hasattr(main_window, 'tags') else []
        
            # Create and show the dialog
            dialog = TagListDialog(main_window, tags)
        
            # Connect the tagsChanged signal
            def on_tags_changed():
                # Update main window tags
                main_window.tags = dialog.get_tags()
                main_window.mark_changes_pending()
            
            dialog.tagsChanged.connect(on_tags_changed)
            dialog.exec()

    def refresh_annotation_display(self, annotation_id):
        """Refresh the display of a specific annotation to show updated tags in secondary row"""
        print(f"[DEBUG] refresh_annotation_display called for {annotation_id}")
        print(f"[DEBUG] Searching through {self.count()} items in list")
        
        # Find the annotation item in the list and update its display
        for i in range(self.count()):
            item = self.item(i)
            if item:
                item_id = item.data(Qt.ItemDataRole.UserRole)
                print(f"[DEBUG] Item {i} has ID: {item_id}")
                if item_id == annotation_id:
                    # Get the annotation data
                    main_window = self.window()
                    if isinstance(main_window, ScriptoriaMain):
                        for anno in main_window.web_view.annotations:
                            if anno.get('id') == annotation_id:
                                # Get the widget
                                widget = self.itemWidget(item)
                                if widget:
                                    # Update cached tags data
                                    current_tags = anno.get('tags', [])
                                    if current_tags:
                                        tags_text = ", ".join([f"#{tag}" for tag in current_tags])
                                        widget.setProperty('cached_tags_data', {
                                            'tags': current_tags,
                                            'annotation_id': annotation_id,
                                            'tags_text': tags_text,
                                            'tooltip': f"Tags: {tags_text}",
                                            'has_tags': True
                                        })
                                    else:
                                        widget.setProperty('cached_tags_data', {
                                            'tags': [],
                                            'annotation_id': annotation_id,
                                            'tags_text': 'add tags',
                                            'tooltip': 'Click to add tags',
                                            'has_tags': False
                                        })
                                    
                                    # Remove existing secondary row and rebuild it
                                    for child in widget.findChildren(QWidget):
                                        if child.property('is_secondary_row'):
                                            child.setParent(None)
                                            child.deleteLater()
                                            break
                                    
                                    # Rebuild secondary row with updated tags
                                    self._build_secondary_row_for_item(widget, annotation_id, force_recalc=True)
                                    print(f"[DEBUG] Rebuilt secondary row with updated tags for {annotation_id}: {current_tags}")
                                    break
                                break
                        break
        print(f"[DEBUG] refresh_annotation_display: annotation {annotation_id} not found in list")

    def open_tag_list_dialog(self, edit):
        """Open the TagListDialog to manage tags"""
        main_window = self.window()
        if isinstance(main_window, ScriptoriaMain):
            # Get existing tags
            tags = main_window.tags if hasattr(main_window, 'tags') else []
        
            # Create and show the dialog
            dialog = TagListDialog(main_window, tags)
        
            # Connect the tagsChanged signal
            def on_tags_changed():
                # Update main window tags
                main_window.tags = dialog.get_tags()
                main_window.mark_changes_pending()
            
                # If the notes field is empty, insert the first tag
                if edit.text().strip() == "" and main_window.tags:
                    self.insert_tag_to_notes(edit, main_window.tags[0])
        
            dialog.tagsChanged.connect(on_tags_changed)
            dialog.exec()

    def insert_tag_to_notes(self, edit, tag):
        """Insert the selected tag into the notes edit, automatically
        adding a comma and a space if there is already text present."""
        current_text = edit.text()
        # If there is already text, append ", " before the tag
        if current_text:
            # Check if current text already ends with a comma and space.
            # This simple check avoids duplicate punctuation.
            if not current_text.endswith(", "):
                new_text = current_text + ", " + tag
            else:
                new_text = current_text + tag
        else:
            new_text = tag
        edit.setText(new_text)
        # Move cursor to the end of the text
        edit.setCursorPosition(len(new_text))

    def on_checkbox_changed(self, text, annotation_id, state):
        main_window = self.window()
        if isinstance(main_window, ScriptoriaMain):
            found = False
            for anno in main_window.web_view.annotations:
                if anno.get('id') == annotation_id:
                    # 1. Update the used status in the Python data structure
                    anno['used'] = bool(state)
                    found = True

                    # 2. Prepare the payload - INCLUDE notes_html and tags
                    update_payload = {
                        'id': annotation_id,
                        'text': text, # Uses the 'text' passed into the function
                        'used': bool(state),
                        'favorite': anno.get('favorite', False), # Gets current favorite status
                        'notes': anno.get('notes', ''), # Gets current plain notes
                        'notes_html': anno.get('notes_html', ''), # <-- *** ADD THIS LINE ***
                        'tags': anno.get('tags', []), # Preserve tags
                        'secondary_scenes': anno.get('secondary_scenes', []) # Preserve secondary_scenes
                    }
                    # Add logging for verification
                    print(f"DEBUG on_checkbox_changed: Emitting update payload: {json.dumps(update_payload, indent=2)}")

                    # 3. Emit the signal with the complete payload
                    main_window.web_view.annotation_updated.emit(json.dumps(update_payload))

                    main_window.mark_changes_pending()
                    
                    # 4. Apply targeted filtering after DOM attributes are updated
                    scene = anno.get('scene', '')
                    if scene and hasattr(main_window.web_view, '_apply_filters_to_annotation'):
                        # Small delay to ensure DOM attributes are updated first
                        def apply_targeted_filter():
                            print(f"[DEBUG] Applying targeted filtering after used status change: {annotation_id}")
                            main_window.web_view._apply_filters_to_annotation(annotation_id, scene, anno)
                        QTimer.singleShot(50, apply_targeted_filter)
                
                    # 5. ADDED: Handle theme view updates more efficiently
                    # Apply filters directly without full rebuild
                    if main_window.theme_view and main_window.theme_view.isVisible():
                        if hasattr(main_window.script_search, 'apply_current_filters'):
                            print("[DEBUG] Applying filters directly after status change")
                            main_window.script_search.apply_current_filters()
                        else:
                            print("[DEBUG] No apply_current_filters method - doing targeted update")
                            # Just update the visual state of this specific item
                            scene = anno.get('scene', '')
                    
                    # 5. Let storyboard handle its own updates via targeted methods
                    # No need to manually sync - storyboard will update itself through annotation_updated signal
                            # Find the tab for this scene
                            for i in range(main_window.scene_tabs.count()):
                                if main_window.scene_tabs.tabText(i) == scene:
                                    list_widget = main_window.scene_tabs.widget(i)
                                    if isinstance(list_widget, AnnotationListWidget):
                                        # Find and update the item with this annotation ID
                                        for j in range(list_widget.count()):
                                            item = list_widget.item(j)
                                            if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                                                # Update the item widget to reflect new state
                                                widget = list_widget.itemWidget(item)
                                                if widget:
                                                    # Update the favorite star or used checkbox visual
                                                    if 'favorite' in update_payload:
                                                        favorite_label = widget.findChild(QLabel, "favorite_star")
                                                        if favorite_label:
                                                            favorite_label.setText("★" if update_payload['favorite'] else "☆")
                                                    if 'used' in update_payload:
                                                        used_checkbox = widget.findChild(CustomCheckBox)
                                                        if used_checkbox:
                                                            used_checkbox.setChecked(update_payload['used'])
                                                print(f"[DEBUG] Updated annotation {annotation_id} item widget")
                                                break
                                    break
                
                    # Update storyboard if visible
                    self._update_storyboard_if_visible()
                    break
            if not found:
                print(f"Warning: Could not find annotation with ID {annotation_id} to update state")


    def on_favorite_changed(self, text, annotation_id, is_favorite):
        main_window = self.window()
        if isinstance(main_window, ScriptoriaMain):
            found = False
            for anno in main_window.web_view.annotations:
                if anno.get('id') == annotation_id:
                    # 1. Update the favorite status in the Python data structure
                    anno['favorite'] = is_favorite
                    found = True

                    # 2. Prepare the payload - INCLUDE notes_html and tags
                    update_payload = {
                        'id': annotation_id,
                        'text': text, # Uses the 'text' passed into the function
                        'favorite': is_favorite,
                        'notes': anno.get('notes', ''), # Gets current plain notes
                        'notes_html': anno.get('notes_html', ''), # <-- *** ADD THIS LINE ***
                        'used': anno.get('used', False), # Gets current used status
                        'tags': anno.get('tags', []), # Preserve tags
                        'secondary_scenes': anno.get('secondary_scenes', []) # Preserve secondary_scenes
                    }
                    # Add logging for verification
                    print(f"DEBUG on_favorite_changed: Emitting update payload: {json.dumps(update_payload, indent=2)}")

                    # 3. Emit the signal with the complete payload
                    main_window.web_view.annotation_updated.emit(json.dumps(update_payload))

                    main_window.mark_changes_pending()
                    
                    # 4. Apply targeted filtering after DOM attributes are updated
                    scene = anno.get('scene', '')
                    if scene and hasattr(main_window.web_view, '_apply_filters_to_annotation'):
                        # Small delay to ensure DOM attributes are updated first
                        def apply_targeted_filter():
                            print(f"[DEBUG] Applying targeted filtering after favorite change: {annotation_id}")
                            main_window.web_view._apply_filters_to_annotation(annotation_id, scene, anno)
                        QTimer.singleShot(50, apply_targeted_filter)
                
                    # 5. ADDED: Handle theme view updates more efficiently
                    # Apply filters directly without full rebuild
                    if main_window.theme_view and main_window.theme_view.isVisible():
                        if hasattr(main_window.script_search, 'apply_current_filters'):
                            print("[DEBUG] Applying filters directly after status change")
                            main_window.script_search.apply_current_filters()
                        else:
                            print("[DEBUG] No apply_current_filters method - doing targeted update")
                            # Just update the visual state of this specific item
                            scene = anno.get('scene', '')
                    
                    # 5. Let storyboard handle its own updates via targeted methods
                    # No need to manually sync - storyboard will update itself through annotation_updated signal
                            # Find the tab for this scene
                            for i in range(main_window.scene_tabs.count()):
                                if main_window.scene_tabs.tabText(i) == scene:
                                    list_widget = main_window.scene_tabs.widget(i)
                                    if isinstance(list_widget, AnnotationListWidget):
                                        # Find and update the item with this annotation ID
                                        for j in range(list_widget.count()):
                                            item = list_widget.item(j)
                                            if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                                                # Update the item widget to reflect new state
                                                widget = list_widget.itemWidget(item)
                                                if widget:
                                                    # Update the favorite star or used checkbox visual
                                                    if 'favorite' in update_payload:
                                                        favorite_label = widget.findChild(QLabel, "favorite_star")
                                                        if favorite_label:
                                                            favorite_label.setText("★" if update_payload['favorite'] else "☆")
                                                    if 'used' in update_payload:
                                                        used_checkbox = widget.findChild(CustomCheckBox)
                                                        if used_checkbox:
                                                            used_checkbox.setChecked(update_payload['used'])
                                                print(f"[DEBUG] Updated annotation {annotation_id} item widget")
                                                break
                                    break
                
                    # Update storyboard if visible
                    self._update_storyboard_if_visible()
                    break
            if not found:
                print(f"Warning: Could not find annotation with ID {annotation_id} to update favorite state")

    def get_item_notes(self, item):
        item_widget = self.itemWidget(item)
        if item_widget:
            notes_edit = item_widget.findChild(QLineEdit)
            if notes_edit:
                return notes_edit.text()
        return ""

    def set_item_notes(self, item, notes):
        item_widget = self.itemWidget(item)
        if item_widget:
            notes_edit = item_widget.findChild(QLineEdit)
            if notes_edit:
                notes_edit.setText(notes)

    def scroll_to_annotation(self, item):
        item_widget = self.itemWidget(item)
        if item_widget:
            # Find the main content label by its object name (set in add_item_with_checkbox)
            label = item_widget.findChild(QLabel, "main_content_label")
            if label:
                text = label.text()
                main_window = self.window()
                if isinstance(main_window, ScriptoriaMain):
                    print("scroll_to_annotation: Found label text:", text)
                    matching_annotation = next(
                        (anno for anno in main_window.web_view.annotations if anno['text'].strip() == text.strip()),
                        None
                    )
                    if matching_annotation:
                        print("scroll_to_annotation: Found matching annotation:", matching_annotation)
                        # Clean text for JS injection by escaping special characters
                        text_escaped = text.replace('\\', '\\\\').replace('"', '\\"').replace("'", "\\'").replace('\n', '\\n')
                        js_code = f'''
                            (function() {{
                            // Define variables for this execution context - now scoped to this IIFE
                            const annotationId = "{matching_annotation['id']}";
                            const textToMatch = "{text_escaped}";
                    
                            // This function adds a class-based approach with animation cleanup
                            function scrollToText() {{
                                console.log("scrollToText: Searching for span with annotation id:", annotationId);
                                var spans = document.querySelectorAll(`span[data-annotation-id="${{annotationId}}"]`);
                                if (spans.length > 0) {{
                                    console.log("scrollToText: Found span(s) using annotation id.");
                                    return spans;
                                }}
                                console.warn("scrollToText: No span found with annotation id. Falling back to text match.");
                                var allSpans = document.querySelectorAll('span');
                                for (var i = 0; i < allSpans.length; i++) {{
                                    if (allSpans[i].textContent.trim() === textToMatch.trim()) {{
                                        console.log("scrollToText: Found span using text match at index", i);
                                        return [allSpans[i]];
                                    }}
                                }}
                                console.error("scrollToText: No span found matching the text.");
                                return [];
                            }}

                            // First, ensure we have a cleanup function in the global scope if not already defined
                            if (typeof window.cleanupHighlights !== 'function') {{
                                // Store all active highlight animations
                                window.activeHighlights = window.activeHighlights || new Map();
                        
                                // Global cleanup function that can be called to clear all highlights
                                window.cleanupHighlights = function() {{
                                    if (window.activeHighlights) {{
                                        window.activeHighlights.forEach((timerId, element) => {{
                                            clearTimeout(timerId);
                                            element.classList.remove('annotation-highlight');
                                            element.classList.remove('annotation-highlight-fadeout');
                                            element.style.boxShadow = '';
                                        }});
                                        window.activeHighlights.clear();
                                    }}
                                }};
                        
                                // Add the CSS for our highlight animation if not already present
                                if (!document.getElementById('highlight-animation-styles')) {{
                                    const style = document.createElement('style');
                                    style.id = 'highlight-animation-styles';
                                    style.textContent = `
                                        .annotation-highlight {{
                                            transition: box-shadow 0.5s ease-in-out;
                                        }}
                                        .annotation-highlight-fadeout {{
                                            box-shadow: none !important;
                                            transition: box-shadow 0.5s ease-out !important;
                                        }}
                                    `;
                                    document.head.appendChild(style);
                                }}
                            }}

                            // Helper function to get true complementary color using proper color theory
                            function getComplementaryColor(color) {{
                                console.log("Getting complementary color for:", color);
                        
                                // Extract RGB components
                                let r, g, b;
                        
                                try {{
                                    // Handle rgba or rgb format
                                    const rgbMatch = color.match(/rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([\\d.]+)\\s*)?\\)/i);
                                    if (rgbMatch) {{
                                        r = parseInt(rgbMatch[1], 10);
                                        g = parseInt(rgbMatch[2], 10);
                                        b = parseInt(rgbMatch[3], 10);
                                    }}
                                    // Handle hex format
                                    else if (color.match(/#[0-9a-f]{{3,6}}/i)) {{
                                        let hex = color.replace(/^#/, '');
                                        if (hex.length === 3) {{
                                            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                                        }}
                                        r = parseInt(hex.substring(0, 2), 16);
                                        g = parseInt(hex.substring(2, 4), 16);
                                        b = parseInt(hex.substring(4, 6), 16);
                                    }}
                                    // Handle color names
                                    else {{
                                        const colorMap = {{
                                            'yellow': [255, 255, 0], 'lightyellow': [255, 255, 224], 'gold': [255, 215, 0],
                                            'orange': [255, 165, 0], 'red': [255, 0, 0], 'pink': [255, 192, 203],
                                            'purple': [128, 0, 128], 'blue': [0, 0, 255], 'lightblue': [173, 216, 230],
                                            'green': [0, 128, 0], 'lightgreen': [144, 238, 144], 'white': [255, 255, 255],
                                            'black': [0, 0, 0], 'gray': [128, 128, 128], 'brown': [165, 42, 42]
                                        }};
                                        const lowerColor = color.toLowerCase();
                                        for (const [name, rgb] of Object.entries(colorMap)) {{
                                            if (lowerColor.includes(name)) {{
                                                [r, g, b] = rgb;
                                                break;
                                            }}
                                        }}
                                        if (r === undefined) {{
                                            [r, g, b] = [255, 255, 240]; // Default to light yellow
                                        }}
                                    }}
                            
                                    // Convert RGB to HSL
                                    function rgbToHsl(r, g, b) {{
                                        r /= 255; g /= 255; b /= 255;
                                        const max = Math.max(r, g, b);
                                        const min = Math.min(r, g, b);
                                        let h, s, l = (max + min) / 2;
                            
                                        if (max === min) {{
                                            h = s = 0; // achromatic
                                        }} else {{
                                            const d = max - min;
                                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                                            switch (max) {{
                                                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                                                case g: h = (b - r) / d + 2; break;
                                                case b: h = (r - g) / d + 4; break;
                                            }}
                                            h /= 6;
                                        }}
                                        return [h * 360, s, l];
                                    }}
                            
                                    // Convert HSL to RGB
                                    function hslToRgb(h, s, l) {{
                                        h /= 360;
                                        function hue2rgb(p, q, t) {{
                                            if (t < 0) t += 1;
                                            if (t > 1) t -= 1;
                                            if (t < 1/6) return p + (q - p) * 6 * t;
                                            if (t < 1/2) return q;
                                            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                                            return p;
                                        }}
                            
                                        if (s === 0) {{
                                            r = g = b = l; // achromatic
                                        }} else {{
                                            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                                            const p = 2 * l - q;
                                            r = hue2rgb(p, q, h + 1/3);
                                            g = hue2rgb(p, q, h);
                                            b = hue2rgb(p, q, h - 1/3);
                                        }}
                                        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
                                    }}
                            
                                    if (r !== undefined && g !== undefined && b !== undefined) {{
                                        console.log("Original RGB:", r, g, b);
                                        
                                        // Convert to HSL
                                        const [h, s, l] = rgbToHsl(r, g, b);
                                        console.log("HSL:", h, s, l);
                                        
                                        // Calculate complementary hue (opposite on color wheel)
                                        let compHue = (h + 180) % 360;
                                        
                                        // Enhance saturation and adjust lightness for better visibility
                                        let compSat = Math.min(1, s + 0.2); // Boost saturation slightly
                                        let compLight = l < 0.5 ? Math.min(0.7, l + 0.3) : Math.max(0.3, l - 0.3); // Ensure good contrast
                                        
                                        // Convert back to RGB
                                        const [compR, compG, compB] = hslToRgb(compHue, compSat, compLight);
                                        console.log("Complementary RGB:", compR, compG, compB);
                                        
                                        return `rgba(${{compR}}, ${{compG}}, ${{compB}}, 0.9)`;
                                    }}
                                }} catch (e) {{
                                    console.error("Error calculating complementary color:", e);
                                }}
                        
                                // Fallback to vibrant blue
                                return 'rgba(0, 100, 255, 0.9)';
                            }}

                            // Clean up any existing animations before starting new ones
                            window.cleanupHighlights();

                            var targetSpans = scrollToText();
                            if (targetSpans.length > 0) {{
                                console.log("scroll_to_annotation: Scrolling to first matching span.");
                                targetSpans[0].scrollIntoView({{ behavior: 'smooth', block: 'center' }});
                        
                                targetSpans.forEach(function(span) {{
                                    // Get the background color and calculate complementary color
                                    const bgColor = window.getComputedStyle(span).backgroundColor;
                                    const compColor = getComplementaryColor(bgColor);
                                    console.log("Background color:", bgColor, "Complementary color:", compColor);
                            
                                    // Apply highlight with complementary color
                                    span.classList.add('annotation-highlight');
                                    span.style.boxShadow = `0 0 10px 3px ${{compColor}}`; // Increased shadow size and spread
                            
                                    // Set a timeout to start fading out
                                    const fadeStartTime = setTimeout(() => {{
                                        // Add the fadeout class
                                        span.classList.add('annotation-highlight-fadeout');
                                
                                        // Set another timeout to completely clean up after fade completes
                                        const fadeEndTime = setTimeout(() => {{
                                            span.classList.remove('annotation-highlight');
                                            span.classList.remove('annotation-highlight-fadeout');
                                            span.style.boxShadow = '';
                                            window.activeHighlights.delete(span);
                                        }}, 600); // slightly longer than transition time to ensure it completes
                                
                                        // Update the timer ID in our map
                                        window.activeHighlights.set(span, fadeEndTime);
                                    }}, 1000);
                            
                                    // Store the initial animation timer in our tracking map
                                    window.activeHighlights.set(span, fadeStartTime);
                                }});
                            }} else {{
                                console.warn("scroll_to_annotation: No matching annotation span found.");
                            }}
                            }})(); // Close the IIFE
                        '''
                        main_window.web_view.page().runJavaScript(js_code)
                    else:
                        print("scroll_to_annotation: No matching annotation found for text:", text)
                else:
                    print("scroll_to_annotation: Main window is not an instance of ScriptoriaMain.")
            else:
                print("scroll_to_annotation: No QLabel found in the item widget.")
        else:
            print("scroll_to_annotation: No widget found for the given item.")

    def show_context_menu(self, position):
        menu = QMenu()
        menu.setStyleSheet("""
            QMenu {
                background-color: white;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 8px 24px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #e3f2fd;
                color: #2C4952;
            }
            QMenu::separator {
                height: 1px;
                background: #e0e0e0;
                margin: 4px 0;
            }
        """)

        if self.selectedItems():
            # Add "Find in Storyboard" option for single selection only
            if len(self.selectedItems()) == 1:
                selected_item = self.selectedItems()[0]
                annotation_id = selected_item.data(Qt.ItemDataRole.UserRole)
                
                # Check if annotation exists in storyboard (has order field)
                if self._annotation_exists_in_storyboard(annotation_id):
                    find_storyboard_action = menu.addAction("📋 Find in Storyboard")
                    find_storyboard_action.triggered.connect(lambda: self._navigate_to_storyboard(annotation_id))
                    menu.addSeparator()
            
            delete_action = menu.addAction("Delete Annotation")
            delete_action.triggered.connect(self.delete_selected_annotations)
            
            if len(self.selectedItems()) > 1:
                delete_action.setText(f"Delete Selected ({len(self.selectedItems())} items)")

        if not menu.isEmpty():
            menu.exec(self.mapToGlobal(position))

    def _annotation_exists_in_storyboard(self, annotation_id):
        """Check if annotation exists in storyboard (has order field)"""
        try:
            # Get main window
            main_window = self.window()
            while main_window and not hasattr(main_window, 'web_view'):
                main_window = main_window.parent()
            
            if not main_window or not hasattr(main_window, 'web_view'):
                return False
            
            # Find annotation and check if it has order field
            if hasattr(main_window.web_view, 'annotations'):
                for annotation in main_window.web_view.annotations:
                    if annotation.get('id') == annotation_id:
                        has_order = 'order' in annotation and annotation.get('order') is not None
                        return has_order
            
            return False
        except Exception as e:
            print(f"Error checking annotation in storyboard: {e}")
            return False

    def _navigate_to_storyboard(self, annotation_id):
        """Navigate to annotation in storyboard"""
        try:
            # Get main window
            main_window = self.window()
            while main_window and not hasattr(main_window, 'handle_storyboard_navigation'):
                main_window = main_window.parent()
            
            if main_window and hasattr(main_window, 'handle_storyboard_navigation'):
                print(f"Navigating to annotation {annotation_id} in storyboard from theme view")
                main_window.handle_storyboard_navigation(annotation_id)
            else:
                print("Could not find main window with storyboard navigation capability")
                QMessageBox.warning(self, "Navigation Error", 
                                  "Could not navigate to storyboard. Main window not found.")
                
        except Exception as e:
            print(f"Error navigating to storyboard from theme view: {e}")
            QMessageBox.warning(self, "Navigation Error", 
                              f"Could not navigate to storyboard: {str(e)}")

    def delete_selected_annotations(self):
        """Delete selected annotations and conditionally refresh the storyboard."""
        # Store current scroll position
        current_scroll = self.verticalScrollBar().value()

        # Get selected items and validate main window
        selected_items = self.selectedItems()
        if not selected_items:
            return

        main_window = self.window()
        if not isinstance(main_window, ScriptoriaMain):
            return

        # Look up the storyboard dialog once
        storyboard_dialog = getattr(main_window, 'storyboard_dialog', None)

        # Track whether at least one annotation had 'order'
        had_order_any = False

        for item in selected_items:
            # Get annotation ID directly from item data
            annotation_id = item.data(Qt.ItemDataRole.UserRole)
            if not annotation_id:
                continue

            # Find the annotation in the main window's annotations
            annotation = next(
                (anno for anno in main_window.web_view.annotations if anno.get('id') == annotation_id),
                None
            )

            if annotation:
                # Check if annotation has an 'order'
                if annotation.get('order') is not None:
                    had_order_any = True  # We'll refresh storyboard later

                # Remove the annotation from your main data structure
                main_window.web_view.annotations.remove(annotation)

                # Remove item from the list widget
                self.takeItem(self.row(item))

                # Optionally remove highlight from the web view
                js_code = f'''
                    function removeAnnotation() {{
                        var spans = document.querySelectorAll('span[data-annotation-id="{annotation_id}"]');
                        spans.forEach(function(span) {{
                            var textNode = document.createTextNode(span.textContent);
                            span.parentNode.replaceChild(textNode, span);
                        }});
                        return true;
                    }}
                    removeAnnotation();
                '''
                main_window.web_view.page().runJavaScript(js_code)

                # Mark changes pending
                main_window.mark_changes_pending()

        # 1. If at least one annotation had an order, refresh the storyboard
        if had_order_any and storyboard_dialog:
            storyboard_dialog.populate_order_list_skip_partial_fallback()

        # 2. If list widget is now empty, mirror remove_highlight path: remove the empty tab and show overlay if last
        if self.count() == 0:
            try:
                # Remove this tab from the tab widget
                tab_index = main_window.scene_tabs.indexOf(self)
                if tab_index != -1:
                    main_window.scene_tabs.removeTab(tab_index)
                    print(f"[DEBUG] Removed empty tab from theme view (context menu)")

                # If that was the last tab, show the empty-state overlay immediately
                if main_window.scene_tabs.count() == 0 and hasattr(main_window, 'script_search') and main_window.script_search:
                    main_window.script_search._update_placeholder_overlay(0)
            except Exception as _e:
                print(f"[DEBUG] Error removing empty tab / showing overlay after delete: {_e}")

        # Restore scroll position
        self.verticalScrollBar().setValue(current_scroll)



    def handle_highlight_removal_complete(self, success, deletion_info, main_window):
        """Handle completion of highlight removal."""
        if success:
            # Remove annotation from data structure
            for anno in list(main_window.web_view.annotations):
                if anno.get('id') == deletion_info.get('id'):
                    # Enhance deletion_info with complete annotation data
                    deletion_info.update({
                        'scene': anno.get('scene', ''),
                        'text': anno.get('text', ''),
                        'notes': anno.get('notes', ''),
                        'notes_html': anno.get('notes_html', ''),
                        'used': anno.get('used', False),
                        'favorite': anno.get('favorite', False),
                        'tags': anno.get('tags', []),
                        'secondary_scenes': anno.get('secondary_scenes', []),
                        'speech_title': anno.get('speech_title', '')
                    })
                    main_window.web_view.annotations.remove(anno)
                    break

            # Emit deletion signal with complete annotation info
            main_window.web_view.annotation_deleted.emit(json.dumps(deletion_info))
            main_window.web_view.scenes_updated.emit()
            main_window.status_bar.showMessage("Annotation removed successfully", 5000)
            #main_window.web_view.page().toHtml(main_window.update_preview_content)
        else:
            main_window.status_bar.showMessage("Failed to remove highlight", 5000) # -- this is the theme panel

    def startDrag(self, supportedActions):
        """Override startDrag to enable custom drag pixmap and Alt+drag for external copy behavior"""
        print("\n=== ANNOTATION START DRAG EVENT ===")
        
        # Check if Alt key is held down
        modifiers = QApplication.keyboardModifiers()
        is_alt_drag = modifiers & Qt.KeyboardModifier.AltModifier
        print(f"Alt key held: {is_alt_drag}")
        
        if is_alt_drag:
            print("*** ALT+DRAG DETECTED - Using CUSTOM drag system ***")
            
            # Store Copy Caption text for external use
            current_item = self.currentItem()
            copy_caption_text = ""
            if current_item:
                widget = self.itemWidget(current_item)
                if widget:
                    main_label = widget.findChild(QLabel, "main_content_label")
                    if main_label:
                        raw_text = main_label.text()
                        print(f"DEBUG ALT: Raw label text: '{raw_text[:100]}...'")
                        copy_caption_text = self.smart_copy_text(raw_text)
                        print(f"DEBUG ALT: Smart copy result: '{copy_caption_text}'")
                        print(f"Prepared Copy Caption text: {copy_caption_text[:50]}...")
            
            # Start custom drag system (bypasses Qt drag entirely)
            self._start_custom_drag(copy_caption_text)
            return  # Don't call super().startDrag()
            
        else:
            print("*** NORMAL DRAG - Custom drag with text preview and drop indicators ***")
            
            # Get the current selected items
            selected_items = self.selectedItems()
            if not selected_items:
                return
            
            # Create drag object and mime data
            drag = QDrag(self)
            mimeData = self.mimeData(selected_items)
            drag.setMimeData(mimeData)
            
            # Get text for custom pixmap
            current_item = selected_items[0]
            drag_text = ""
            
            if current_item:
                widget = self.itemWidget(current_item)
                if widget:
                    # Get annotation text
                    main_label = widget.findChild(QLabel, "main_content_label")
                    if main_label:
                        drag_text = self.extract_clean_text_for_display(main_label.text())
                        print(f"Annotation drag text: {drag_text[:30]}...")
                    else:
                        # Fallback: try to get any label with text
                        all_labels = widget.findChildren(QLabel)
                        for label in all_labels:
                            if label.text().strip():
                                print(f"Using fallback label for drag text")
                                drag_text = self.extract_clean_text_for_display(label.text())
                                break
            
            # Set custom pixmap with text preview - DEBUG VERSION
            if drag_text:
                print(f"About to create pixmap with text: '{drag_text}'")
                self.create_normal_drag_pixmap(drag, drag_text)
                print(f"Finished creating pixmap, drag object pixmap null: {drag.pixmap().isNull()}")
            else:
                print("WARNING: No drag text found for pixmap!")
            
            # Enable custom drop indicators during drag
            self._custom_drop_indicators_active = True
            
            # Execute drag with custom drop indicator handling
            result = drag.exec(supportedActions)
            
            # Disable custom drop indicators
            self._custom_drop_indicators_active = False
            self.update()  # Clear any remaining indicators
            print(f"Drag completed with result: {result}")
        
        print("=== ANNOTATION START DRAG EVENT END ===\n")

    def create_normal_drag_pixmap(self, drag, annotation_text):
        """Create fixed-size text preview pixmap for annotation drag operations"""
        try:
            # Ensure text is exactly 60 characters (or show full text if shorter)
            preview_text = annotation_text[:60]
            if len(annotation_text) > 60:
                preview_text += "..."
            if not preview_text:
                preview_text = "Annotation"
            
            # Create a pixmap for annotation - EXACT SAME SIZE AS OrderListWidget
            pixmap = QPixmap(350, 28)  # Same as OrderListWidget
            pixmap.fill(Qt.GlobalColor.transparent)
            
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw a subtle background for annotation drag - EXACT SAME AS OrderListWidget
            painter.setPen(QPen(QColor(120, 120, 120), 1))
            painter.setBrush(QColor(245, 245, 245, 220))
            painter.drawRoundedRect(2, 2, 346, 24, 4, 4)  # Same as OrderListWidget
            
            # Add a small reorder icon (≡ hamburger) at the start - EXACT SAME AS OrderListWidget
            painter.setPen(QPen(QColor(80, 80, 80), 2))
            painter.drawLine(8, 9, 16, 9)
            painter.drawLine(8, 14, 16, 14)
            painter.drawLine(8, 19, 16, 19)
            
            # Draw the text preview with eliding if too long - EXACT SAME AS OrderListWidget
            painter.setPen(QColor(40, 40, 40))
            painter.setFont(QFont("Arial", 8, QFont.Weight.Normal))
            
            # Calculate available width for text - EXACT SAME AS OrderListWidget
            text_start_x = 22  # Same as OrderListWidget
            available_width = 346 - text_start_x - 5  # Same calculation as OrderListWidget
            font_metrics = QFontMetrics(painter.font())
            elided_text = font_metrics.elidedText(preview_text, Qt.TextElideMode.ElideRight, available_width)
            
            painter.drawText(text_start_x, 17, elided_text)
            
            painter.end()
            
            # Set pixmap with appropriate hot spot - EXACT SAME AS OrderListWidget
            drag.setPixmap(pixmap)
            drag.setHotSpot(QPoint(15, 14))
            print(f"Created annotation drag pixmap (350x28): {elided_text}")
            
        except Exception as e:
            print(f"Error creating annotation drag pixmap: {e}")

    def extract_clean_text_for_display(self, label_text):
        """Extract clean text for display in drag pixmaps"""
        import re
        
        # Remove strikethrough text (anything inside <s> tags)
        text_without_strikethrough = re.sub(r'<s[^>]*>.*?</s>', '', label_text, flags=re.DOTALL)
        
        # Remove headers (h1-h6 tags) and their content
        text_without_headers = re.sub(r'<h[1-6][^>]*>.*?</h[1-6]>', '', text_without_strikethrough, flags=re.DOTALL)
        
        # Remove all HTML tags
        plain_text = re.sub(r'<[^>]*>', '', text_without_headers)
        
        # Strip leading/trailing whitespace
        return plain_text.strip()

    def smart_copy_text(self, label_text):
        """Smart text extraction with cleaner tab matching logic."""
        # Extract clean text using existing logic
        clean_text = self.extract_clean_text_for_display(label_text)
        
        # Get cleaner tab text
        cleaner_text = self.get_cleaner_tab_text()
        
        # If no cleaner text, return first 25 chars as fallback
        if not cleaner_text:
            return clean_text[:25] if clean_text else ""
        
        # Split cleaner text into lines
        cleaner_lines = [line.strip() for line in cleaner_text.splitlines() if line.strip()]
        
        # Try 25-character matching
        segments_25 = self.extract_text_segments(clean_text, 25)
        for segment in segments_25:
            if self.find_text_on_single_line(segment, cleaner_lines):
                return segment
        
        # Fallback to 8-character matching
        segments_8 = self.extract_text_segments(clean_text, 8)
        for segment in segments_8:
            if self.find_text_on_single_line(segment, cleaner_lines):
                return segment
        
        # Final fallback: first 25 characters
        return clean_text[:25] if clean_text else ""

    def get_cleaner_tab_text(self):
        """Get the text from the cleaner tab's 'Cleaned Text Without Timecodes' section."""
        # Get main window reference
        main_window = self.window()
        while main_window and not hasattr(main_window, 'cleaner_output_text'):
            main_window = main_window.parent()
        
        if not main_window:
            return ""
        
        try:
            cleaner_text = main_window.cleaner_output_text.toPlainText().strip()
            return cleaner_text
        except AttributeError:
            return ""

    def find_text_on_single_line(self, search_text, cleaner_lines):
        """Check if search_text exists as a continuous string on any single line."""
        if not search_text or not cleaner_lines:
            return False
        
        for line in cleaner_lines:
            line_clean = line.strip()
            if search_text in line_clean:
                return True
        return False

    def extract_text_segments(self, clean_text, char_count):
        """Extract sequential text segments of specified character count."""
        segments = []
        if len(clean_text) < char_count:
            return [clean_text] if clean_text else []
        
        for i in range(len(clean_text) - char_count + 1):
            segment = clean_text[i:i + char_count].strip()
            if segment and len(segment) >= char_count - 2:  # Allow slight tolerance
                segments.append(segment)
        
        return segments

    def _start_custom_drag(self, copy_caption_text):
        """Start custom drag system that bypasses Qt entirely"""
        print("Starting custom drag system...")
        
        # Cancel any pending timers from previous operations
        if hasattr(self, '_pending_timers'):
            for timer in self._pending_timers:
                if timer.isActive():
                    timer.stop()
        self._pending_timers = []
        
        # Set custom drag state
        self._custom_drag_active = True
        self._custom_drag_text = copy_caption_text
        
        # Create the drag overlay window
        self._create_drag_overlay(copy_caption_text)
        
        # Hide normal cursor and start tracking
        self.setCursor(Qt.CursorShape.BlankCursor)
        self.setMouseTracking(True)
        
        # Use application-wide event filter instead of grabMouse
        QApplication.instance().installEventFilter(self)
        print("Installed application event filter for custom drag")
        
        print("Custom drag system activated")
    
    def _create_drag_overlay(self, copy_caption_text):
        """Create floating overlay window with drag pixmap"""
        try:
            # Create borderless overlay window
            self._drag_overlay = QWidget()
            self._drag_overlay.setWindowFlags(
                Qt.WindowType.FramelessWindowHint | 
                Qt.WindowType.WindowStaysOnTopHint |
                Qt.WindowType.Tool
            )
            self._drag_overlay.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
            self._drag_overlay.setFixedSize(220, 35)
            
            # Create pixmap for the overlay
            preview_text = copy_caption_text[:30] + "..." if len(copy_caption_text) > 30 else copy_caption_text
            
            pixmap = QPixmap(220, 35)
            pixmap.fill(Qt.GlobalColor.transparent)
            
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw a nice rounded background
            painter.setPen(QPen(QColor(100, 100, 100), 1))
            painter.setBrush(QColor(255, 255, 255, 240))
            painter.drawRoundedRect(2, 2, 216, 31, 5, 5)
            
            # Add "ALT" indicator in corner
            painter.setPen(QPen(QColor(0, 120, 0), 1))
            painter.setFont(QFont("Arial", 7, QFont.Weight.Bold))
            painter.drawText(QRect(190, 5, 25, 12), Qt.AlignmentFlag.AlignCenter, "ALT")
            
            # Add a small document icon
            painter.setPen(QPen(QColor(50, 50, 50), 1))
            painter.drawRect(8, 8, 12, 16)
            painter.drawLine(16, 8, 16, 12)
            painter.drawLine(16, 12, 20, 12)
            
            # Draw the text preview
            painter.setPen(QColor(20, 20, 20))
            painter.setFont(QFont("Arial", 9, QFont.Weight.Normal))
            painter.drawText(25, 20, preview_text)
            
            painter.end()
            
            # Set pixmap as overlay background
            label = QLabel(self._drag_overlay)
            label.setPixmap(pixmap)
            label.setGeometry(0, 0, 220, 35)
            
            # Position overlay at cursor
            cursor_pos = QCursor.pos()
            self._drag_overlay.move(cursor_pos.x() - 15, cursor_pos.y() - 17)
            self._drag_overlay.show()
            
            print(f"Created custom drag overlay with text: {preview_text}")
            
        except Exception as e:
            print(f"Error creating drag overlay: {e}")
    
    def mouseMoveEvent(self, event):
        """Override mouse move to handle custom drag"""
        if hasattr(self, '_custom_drag_active') and self._custom_drag_active:
            # Update overlay position
            if hasattr(self, '_drag_overlay') and self._drag_overlay:
                global_pos = self.mapToGlobal(event.pos())
                self._drag_overlay.move(global_pos.x() - 15, global_pos.y() - 17)
            return  # Don't call super() for custom drag
        
        # Normal mouse move behavior
        super().mouseMoveEvent(event)
    
    def mouseReleaseEvent(self, event):
        """Override mouse release to handle custom drag end"""
        if hasattr(self, '_custom_drag_active') and self._custom_drag_active:
            print("Custom drag ended - triggering paste")
            
            # Trigger Windows paste to whatever is under cursor
            if hasattr(self, '_custom_drag_text') and self._custom_drag_text:
                self.trigger_windows_paste(self._custom_drag_text)
            
            # Clean up custom drag
            self._cleanup_custom_drag()
            return  # Don't call super() for custom drag
        
        # Normal mouse release behavior
        super().mouseReleaseEvent(event)
    
    def _cleanup_custom_drag(self):
        """Clean up custom drag state and overlay"""
        print("Cleaning up custom drag system...")
        
        # Remove overlay window
        if hasattr(self, '_drag_overlay') and self._drag_overlay:
            self._drag_overlay.hide()
            self._drag_overlay.deleteLater()
            self._drag_overlay = None
        
        # Restore normal state
        if hasattr(self, '_custom_drag_active'):
            self._custom_drag_active = False
        if hasattr(self, '_custom_drag_text'):
            self._custom_drag_text = ""
        
        # Restore normal cursor and mouse tracking
        self.setCursor(Qt.CursorShape.ArrowCursor)
        self.setMouseTracking(False)
        
        # Remove application event filter
        QApplication.instance().removeEventFilter(self)
        print("Removed application event filter")
        
        print("Custom drag cleanup complete")

    def eventFilter(self, obj, event):
        """Application-wide event filter for custom drag system"""
        if hasattr(self, '_custom_drag_active') and self._custom_drag_active:
            if event.type() == QEvent.Type.MouseMove:
                # Update overlay position based on global cursor
                if hasattr(self, '_drag_overlay') and self._drag_overlay:
                    cursor_pos = QCursor.pos()
                    self._drag_overlay.move(cursor_pos.x() - 15, cursor_pos.y() - 17)
                return True  # Event handled
                
            elif event.type() == QEvent.Type.MouseButtonRelease:
                if event.button() == Qt.MouseButton.LeftButton:
                    print("Custom drag ended via event filter - triggering paste")
                    
                    # Trigger Windows paste to whatever is under cursor
                    if hasattr(self, '_custom_drag_text') and self._custom_drag_text:
                        # Small delay to ensure target window is ready
                        drag_text = self._custom_drag_text  # Capture in local variable
                        QTimer.singleShot(50, lambda: self.trigger_windows_paste(drag_text))
                    
                    # Clean up custom drag
                    self._cleanup_custom_drag()
                    return True  # Event handled
        
        # Let other events through normally
        return super().eventFilter(obj, event)

    def trigger_windows_paste(self, text):
        """Copy text to clipboard and send Ctrl+V to Windows"""
        try:
            import ctypes
            from ctypes import wintypes
            
            
            # Copy text to Windows clipboard
            QApplication.clipboard().setText(text)
            print(f"Copied to clipboard: {text[:50]}...")
            
            # Small delay to ensure clipboard is ready
            QTimer.singleShot(50, lambda: self.send_ctrl_v_from_trigger())
            
        except Exception as e:
            print(f"Error in trigger_windows_paste: {e}")
    
    def send_ctrl_v_from_trigger(self):
        """Send Ctrl+V keystroke to window under cursor on Windows"""
        try:
            import ctypes
            from ctypes import wintypes
            
            # Windows API constants
            KEYEVENTF_KEYUP = 0x0002
            VK_CONTROL = 0x11
            VK_V = 0x56
            
            # Get Windows API functions
            user32 = ctypes.windll.user32
            
            # Get cursor position
            cursor_pos = QCursor.pos()
            print(f"Cursor position: {cursor_pos.x()}, {cursor_pos.y()}")
            
            # Get window under cursor
            point = wintypes.POINT(cursor_pos.x(), cursor_pos.y())
            hwnd = user32.WindowFromPoint(point)
            
            if hwnd:
                print(f"Found window handle: {hwnd}")
                
                # Get window title for debugging
                window_title = ctypes.create_unicode_buffer(256)
                user32.GetWindowTextW(hwnd, window_title, 256)
                print(f"Target window: {window_title.value}")
                
                # First click on the window to ensure focus
                print("Clicking on target window to ensure focus...")
                user32.SetCursorPos(cursor_pos.x(), cursor_pos.y())
                user32.mouse_event(0x0002, 0, 0, 0, 0)  # MOUSEEVENTF_LEFTDOWN
                user32.mouse_event(0x0004, 0, 0, 0, 0)  # MOUSEEVENTF_LEFTUP
                
                # Set focus to the window under cursor
                user32.SetForegroundWindow(hwnd)
                
                # Reduced delay after click and focus
                QTimer.singleShot(50, lambda h=hwnd: self.send_keystrokes(h))
            else:
                print("No window found under cursor")
                
        except Exception as e:
            print(f"Error in send_ctrl_v: {e}")
    
    def send_keystrokes(self, hwnd):
        """Send Ctrl+Shift+F, Ctrl+A, then Ctrl+V sequence"""
        try:
            import ctypes
            
            # Windows API constants
            KEYEVENTF_KEYUP = 0x0002
            VK_CONTROL = 0x11
            VK_SHIFT = 0x10
            VK_F = 0x46
            
            user32 = ctypes.windll.user32
            
            # Send Ctrl+Shift+F to open find/search
            print("Sending Ctrl+Shift+F (open find/search)...")
            user32.keybd_event(VK_CONTROL, 0, 0, 0)          # Press Ctrl
            user32.keybd_event(VK_SHIFT, 0, 0, 0)            # Press Shift
            user32.keybd_event(VK_F, 0, 0, 0)                # Press F
            user32.keybd_event(VK_F, 0, KEYEVENTF_KEYUP, 0)  # Release F
            user32.keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0)  # Release Shift
            user32.keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0)  # Release Ctrl
            print("Ctrl+Shift+F sent, waiting for search dialog...")
            
            # Wait for search box to open and focus
            QTimer.singleShot(50, lambda h=hwnd: self.send_ctrl_a(h))
            
        except Exception as e:
            print(f"Error sending Ctrl+Shift+F: {e}")
    
    def send_ctrl_a(self, hwnd):
        """Send Ctrl+A to select all in search box"""
        try:
            import ctypes
            
            KEYEVENTF_KEYUP = 0x0002
            VK_CONTROL = 0x11
            VK_A = 0x41
            
            user32 = ctypes.windll.user32
            
            # Send Ctrl+A
            print("Sending Ctrl+A (select all)...")
            user32.keybd_event(VK_CONTROL, 0, 0, 0)          # Press Ctrl
            user32.keybd_event(VK_A, 0, 0, 0)                # Press A
            user32.keybd_event(VK_A, 0, KEYEVENTF_KEYUP, 0)  # Release A
            user32.keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0)  # Release Ctrl
            print("Ctrl+A sent, waiting before paste...")
            
            # Wait before sending Ctrl+V
            QTimer.singleShot(50, lambda h=hwnd: self.send_ctrl_v_final(h))
            
        except Exception as e:
            print(f"Error sending Ctrl+A: {e}")
    
    def send_ctrl_v_final(self, hwnd):
        """Send final Ctrl+V to paste"""
        try:
            import ctypes
            
            KEYEVENTF_KEYUP = 0x0002
            VK_CONTROL = 0x11
            VK_V = 0x56
            
            user32 = ctypes.windll.user32
            
            # Send Ctrl+V
            print("Sending Ctrl+V (paste)...")
            user32.keybd_event(VK_CONTROL, 0, 0, 0)          # Press Ctrl
            user32.keybd_event(VK_V, 0, 0, 0)                # Press V
            user32.keybd_event(VK_V, 0, KEYEVENTF_KEYUP, 0)  # Release V
            user32.keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0)  # Release Ctrl
            print(f"Ctrl+V sent to window handle: {hwnd}")
            print("Keystroke sequence complete!")
            
        except Exception as e:
            print(f"Error sending Ctrl+V: {e}")

    def paintEvent(self, event):
        """Override paint event to draw custom drop indicators"""
        # First draw the normal widget
        super().paintEvent(event)
        
        # Then draw custom drop indicator if active
        if (hasattr(self, '_custom_drop_indicators_active') and 
            self._custom_drop_indicators_active and
            hasattr(self, '_drop_indicator_y')):
            
            painter = QPainter(self.viewport())
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw a blue line to indicate drop position
            painter.setPen(QPen(QColor(0, 120, 215), 2))  # Blue line
            viewport_rect = self.viewport().rect()
            y = self._drop_indicator_y
            
            # Draw the drop line across the width
            painter.drawLine(5, y, viewport_rect.width() - 5, y)
            
            # Draw small triangles at the ends
            painter.setBrush(QColor(0, 120, 215))
            
            # Left triangle
            left_triangle = [
                QPoint(5, y - 3),
                QPoint(5, y + 3),
                QPoint(11, y)
            ]
            painter.drawPolygon(left_triangle)
            
            # Right triangle
            right_triangle = [
                QPoint(viewport_rect.width() - 5, y - 3),
                QPoint(viewport_rect.width() - 5, y + 3),
                QPoint(viewport_rect.width() - 11, y)
            ]
            painter.drawPolygon(right_triangle)
            
            painter.end()

    def dragMoveEvent(self, event):
        """Handle drag move events with drop indicators"""
        print("\n=== ANNOTATION DRAG MOVE EVENT START ===")
    
        # Check if this is an internal drag or external drag with valid data
        source_widget = event.source()
        is_internal = source_widget == self
        
        # Check for valid MIME data
        has_valid_mime = False
        if event.mimeData():
            has_valid_mime = (event.mimeData().hasFormat("application/x-annotation-id") or
                            event.mimeData().hasText())
        
        print(f"Internal drag: {is_internal}, Valid MIME: {has_valid_mime}")
        
        if is_internal or has_valid_mime:
            # Accept the event
            event.acceptProposedAction()
            
            # If custom drop indicators are active, draw them manually
            if hasattr(self, '_custom_drop_indicators_active') and self._custom_drop_indicators_active:
                self._draw_custom_drop_indicator(event.position().toPoint())
            else:
                # Use Qt's default behavior
                super().dragMoveEvent(event)
        else:
            event.ignore()
        
        print("=== ANNOTATION DRAG MOVE EVENT END ===\n")

    def _draw_custom_drop_indicator(self, pos):
        """Draw custom drop indicator at the specified position"""
        try:
            # Find the item at the drop position
            drop_item = self.itemAt(pos)
            drop_index = -1
            
            if drop_item:
                drop_index = self.row(drop_item)
                item_rect = self.visualItemRect(drop_item)
                
                # Determine insertion index based on position
                if pos.y() < item_rect.center().y():
                    # Will insert before this item (drop_index stays same)
                    insertion_index = drop_index
                else:
                    # Will insert after this item
                    insertion_index = drop_index + 1
                
                # ALWAYS show indicator at bottom of the item that will be ABOVE the insertion
                if insertion_index == 0:
                    # Inserting at very beginning - show at top of first item (only exception)
                    self._drop_indicator_y = item_rect.top()
                else:
                    # Show at bottom of the item that will be above the insertion point
                    above_item = self.item(insertion_index - 1)
                    above_rect = self.visualItemRect(above_item)
                    self._drop_indicator_y = above_rect.bottom()
                
                drop_index = insertion_index
            else:
                # No item at drop position - find the correct position based on Y coordinate
                drop_index = self.count()  # Default to end
                
                if self.count() > 0:
                    # Find the correct insertion point based on Y position
                    insertion_index = self.count()  # Default to end
                    
                    for i in range(self.count()):
                        item = self.item(i)
                        item_rect = self.visualItemRect(item)
                        
                        if pos.y() < item_rect.center().y():
                            # Will insert before this item
                            insertion_index = i
                            break
                    
                    # ALWAYS show indicator at bottom of the item that will be ABOVE the insertion
                    if insertion_index == 0:
                        # Inserting at very beginning - show at top of first item (only exception)
                        first_item = self.item(0)
                        first_rect = self.visualItemRect(first_item)
                        self._drop_indicator_y = first_rect.top()
                    else:
                        # Show at bottom of the item that will be above the insertion point
                        above_item = self.item(insertion_index - 1)
                        above_rect = self.visualItemRect(above_item)
                        self._drop_indicator_y = above_rect.bottom()
                    
                    drop_index = insertion_index
                else:
                    # Empty list
                    drop_index = 0
                    self._drop_indicator_y = 10
            
            # Store the drop index and trigger a repaint
            self._drop_indicator_index = drop_index
            self.update()
            
        except Exception as e:
            print(f"Error drawing custom drop indicator: {e}")


class ColoredTabBar(QTabBar):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.scene_styles = {}
        self.filtered_tabs = set()  # Track which tabs are in filtered state
        self.setDrawBase(False)
        self.setExpanding(False)  
        self.setContentsMargins(0, 0, 0, 0)  
        self.fixed_height = 33
        self.hovered_index = None  # Keep track of hovered tab for animation
        from PyQt6.QtCore import QTimer
        self.hover_effect_timer = QTimer(self)
        self.hover_effect_timer.timeout.connect(self.update)
        self.hover_effect_timer.start(15)  # Frequent refresh for smooth effect
        self.hover_width_increment = 0  # Controls hover animation expansion
        
        # Enable scroll buttons for functionality but hide them visually
        self.setUsesScrollButtons(True)
        self.setElideMode(Qt.TextElideMode.ElideNone)
        
        # Hide scroll buttons programmatically
        QTimer.singleShot(100, self.hide_scroll_buttons)

    def hide_scroll_buttons(self):
        """Hide scroll buttons programmatically"""
        try:
            from PyQt6.QtWidgets import QToolButton
            scroll_buttons = self.findChildren(QToolButton)
            print(f"DEBUG: Found {len(scroll_buttons)} scroll buttons to hide")
            
            for button in scroll_buttons:
                button.setVisible(False)
                button.hide()
                # Also set size to 0 as backup
                button.setFixedSize(0, 0)
                print(f"DEBUG: Hidden scroll button: {button}")
                
        except Exception as e:
            print(f"DEBUG: Error hiding scroll buttons - {e}")
    
    def update_scene_style(self, scene, style):
        self.scene_styles[scene] = style
        self.update()
        
    def update_scene_styles(self, styles):
        self.scene_styles = styles.copy()
        self.update()
        
    def update_tab_filter_state(self, scene_name, is_filtered):
        """Update the filtered state of a specific tab"""
        if is_filtered:
            self.filtered_tabs.add(scene_name)
        else:
            self.filtered_tabs.discard(scene_name)
        self.update()
    

    def get_color_from_style(self, style):
        match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', style)
        if match:
            return QColor(match.group(1))
        return QColor('#FFFFFF')

    def tabSizeHint(self, index):
        """Return variable tab widths based on text length while keeping the height fixed."""
        text = self.tabText(index)
        font_metrics = QFontMetrics(self.font())

        # Calculate text width with dynamic padding based on text length
        truncated_text = text if len(text) <= 20 else text[:20] + '...'
        text_width = font_metrics.horizontalAdvance(truncated_text)

        # Set reduced padding for short text and normal for longer text
        if len(text) <= 10:
            extra_padding = 4  # Less padding for shorter words
        else:
            extra_padding = 6  # More padding for longer words

        # Adjust the width dynamically based on text length
        adjusted_width = text_width + extra_padding


        # Hover effect expansion logic (if still required)
        if index == self.hovered_index:
            adjusted_width += self.hover_width_increment  

        return QSize(max(adjusted_width, 80), self.fixed_height)
    
    def minimumSizeHint(self):
        """Allow tab bar to shrink below total tab width"""
        return QSize(150, self.fixed_height)


    def enterEvent(self, event):
        """Start the hover effect."""
        self.hover_effect_timer.start()
        self.update()
        super().enterEvent(event)

    def leaveEvent(self, event):
        """Stop the hover effect when leaving the widget."""
        self.hovered_index = None
        self.hover_width_increment = 0
        self.update()
        super().leaveEvent(event)

    def mouseMoveEvent(self, event):
        """Detect tab hover and trigger animation."""
        hovered_index = self.tabAt(event.pos())
        if hovered_index != self.hovered_index:
            self.hovered_index = hovered_index
            self.hover_width_increment = 0  # Reset the expansion effect
        self.update()

    def paintEvent(self, event):
        """Custom painting with hover animations."""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        for index in range(self.count()):
            scene_name = self.tabText(index)
            
            # Truncate and manage tooltip
            truncated_text = scene_name if len(scene_name) <= 20 else scene_name[:20] + '...'
            self.setTabToolTip(index, scene_name if len(scene_name) > 20 else "")

            rect = QRectF(self.tabRect(index))
            rect.setHeight(self.fixed_height)

            # Selected/Unselected Tab Adjustments
            if self.currentIndex() == index:
                rect.adjust(0, 0, 0, 1)
            else:
                rect.adjust(0, 2, 0, 0)

            # Prepare the tab drawing path
            path = QPainterPath()
            path.addRoundedRect(rect, 4.0, 4.0)

            # Style fetching and hover brightness adjustment
            style = self.scene_styles.get(scene_name, '')
            base_color = self.get_color_from_style(style)
            if index == self.hovered_index:
                base_color = base_color.lighter(110)  # Lighten the color on hover

            # Check if this tab is in filtered state
            is_filtered = scene_name in self.filtered_tabs
            
            # Tab painting based on selection
            if self.currentIndex() == index:
                painter.setPen(Qt.PenStyle.NoPen)
                painter.setBrush(QColor('#2196F3'))  
                painter.drawPath(path)
    
                # Draw the tab content
                painter.setBrush(base_color)
                painter.drawPath(path)
    
                # Make the selection highlight wider (5px for better visibility)
                top_line = QRectF(rect.x(), rect.y(), rect.width(), 3)  # Increased from 3 to 5px
                painter.fillRect(top_line, QColor('#2196F3'))

            else:
                darker_color = QColor(base_color)
                darker_color.setAlpha(180)
                painter.setPen(QColor('#E0E0E0'))
                painter.setBrush(darker_color)
                painter.drawPath(path)
                
            # Add visual indication for filtered tabs
            if is_filtered:
                # Draw a thick border around filtered tabs
                filter_pen = QPen(QColor('#FF9800'), 3)  # Orange border, 3px thick
                filter_pen.setJoinStyle(Qt.PenJoinStyle.RoundJoin)
                painter.setPen(filter_pen)
                painter.setBrush(Qt.BrushStyle.NoBrush)
                # Draw slightly inset border for better visibility
                filter_rect = QRectF(rect.adjusted(1, 1, -1, -1))
                filter_path = QPainterPath()
                filter_path.addRoundedRect(filter_rect, 3.0, 3.0)
                painter.drawPath(filter_path)
            
            # Text adjustments
            font = self.font()
            if len(scene_name) > 10:
                font.setPointSize(font.pointSize() - 1)
            painter.setFont(font)

            # Text contrast calculation
            brightness = (base_color.red() * 299 + 
                          base_color.green() * 587 + 
                          base_color.blue() * 114) / 1000
            text_color = QColor('black') if brightness > 128 else QColor('white')
            painter.setPen(text_color)

            # Center the text inside the tab
            painter.drawText(rect, Qt.AlignmentFlag.AlignCenter, truncated_text)

class ColoredTabWidget(QTabWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        
        self.colored_tab_bar = ColoredTabBar(self)
        self.setTabBar(self.colored_tab_bar)
        
        # Add passive horizontal scrollbar that just displays scroll state
        from PyQt6.QtWidgets import QScrollBar, QHBoxLayout, QVBoxLayout, QWidget
        
        # Create scrollbar as child of this widget
        self.h_scrollbar = QScrollBar(Qt.Orientation.Horizontal, self)
        self.h_scrollbar.setFixedHeight(12)
        self.h_scrollbar.setVisible(False)  # Hidden by default
        
        # Position it manually below the tab bar
        self.h_scrollbar.move(0, 35)  # Below tab height
        
        # Connect double-click signal to filtering
        self.tabBarDoubleClicked.connect(self.handle_tab_double_click)
        
        # Connect scrollbar dragging to tab scrolling
        self.h_scrollbar.valueChanged.connect(self.on_scrollbar_moved)
        
        
        # Monitor tab bar for scroll changes without interfering
        self.colored_tab_bar.installEventFilter(self)
        
        # Simplified the stylesheet to avoid conflicts with tab spacing
        self.setStyleSheet("""
            QTabWidget::pane {
                border: 1px solid black;
                border-top: none;
                background: white;
            }
            QTabBar::tab {
                padding: 0px; /* Removed extra padding */
                margin: 0px;  /* Removed extra margin for zero spacing */
            }
            QTabWidget {
                background: transparent;
            }
            QScrollBar:horizontal {
                height: 12px;
                background: rgba(240, 240, 240, 0.9);
                border: 1px solid rgba(221, 221, 221, 0.9);
                border-radius: 6px;
            }
            QScrollBar::handle:horizontal {
                background: rgba(136, 136, 136, 0.8);
                border-radius: 5px;
                min-width: 20px;
                margin: 1px;
            }
            QScrollBar::handle:horizontal:hover {
                background: rgba(102, 102, 102, 0.9);
            }
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
                width: 0px;
            }
            QTabBar::scroller {
                width: 0px;  /* Hide the scroll buttons */
                background: transparent;
            }
            QTabBar QToolButton {
                width: 0px;  /* Hide scroll button tools */
                height: 0px;
                max-width: 0px;
                max-height: 0px;
                min-width: 0px; 
                min-height: 0px;
                background: transparent;
                border: none;
                margin: 0px;
                padding: 0px;
            }
            QTabBar QToolButton::left-arrow {
                width: 0px; height: 0px;
            }
            QTabBar QToolButton::right-arrow {
                width: 0px; height: 0px;
            }
        """)
    
    def eventFilter(self, source, event):
        """Monitor tab bar events and update passive scrollbar"""
        if source == self.colored_tab_bar:
            if event.type() == event.Type.Resize:
                self.update_passive_scrollbar()
        return super().eventFilter(source, event)
    
    
    def update_passive_scrollbar(self):
        """Update scrollbar to reflect current tab bar scroll state"""
        try:
            tab_bar = self.colored_tab_bar
            if not tab_bar or tab_bar.count() == 0:
                print(f"DEBUG SCROLLBAR: No tabs, hiding scrollbar")
                self.h_scrollbar.setVisible(False)
                return
                
            # Calculate total width of all tabs
            total_tab_width = 0
            for i in range(tab_bar.count()):
                total_tab_width += tab_bar.tabRect(i).width()
            
            # Get visible width
            visible_width = tab_bar.width()
            
            print(f"DEBUG SCROLLBAR: total_tab_width={total_tab_width}, visible_width={visible_width}")
            
            # Show scrollbar only if tabs exceed visible width
            if total_tab_width > visible_width:
                print(f"DEBUG SCROLLBAR: Should show scrollbar")
                
                # Position and size the scrollbar to match the tab bar
                tab_bar_rect = tab_bar.geometry()
                self.h_scrollbar.setGeometry(tab_bar_rect.x(), tab_bar_rect.bottom() + 2, tab_bar_rect.width(), 12)
                
                self.h_scrollbar.setVisible(True)
                self.h_scrollbar.show()  # Force show
                self.h_scrollbar.raise_()  # Bring to front
                
                # Calculate range based on hidden tabs
                visible_tabs = max(1, visible_width // 100)
                hidden_tabs = max(0, tab_bar.count() - visible_tabs)
                scrollbar_range = max(hidden_tabs, 5)
                
                self.h_scrollbar.setRange(0, scrollbar_range)
                
                # Read Qt's current scroll position and reflect it in scrollbar
                # Check which tab is currently selected for better positioning
                current_tab = tab_bar.currentIndex()
                selected_tab_rect = tab_bar.tabRect(current_tab)
                
                # Get the position of first tab to determine scroll offset
                first_tab_rect = tab_bar.tabRect(0)
                current_scroll_offset = abs(min(0, first_tab_rect.x()))
                
                # Calculate scrollbar position based on selected tab position and scroll state
                if current_tab == 0:
                    # First tab is selected - should be at or near scroll start
                    estimated_scroll_value = 0
                elif current_tab == tab_bar.count() - 1:
                    # Last tab is selected - check if it's fully visible
                    tab_right_edge = selected_tab_rect.right()
                    if tab_right_edge > visible_width:
                        # Last tab not fully visible - should be at scroll end
                        estimated_scroll_value = scrollbar_range
                    else:
                        # Last tab is fully visible - leave some scroll room
                        estimated_scroll_value = max(0, scrollbar_range - 2)
                else:
                    # Middle tab selected - calculate position based on scroll offset
                    # But ensure we don't go to extremes unless necessary
                    raw_scroll_value = min(scrollbar_range, current_scroll_offset // 40)
                    
                    # If selected tab is fully visible, don't go to scroll extremes
                    tab_left_edge = selected_tab_rect.left()
                    tab_right_edge = selected_tab_rect.right()
                    
                    if tab_left_edge >= 0 and tab_right_edge <= visible_width:
                        # Selected tab is fully visible - use moderate scroll position
                        estimated_scroll_value = max(1, min(scrollbar_range - 1, raw_scroll_value))
                    else:
                        # Selected tab is partially cut off - use raw calculation
                        estimated_scroll_value = raw_scroll_value
                
                print(f"DEBUG SCROLLBAR: current_tab={current_tab}, total_tabs={tab_bar.count()}")
                print(f"DEBUG SCROLLBAR: selected_tab_rect=({selected_tab_rect.left()}, {selected_tab_rect.right()}), visible_width={visible_width}")
                print(f"DEBUG SCROLLBAR: estimated_scroll_value={estimated_scroll_value}, scrollbar_range={scrollbar_range}")
                
                # Temporarily disconnect to avoid triggering scroll events
                self.h_scrollbar.valueChanged.disconnect()
                self.h_scrollbar.setValue(estimated_scroll_value)
                self.h_scrollbar.valueChanged.connect(self.on_scrollbar_moved)
                
                print(f"DEBUG SCROLLBAR: Range 0-{scrollbar_range}, Qt scroll offset={current_scroll_offset}px, scrollbar value={estimated_scroll_value}")
            else:
                print(f"DEBUG SCROLLBAR: All tabs visible, hiding scrollbar")
                self.h_scrollbar.setVisible(False)
                
        except Exception as e:
            print(f"DEBUG SCROLLBAR: Error - {e}")
            pass
    
    def on_scrollbar_moved(self, value):
        """Handle scrollbar movement to scroll tabs"""
        try:
            print(f"DEBUG SCROLLBAR: Scrollbar moved to value={value}")
            tab_bar = self.colored_tab_bar
            if not tab_bar:
                return
            
            # Track the last scrollbar value to determine direction
            if not hasattr(self, '_last_scrollbar_value'):
                self._last_scrollbar_value = 0
            
            delta = value - self._last_scrollbar_value
            self._last_scrollbar_value = value
            
            if delta == 0:
                return
                
            # Find Qt's scroll buttons (QToolButton children) - they're hidden but still functional
            from PyQt6.QtWidgets import QToolButton
            scroll_buttons = tab_bar.findChildren(QToolButton)
            
            print(f"DEBUG SCROLLBAR: Found {len(scroll_buttons)} scroll buttons")
            
            # Store buttons for future use if we found them
            if len(scroll_buttons) >= 2 and not hasattr(self, '_scroll_buttons_cached'):
                self._scroll_buttons_cached = scroll_buttons
                print(f"DEBUG SCROLLBAR: Cached scroll buttons for future use")
            
            # Use cached buttons if available
            if hasattr(self, '_scroll_buttons_cached'):
                scroll_buttons = self._scroll_buttons_cached
            
            if len(scroll_buttons) >= 2:
                left_button = scroll_buttons[0]  # Usually the left scroll button
                right_button = scroll_buttons[1]  # Usually the right scroll button
                
                # Click the appropriate button based on scroll direction
                if delta > 0:  # Scrolling right
                    print(f"DEBUG SCROLLBAR: Clicking right scroll button (enabled: {right_button.isEnabled()})")
                    clicks = max(1, abs(delta) // 10)
                    
                    # If button is already disabled but we're trying to scroll right, force visibility of last tab
                    if not right_button.isEnabled():
                        print(f"DEBUG SCROLLBAR: Right button already disabled, forcing last tab to be fully visible")
                        # Try a few clicks anyway to ensure last tab is fully visible
                        for attempt in range(3):
                            # Temporarily scroll left then right to "shake" the position
                            if left_button.isEnabled():
                                left_button.click()
                            if right_button.isEnabled():
                                right_button.click()
                                print(f"DEBUG SCROLLBAR: Force-visibility attempt #{attempt + 1}")
                    else:
                        # Normal clicking if button is enabled
                        for _ in range(clicks):
                            if right_button.isEnabled():
                                right_button.click()
                            else:
                                break
                    
                    # Extra safety: if we're near the scrollbar maximum, keep clicking until truly at end
                    if value >= self.h_scrollbar.maximum() * 0.8:
                        safety_clicks = 0
                        while right_button.isEnabled() and safety_clicks < 5:
                            right_button.click()
                            safety_clicks += 1
                            print(f"DEBUG SCROLLBAR: Safety click #{safety_clicks} to ensure we reach true end")
                        
                else:  # Scrolling left
                    print(f"DEBUG SCROLLBAR: Clicking left scroll button")
                    clicks = max(1, abs(delta) // 10)
                    
                    # Click the button if it's enabled
                    for _ in range(clicks):
                        if left_button.isEnabled():
                            left_button.click()
                        else:
                            break
                    
                    # Extra safety: if we're near the scrollbar minimum, keep clicking until truly at start
                    if value <= self.h_scrollbar.maximum() * 0.2:
                        safety_clicks = 0
                        while left_button.isEnabled() and safety_clicks < 5:
                            left_button.click()
                            safety_clicks += 1
                            print(f"DEBUG SCROLLBAR: Safety click #{safety_clicks} to ensure we reach true beginning")
            
        except Exception as e:
            print(f"DEBUG SCROLLBAR: Error in on_scrollbar_moved - {e}")
    
    
    def minimumSizeHint(self):
        """Allow widget to shrink below total tab width"""
        hint = super().minimumSizeHint()
        hint.setWidth(200)  # Allow shrinking to reasonable minimum
        return hint
    def update_scene_style(self, scene, style):
        self.colored_tab_bar.update_scene_style(scene, style)
        self.colored_tab_bar.update()  # Ensure immediate repaint after style update
        
    def update_scene_styles(self, styles):
        self.colored_tab_bar.update_scene_styles(styles)
        self.colored_tab_bar.update()  # Ensure immediate repaint after multiple style updates
    
    def resizeEvent(self, event):
        """Handle resize events to keep progress overlay properly positioned"""
        super().resizeEvent(event)
        # If there's a progress overlay, resize it to match
        main_window = self.window()
        if main_window and hasattr(main_window, '_progress_overlay'):
            if main_window._progress_overlay and main_window._progress_overlay.isVisible():
                main_window._resize_progress_overlay()

    def add_colored_tab(self, widget, scene_name, style):
        index = self.addTab(widget, scene_name)
        self.colored_tab_bar.update_scene_style(scene_name, style)
        self.colored_tab_bar.update()  # Ensure tab size is updated after adding a new tab
        
        # Update scrollbar after adding tab
        from PyQt6.QtCore import QTimer
        QTimer.singleShot(10, self.update_passive_scrollbar)
        return index
    
    def handle_tab_double_click(self, index):
        """Handle double-click on scene tab to trigger theme filtering"""
        if index < 0 or index >= self.count():
            return
            
        scene_name = self.tabText(index)
        print(f"[DEBUG] Double-clicked on scene tab: {scene_name}")
        
        # Get the main window to access script_search
        main_window = self.window()
        if not main_window or not hasattr(main_window, 'script_search'):
            return
            
        script_search = main_window.script_search
        
        # Toggle theme filtering for this scene
        if scene_name in script_search.selected_themes:
            # Scene is already filtered - remove filter
            script_search.selected_themes.discard(scene_name)
            print(f"[DEBUG] Removed theme filter for: {scene_name}")
        else:
            # Add theme filter for this scene
            script_search.selected_themes.add(scene_name)
            print(f"[DEBUG] Added theme filter for: {scene_name}")
        
        # Update UI to reflect filter changes
        script_search._update_filter_themes_button_text()
        script_search._update_clear_button_visibility()
        
        # Update tab visual state
        self.update_tab_filter_state(scene_name, scene_name in script_search.selected_themes)
        
        # Apply the filters
        script_search.force_search()
        
    def update_tab_filter_state(self, scene_name, is_filtered):
        """Update the visual state of a tab to show if it's being filtered"""
        # Find tab index for this scene
        tab_index = -1
        for i in range(self.count()):
            if self.tabText(i) == scene_name:
                tab_index = i
                break
                
        if tab_index >= 0:
            # Store filter state on the tab
            tab_widget = self.widget(tab_index)
            if tab_widget:
                tab_widget.setProperty('filtered_state', is_filtered)
                
            # Update tab bar visual styling
            self.colored_tab_bar.update_tab_filter_state(scene_name, is_filtered)
            self.colored_tab_bar.update()
            
    def get_filtered_tabs(self):
        """Get list of scene names that are currently filtered"""
        filtered_scenes = set()
        for i in range(self.count()):
            tab_widget = self.widget(i)
            if tab_widget and tab_widget.property('filtered_state'):
                filtered_scenes.add(self.tabText(i))
        return filtered_scenes
        
    def restore_tab_filter_states(self, filtered_scenes):
        """Restore tab filter states after theme view rebuild"""
        for scene_name in filtered_scenes:
            self.update_tab_filter_state(scene_name, True)

class JsHandler(QObject):
    assignTheme = pyqtSignal(str, str)  # Signal to assign scene (selected_text, key_char)
    removeHighlight = pyqtSignal(str)   # Signal to remove highlight
    contentChanged = pyqtSignal(str)    # Signal for content changes
    checkboxToggled = pyqtSignal(bool)   # Signal for checkbox toggles
    bookmarkToggled = pyqtSignal(bool)  # NEW: Signal for bookmark toggles (speech_id, is_bookmarked)

    navigateToAnnotationRequested = pyqtSignal(str, str) # annotation_id, scene_name
    storyboardNavigationRequested = pyqtSignal(str)  # annotation_id for storyboard navigation

    # New signal for annotation updates
    updateAnnotation = pyqtSignal(str)  # Signal to update annotation attributes in DOM
    
    # Signal for AI query requests
    aiQueryRequested = pyqtSignal(str, str)  # Signal for AI queries (selected_text, title)
    
    # Signals for sticky header
    showStickyHeaderRequested = pyqtSignal()  # Signal to show sticky header
    hideStickyHeaderRequested = pyqtSignal()  # Signal to hide sticky header
    
    def __init__(self):
        super().__init__()

    @pyqtSlot(bool)
    def bookmarkToggledFromJs(self, is_bookmarked: bool):
        """Called from JS whenever a user toggles a bookmark icon."""
        print(f"Bookmark toggled: {is_bookmarked}")
        self.bookmarkToggled.emit(is_bookmarked)

    @pyqtSlot(bool)
    def checkboxToggledFromJs(self, is_checked: bool):
        """Called from JS whenever a user toggles a .speech-checkbox."""
        print(f"Checkbox toggled: {is_checked}")
        self.checkboxToggled.emit(is_checked)

    @pyqtSlot(str, str)
    def assignThemeFromJs(self, selected_text, key_char):
        self.assignTheme.emit(selected_text, key_char)

    @pyqtSlot(str)
    def removeHighlightFromJs(self, selected_text):
        self.removeHighlight.emit(selected_text)

    @pyqtSlot(str)
    def contentChangedFromJs(self, html_content):
        self.contentChanged.emit(html_content)

    @pyqtSlot(str)
    def updateAnnotationFromJs(self, annotation_json):
        """Called from JS to update an annotation in the DOM"""
        print(f"Updating annotation from JS: {annotation_json[:100]}...")
        self.updateAnnotation.emit(annotation_json)

    @pyqtSlot(str, str)
    def requestAnnotationNavigation(self, annotation_id, scene):
        print(f"JS Request Received: Navigate to Annotation ID: {annotation_id}, Scene: {scene}") # Debug
        self.navigateToAnnotationRequested.emit(annotation_id, scene)
    
    @pyqtSlot(str, str)
    def requestAiQuery(self, selected_text, title):
        """Called from JS when user requests AI query on selected text"""
        print(f"AI Query requested for text: {selected_text[:50]}... from title: {title}")
        self.aiQueryRequested.emit(selected_text, title)

    @pyqtSlot(str, result=bool)
    def checkAnnotationInStoryboard(self, annotation_id):
        """Check if an annotation exists in the storyboard (has an order field)"""
#         print(f"[DEBUG] Python: checkAnnotationInStoryboard called for: {annotation_id}")
        try:
            # Get the main window - JSHandler doesn't have a direct parent hierarchy to main window
            # so we need to get it through the web view that owns this js_handler
            main_window = None
            
            # Try to get main window through QApplication - look specifically for ScriptoriaMain
            from PyQt6.QtWidgets import QApplication
            app = QApplication.instance()
            if app:
                for widget in app.allWidgets():
                    # Look specifically for ScriptoriaMain class, not just any widget with web_view
                    if (type(widget).__name__ == 'ScriptoriaMain' and 
                        hasattr(widget, 'web_view') and 
                        hasattr(widget.web_view, 'annotations') and 
                        hasattr(widget.web_view, 'js_handler')):
                        if widget.web_view.js_handler == self:
                            main_window = widget
                            #print(f"[DEBUG] Found main window via QApplication: {type(main_window).__name__}")
                            break
            
            if not main_window:
                print("[DEBUG] No main window found via QApplication, trying parent hierarchy")
                # Fallback to parent hierarchy
                current = self.parent()
                while current:
                    print(f"[DEBUG] Checking parent: {type(current).__name__}")
                    if hasattr(current, 'web_view') and hasattr(current.web_view, 'annotations'):
                        main_window = current
                        print(f"[DEBUG] Found main window via parent: {type(main_window).__name__}")
                        break
                    current = current.parent()
            
            if not main_window:
                print("[DEBUG] No main window found")
                return False
                
            # Find the annotation and check if it has an order field
            if hasattr(main_window, 'web_view') and hasattr(main_window.web_view, 'annotations'):
                #print(f"[DEBUG] Searching through {len(main_window.web_view.annotations)} annotations")
                for annotation in main_window.web_view.annotations:
                    if annotation.get('id') == annotation_id:
                        # Annotation is in storyboard if it has an 'order' field
                        has_order = 'order' in annotation and annotation.get('order') is not None
                        #print(f"[DEBUG] Found annotation {annotation_id} - in storyboard: {has_order} (order: {annotation.get('order', 'None')})")
                        return has_order
                
                print(f"[DEBUG] Annotation {annotation_id} not found in annotations list")
            else:
                print("[DEBUG] No web_view.annotations available")
            
            return False
        except Exception as e:
            print(f"[DEBUG] Error checking annotation in storyboard: {e}")
            import traceback
            traceback.print_exc()
            return False

    @pyqtSlot(str)
    def requestStoryboardNavigation(self, annotation_id):
        """Request navigation to annotation in storyboard"""
        print(f"JS Request: Navigate to annotation {annotation_id} in storyboard")
        self.storyboardNavigationRequested.emit(annotation_id)

    @pyqtSlot()
    def showStickyHeader(self):
        """Called from JS to show the sticky header"""
        print("[DEBUG] ========= JS HANDLER showStickyHeader CALLED =========")
        print("JS Request: Show sticky header")
        print("[DEBUG] About to emit showStickyHeaderRequested signal")
        self.showStickyHeaderRequested.emit()
        print("[DEBUG] showStickyHeaderRequested signal emitted successfully")

    @pyqtSlot()
    def hideStickyHeader(self):
        """Called from JS to hide the sticky header"""
        print("JS Request: Hide sticky header")
        self.hideStickyHeaderRequested.emit()

class CustomWebPage(QWebEnginePage):
    def acceptNavigationRequest(self, url, nav_type, is_main_frame):
        # Block back/forward navigation
        if nav_type == QWebEnginePage.NavigationType.NavigationTypeBackForward:
            print(f"Blocked navigation request: {nav_type}")
            return False
        return super().acceptNavigationRequest(url, nav_type, is_main_frame)

class StickyThemeHeader(QWidget):
    """Compact sticky header showing available themes with colors and hotkeys"""
    
    theme_visibility_toggled = pyqtSignal(str, bool)  # Emits (theme_name, is_visible)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.themes = {}  # Dictionary of {hotkey: {'name': str, 'color': str}}
        self.hidden_themes = set()  # Track which themes are visually hidden
        self.solo_theme = None  # Track which theme is soloed (if any)
        self.pre_solo_hidden_themes = set()  # Store hidden state before solo
        
        # Performance caching
        self._cached_nav_width = None
        self._cached_positions = None
        self._button_cache = {}  # Cache created buttons to avoid recreation
        self.setup_ui()
        self.hide()  # Initially hidden
        
        # Store fixed geometry to prevent drift
        self._fixed_geometry_set = False
        self._fixed_x = 0  # Start from left edge
        self._fixed_width = 0  # Will be set dynamically to full width
        
        # Track last themes to avoid unnecessary updates
        self._last_theme_names = []
        self._last_theme_colors = {}
        self._last_content_overflows = False
        
        # Setup animations
        self.show_animation = QPropertyAnimation(self, b"pos")
        self.show_animation.setDuration(300)
        self.show_animation.setEasingCurve(QEasingCurve.Type.OutCubic)
        
        self.hide_animation = QPropertyAnimation(self, b"pos") 
        self.hide_animation.setDuration(250)
        self.hide_animation.setEasingCurve(QEasingCurve.Type.InCubic)
        self.hide_animation.finished.connect(self.hide)
        
    def setup_ui(self):
        """Setup the UI layout for the sticky header"""
        self.setFixedHeight(36)  # Increased to fit theme buttons
        self.setObjectName("stickyThemeHeader")
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
        self.setAutoFillBackground(False)
        
        # Ensure the header can expand to full width
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        
        # Main layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(12, 4, 12, 4)  # Small top/bottom margins for centering
        layout.setSpacing(6)
        
        # Ensure the layout stretches to fill the full width
        layout.setSizeConstraint(QHBoxLayout.SizeConstraint.SetDefaultConstraint)
        
        
        
        # Scroll area for themes
        self.scroll_area = QScrollArea(self)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.scroll_area.setFixedHeight(45)  # Increased height to accommodate scroll bar when needed
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setContentsMargins(0, 0, 0, 0)
        self.scroll_area.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
        self.scroll_area.setAutoFillBackground(False)
        # Force transparent styling for scroll area
        self.scroll_area.setStyleSheet("QScrollArea { background: transparent; border: none; }")
        
        # Make sure scroll area expands to fill available space
        self.scroll_area.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        self.scroll_area.setMinimumWidth(0)  # Remove any minimum width constraint
        self.scroll_area.setMaximumWidth(16777215)  # Remove any maximum width constraint
        
        # Theme container widget
        self.theme_container = QWidget()
        self.theme_container.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
        self.theme_container.setAutoFillBackground(False)
        # Force transparent styling for theme container
        self.theme_container.setStyleSheet("QWidget { background: transparent; border: none; }")
        self.theme_layout = QHBoxLayout(self.theme_container)
        self.theme_layout.setContentsMargins(0, 0, 0, 0)
        self.theme_layout.setSpacing(4)
        initial_alignment = Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignVCenter
        self.theme_layout.setAlignment(initial_alignment)
        print(f"[DEBUG] SETUP: Initial theme layout alignment set to CENTER: {initial_alignment}")
        
        # Ensure theme container expands to fill scroll area width for proper centering
        self.theme_container.setContentsMargins(0, 0, 0, 0)
        self.theme_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        
        self.scroll_area.setWidget(self.theme_container)
        layout.addWidget(self.scroll_area, 1)  # Add with stretch factor 1 to fill available space
        
        # Apply styling
        self.apply_styling()
        
    def apply_styling(self):
        """Apply QSS styling to the header"""
        self.setStyleSheet("""
            #stickyThemeHeader {
                background: transparent;
                border: none;
                border-radius: 0px;
                margin: 0px;
                padding: 0px;
            }
            QLabel {
                color: #000;
                font-weight: bold;
                font-size: 11px;
                margin-right: 4px;
            }
            QScrollArea {
                border: none;
                background: transparent;
                margin: 0px;
                padding: 0px;
            }
            QScrollBar:horizontal {
                height: 6px;
                background: rgba(0, 0, 0, 0.08);
                border-radius: 3px;
                margin: 0px;
            }
            QScrollBar::handle:horizontal {
                background: rgba(76, 175, 80, 0.6);
                border-radius: 3px;
                min-width: 20px;
            }
            QScrollBar::handle:horizontal:hover {
                background: rgba(76, 175, 80, 0.8);
            }
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
                width: 0px;
                height: 0px;
            }
        """)
        
    def invalidate_cache(self):
        """Banish all cached spirits when a new session arrives"""
        print("[DEBUG] StickyThemeHeader: Invalidating all cache data for new session")
        
        # Clear navigation caching
        self._cached_nav_width = None
        self._cached_positions = None
        
        # Clear theme caching
        self._last_theme_names = []
        self._last_theme_colors = {}
        self._last_content_overflows = False
        
        # Clear button cache to force recreation
        self._button_cache = {}
        
        # Reset geometry caching
        self._fixed_geometry_set = False
        self._fixed_x = 0
        self._fixed_width = 0
        
        print("[DEBUG] StickyThemeHeader: All cache data cleared")
        
    def update_themes(self, scene_styles, content_overflows=False, force_update=False):
        """Update the header with current themes from scene_styles"""
        print(f"[DEBUG] StickyThemeHeader.update_themes called with {len(scene_styles)} themes, overflow={content_overflows}, force={force_update}")
        
        # Prevent duplicate updates with same data (unless force_update=True)
        if not force_update:
            current_theme_names = list(scene_styles.keys()) if scene_styles else []
            current_theme_colors = {}
            for name, style in scene_styles.items():
                current_theme_colors[name] = self.extract_color_from_css(style)
            current_button_count = self.theme_layout.count()
            
            # Check if themes, colors, order, and overflow state are all the same
            if (hasattr(self, '_last_theme_names') and 
                self._last_theme_names == current_theme_names and 
                hasattr(self, '_last_theme_colors') and
                self._last_theme_colors == current_theme_colors and
                hasattr(self, '_last_content_overflows') and
                self._last_content_overflows == content_overflows and
                current_button_count == len(current_theme_names)):
                print(f"[DEBUG] Skipping duplicate theme update - same themes, colors, order ({len(current_theme_names)}), overflow ({content_overflows}), and button count ({current_button_count})")
                return
        else:
            print(f"[DEBUG] Force update requested - skipping duplicate detection")
        
        # Store current state to prevent duplicates
        current_theme_names = list(scene_styles.keys()) if scene_styles else []
        current_theme_colors = {}
        for name, style in scene_styles.items():
            current_theme_colors[name] = self.extract_color_from_css(style)
        
        self._last_theme_names = current_theme_names.copy()
        self._last_theme_colors = current_theme_colors.copy()
        self._last_content_overflows = content_overflows
        
        # Check current alignment before clearing
        current_alignment = self.theme_layout.alignment()
        print(f"[DEBUG] BEFORE CLEAR: Current theme layout alignment: {current_alignment}")
        
        # Properly clear all existing buttons by removing them from layout
        button_count_before = self.theme_layout.count()
        
        # Actually remove widgets from layout instead of just hiding them
        while self.theme_layout.count() > 0:
            item = self.theme_layout.takeAt(0)  # Take the first item
            if item and item.widget():
                widget = item.widget()
                widget.setParent(None)  # Remove from parent
                widget.deleteLater()    # Schedule for deletion
        
        print(f"[DEBUG] PROPERLY CLEARED: Removed {button_count_before} widgets from layout")
        
        button_count_after = self.theme_layout.count()
        print(f"[DEBUG] LAYOUT NOW HAS: {button_count_after} widgets")
        
        # Check alignment after clearing
        alignment_after_clear = self.theme_layout.alignment()
        print(f"[DEBUG] AFTER CLEAR: Theme layout alignment: {alignment_after_clear}")
        
        self.themes.clear()
        
        # Create hotkey mapping (same as in TranscriptWebView)
        theme_names = list(scene_styles.keys())
        hotkey_map = {}
        
        print(f"[DEBUG] Theme names: {theme_names}")
        
        for i, theme_name in enumerate(theme_names[:12]):  # Max 12 themes
            if i < 9:
                hotkey = str(i + 1)
            elif i == 9:
                hotkey = "0"
            elif i == 10:
                hotkey = "-"
            elif i == 11:
                hotkey = "+"
            
            hotkey_map[hotkey] = theme_name
            
            # Extract color from CSS style
            css_style = scene_styles[theme_name]
            color = self.extract_color_from_css(css_style)
            
            print(f"[DEBUG] Theme {i+1}: {theme_name} -> hotkey {hotkey} -> color {color}")
            
            self.themes[hotkey] = {
                'name': theme_name,
                'color': color
            }
            
            # Create fresh button (layout was cleared above)
            button_key = f"{hotkey}:{theme_name}"
            theme_btn = self.create_theme_button(hotkey, theme_name, color)
            self.theme_layout.addWidget(theme_btn)
            print(f"[DEBUG] CREATED fresh button: {button_key}")
            
            # Restore hidden state if needed
            if theme_name in self.hidden_themes:
                self.update_button_visual_state(theme_btn, theme_name, False)
            
            # Check alignment after each button add
            alignment_after_add = self.theme_layout.alignment()
            print(f"[DEBUG] AFTER ADDING BUTTON {i+1}: Layout alignment: {alignment_after_add}")
        
        # Check alignment before forced update
        alignment_before_update = self.theme_layout.alignment()
        print(f"[DEBUG] BEFORE UPDATE: Layout alignment: {alignment_before_update}")
        
        # Force layout update to prevent positioning issues
        self.theme_container.adjustSize()
        self.theme_layout.update()
        
        # Check alignment after update
        alignment_after_update = self.theme_layout.alignment()
        print(f"[DEBUG] AFTER UPDATE: Layout alignment: {alignment_after_update}")
        
        # Choose alignment and scroll policy based on content overflow
        if content_overflows:
            # Use left alignment when content overflows to show buttons from start
            final_alignment = Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter
            # Enable horizontal scrolling when content overflows
            self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
            print(f"[DEBUG] Content overflows, using LEFT alignment with scroll enabled")
        else:
            # Use center alignment when content fits
            final_alignment = Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignVCenter
            # Disable horizontal scrolling when content fits
            self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            print(f"[DEBUG] Content fits, using CENTER alignment with scroll disabled")
            
        self.theme_layout.setAlignment(final_alignment)
        
        # Verify the alignment was actually set
        actual_alignment = self.theme_layout.alignment()
        print(f"[DEBUG] FINAL: Set alignment to {final_alignment}, actual alignment is: {actual_alignment}")
        
        # Debug scroll area and container geometry
        scroll_geometry = self.scroll_area.geometry()
        container_geometry = self.theme_container.geometry()
        container_size = self.theme_container.size()
        scroll_size = self.scroll_area.size()
        
        print(f"[DEBUG] GEOMETRY: Scroll area: {scroll_geometry}")
        print(f"[DEBUG] GEOMETRY: Theme container: {container_geometry}")
        print(f"[DEBUG] GEOMETRY: Container size: {container_size}")
        print(f"[DEBUG] GEOMETRY: Scroll area size: {scroll_size}")
        
        # Properly size container for theme buttons - don't force to scroll area width
        # Calculate actual width needed for buttons
        button_count = len(scene_styles)
        if button_count > 0:
            # Get actual width from layout's sizeHint
            layout_hint = self.theme_layout.sizeHint()
            needed_width = layout_hint.width()
            needed_height = max(22, layout_hint.height())  # Minimum 22px for buttons
            
            print(f"[DEBUG] Layout suggests size: {needed_width}x{needed_height}px for {button_count} buttons")
            
            # Only resize if we have a valid size
            if needed_width > 0 and needed_height > 0:
                self.theme_container.setMinimumSize(needed_width, needed_height)
                self.theme_container.resize(needed_width, needed_height)
                print(f"[DEBUG] Set container size to {needed_width}x{needed_height}px based on content")
            else:
                # Fallback to reasonable size
                fallback_width = min(800, scroll_size.width())
                self.theme_container.setMinimumSize(fallback_width, 22)
                self.theme_container.resize(fallback_width, 22)
                print(f"[DEBUG] Used fallback container size: {fallback_width}x22px")
            
            # Update geometry debug after forcing size
            new_container_size = self.theme_container.size()
            print(f"[DEBUG] GEOMETRY AFTER FORCE: Container size: {new_container_size}")
        
        # Check scroll position
        h_scrollbar = self.scroll_area.horizontalScrollBar()
        scroll_value = h_scrollbar.value()
        scroll_min = h_scrollbar.minimum()
        scroll_max = h_scrollbar.maximum()
        
        print(f"[DEBUG] SCROLL: Value={scroll_value}, Min={scroll_min}, Max={scroll_max}")
        
        print(f"[DEBUG] Created {len(self.themes)} theme buttons and updated layout with LEFT alignment")
        
    def update_scroll_area_size(self):
        """Force the scroll area to update its size to match the header width"""
        try:
            # Get the current header width
            header_width = self.width()
            
            # Calculate available width for scroll area (minus margins)
            margins = self.layout().contentsMargins()
            available_width = header_width - margins.left() - margins.right()
            
            print(f"[DEBUG] Updating scroll area size: header_width={header_width}, available_width={available_width}")
            
            # Set the scroll area width explicitly
            self.scroll_area.setFixedWidth(available_width)
            
            # Force layout update
            self.layout().update()
            self.scroll_area.updateGeometry()
            
            # Log the new geometry
            print(f"[DEBUG] Updated scroll area geometry: {self.scroll_area.geometry()}")
            
        except Exception as e:
            print(f"[DEBUG] Error updating scroll area size: {e}")
        
    def update_title(self, title):
        """Update the title shown in the header"""
        if hasattr(self, 'title_label'):
            # Truncate title if too long
            display_title = title[:25] + "..." if len(title) > 25 else title
            self.title_label.setText(display_title)
            self.title_label.setToolTip(title)  # Full title in tooltip
        
    def extract_color_from_css(self, css_style):
        """Extract hex color from CSS background-color style"""
        import re
        # Look for hex colors
        hex_match = re.search(r'#[0-9A-Fa-f]{6}', css_style)
        if hex_match:
            return hex_match.group(0)
        
        # Look for rgb colors and convert to hex
        rgb_match = re.search(r'rgb\((\d+),\s*(\d+),\s*(\d+)\)', css_style)
        if rgb_match:
            r, g, b = map(int, rgb_match.groups())
            return f"#{r:02x}{g:02x}{b:02x}"
        
        # Default color if not found
        return "#cccccc"
        
    def create_theme_button(self, hotkey, theme_name, color):
        """Create a compact theme button with dynamic width"""
        btn = QPushButton(self.theme_container)  # Parent to theme_container specifically
        
        # Set text without truncation to get accurate size measurement
        btn.setText(f"{hotkey}: {theme_name}")  # Show full theme name
        btn.setToolTip(f"{theme_name} (Hotkey: {hotkey})")
        
        # Calculate required width based on text content
        font_metrics = btn.fontMetrics()
        text_width = font_metrics.horizontalAdvance(btn.text())
        padding = 16  # 8px padding on each side
        min_width = 80   # Minimum button width
        max_width = 300  # Maximum button width to prevent extremely long buttons
        
        optimal_width = max(min_width, min(text_width + padding, max_width))
        btn.setFixedSize(optimal_width, 22)
        btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        
        print(f"[DEBUG] Button '{theme_name}' -> width: {optimal_width}px (text: {text_width}px)")
        
        # Style the button with the theme color (initially visible state)
        btn.setStyleSheet(f"""
            QPushButton {{
                background-color: {color};
                color: #2c3e50;
                border: 1px solid #bbb;
                border-radius: 4px;
                font-weight: bold;
                font-size: 10px;
                padding: 2px 4px;
                margin: 1px;
                opacity: 1.0;
            }}
            QPushButton:hover {{
                border: 2px solid #4CAF50;
                background-color: {self.lighten_color(color)};
            }}
            QPushButton:pressed {{
                background-color: {self.darken_color(color)};
                border: 2px solid #388E3C;
            }}
        """)
        
        # Set initial tooltip (theme starts visible)
        btn.setToolTip(f"{theme_name} (VISIBLE - Click to hide)")
        
        # Connect click to toggle theme visibility
        btn.clicked.connect(lambda: self.toggle_theme_visibility(theme_name, btn))
        
        # Connect double-click to solo mode
        btn.mouseDoubleClickEvent = lambda event: self.solo_theme_mode(theme_name)
        
        return btn
    
    def update_button_color(self, button, color):
        """Update an existing button's color without recreating it"""
        # Get theme name from button text
        button_text = button.text()
        if ": " in button_text:
            theme_name = button_text.split(": ", 1)[1]
            # Update the button's style with new color
            is_visible = theme_name not in self.hidden_themes
            is_soloed = theme_name == self.solo_theme
            self.update_button_visual_state_with_solo(button, theme_name, is_visible, is_soloed)
    
    def solo_theme_mode(self, theme_name):
        """Solo a theme (hide all others) or unsolo if already soloed"""
        print(f"[DEBUG] Solo mode triggered for theme: {theme_name}")
        
        if self.solo_theme == theme_name:
            # Already soloed this theme, unsolo it
            self.unsolo_all_themes()
        else:
            # Solo this theme (hide all others)
            self.solo_single_theme(theme_name)
    
    def solo_single_theme(self, theme_name):
        """Hide all themes except the specified one"""
        print(f"[DEBUG] Soloing theme: {theme_name}")
        
        # Store current hidden state before solo
        self.pre_solo_hidden_themes = self.hidden_themes.copy()
        
        # Set solo state
        self.solo_theme = theme_name
        
        # Hide all themes except the soloed one
        all_theme_names = [data['name'] for data in self.themes.values()]
        for name in all_theme_names:
            if name != theme_name:
                if name not in self.hidden_themes:
                    self.hidden_themes.add(name)
                    # Emit signal to hide this theme
                    self.theme_visibility_toggled.emit(name, False)
            else:
                # Ensure the soloed theme is visible
                if name in self.hidden_themes:
                    self.hidden_themes.remove(name)
                    # Emit signal to show this theme
                    self.theme_visibility_toggled.emit(name, True)
        
        # Update all button visual states
        self.update_all_button_states()
        
        print(f"[DEBUG] Solo complete: showing only '{theme_name}'")
    
    def unsolo_all_themes(self):
        """Exit solo mode and make ALL themes visible"""
        print(f"[DEBUG] Unsoloing theme: {self.solo_theme}")
        
        # Store which themes were hidden before unsolo
        old_hidden = self.hidden_themes.copy()
        
        # Clear ALL hidden themes - make everything visible
        self.hidden_themes.clear()
        
        # Clear solo state
        self.solo_theme = None
        self.pre_solo_hidden_themes.clear()
        
        # Update visibility for ALL themes to visible
        all_theme_names = [data['name'] for data in self.themes.values()]
        for name in all_theme_names:
            if name in old_hidden:
                # This theme was hidden, now make it visible
                self.theme_visibility_toggled.emit(name, True)
        
        # Update all button visual states
        self.update_all_button_states()
        
        print("[DEBUG] Unsolo complete: ALL themes now visible")
    
    def update_all_button_states(self):
        """Update visual state of all buttons"""
        # Find all buttons and update their states
        for i in range(self.theme_layout.count()):
            item = self.theme_layout.itemAt(i)
            if item and item.widget():
                button = item.widget()
                button_text = button.text()
                # Extract theme name from button text (format: "hotkey: theme_name")
                if ": " in button_text:
                    theme_name = button_text.split(": ", 1)[1]
                    is_visible = theme_name not in self.hidden_themes
                    is_soloed = theme_name == self.solo_theme
                    self.update_button_visual_state_with_solo(button, theme_name, is_visible, is_soloed)
    
    def toggle_theme_visibility(self, theme_name, button):
        """Toggle the visibility of a theme's highlights"""
        if theme_name in self.hidden_themes:
            # Theme is hidden, show it
            self.hidden_themes.remove(theme_name)
            is_visible = True
            print(f"[DEBUG] Showing theme: {theme_name}")
        else:
            # Theme is visible, hide it
            self.hidden_themes.add(theme_name)
            is_visible = False
            print(f"[DEBUG] Hiding theme: {theme_name}")
        
        # Update button visual state
        is_soloed = theme_name == self.solo_theme
        self.update_button_visual_state_with_solo(button, theme_name, is_visible, is_soloed)
        
        # Emit signal to update document
        self.theme_visibility_toggled.emit(theme_name, is_visible)
    
    def update_button_visual_state_with_solo(self, button, theme_name, is_visible, is_soloed=False):
        """Update button appearance to show hidden/visible/solo state"""
        # Get the original color for this theme
        original_color = None
        for hotkey, theme_data in self.themes.items():
            if theme_data['name'] == theme_name:
                original_color = theme_data['color']
                break
        
        if not original_color:
            original_color = "#cccccc"
        
        if is_soloed:
            # Theme is soloed - bright with special border
            button.setStyleSheet(f"""
                QPushButton {{
                    background-color: {original_color};
                    color: #2c3e50;
                    border: 3px solid #ff9800;
                    border-radius: 4px;
                    font-weight: bold;
                    font-size: 10px;
                    padding: 2px 4px;
                    margin: 1px;
                    opacity: 1.0;
                    box-shadow: 0 0 8px rgba(255, 152, 0, 0.5);
                }}
                QPushButton:hover {{
                    border: 3px solid #f57c00;
                    background-color: {self.lighten_color(original_color)};
                    box-shadow: 0 0 12px rgba(255, 152, 0, 0.7);
                }}
                QPushButton:pressed {{
                    background-color: {self.darken_color(original_color)};
                    border: 3px solid #e65100;
                }}
            """)
            button.setToolTip(f"{theme_name} (SOLO - Double-click to unsolo)")
        elif is_visible:
            # Theme is visible - normal bright appearance
            button.setStyleSheet(f"""
                QPushButton {{
                    background-color: {original_color};
                    color: #2c3e50;
                    border: 1px solid #bbb;
                    border-radius: 4px;
                    font-weight: bold;
                    font-size: 10px;
                    padding: 2px 4px;
                    margin: 1px;
                    opacity: 1.0;
                }}
                QPushButton:hover {{
                    border: 2px solid #4CAF50;
                    background-color: {self.lighten_color(original_color)};
                }}
                QPushButton:pressed {{
                    background-color: {self.darken_color(original_color)};
                    border: 2px solid #388E3C;
                }}
            """)
            button.setToolTip(f"{theme_name} (VISIBLE - Click to hide, Double-click to solo)")
        else:
            # Theme is hidden - desaturated/grayed out appearance with strikethrough
            gray_color = self.desaturate_color(original_color)
            button.setStyleSheet(f"""
                QPushButton {{
                    background-color: {gray_color};
                    color: #666;
                    border: 1px solid #999;
                    border-radius: 4px;
                    font-weight: normal;
                    font-size: 10px;
                    padding: 2px 4px;
                    margin: 1px;
                    opacity: 0.75;
                    text-decoration: line-through;
                }}
                QPushButton:hover {{
                    border: 2px solid #ff6b6b;
                    background-color: {self.lighten_color(gray_color)};
                    opacity: 0.8;
                }}
                QPushButton:pressed {{
                    background-color: {self.darken_color(gray_color)};
                    border: 2px solid #e74c3c;
                }}
            """)
            button.setToolTip(f"{theme_name} (HIDDEN - Click to show, Double-click to solo)")
    
    def update_button_visual_state(self, button, theme_name, is_visible):
        """Update button appearance to show hidden/visible state (legacy method)"""
        is_soloed = theme_name == self.solo_theme
        self.update_button_visual_state_with_solo(button, theme_name, is_visible, is_soloed)
        
    def desaturate_color(self, hex_color):
        """Convert a color to a desaturated/grayscale version"""
        try:
            color = QColor(hex_color)
            h, s, l, a = color.getHsl()
            # Reduce saturation significantly and lighten
            s = int(s * 0.2)  # 20% of original saturation
            l = min(255, int(l * 1.1))  # Slightly lighter
            color.setHsl(h, s, l, a)
            return color.name()
        except:
            return "#d3d3d3"  # Light gray fallback
        
    def lighten_color(self, hex_color):
        """Lighten a hex color by 20%"""
        try:
            color = QColor(hex_color)
            h, s, l, a = color.getHsl()
            l = min(255, int(l * 1.2))
            color.setHsl(h, s, l, a)
            return color.name()
        except:
            return hex_color
            
    def darken_color(self, hex_color):
        """Darken a hex color by 20%"""
        try:
            color = QColor(hex_color)
            h, s, l, a = color.getHsl()
            l = max(0, int(l * 0.8))
            color.setHsl(h, s, l, a)
            return color.name()
        except:
            return hex_color
            
    def show_header(self):
        """Show the header with animation"""
        print(f"[DEBUG] StickyThemeHeader.show_header called - currently visible: {self.isVisible()}")
        
        if self.isVisible():
            print("[DEBUG] Header already visible, forcing refresh")
            # Don't return - force a refresh even if visible
            
        # Use fixed geometry stored during first positioning
        fixed_x = self._fixed_x if self._fixed_geometry_set else 0
        fixed_width = self._fixed_width if self._fixed_geometry_set else 1200
        
        print(f"[DEBUG] Using FIXED geometry for animation: x={fixed_x}, width={fixed_width}")
        
        # Important: Stop any running animations first to prevent position conflicts
        if self.show_animation.state() == QPropertyAnimation.State.Running:
            self.show_animation.stop()
        if self.hide_animation.state() == QPropertyAnimation.State.Running:
            self.hide_animation.stop()
            
        # Use fixed position, start at target position (no animation for debugging)
        target_y = 0  # Position at top of parent
        self.setGeometry(int(fixed_x), int(target_y), int(fixed_width), self.height())
        
        # Force all visual properties
        self.show()
        self.raise_()
        self.setWindowOpacity(1.0)  # Ensure fully opaque
        self.setAttribute(Qt.WidgetAttribute.WA_OpaquePaintEvent, False)  # Allow transparency
        self.setAutoFillBackground(False)  # Don't auto-fill to allow transparency
        
        # Clean styling - fully transparent background
        self.setStyleSheet("StickyThemeHeader { background: transparent; border: none; }")
        
        print(f"[DEBUG] ========= DETAILED HEADER DEBUG =========")
        print(f"[DEBUG] Header positioned at FIXED ({fixed_x}, {target_y}) with width {fixed_width}")
        print(f"[DEBUG] Header isVisible: {self.isVisible()}")
        print(f"[DEBUG] Header geometry: {self.geometry()}")
        print(f"[DEBUG] Header parent: {self.parent()}")
        print(f"[DEBUG] Header z-order: {self.windowOpacity()}")
        print(f"[DEBUG] Header transparency: {self.testAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)}")
        print(f"[DEBUG] Header autofill: {self.autoFillBackground()}")
        
        print(f"[DEBUG] Scroll area visible: {self.scroll_area.isVisible()}")
        print(f"[DEBUG] Scroll area geometry: {self.scroll_area.geometry()}")
        print(f"[DEBUG] Scroll area size policy: {self.scroll_area.sizePolicy().horizontalPolicy()}")
        
        print(f"[DEBUG] Theme container visible: {self.theme_container.isVisible()}")
        print(f"[DEBUG] Theme container geometry: {self.theme_container.geometry()}")
        print(f"[DEBUG] Theme container size: {self.theme_container.size()}")
        
        print(f"[DEBUG] Theme layout count: {self.theme_layout.count()}")
        
        # Force everything to show and repaint
        self.repaint()
        self.scroll_area.show()
        self.scroll_area.repaint()
        self.theme_container.show()
        self.theme_container.repaint()
        
        # Debug each theme button individually
        for i in range(self.theme_layout.count()):
            item = self.theme_layout.itemAt(i)
            if item and item.widget():
                btn = item.widget()
                btn.show()
                btn.raise_()
                btn.repaint()
                print(f"[DEBUG] Button {i}: '{btn.text()}' - visible: {btn.isVisible()}, geometry: {btn.geometry()}, size: {btn.size()}")
            else:
                print(f"[DEBUG] Button {i}: No widget found")
        
        print(f"[DEBUG] ========= END HEADER DEBUG =========")
        
        # TEMPORARILY DISABLE ANIMATION FOR DEBUGGING
        # # Animate sliding down to top of parent, maintaining fixed position
        # self.show_animation.setStartValue(QPoint(fixed_x, -self.height()))
        # self.show_animation.setEndValue(QPoint(fixed_x, 0))
        # self.show_animation.start()
        
        print("[DEBUG] Header positioned WITHOUT animation for debugging visibility issue")
        
    def hide_header(self):
        """Hide the header with animation"""
        print(f"[DEBUG] StickyThemeHeader.hide_header called - currently visible: {self.isVisible()}")
        
        if not self.isVisible():
            print("[DEBUG] Header already hidden, skipping")
            return  # Already hidden
        
        # Stop any running animations first
        if self.show_animation.state() == QPropertyAnimation.State.Running:
            self.show_animation.stop()
        if self.hide_animation.state() == QPropertyAnimation.State.Running:
            self.hide_animation.stop()
            
        # Use fixed position to maintain centering during hide animation
        fixed_x = self._fixed_x if self._fixed_geometry_set else self.x()
        
        # Animate sliding up from fixed centered position
        self.hide_animation.setStartValue(QPoint(fixed_x, 0))
        self.hide_animation.setEndValue(QPoint(fixed_x, -self.height()))
        self.hide_animation.start()
        
        print(f"[DEBUG] Hide animation started from FIXED x={fixed_x}")

class TranscriptWebView(QWebEngineView):
    text_selected = pyqtSignal(str)
    scenes_updated = pyqtSignal()
    content_changed = pyqtSignal(str)
    annotation_deleted = pyqtSignal(str)
    annotation_updated = pyqtSignal(str)
    annotation_added = pyqtSignal(str)
    search_requested = pyqtSignal(str)
    reassignment_completed = pyqtSignal(list)  # Signal emitted when annotation reassignment is fully complete, carries list of new annotation IDs

    tooltips_enabled = True  # Flag to track if tooltips are enabled




    def __init__(self, main_window, parent=None):
        super().__init__(parent)
        self.main_window = main_window
        self.annotations = []
        self.scene_styles = {}
        self.voice_chat_dialog = None  # Track single voice chat dialog instance

        # Simple undo/redo stacks for recent removals
        self._undo_stack = []  # list of dicts: { 'ts': float, 'type': 'remove', 'payload': {...} }
        self._redo_stack = []  # list of dicts: { 'ts': float, 'type': 'restore', 'payload': {...} }

        # Instantiate the custom web page and set it for this view
        custom_page = CustomWebPage(self)
        self.setPage(custom_page)
    
        # Initialize settings with a different name to avoid conflicts with QWebEngineView.settings()
        self.app_settings = None
        try:
            app_dir = os.path.dirname(os.path.abspath(__file__))
            settings_dir = os.path.join(app_dir, "data")
            if not os.path.exists(settings_dir):
                os.makedirs(settings_dir)
        
            settings_path = os.path.join(settings_dir, "settings.ini")
            self.app_settings = QSettings(settings_path, QSettings.Format.IniFormat)
        
            # Try to verify settings access by reading and setting a test value
            test_val = self.app_settings.value("test", "")
            self.app_settings.setValue("test", "test")
            self.app_settings.sync()
        
            # Load tooltip state from settings
            self.tooltips_enabled = self.app_settings.value("tooltips/enabled", True, type=bool)
            
            # Load sticky header state from settings
            self.sticky_header_enabled = self.app_settings.value("sticky_header/enabled", True, type=bool)
            # Sticky header height multiplier (0.5 to 2.0, default 1.0)
            self.sticky_header_size = self.app_settings.value("sticky_header/size", 1.0, type=float)
            print(f"Settings initialized from: {settings_path}")
        except Exception as e:
            print(f"Error initializing settings: {e}")
            # Fallback to memory-only settings if file access fails
            self.app_settings = QSettings(QSettings.Format.IniFormat, QSettings.Scope.UserScope, "AppName", "Settings")
            self.tooltips_enabled = True
            self.sticky_header_enabled = True
            self.sticky_header_size = 1.0
        
            # Notify user of settings issue
            QTimer.singleShot(1000, lambda: QMessageBox.warning(
                self, 
                "Settings Error", 
                f"Could not initialize settings file. Settings will not be saved between sessions.\n\nError: {str(e)}",
                QMessageBox.StandardButton.Ok
            ))
    

        # Create the js_handler FIRST
        self.js_handler = JsHandler()
        self.channel = QWebChannel()
        self.page().setWebChannel(self.channel)
        self.channel.registerObject('jsHandler', self.js_handler)

        # THEN connect signals AFTER js_handler is created
        self.js_handler.assignTheme.connect(self.handle_assign_scene)
        self.js_handler.removeHighlight.connect(self.handle_remove_highlight)
        self.js_handler.contentChanged.connect(self.on_content_changed)
        self.js_handler.navigateToAnnotationRequested.connect(self.main_window.handle_navigate_to_annotation)
        self.js_handler.storyboardNavigationRequested.connect(self.main_window.handle_storyboard_navigation)
        self.js_handler.aiQueryRequested.connect(self.handle_ai_query)
    
        # Connect for annotation updates
        self.annotation_updated.connect(self.handle_annotation_update)

        # PyQt sticky header - DISABLED in favor of DOM-based version
        # print("[DEBUG] Creating sticky header widget")
        # self.sticky_header = StickyThemeHeader(self)
        # self.sticky_header.setParent(self)
        # self.sticky_header.hide()  # Initially hidden
        # print(f"[DEBUG] Sticky header created - enabled: {self.sticky_header_enabled}")
        
        # # Connect sticky header signals
        # self.js_handler.showStickyHeaderRequested.connect(self.show_sticky_header)
        # self.js_handler.hideStickyHeaderRequested.connect(self.hide_sticky_header)
        # self.sticky_header.theme_visibility_toggled.connect(self.toggle_theme_highlights_visibility)
        # print("[DEBUG] Sticky header signals connected")

        # # Add F1 shortcut for search
        # self.search_shortcut = QShortcut(QKeySequence("F1"), self)
        # self.search_shortcut.activated.connect(self.search_selected_text)

        # Set up a timer for periodic content checks
        self.content_check_timer = QTimer(self)
        self.content_check_timer.timeout.connect(self.check_content)
        self.content_check_timer.start(1000)

        # Make the content editable and initialize web view when page loads
        self.page().loadFinished.connect(self.initialize_web_view)

        # Add keyboard event handler for Ctrl key detection
        self.installEventFilter(self)

        # Keyboard shortcut: Ctrl+Z to undo last removal (within 5 minutes)
        try:
            self.undo_shortcut = QShortcut(QKeySequence("Ctrl+Z"), self)
            self.undo_shortcut.activated.connect(self.undo_last_removal)
            print("[UNDO] Successfully registered Ctrl+Z shortcut!")
        except Exception as _e:
            print(f"[UNDO] Failed to register Ctrl+Z shortcut: {_e}")
        
        # Keyboard shortcut: Ctrl+Shift+Z to redo last undone action (within 5 minutes)
        # TEMPORARILY DISABLED - DOM corruption issue
        # try:
        #     self.redo_shortcut = QShortcut(QKeySequence("Ctrl+Shift+Z"), self)
        #     self.redo_shortcut.activated.connect(self.redo_last_action)
        #     print("[REDO] Successfully registered Ctrl+Shift+Z shortcut!")
        # except Exception as _e:
        #     print(f"[REDO] Failed to register Ctrl+Shift+Z shortcut: {_e}")

        # Initial HTML content with QWebChannel script
        initial_html = '''
            <!DOCTYPE html>
            <html>
            <head>
                <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
            </head>
            <body>
            </body>
            </html>
        '''
        self.setHtml(initial_html)

    def undo_last_removal(self):
        """Undo the last removal operation if within 5 minutes."""
        print("[UNDO] undo_last_removal method called!")
        print(f"[UNDO] Current annotations count: {len(self.annotations)}")
        print(f"[UNDO] Undo stack size: {len(self._undo_stack)}")
        try:
            import time
            current_time = time.time()
            print(f"[UNDO] Current time: {current_time}")
            print(f"[UNDO] Undo stack size: {len(self._undo_stack)}")
            
            # Check if we have any undo entries
            if not self._undo_stack:
                print("[UNDO] No removal operations to undo")
                return
            
            # Get the most recent removal
            last_undo = self._undo_stack[-1]
            
            # Check if it's within 5 minutes (300 seconds)
            if current_time - last_undo['ts'] > 300:
                print("[UNDO] Last removal is older than 5 minutes, cannot undo")
                # Clear old undo entries
                self._undo_stack = []
                return
            
            # Handle both 'remove' and 'restore' type operations
            if last_undo['type'] not in ['remove', 'restore']:
                print(f"[UNDO] Unsupported undo type: {last_undo['type']}")
                return
            
            # If it's a 'restore' type (from redo), we need to restore highlights
            # If it's a 'remove' type (from normal operations), we also restore highlights
            # Both cases mean "undo a removal" = "restore highlights"
            
            payload = last_undo['payload']
            removed_spans = payload.get('removedSpans', [])
            updated_spans = payload.get('updatedSpans', [])
            annotations = payload.get('annotations', [])
            
            print(f"[UNDO] Restoring {len(removed_spans)} removed spans and {len(annotations)} annotations")
            
            # Restore annotations to the data model first (we'll remove them later if highlighting fails)
            temp_restored_annotations = []
            for annotation in annotations:
                # Check if annotation already exists (to avoid duplicates)
                existing = next((a for a in self.annotations if a.get('id') == annotation.get('id')), None)
                if not existing:
                    self.annotations.append(annotation)
                    temp_restored_annotations.append(annotation)
                    print(f"[UNDO] Temporarily restored annotation: {annotation.get('id')}")
            
            # Try to restore highlights in DOM and track which ones actually get added
            successfully_highlighted = []
            failed_to_highlight = []
            
            print(f"[UNDO] Attempting to restore {len(removed_spans)} highlights")
            
            for span in removed_spans:
                annotation_id = span.get('originalId') or span.get('annotationId')
                text = span.get('text', '')
                scene = span.get('scene', '')
                
                if annotation_id and text and scene:
                    # Find the corresponding annotation for full metadata
                    annotation = next((a for a in annotations if a.get('id') == annotation_id), None)
                    if annotation:
                        print(f"[UNDO] Attempting to highlight text for annotation {annotation_id}")
                        
                        # Try to highlight and check if it was actually added
                        self.highlight_text(text, scene, annotation_id, annotation)
                        
                        # Small delay to let the DOM update before checking
                        time.sleep(0.1)
                        
                        # Check if the highlight was actually added to the DOM
                        if self.check_if_highlight_exists_in_dom(annotation_id):
                            successfully_highlighted.append(span)
                            print(f"[UNDO] Successfully highlighted annotation {annotation_id}")
                        else:
                            failed_to_highlight.append(span)
                            print(f"[UNDO] Failed to highlight annotation {annotation_id} - DOM rejected it (likely overlap)")
            
            print(f"[UNDO] Highlight results: {len(successfully_highlighted)} successful, {len(failed_to_highlight)} failed")
            
            # Remove annotations from data model if their highlights failed
            if failed_to_highlight:
                failed_annotation_ids = set()
                for span in failed_to_highlight:
                    annotation_id = span.get('originalId') or span.get('annotationId')
                    if annotation_id:
                        failed_annotation_ids.add(annotation_id)
                
                # Remove failed annotations from self.annotations
                self.annotations = [a for a in self.annotations if a.get('id') not in failed_annotation_ids]
                print(f"[UNDO] Removed {len(failed_annotation_ids)} annotations that failed to highlight")
                
                # Show popup to inform user about blocked undo
                if len(failed_to_highlight) == len(removed_spans):
                    print(f"[UNDO] All {len(failed_to_highlight)} highlights were blocked by overlaps")
                    from PyQt6.QtWidgets import QMessageBox
                    msg = QMessageBox()
                    msg.setIcon(QMessageBox.Icon.Information)
                    msg.setWindowTitle("Undo Blocked")
                    msg.setText(f"Cannot undo: All {len(failed_to_highlight)} text segments overlap with existing highlights.")
                    msg.setInformativeText("Remove the overlapping highlights first, then try undo again.")
                    msg.exec()
                else:
                    print(f"[UNDO] Partial success: {len(successfully_highlighted)} restored, {len(failed_to_highlight)} blocked")
                    from PyQt6.QtWidgets import QMessageBox
                    msg = QMessageBox()
                    msg.setIcon(QMessageBox.Icon.Information)
                    msg.setWindowTitle("Partial Undo")
                    msg.setText(f"Partially restored: {len(successfully_highlighted)} highlights restored, {len(failed_to_highlight)} blocked by overlaps.")
                    msg.exec()
            
            # Update theme view only for successfully highlighted annotations
            successfully_highlighted_ids = set()
            for span in successfully_highlighted:
                annotation_id = span.get('originalId') or span.get('annotationId')
                if annotation_id:
                    successfully_highlighted_ids.add(annotation_id)
            
            for annotation in annotations:
                if annotation.get('id') in successfully_highlighted_ids:
                    self.annotation_added.emit(json.dumps(annotation))
            
            # Move this undo entry to redo stack only if something was actually restored
            if successfully_highlighted:
                undo_entry = self._undo_stack.pop()
                # Convert to redo entry (reverse operation)
                redo_entry = {
                    'ts': time.time(),
                    'type': 'restore',  # redo means re-removing what we just restored
                    'payload': {
                        'removedSpans': successfully_highlighted,  # Only spans that were actually restored
                        'annotations': [a for a in annotations if a.get('id') in successfully_highlighted_ids]
                    }
                }
                self._redo_stack.append(redo_entry)
                
                # Clear redo stack if it gets too large
                if len(self._redo_stack) > 20:
                    self._redo_stack = self._redo_stack[-20:]
                
                print(f"[UNDO] Successfully restored {len(successfully_highlighted_ids)} annotations, moved to redo stack")
            else:
                print(f"[UNDO] No highlights were restored, keeping undo entry in stack")
            
        except Exception as e:
            print(f"[UNDO] Error during undo operation: {e}")
            import traceback
            traceback.print_exc()
    
    def redo_last_action(self):
        """Redo the last undone operation if within 5 minutes."""
        print("[REDO] redo_last_action method called!")
        print(f"[REDO] Current annotations count: {len(self.annotations)}")
        print(f"[REDO] Redo stack size: {len(self._redo_stack)}")
        try:
            import time
            current_time = time.time()
            print(f"[REDO] Current time: {current_time}")
            
            # Check if we have any redo entries
            if not self._redo_stack:
                print("[REDO] No operations to redo")
                return
            
            # Get the most recent redo
            last_redo = self._redo_stack[-1]
            
            # Check if it's within 5 minutes (300 seconds)
            if current_time - last_redo['ts'] > 300:
                print("[REDO] Last redo is older than 5 minutes, cannot redo")
                # Clear old redo entries
                self._redo_stack = []
                return
            
            # Only handle 'restore' type operations for now
            if last_redo['type'] != 'restore':
                print(f"[REDO] Unsupported redo type: {last_redo['type']}")
                return
            
            payload = last_redo['payload']
            removed_spans = payload.get('removedSpans', [])
            annotations = payload.get('annotations', [])
            
            print(f"[REDO] Re-removing {len(removed_spans)} spans and {len(annotations)} annotations")
            
            # Track which annotations were successfully removed from DOM
            successfully_removed_spans = []
            failed_to_remove_spans = []
            
            print(f"[REDO] Attempting to remove {len(removed_spans)} highlights from DOM")
            
            # Try to remove highlights from DOM and track success
            for span in removed_spans:
                annotation_id = span.get('originalId') or span.get('annotationId')
                if annotation_id:
                    print(f"[REDO] Attempting to remove highlights for annotation {annotation_id}")
                    
                    # Use JavaScript to remove highlights with this annotation ID
                    def escape_js_string(s):
                        return str(s).replace('\\', '\\\\').replace('"', '\\"').replace("'", "\\'")
                    
                    escaped_id = escape_js_string(annotation_id)
                    js_code = f'''
                    (function() {{
                        try {{
                            var spans = document.querySelectorAll('span[data-annotation-id="{escaped_id}"]');
                            console.log("Removing " + spans.length + " spans for annotation {escaped_id}");
                            var removedCount = 0;
                            for (var i = 0; i < spans.length; i++) {{
                                var span = spans[i];
                                var parent = span.parentNode;
                                // Replace span with its text content
                                var textNode = document.createTextNode(span.textContent);
                                parent.replaceChild(textNode, span);
                                removedCount++;
                            }}
                            return removedCount;
                        }} catch (e) {{
                            console.error("Error removing spans:", e);
                            return 0;
                        }}
                    }})();
                    '''
                    # Execute JavaScript synchronously and get result
                    removal_result = {'removed_count': 0, 'completed': False}
                    
                    def handle_removal_result(result):
                        removal_result['removed_count'] = int(result) if result else 0
                        removal_result['completed'] = True
                        print(f"[REDO] JavaScript returned: removed {result} spans for {annotation_id}")
                    
                    self.page().runJavaScript(js_code, handle_removal_result)
                    
                    # Wait for JavaScript to complete
                    max_wait = 50  # 500ms total wait
                    wait_count = 0
                    while not removal_result['completed'] and wait_count < max_wait:
                        time.sleep(0.01)
                        wait_count += 1
                        from PyQt6.QtWidgets import QApplication
                        QApplication.processEvents()
                    
                    # Check success based on JavaScript result and DOM verification
                    if removal_result['completed'] and removal_result['removed_count'] > 0:
                        # Double-check with DOM verification
                        time.sleep(0.1)  # Small additional delay
                        if not self.check_if_highlight_exists_in_dom(annotation_id):
                            successfully_removed_spans.append(span)
                            print(f"[REDO] Successfully removed highlights for annotation {annotation_id}")
                        else:
                            failed_to_remove_spans.append(span)
                            print(f"[REDO] JavaScript reported removal but DOM still contains annotation {annotation_id}")
                    else:
                        failed_to_remove_spans.append(span)
                        print(f"[REDO] JavaScript failed to remove annotation {annotation_id}")
            
            print(f"[REDO] Removal results: {len(successfully_removed_spans)} successful, {len(failed_to_remove_spans)} failed")
            
            # Remove annotations from data model only for successfully removed highlights
            successfully_removed_ids = set()
            for span in successfully_removed_spans:
                annotation_id = span.get('originalId') or span.get('annotationId')
                if annotation_id:
                    successfully_removed_ids.add(annotation_id)
            
            # Remove only successfully removed annotations from self.annotations
            self.annotations = [a for a in self.annotations if a.get('id') not in successfully_removed_ids]
            print(f"[REDO] Removed {len(successfully_removed_ids)} annotations from data model")
            
            # Show user feedback if some operations failed
            if failed_to_remove_spans:
                if len(failed_to_remove_spans) == len(removed_spans):
                    print(f"[REDO] All {len(failed_to_remove_spans)} highlight removals were blocked")
                    from PyQt6.QtWidgets import QMessageBox
                    msg = QMessageBox()
                    msg.setIcon(QMessageBox.Icon.Information)
                    msg.setWindowTitle("Redo Blocked")
                    msg.setText(f"Cannot redo: All {len(failed_to_remove_spans)} highlights could not be removed.")
                    msg.setInformativeText("The highlights may be protected or in use.")
                    msg.exec()
                else:
                    print(f"[REDO] Partial success: {len(successfully_removed_spans)} removed, {len(failed_to_remove_spans)} failed")
                    from PyQt6.QtWidgets import QMessageBox
                    msg = QMessageBox()
                    msg.setIcon(QMessageBox.Icon.Information)
                    msg.setWindowTitle("Partial Redo")
                    msg.setText(f"Partially completed: {len(successfully_removed_spans)} highlights removed, {len(failed_to_remove_spans)} could not be removed.")
                    msg.exec()
            
            # Update theme view to remove annotations (only successfully removed ones)
            for annotation in annotations:
                if annotation.get('id') in successfully_removed_ids:
                    annotation_id = annotation.get('id')
                    scene = annotation.get('scene', '')
                    print(f"[REDO] Removing annotation {annotation_id} from theme view scene {scene}")
                    
                    # Remove from theme view using the same logic as normal removal
                    main_window = self.window()
                    if main_window and hasattr(main_window, 'scene_tabs') and main_window.scene_tabs:
                        try:
                            # Find the right tab for this scene
                            for i in range(main_window.scene_tabs.count()):
                                tab = main_window.scene_tabs.widget(i)
                                tab_name = main_window.scene_tabs.tabText(i)
                                
                                if tab_name == scene:
                                    list_widget = tab
                                    
                                    # Find and remove the annotation item
                                    for j in range(list_widget.count()):
                                        item = list_widget.item(j)
                                        if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                                            list_widget.takeItem(j)
                                            print(f"[REDO] Successfully removed annotation {annotation_id} from theme view")
                                            break
                                    break
                        except Exception as e:
                            print(f"[REDO] Error removing annotation {annotation_id} from theme view: {e}")
            
            # Move this redo entry back to undo stack only if something was actually removed
            if successfully_removed_spans:
                redo_entry = self._redo_stack.pop()
                # Convert back to undo entry with only successfully removed spans
                undo_entry = {
                    'ts': time.time(),
                    'type': 'remove',  # This represents a removal that can be undone (restored)
                    'payload': {
                        'removedSpans': successfully_removed_spans,
                        'updatedSpans': [],  # Add this field for consistency
                        'selectionInfo': {},  # Add this field for consistency  
                        'annotations': [a for a in annotations if a.get('id') in successfully_removed_ids]
                    }
                }
                self._undo_stack.append(undo_entry)
                
                # Clear undo stack if it gets too large
                if len(self._undo_stack) > 20:
                    self._undo_stack = self._undo_stack[-20:]
                
                print(f"[REDO] Successfully removed {len(successfully_removed_ids)} annotations, moved to undo stack")
            else:
                print(f"[REDO] No highlights were removed, keeping redo entry in stack")
            
        except Exception as e:
            print(f"[REDO] Error during redo operation: {e}")
            import traceback
            traceback.print_exc()
    
    def check_highlight_overlap(self, text, speech_content_id=None):
        """
        Check if highlighting the given text would overlap with existing highlights.
        Uses JavaScript to simulate text selection and check for intersections.
        Only checks within the specified speech-content container for performance.
        
        Args:
            text: Text to check for overlap
            speech_content_id: ID of speech-content container to limit search to
        
        Returns True if overlap detected, False otherwise.
        """
        try:
            import time
            from PyQt6.QtCore import QEventLoop
            
            # Escape the text for JavaScript
            def escape_js_string(s):
                return (
                    str(s).replace('\\', '\\\\')
                     .replace('"', '\\"')
                     .replace("'", "\\'")
                     .replace('\n', '\\n')
                     .replace('\r', '\\r')
                )
            
            escaped_text = escape_js_string(text)
            escaped_speech_content_id = escape_js_string(speech_content_id) if speech_content_id else 'null'
            
            # JavaScript code to check for overlap with existing data-annotation-id spans
            js_code = f"""
            (function() {{
                try {{
                    var searchText = "{escaped_text}";
                    var speechContentId = {escaped_speech_content_id if speech_content_id else 'null'};
                    console.log("Checking overlap for text:", searchText.substring(0, 50) + "...");
                    console.log("Limiting search to speech-content container:", speechContentId);
                    
                    // Find the specific speech-content container if specified
                    var searchContainer = document.body;
                    if (speechContentId && speechContentId !== 'null' && speechContentId !== 'no-container') {{
                        var speechContentElement = document.getElementById(speechContentId);
                        if (speechContentElement) {{
                            searchContainer = speechContentElement;
                            console.log("Found speech-content container, limiting search");
                        }} else {{
                            // Try to find by class if ID doesn't work
                            var speechContents = document.querySelectorAll('.speech-content');
                            for (var i = 0; i < speechContents.length; i++) {{
                                if (speechContents[i].id === speechContentId) {{
                                    searchContainer = speechContents[i];
                                    break;
                                }}
                            }}
                        }}
                    }}
                    
                    // Get existing highlight spans only within the search container
                    var existingSpans = searchContainer.querySelectorAll('span[data-annotation-id]');
                    console.log("Found", existingSpans.length, "existing highlighted spans in container");
                    
                    if (existingSpans.length === 0) {{
                        console.log("No existing highlights found in container - no overlap possible");
                        return false;
                    }}
                    
                    // Try to find where our text would be positioned in the container
                    var walker = document.createTreeWalker(
                        searchContainer,
                        NodeFilter.SHOW_TEXT,
                        null,
                        false
                    );
                    
                    var textNode;
                    while (textNode = walker.nextNode()) {{
                        var nodeText = textNode.textContent;
                        var index = nodeText.indexOf(searchText);
                        
                        if (index !== -1) {{
                            // Found our text - create a range to represent where it would be highlighted
                            var range = document.createRange();
                            range.setStart(textNode, index);
                            range.setEnd(textNode, index + searchText.length);
                            
                            // Check if this range intersects with any existing highlight spans
                            for (var i = 0; i < existingSpans.length; i++) {{
                                var span = existingSpans[i];
                                try {{
                                    if (range.intersectsNode(span)) {{
                                        var spanText = span.textContent || span.innerText || '';
                                        var annotationId = span.getAttribute('data-annotation-id');
                                        console.log("OVERLAP DETECTED!");
                                        console.log("- New text:", searchText.substring(0, 50) + "...");
                                        console.log("- Existing span text:", spanText.substring(0, 50) + "...");
                                        console.log("- Existing annotation ID:", annotationId);
                                        return true;  // Overlap found
                                    }}
                                }} catch (e) {{
                                    console.warn("Error checking intersection with span:", e);
                                }}
                            }}
                            
                            console.log("Text found but no intersection with existing highlights");
                            break;  // Check only the first occurrence
                        }}
                    }}
                    
                    console.log("No overlap detected for text:", searchText.substring(0, 50) + "...");
                    return false;  // No overlap found
                    
                }} catch (e) {{
                    console.error("Error checking highlight overlap:", e);
                    return false;  // Assume no overlap on error
                }}
            }})();
            """
            
            # Use JavaScript to properly check for position-based overlaps
            print(f"[UNDO] Checking overlap for text: '{text[:50]}...' in container: {speech_content_id}")
            
            # Create a callback to handle JavaScript result
            overlap_result = {'detected': False, 'completed': False}
            
            def handle_js_result(result):
                overlap_result['detected'] = bool(result)
                overlap_result['completed'] = True
                print(f"[UNDO] JavaScript overlap check result: {result}")
            
            # Execute JavaScript to check for actual DOM overlaps
            self.transcript_web_view.page().runJavaScript(js_code, handle_js_result)
            
            # Wait for JavaScript to complete (with timeout)
            import time
            max_wait = 2.0  # Wait up to 2 seconds
            waited = 0.0
            wait_step = 0.1
            
            while waited < max_wait and not overlap_result['completed']:
                time.sleep(wait_step)
                waited += wait_step
                # Process Qt events to allow JavaScript callback to execute
                from PyQt6.QtWidgets import QApplication
                QApplication.processEvents()
            
            if overlap_result['completed']:
                if overlap_result['detected']:
                    print(f"[UNDO] Real DOM overlap detected for text: '{text[:50]}...'")
                    return True
                else:
                    print(f"[UNDO] No DOM overlap detected for text: '{text[:50]}...'")
                    return False
            else:
                print(f"[UNDO] JavaScript timeout - assuming no overlap for safety")
                return False
                
        except Exception as e:
            print(f"[UNDO] Error checking highlight overlap: {e}")
            return False  # Assume no overlap on error
    
    def check_highlight_overlap_with_context(self, text, speech_content_id=None, text_context='', text_position=-1):
        """
        Check if highlighting the given text would overlap with existing highlights using context and position.
        Much more accurate than the basic version.
        
        Args:
            text: Text to check for overlap
            speech_content_id: ID of speech-content container to limit search to
            text_context: Surrounding text context for accurate positioning
            text_position: Position of text within the speech-content container
        
        Returns True if overlap detected, False otherwise.
        """
        try:
            print(f"[UNDO] Context-based overlap check for text: '{text[:50]}...' at position {text_position}")
            
            # If we have position info, use it for much more accurate detection
            if text_position >= 0 and speech_content_id and speech_content_id != 'no-container':
                
                # Use JavaScript to check for overlaps at the specific position
                def escape_js_string(s):
                    return (
                        str(s).replace('\\', '\\\\')
                         .replace('"', '\\"')
                         .replace("'", "\\'")
                         .replace('\n', '\\n')
                         .replace('\r', '\\r')
                    )
                
                escaped_text = escape_js_string(text)
                escaped_context = escape_js_string(text_context)
                escaped_speech_id = escape_js_string(speech_content_id) if speech_content_id else 'null'
                
                js_code = f"""
                (function() {{
                    try {{
                        var searchText = "{escaped_text}";
                        var textContext = "{escaped_context}";
                        var textPosition = {text_position};
                        var speechContentId = "{escaped_speech_id}";
                        
                        console.log("Context-based overlap check for:", searchText.substring(0, 50), "at position", textPosition);
                        
                        // Find the speech-content container
                        var container = document.getElementById(speechContentId);
                        if (!container) {{
                            var containers = document.querySelectorAll('.speech-content');
                            for (var i = 0; i < containers.length; i++) {{
                                if (containers[i].id === speechContentId) {{
                                    container = containers[i];
                                    break;
                                }}
                            }}
                        }}
                        
                        if (!container) {{
                            console.log("No container found for speech-content ID:", speechContentId);
                            return false;
                        }}
                        
                        // Get existing highlights in this container
                        var existingSpans = container.querySelectorAll('span[data-annotation-id]');
                        console.log("Found", existingSpans.length, "existing highlights in container");
                        
                        if (existingSpans.length === 0) {{
                            return false;
                        }}
                        
                        // Calculate approximate start/end positions for our text
                        var containerText = container.textContent;
                        var searchStart = textPosition;
                        var searchEnd = textPosition + searchText.length;
                        
                        console.log("Search range:", searchStart, "-", searchEnd, "in container of length", containerText.length);
                        
                        // Check each existing highlight for position overlap
                        for (var i = 0; i < existingSpans.length; i++) {{
                            var span = existingSpans[i];
                            var spanText = span.textContent;
                            var spanStart = containerText.indexOf(spanText);
                            var spanEnd = spanStart + spanText.length;
                            
                            // Check for position overlap
                            if (spanStart !== -1 && 
                                (searchStart < spanEnd && searchEnd > spanStart)) {{
                                console.log("POSITION OVERLAP DETECTED!");
                                console.log("- New text:", searchText.substring(0, 30), "at", searchStart, "-", searchEnd);
                                console.log("- Existing text:", spanText.substring(0, 30), "at", spanStart, "-", spanEnd);
                                return true;
                            }}
                        }}
                        
                        console.log("No position-based overlap detected");
                        return false;
                        
                    }} catch (e) {{
                        console.error("Error in context-based overlap check:", e);
                        return false;
                    }}
                }})();
                """
                
                # Create a callback to handle JavaScript result
                overlap_result = {'detected': False, 'completed': False}
                
                def handle_js_result(result):
                    overlap_result['detected'] = bool(result)
                    overlap_result['completed'] = True
                    print(f"[UNDO] Context-based JavaScript result: {result}")
                
                # Execute JavaScript
                self.transcript_web_view.page().runJavaScript(js_code, handle_js_result)
                
                # Wait for JavaScript to complete
                import time
                max_wait = 2.0
                waited = 0.0
                wait_step = 0.1
                
                while waited < max_wait and not overlap_result['completed']:
                    time.sleep(wait_step)
                    waited += wait_step
                    from PyQt6.QtWidgets import QApplication
                    QApplication.processEvents()
                
                if overlap_result['completed']:
                    result = overlap_result['detected']
                    print(f"[UNDO] Context-based overlap result: {result}")
                    return result
                else:
                    print(f"[UNDO] Context-based check timeout - assuming no overlap")
                    return False
            else:
                # Fallback to basic text-based checking if no position info
                print(f"[UNDO] No position info, falling back to basic text check")
                return self.check_highlight_overlap(text, speech_content_id)
                
        except Exception as e:
            print(f"[UNDO] Error in context-based overlap check: {e}")
            return False
    
    def check_if_highlight_exists_in_dom(self, annotation_id):
        """
        Check if a highlight with the given annotation-id actually exists in the DOM.
        Returns True if found, False otherwise.
        """
        try:
            from PyQt6.QtCore import QEventLoop
            from PyQt6.QtWidgets import QApplication
            
            def escape_js_string(s):
                return str(s).replace('\\', '\\\\').replace('"', '\\"').replace("'", "\\'")
            
            escaped_id = escape_js_string(annotation_id)
            
            js_code = f"""
            (function() {{
                try {{
                    var spans = document.querySelectorAll('span[data-annotation-id="{escaped_id}"]');
                    console.log("Checking for annotation-id '{escaped_id}': found", spans.length, "spans");
                    return spans.length > 0;
                }} catch (e) {{
                    console.error("Error checking DOM for annotation:", e);
                    return false;
                }}
            }})();
            """
            
            # Use synchronous approach with event loop
            result_container = {'result': None, 'finished': False}
            
            def handle_result(result):
                result_container['result'] = bool(result)
                result_container['finished'] = True
                print(f"[UNDO] DOM check for {annotation_id}: {result}")
            
            # Execute JavaScript
            self.page().runJavaScript(js_code, handle_result)
            
            # Process events until we get a result or timeout
            loop = QEventLoop()
            max_iterations = 100  # About 1 second with 10ms delays
            iterations = 0
            
            while not result_container['finished'] and iterations < max_iterations:
                QApplication.processEvents(QEventLoop.ProcessEventsFlag.AllEvents, 10)
                iterations += 1
            
            if result_container['finished']:
                return result_container['result']
            else:
                print(f"[UNDO] DOM check timeout for {annotation_id} - assuming not exists")
                return False
                
        except Exception as e:
            print(f"[UNDO] Error checking DOM for annotation {annotation_id}: {e}")
            return False

    def handle_ai_query(self, selected_text, title):
        """Handle AI query request from JavaScript."""
        def handle_section_info_result(result):
            """Handle the section information extracted from JavaScript."""
            speech_section = ""
            
            if isinstance(result, dict):
                # Extract speech section header
                speech_section = result.get('header', '')
            
            try:
                # Reuse existing dialog or create new one
                if self.main_window._ai_query_dialog is None:
                    # Create new dialog
                    self.main_window._ai_query_dialog = AIQueryDialog(self, selected_text, title, speech_section, self.main_window)
                    self.main_window._ai_query_dialog.show()
                else:
                    # Refresh existing dialog with new content
                    self.main_window._ai_query_dialog.refresh_with_new_content(selected_text, title, speech_section)
            except Exception as e:
                print(f"Error opening AI query dialog: {e}")
                QMessageBox.critical(self, "Error", f"Failed to open AI query dialog: {str(e)}")
        
        # Extract speech section information using JavaScript
        js_code = '''
        (function() {
            var speechSection = '';
            
            // Get current selection to find which speech section it's in
            var selection = window.getSelection();
            if (selection.rangeCount > 0) {
                var range = selection.getRangeAt(0);
                var container = range.commonAncestorContainer;
                
                // Find the closest speech article
                var element = container.nodeType === Node.TEXT_NODE ? container.parentNode : container;
                var speechArticle = element.closest ? element.closest('.speech') : null;
                
                if (speechArticle) {
                    var speechTitle = speechArticle.querySelector('.speech-title');
                    if (speechTitle) {
                        speechSection = speechTitle.textContent.trim();
                    }
                }
            }
            
            return {
                header: speechSection
            };
        })();
        '''
        self.page().runJavaScript(js_code, handle_section_info_result)
    
    def handle_ai_query_with_section(self, selected_text, title, speech_section):
        """Handle AI query request with speech section information."""
        try:
            # Reuse existing dialog or create new one
            if self.main_window._ai_query_dialog is None:
                # Create new dialog
                self.main_window._ai_query_dialog = AIQueryDialog(self, selected_text, title, speech_section, self.main_window)
                self.main_window._ai_query_dialog.show()
            else:
                # Refresh existing dialog with new content
                self.main_window._ai_query_dialog.refresh_with_new_content(selected_text, title, speech_section)
        except Exception as e:
            print(f"Error opening AI query dialog: {e}")
            QMessageBox.critical(self, "Error", f"Failed to open AI query dialog: {str(e)}")

    def handle_ai_query_from_menu(self, selected_text):
        """Handle AI query request from context menu."""
        def handle_section_info_result(result):
            """Handle the section information extracted from JavaScript."""
            title = "Untitled Document"
            speech_section = ""
            
            if isinstance(result, dict):
                # Extract title from document
                title = result.get('title', 'Untitled Document')
                # Extract speech section header
                speech_section = result.get('header', '')
            
            self.handle_ai_query_with_section(selected_text, title, speech_section)
        
        # Extract both title and speech section information using JavaScript
        js_code = '''
        (function() {
            var title = document.title || 'Untitled Document';
            var speechSection = '';
            
            // Get current selection to find which speech section it's in
            var selection = window.getSelection();
            if (selection.rangeCount > 0) {
                var range = selection.getRangeAt(0);
                var container = range.commonAncestorContainer;
                
                // Find the closest speech article
                var element = container.nodeType === Node.TEXT_NODE ? container.parentNode : container;
                var speechArticle = element.closest ? element.closest('.speech') : null;
                
                if (speechArticle) {
                    var speechTitle = speechArticle.querySelector('.speech-title');
                    if (speechTitle) {
                        speechSection = speechTitle.textContent.trim();
                    }
                }
            }
            
            return {
                title: title,
                header: speechSection
            };
        })();
        '''
        self.page().runJavaScript(js_code, handle_section_info_result)

    def handle_live_voice_chat_from_menu(self, selected_text):
        """Handle Voice Chat request from context menu."""
        def handle_section_info_result(result):
            """Handle the section information extracted from JavaScript."""
            title = "Untitled Document"
            speech_section = ""
            expanded_context = selected_text
            
            if isinstance(result, dict):
                # Extract title from document
                title = result.get('title', 'Untitled Document')
                # Extract speech section header
                speech_section = result.get('header', '')
                # Extract expanded context
                expanded_context = result.get('expandedContext', selected_text)
            
            # Create or update VoiceChatDialog
            try:
                if self.voice_chat_dialog is None or not self.voice_chat_dialog.isVisible():
                    # Create new dialog if none exists or previous one was closed
                    self.voice_chat_dialog = VoiceChatDialog(
                        parent=self,
                        selected_text=selected_text,
                        expanded_context=expanded_context,
                        title=title,
                        speech_section=speech_section,
                        main_window=self.main_window
                    )
                    self.voice_chat_dialog.show()
                    print("Created new voice chat dialog")
                else:
                    # Update existing dialog with new context
                    self.voice_chat_dialog.update_context(selected_text, title, speech_section, expanded_context)
                    self.voice_chat_dialog.raise_()  # Bring to front
                    self.voice_chat_dialog.activateWindow()  # Give it focus
                    print("Updated existing voice chat dialog")
            except Exception as e:
                print(f"Error opening Voice Chat dialog: {e}")
                QMessageBox.critical(self, "Error", f"Failed to open Voice Chat dialog: {str(e)}")
        
        # Extract title, speech section, and expand context using JavaScript
        js_code = '''
        (function() {
            var title = document.title || 'Untitled Document';
            var speechSection = '';
            var expandedContext = '';
            var originalSelection = '';
            
            // Get current selection to find which speech section it's in
            var selection = window.getSelection();
            if (selection.rangeCount > 0) {
                var range = selection.getRangeAt(0);
                originalSelection = selection.toString();
                var container = range.commonAncestorContainer;
                
                // Find the closest speech article
                var element = container.nodeType === Node.TEXT_NODE ? container.parentNode : container;
                var speechArticle = element.closest ? element.closest('.speech') : null;
                
                if (speechArticle) {
                    var speechTitle = speechArticle.querySelector('.speech-title');
                    if (speechTitle) {
                        speechSection = speechTitle.textContent.trim();
                    }
                }
                
                // Expand context by 350 characters before and after
                var textContent = document.body.textContent || document.body.innerText || '';
                var selectionStart = textContent.indexOf(originalSelection);
                
                if (selectionStart !== -1) {
                    var expandStart = Math.max(0, selectionStart - 350);
                    var expandEnd = Math.min(textContent.length, selectionStart + originalSelection.length + 350);
                    expandedContext = textContent.substring(expandStart, expandEnd);
                } else {
                    expandedContext = originalSelection;
                }
            }
            
            return {
                title: title,
                header: speechSection,
                expandedContext: expandedContext,
                originalSelection: originalSelection
            };
        })();
        '''
        self.page().runJavaScript(js_code, handle_section_info_result)

    def handle_quick_summary_from_menu(self, selected_text):
        """Handle quick AI summarize request from context menu."""
        def handle_section_info_result(result):
            """Handle the section information extracted from JavaScript."""
            title = "Untitled Document"
            speech_section = ""
            
            if isinstance(result, dict):
                # Extract title from document
                title = result.get('title', 'Untitled Document')
                # Extract speech section header
                speech_section = result.get('header', '')
            
            # Check if API key exists
            api_key_path = self._get_api_key_path_for_quick_summary()
            api_key = self._load_api_key_for_quick_summary(api_key_path)
            
            if not api_key:
                # Ask for API key
                api_key, ok = QInputDialog.getText(
                    self, 
                    "API Key Required", 
                    "Enter your Gemini API key for Quick Summarize:",
                    QLineEdit.EchoMode.Password
                )
                if not ok or not api_key.strip():
                    return
                api_key = api_key.strip()
                
                # Save the API key for future use
                self._save_api_key_for_quick_summary(api_key_path, api_key)
            
            # Create and show quick summary dialog with speech section
            dialog = QuickSummaryDialog(self, selected_text, title, api_key, speech_section)
            dialog.show()  # Non-modal dialog
        
        # Extract both title and speech section information using JavaScript
        js_code = '''
        (function() {
            var title = document.title || 'Untitled Document';
            var speechSection = '';
            
            // Get current selection to find which speech section it's in
            var selection = window.getSelection();
            if (selection.rangeCount > 0) {
                var range = selection.getRangeAt(0);
                var container = range.commonAncestorContainer;
                
                // Find the closest speech article
                var element = container.nodeType === Node.TEXT_NODE ? container.parentNode : container;
                var speechArticle = element.closest ? element.closest('.speech') : null;
                
                if (speechArticle) {
                    var speechTitle = speechArticle.querySelector('.speech-title');
                    if (speechTitle) {
                        speechSection = speechTitle.textContent.trim();
                    }
                }
            }
            
            return {
                title: title,
                header: speechSection
            };
        })();
        '''
        self.page().runJavaScript(js_code, handle_section_info_result)
    
    def _get_api_key_path_for_quick_summary(self):
        """Get API key path for quick summary functionality."""
        try:
            if getattr(sys, 'frozen', False):
                base_path = os.path.dirname(sys.executable)
            else:
                base_path = os.path.dirname(os.path.abspath(__file__))
            
            data_folder = os.path.join(base_path, "data")
            os.makedirs(data_folder, exist_ok=True)
            return os.path.join(data_folder, "api_key.txt")
        except Exception as e:
            print(f"Error determining API key path: {e}")
            return os.path.join(os.getcwd(), "api_key.txt")
    
    def _load_api_key_for_quick_summary(self, api_key_path):
        """Load API key for quick summary."""
        try:
            if os.path.exists(api_key_path):
                with open(api_key_path, "r", encoding='utf-8') as f:
                    key = f.read().strip()
                    if key and len(key) > 30:
                        return key
        except Exception as e:
            print(f"Error loading API key: {e}")
        return None
    
    def _save_api_key_for_quick_summary(self, api_key_path, api_key):
        """Save API key for quick summary."""
        try:
            data_folder = os.path.dirname(api_key_path)
            os.makedirs(data_folder, exist_ok=True)
            with open(api_key_path, "w", encoding='utf-8') as f:
                f.write(api_key)
            print(f"API Key saved to {api_key_path}")
        except Exception as e:
            print(f"Error saving API key: {e}")

    def handle_quick_explain_from_menu(self, selected_text):
        """Handle quick AI explain request from context menu."""
        def handle_section_info_result(result):
            """Handle the section information extracted from JavaScript."""
            title = "Untitled Document"
            speech_section = ""
            expanded_context = selected_text
            
            if isinstance(result, dict):
                # Extract title from document
                title = result.get('title', 'Untitled Document')
                # Extract speech section header
                speech_section = result.get('header', '')
                # Extract expanded context
                expanded_context = result.get('expandedContext', selected_text)
            
            # Check if API key exists
            api_key_path = self._get_api_key_path_for_quick_summary()
            api_key = self._load_api_key_for_quick_summary(api_key_path)
            
            if not api_key:
                # Ask for API key
                api_key, ok = QInputDialog.getText(
                    self, 
                    "API Key Required", 
                    "Enter your Gemini API key for Quick Explain:",
                    QLineEdit.EchoMode.Password
                )
                if not ok or not api_key.strip():
                    return
                api_key = api_key.strip()
                
                # Save the API key for future use
                self._save_api_key_for_quick_summary(api_key_path, api_key)
            
            # Create and show quick explain dialog with expanded context
            dialog = QuickExplainDialog(self, selected_text, expanded_context, title, api_key, speech_section)
            dialog.show()  # Non-modal dialog
        
        # Extract title, speech section, and expand context using JavaScript
        js_code = '''
        (function() {
            var title = document.title || 'Untitled Document';
            var speechSection = '';
            var expandedContext = '';
            var originalSelection = '';
            
            // Get current selection to find which speech section it's in
            var selection = window.getSelection();
            if (selection.rangeCount > 0) {
                var range = selection.getRangeAt(0);
                originalSelection = selection.toString();
                var container = range.commonAncestorContainer;
                
                // Find the closest speech article
                var element = container.nodeType === Node.TEXT_NODE ? container.parentNode : container;
                var speechArticle = element.closest('.speech');
                if (speechArticle) {
                    var speechTitle = speechArticle.querySelector('.speech-title');
                    if (speechTitle) {
                        speechSection = speechTitle.textContent.trim();
                    }
                }
                
                // Expand context by 350 characters before and after
                var textContent = document.body.textContent || document.body.innerText || '';
                var selectionStart = textContent.indexOf(originalSelection);
                
                if (selectionStart !== -1) {
                    var expandStart = Math.max(0, selectionStart - 350);
                    var expandEnd = Math.min(textContent.length, selectionStart + originalSelection.length + 350);
                    expandedContext = textContent.substring(expandStart, expandEnd);
                } else {
                    expandedContext = originalSelection;
                }
            }
            
            return {
                title: title,
                header: speechSection,
                expandedContext: expandedContext,
                originalSelection: originalSelection
            };
        })();
        '''
        
        self.page().runJavaScript(js_code, handle_section_info_result)

    def handle_quick_custom_from_menu(self, selected_text):
        """Handle quick AI custom request from context menu."""
        def handle_section_info_result(result):
            """Handle the section information extracted from JavaScript."""
            title = "Untitled Document"
            speech_section = ""
            expanded_context = selected_text
            
            if isinstance(result, dict):
                # Extract title from document
                title = result.get('title', 'Untitled Document')
                # Extract speech section header
                speech_section = result.get('header', '')
                # Extract expanded context
                expanded_context = result.get('expandedContext', selected_text)
            
            # Check if API key exists
            api_key_path = self._get_api_key_path_for_quick_summary()
            api_key = self._load_api_key_for_quick_summary(api_key_path)
            
            if not api_key:
                # Ask for API key
                api_key, ok = QInputDialog.getText(
                    self, 
                    "API Key Required", 
                    "Enter your Gemini API key for Preset Prompt:",
                    QLineEdit.EchoMode.Password
                )
                if not ok or not api_key.strip():
                    return
                api_key = api_key.strip()
                
                # Save the API key for future use
                self._save_api_key_for_quick_summary(api_key_path, api_key)
            
            # Create and show quick custom dialog with expanded context
            dialog = QuickCustomDialog(self, selected_text, expanded_context, title, api_key, speech_section)
            dialog.show()  # Non-modal dialog
        
        # Extract title, speech section, and expand context using JavaScript
        js_code = '''
        (function() {
            var title = document.title || 'Untitled Document';
            var speechSection = '';
            var expandedContext = '';
            var originalSelection = '';
            
            // Get current selection to find which speech section it's in
            var selection = window.getSelection();
            if (selection.rangeCount > 0) {
                originalSelection = selection.toString();
                
                // Find the speech section containing this selection
                var range = selection.getRangeAt(0);
                var container = range.commonAncestorContainer;
                
                // Walk up to find the speech section
                var element = container.nodeType === Node.TEXT_NODE ? container.parentNode : container;
                while (element && element !== document.body) {
                    if (element.querySelector && element.querySelector('.speech-section')) {
                        var headerEl = element.querySelector('.speech-section');
                        speechSection = headerEl.textContent || '';
                        break;
                    }
                    element = element.parentNode;
                }
                
                // Get expanded context (700 characters around selection)
                var textContent = document.body.textContent || document.body.innerText || '';
                var selectionStart = textContent.indexOf(originalSelection);
                if (selectionStart >= 0) {
                    var expandStart = Math.max(0, selectionStart - 350);
                    var expandEnd = Math.min(textContent.length, selectionStart + originalSelection.length + 350);
                    expandedContext = textContent.substring(expandStart, expandEnd);
                } else {
                    expandedContext = originalSelection;
                }
            }
            
            return {
                title: title,
                header: speechSection,
                expandedContext: expandedContext,
                originalSelection: originalSelection
            };
        })();
        '''
        
        self.page().runJavaScript(js_code, handle_section_info_result)

    def debug_and_fix_tooltips(self, on_complete=None):
        """Diagnose and fix tooltip issues, then invoke optional completion callback"""
        self.diagnose_tooltips()
        # Apply the fix after diagnostics
        self.apply_tooltip_fix(on_complete=on_complete)
    
    def inject_updated_notes_css(self):
        """Inject updated CSS to show info icons for both data-notes and data-notes-html attributes"""
        js_code = """
        (function() {
            // Find the existing style element or create a new one
            let styleElement = document.getElementById('notes-icon-fix-style');
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = 'notes-icon-fix-style';
                document.head.appendChild(styleElement);
            }
            
            // Updated CSS rules
            const updatedCSS = `
                /* Updated Info icon - Appears if either notes_html or notes has content */
                span[data-annotation-id][data-notes-html]:not([data-notes-html=""]):not([data-notes-html="null"])::before {
                    content: "ℹ";
                    background-color: #2196F3 !important;
                    left: -5px !important;
                    display: flex !important;
                    position: absolute !important;
                    top: -10px !important;
                    font-size: 10px !important;
                    color: white !important;
                    width: 12px !important;
                    height: 12px !important;
                    border-radius: 50% !important;
                    align-items: center !important;
                    justify-content: center !important;
                    line-height: 1 !important;
                    font-weight: bold !important;
                    pointer-events: none !important;
                    border: 1px solid white !important;
                    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2) !important;
                    z-index: 100 !important;
                    box-sizing: content-box !important;
                }
                
                span[data-annotation-id][data-notes]:not([data-notes=""]):not([data-notes="null"])::before {
                    content: "ℹ";
                    background-color: #2196F3 !important;
                    left: -5px !important;
                    display: flex !important;
                    position: absolute !important;
                    top: -10px !important;
                    font-size: 10px !important;
                    color: white !important;
                    width: 12px !important;
                    height: 12px !important;
                    border-radius: 50% !important;
                    align-items: center !important;
                    justify-content: center !important;
                    line-height: 1 !important;
                    font-weight: bold !important;
                    pointer-events: none !important;
                    border: 1px solid white !important;
                    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2) !important;
                    z-index: 100 !important;
                    box-sizing: content-box !important;
                }
                
                /* Updated Star Position Override - when both notes and notes_html are empty */
                span[data-annotation-id][data-favorite="true"][data-notes-html=""][data-notes=""]::after,
                span[data-annotation-id][data-favorite="true"][data-notes-html=""][data-notes="null"]::after,
                span[data-annotation-id][data-favorite="true"][data-notes-html="null"][data-notes=""]::after,
                span[data-annotation-id][data-favorite="true"][data-notes-html="null"][data-notes="null"]::after,
                span[data-annotation-id][data-favorite="true"]:not([data-notes-html])[data-notes=""]::after,
                span[data-annotation-id][data-favorite="true"]:not([data-notes-html])[data-notes="null"]::after,
                span[data-annotation-id][data-favorite="true"]:not([data-notes-html]):not([data-notes])::after,
                span[data-annotation-id][data-favorite="true"][data-notes-html=""]:not([data-notes])::after,
                span[data-annotation-id][data-favorite="true"][data-notes-html="null"]:not([data-notes])::after {
                    left: -5px !important;
                }

                /* Ensure star sits in adjacent slot when any notes exist (prevents overlap) */
                span[data-annotation-id][data-favorite="true"][data-notes]:not([data-notes=""]):not([data-notes="null"])::after,
                span[data-annotation-id][data-favorite="true"][data-notes-html]:not([data-notes-html=""]):not([data-notes-html="null"])::after {
                    left: 9px !important;
                }
            `;
            
            styleElement.textContent = updatedCSS;
            
            // Count how many annotations would be affected
            let notesCount = document.querySelectorAll('span[data-annotation-id][data-notes]:not([data-notes=""]):not([data-notes="null"])').length;
            let notesHtmlCount = document.querySelectorAll('span[data-annotation-id][data-notes-html]:not([data-notes-html=""]):not([data-notes-html="null"])').length;
            
            return {
                success: true,
                notesCount: notesCount,
                notesHtmlCount: notesHtmlCount,
                message: `CSS updated successfully. Found ${notesCount} annotations with data-notes and ${notesHtmlCount} with data-notes-html.`
            };
        })();
        """
        
        def handle_result(result):
            if result and result.get('success'):
                msg = result.get('message', 'CSS updated successfully')
                QMessageBox.information(self, "CSS Update", msg)
                print(f"[CSS UPDATE] {msg}")
            else:
                QMessageBox.warning(self, "CSS Update Failed", "Failed to update CSS")
                print("[CSS UPDATE] Failed to inject CSS")
        
        self.page().runJavaScript(js_code, handle_result)

    def diagnose_tooltips(self):
        """Run diagnostic checks on the tooltip functionality"""
        diagnostic_js = """
        (function() {
            // 1. Check if tooltip element exists
            var tooltip = document.querySelector('.notes-tooltip');
            var existsInDOM = tooltip !== null;
    
            // 2. Check for annotation spans
            var spans = document.querySelectorAll('span[data-annotation-id]');
    
            // 3. Check tooltip styles
            var tooltipStyles = null;
            if (tooltip) {
                tooltipStyles = {
                    display: window.getComputedStyle(tooltip).display,
                    visibility: window.getComputedStyle(tooltip).visibility,
                    opacity: window.getComputedStyle(tooltip).opacity,
                    zIndex: window.getComputedStyle(tooltip).zIndex,
                    position: window.getComputedStyle(tooltip).position
                };
            }
    
            // 4. Check if event listeners are attached
            var hasEventListeners = false;
            if (typeof window.hotkeyHandler !== 'undefined') {
                hasEventListeners = true;
            }
    
            // 5. Get a sample span for testing
            var sampleSpan = spans.length > 0 ? spans[0] : null;
            var sampleSpanInfo = null;
            if (sampleSpan) {
                sampleSpanInfo = {
                    id: sampleSpan.getAttribute('data-annotation-id'),
                    scene: sampleSpan.getAttribute('data-scene'),
                    notes: sampleSpan.getAttribute('data-notes'),
                    notesHtml: sampleSpan.getAttribute('data-notes-html'),
                    text: sampleSpan.textContent.substring(0, 50) + (sampleSpan.textContent.length > 50 ? '...' : '')
                };
            }
    
            return {
                tooltipExists: existsInDOM,
                spanCount: spans.length,
                tooltipStyles: tooltipStyles,
                hasEventListeners: hasEventListeners,
                sampleSpan: sampleSpanInfo,
                webChannelInitialized: typeof window.webChannelInitialized !== 'undefined',
                jsHandlerAvailable: typeof window.jsHandler !== 'undefined',
                // Add additional diagnostics for enhanced features
                tooltipsEnabled: typeof window.tooltipsEnabled !== 'undefined' ? window.tooltipsEnabled : true,
                tooltipPreferredPosition: window.tooltipPreferredPosition || 'left',
                tooltipShowDelay: window.tooltipShowDelay || 300,
                tooltipHideDelay: window.tooltipHideDelay || 400
            };
        })();
        """

        def show_diagnostic_results(results):
            if not results:
                print("Error: No diagnostic results returned")
                return
        
            print("\n=== TOOLTIP DIAGNOSTIC RESULTS ===")
            print(f"Tooltip element exists: {results.get('tooltipExists', False)}")
            print(f"Annotation spans found: {results.get('spanCount', 0)}")
    
            if results.get('tooltipStyles'):
                print("\nTooltip styles:")
                for style, value in results.get('tooltipStyles').items():
                    print(f"  {style}: {value}")
            
            print(f"\nEvent handlers attached: {results.get('hasEventListeners', False)}")
            print(f"Web channel initialized: {results.get('webChannelInitialized', False)}")
            print(f"JS Handler available: {results.get('jsHandlerAvailable', False)}")
        
            # Add enhanced feature diagnostics
            print(f"\nEnhanced Tooltip Features:")
            print(f"  Tooltips enabled: {results.get('tooltipsEnabled', True)}")
            print(f"  Preferred position: {results.get('tooltipPreferredPosition', 'right')}")
            print(f"  Show delay: {results.get('tooltipShowDelay', 300)}ms")
            print(f"  Hide delay: {results.get('tooltipHideDelay', 400)}ms")
    
            if results.get('sampleSpan'):
                print("\nSample annotation span:")
                for prop, value in results.get('sampleSpan').items():
                    print(f"  {prop}: {value}")
    
            # Based on results, provide recommendations
            if not results.get('tooltipExists'):
                print("\nRECOMMENDATION: Tooltip element not found in DOM. Ensure tooltip is properly created.")
    
            if results.get('spanCount') == 0:
                print("\nRECOMMENDATION: No annotation spans found. Check if annotations are properly created.")
        
            if results.get('tooltipStyles') and results.get('tooltipStyles').get('visibility') == 'hidden':
                print("\nRECOMMENDATION: Tooltip has 'visibility: hidden'. Check CSS rules.")
        
            if not results.get('hasEventListeners'):
                print("\nRECOMMENDATION: Event listeners not attached. Check event registration.")
        
            if not results.get('webChannelInitialized'):
                print("\nRECOMMENDATION: Web channel not initialized. Check QWebChannel setup.")
        
            print("=== END DIAGNOSTIC RESULTS ===\n")
    
            # Tooltip fix is only applied at startup, never during annotation creation

        self.page().runJavaScript(diagnostic_js, show_diagnostic_results)

    def apply_tooltip_fix(self, diagnostic_results=None, on_complete=None):
            """Apply fixes to make tooltips work properly with enhancements, then call on_complete"""

            # Preserve tooltip settings from diagnostic results if available
            js_settings = ""
            if diagnostic_results:
                js_settings = f"""
                    // Preserve existing tooltip settings if they exist
                    window.tooltipsEnabled = {str(diagnostic_results.get('tooltipsEnabled', True)).lower()};
                    window.tooltipPreferredPosition = "{diagnostic_results.get('tooltipPreferredPosition', 'left')}";
                    window.tooltipShowDelay = {diagnostic_results.get('tooltipShowDelay', 300)};
                    window.tooltipHideDelay = {diagnostic_results.get('tooltipHideDelay', 400)};
                    console.log("Preserved tooltip settings:", {{
                        tooltipsEnabled: window.tooltipsEnabled,
                        position: window.tooltipPreferredPosition,
                        showDelay: window.tooltipShowDelay,
                        hideDelay: window.tooltipHideDelay
                    }});
                """

            fix_js = f"""
            (function() {{
                console.log('Applying enhanced tooltip fixes with scrollable content...');

                // Prevent duplicate initialization of tooltip enhancer
                if (window.__tooltipEnhancerInitialized__) {{
                    console.log('DEBUG: Tooltip enhancer already initialized; skipping duplicate init');
                    return;
                }}
                window.__tooltipEnhancerInitialized__ = true;
                // Initialize tooltip control variables if they don't exist
                if (typeof window.tooltipsEnabled === 'undefined') window.tooltipsEnabled = true;
                if (typeof window.tooltipCtrlPressed === 'undefined') window.tooltipCtrlPressed = false;
                if (typeof window.tooltipPreferredPosition === 'undefined') window.tooltipPreferredPosition = "left";
                if (typeof window.tooltipShowDelay === 'undefined') window.tooltipShowDelay = 300;
                if (typeof window.tooltipHideDelay === 'undefined') window.tooltipHideDelay = 400;
                if (typeof window.tooltipShowTimer === 'undefined') window.tooltipShowTimer = null;
                if (typeof window.tooltipHideTimer === 'undefined') window.tooltipHideTimer = null;

                {js_settings}

                // Function to add expand functionality to tooltips
                function initializeTooltipExpand() {{
                    console.log('DEBUG: ===== STARTING TOOLTIP EXPAND INITIALIZATION =====');
                    console.log('DEBUG: Function called, about to search for tooltip...');
                    
                    var tooltip = document.querySelector('.notes-tooltip');
                    console.log('DEBUG: Tooltip search result:', tooltip);
                    if (!tooltip) {{
                        console.error('DEBUG: Tooltip element not found for expand initialization');
                        return;
                    }}
                    console.log('DEBUG: Found tooltip element:', tooltip);
                    
                    let expandButton = tooltip.querySelector('.tooltip-expand-button');
                    let pinButton = tooltip.querySelector('.tooltip-pin-button');
                    let controlsContainer = tooltip.querySelector('.tooltip-controls');
                    
                    // If buttons don't exist, create them
                    if (!expandButton || !pinButton) {{
                        console.log('DEBUG: Creating control buttons container and buttons');
                        
                        // Remove any existing buttons first
                        const oldExpandButton = tooltip.querySelector('.tooltip-expand-button');
                        if (oldExpandButton) {{
                            oldExpandButton.remove();
                        }}
                        const oldPinButton = tooltip.querySelector('.tooltip-pin-button');
                        if (oldPinButton) {{
                            oldPinButton.remove();
                        }}
                        const oldControls = tooltip.querySelector('.tooltip-controls');
                        if (oldControls) {{
                            oldControls.remove();
                        }}
                        
                        // Create controls container in right corner
                        controlsContainer = document.createElement('div');
                        controlsContainer.className = 'tooltip-controls';
                        controlsContainer.style.setProperty('position', 'absolute', 'important');
                        controlsContainer.style.setProperty('top', '10px', 'important');
                        controlsContainer.style.setProperty('right', '8px', 'important');
                        controlsContainer.style.setProperty('display', 'flex', 'important');
                        controlsContainer.style.setProperty('gap', '0px', 'important');
                        controlsContainer.style.setProperty('z-index', '9999', 'important');
                        tooltip.appendChild(controlsContainer);
                        
                        // Create expand button first (left side of controls)
                        expandButton = document.createElement('button');
                        expandButton.className = 'tooltip-expand-button';
                        expandButton.innerHTML = '⤢';
                        expandButton.title = 'Expand tooltip';
                        controlsContainer.appendChild(expandButton);
                        console.log('DEBUG: Created expand button in controls');
                        
                        // Create pin button second (right side of controls)
                        pinButton = document.createElement('button');
                        pinButton.className = 'tooltip-pin-button';
                        pinButton.innerHTML = '📌';
                        pinButton.title = 'Pin tooltip';
                        controlsContainer.appendChild(pinButton);
                        console.log('DEBUG: Created pin button in controls');
                        
                        console.log('DEBUG: Created control buttons');
                    }}
                    
                    console.log('DEBUG: Found/created expand button:', expandButton);
                    console.log('DEBUG: Found/created pin button:', pinButton);
                    console.log('DEBUG: All buttons in tooltip:', tooltip.querySelectorAll('button'));
                    console.log('DEBUG: Controls container:', tooltip.querySelector('.tooltip-controls'));
                    
                    // Test button visibility and click ability
                    console.log('DEBUG: Expand button styles:', {{
                        display: window.getComputedStyle(expandButton).display,
                        visibility: window.getComputedStyle(expandButton).visibility,
                        pointerEvents: window.getComputedStyle(expandButton).pointerEvents,
                        position: window.getComputedStyle(expandButton).position,
                        zIndex: window.getComputedStyle(expandButton).zIndex,
                        width: window.getComputedStyle(expandButton).width,
                        height: window.getComputedStyle(expandButton).height,
                        opacity: window.getComputedStyle(expandButton).opacity
                    }});
                    
                    console.log('DEBUG: Pin button styles:', {{
                        display: window.getComputedStyle(pinButton).display,
                        visibility: window.getComputedStyle(pinButton).visibility,
                        width: window.getComputedStyle(pinButton).width,
                        height: window.getComputedStyle(pinButton).height,
                        opacity: window.getComputedStyle(pinButton).opacity
                    }});
                    
                    console.log('DEBUG: Pin button position styles:', {{
                        position: window.getComputedStyle(pinButton).position,
                        top: window.getComputedStyle(pinButton).top,
                        left: window.getComputedStyle(pinButton).left,
                        right: window.getComputedStyle(pinButton).right
                    }});
                    
                    console.log('DEBUG: Expand button position styles:', {{
                        position: window.getComputedStyle(expandButton).position,
                        top: window.getComputedStyle(expandButton).top,
                        left: window.getComputedStyle(expandButton).left,
                        right: window.getComputedStyle(expandButton).right
                    }});
                    
                    // Force visible styles
                    pinButton.style.setProperty('display', 'flex', 'important');
                    pinButton.style.setProperty('opacity', '1', 'important');
                    pinButton.style.setProperty('width', '35px', 'important');
                    pinButton.style.setProperty('height', '35px', 'important');
                    
                    expandButton.style.setProperty('display', 'flex', 'important');
                    expandButton.style.setProperty('opacity', '1', 'important');
                    expandButton.style.setProperty('width', '35px', 'important');
                    expandButton.style.setProperty('height', '35px', 'important');
                    expandButton.style.setProperty('pointer-events', 'auto', 'important');
                    expandButton.style.setProperty('z-index', '10000', 'important');
                    
                    pinButton.style.setProperty('pointer-events', 'auto', 'important');
                    pinButton.style.setProperty('z-index', '10000', 'important');
                    
                    console.log('DEBUG: Applied forced visible styles to buttons with proper spacing');
                    console.log('DEBUG: Expand button final styles:', {{
                        'pointer-events': expandButton.style.pointerEvents,
                        'z-index': expandButton.style.zIndex,
                        'position': expandButton.style.position,
                        'display': expandButton.style.display
                    }});
                    console.log('DEBUG: Pin button final styles:', {{
                        'pointer-events': pinButton.style.pointerEvents,
                        'z-index': pinButton.style.zIndex,
                        'position': pinButton.style.position,
                        'display': pinButton.style.display
                    }});
                    // Force binding of controls (override double-binding protection for debugging)
                    console.log('DEBUG: Forcing event listener binding in FIRST METHOD regardless of controlsBound status');
                    tooltip.dataset.controlsBound = '1';
                    
                    expandButton.addEventListener('click', function(e) {{
                        console.log('DEBUG: ===== EXPAND BUTTON CLICKED =====');
                        console.log('DEBUG: Event object:', e);
                        console.log('DEBUG: Button element:', this);
                        console.log('DEBUG: Button computed style:', window.getComputedStyle(this));
                        console.log('DEBUG: Button parent:', this.parentElement);
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Prevent tooltip from hiding during expand
                        if (window.tooltipHideTimer) {{
                            clearTimeout(window.tooltipHideTimer);
                            window.tooltipHideTimer = null;
                            console.log('DEBUG: Cleared tooltip hide timer');
                        }}
                        
                        const isExpanded = tooltip.classList.contains('expanded');
                        console.log('DEBUG: Current expanded state:', isExpanded);
                        console.log('DEBUG: Tooltip classes before toggle:', tooltip.className);
                        
                        if (isExpanded) {{
                            // Collapse tooltip
                            tooltip.classList.remove('expanded');
                            expandButton.classList.remove('expanded');
                            expandButton.innerHTML = '⤢'; // Expand symbol
                            expandButton.title = 'Expand tooltip';
                            // Force style reset
                            tooltip.style.width = '350px';
                            tooltip.style.height = 'auto';
                            tooltip.style.maxHeight = '650px';
                            tooltip.style.minHeight = 'auto';
                            
                            // Remove force height class
                            tooltip.classList.remove('force-height-expanded');
                            console.log('DEBUG: Collapsed tooltip - new classes:', tooltip.className);
                        }} else {{
                            // Expand tooltip
                            tooltip.classList.add('expanded');
                            expandButton.classList.add('expanded');
                            expandButton.innerHTML = '⤡'; // Collapse symbol
                            expandButton.title = 'Collapse tooltip';
                            // Get current height before expanding to see the difference
                            const currentHeight = tooltip.offsetHeight;
                            console.log('DEBUG: Current tooltip height before expansion:', currentHeight);
                            
                            // Calculate viewport-aware dimensions
                            const viewportWidth = window.innerWidth;
                            const viewportHeight = window.innerHeight;
                            const maxTooltipWidth = Math.min(650, viewportWidth - 40);
                            const maxTooltipHeight = Math.min(800, viewportHeight - 100);
                            
                            console.log('DEBUG: Viewport dimensions:', {{ width: viewportWidth, height: viewportHeight }});
                            console.log('DEBUG: Max tooltip dimensions:', {{ width: maxTooltipWidth, height: maxTooltipHeight }});
                            
                            // Force style application with !important override - responsive to viewport
                            tooltip.style.setProperty('width', maxTooltipWidth + 'px', 'important');
                            tooltip.style.setProperty('height', maxTooltipHeight + 'px', 'important');
                            tooltip.style.setProperty('max-height', maxTooltipHeight + 'px', 'important');
                            tooltip.style.setProperty('min-height', Math.min(800, maxTooltipHeight) + 'px', 'important');
                            
                            // Add a specific class for forcing height
                            tooltip.classList.add('force-height-expanded');
                            console.log('DEBUG: Expanded tooltip - new classes:', tooltip.className);
                            console.log('DEBUG: Applied styles directly:', {{
                                width: tooltip.style.width,
                                height: tooltip.style.height,
                                minHeight: tooltip.style.minHeight,
                                maxHeight: tooltip.style.maxHeight
                            }});
                        }}
                        
                        // Adjust tooltip content height for expanded state
                        const tooltipContent = tooltip.querySelector('.tooltip-content');
                        if (tooltipContent) {{
                            if (isExpanded) {{
                                // Reset to normal max-height when collapsing
                                tooltipContent.style.maxHeight = 'calc(400px - 24px)';
                                tooltipContent.style.minHeight = 'auto';
                                tooltipContent.style.height = 'auto';
                                
                                // Reset the scrollable notes area
                                const tooltipHtmlNotes = tooltip.querySelector('.tooltip-html-notes');
                                if (tooltipHtmlNotes) {{
                                    tooltipHtmlNotes.style.maxHeight = '500px'; // Back to normal size
                                    tooltipHtmlNotes.style.minHeight = 'auto'; // Remove forced height
                                    console.log('DEBUG: Reset html-notes area to normal size');
                                }}
                                console.log('DEBUG: Set content max-height to normal');
                            }} else {{
                                // Calculate viewport-aware dimensions for content
                                const viewportHeight = window.innerHeight;
                                const maxContentHeight = Math.min(720, viewportHeight - 180);
                                const maxNotesHeight = Math.min(600, viewportHeight - 200);
                                const minNotesHeight = Math.min(500, viewportHeight - 250);
                                
                                // Increase max-height and min-height when expanding - responsive to viewport
                                tooltipContent.style.maxHeight = 'calc(' + maxContentHeight + 'px - 80px)'; // Account for title and padding
                                tooltipContent.style.minHeight = maxContentHeight + 'px'; // Force content area to be taller
                                tooltipContent.style.height = maxContentHeight + 'px'; // Force content height to fill most of the tooltip
                                
                                // Also adjust the scrollable notes area specifically
                                const tooltipHtmlNotes = tooltip.querySelector('.tooltip-html-notes');
                                if (tooltipHtmlNotes) {{
                                    tooltipHtmlNotes.style.maxHeight = maxNotesHeight + 'px'; // Viewport-aware scrollable area
                                    tooltipHtmlNotes.style.minHeight = minNotesHeight + 'px'; // Viewport-aware minimum height
                                    console.log('DEBUG: Set html-notes area to expanded size:', {{ maxHeight: maxNotesHeight, minHeight: minNotesHeight }});
                                }}
                                console.log('DEBUG: Set content max-height to expanded:', maxContentHeight);
                            }}
                            console.log('DEBUG: Tooltip content max-height:', tooltipContent.style.maxHeight);
                        }} else {{
                            console.log('DEBUG: No tooltip content found');
                        }}
                        
                        // Reposition tooltip after size change (with timeout to ensure layout update)
                        setTimeout(() => {{
                            const activeSpan = window.activeHighlight;
                            if (activeSpan && typeof positionTooltip === 'function') {{
                                console.log('DEBUG: Repositioning tooltip after size change');
                                
                                // Get the current span's position
                                const spanRect = activeSpan.getBoundingClientRect();
                                
                                // Get new tooltip dimensions after layout update
                                const tooltipWidth = tooltip.offsetWidth;
                                const tooltipHeight = tooltip.offsetHeight;
                                
                                console.log('DEBUG: New tooltip dimensions for positioning:', {{
                                    width: tooltipWidth,
                                    height: tooltipHeight
                                }});
                                
                                // Calculate new position
                                const position = positionTooltip(spanRect, tooltipWidth, tooltipHeight);
                                
                                // Apply new position
                                tooltip.style.top = position.top + 'px';
                                tooltip.style.left = position.left + 'px';
                                
                                console.log('DEBUG: Repositioned tooltip from old position to new:', {{
                                    oldTop: tooltip.style.top,
                                    oldLeft: tooltip.style.left,
                                    newTop: position.top + 'px',
                                    newLeft: position.left + 'px'
                                }});
                            }} else {{
                                console.log('DEBUG: Cannot reposition - no active span or position function not found');
                            }}
                        }}, 50); // Small delay to ensure DOM layout is updated
                        
                        // Log final state
                        console.log('DEBUG: Final tooltip dimensions:', {{
                            width: tooltip.offsetWidth,
                            height: tooltip.offsetHeight,
                            computedWidth: window.getComputedStyle(tooltip).width,
                            computedMaxHeight: window.getComputedStyle(tooltip).maxHeight,
                            computedMinWidth: window.getComputedStyle(tooltip).minWidth,
                            hasExpandedClass: tooltip.classList.contains('expanded'),
                            allClasses: tooltip.className,
                            top: tooltip.style.top,
                            left: tooltip.style.left
                        }});
                        
                        // Force a style recalculation and check again
                        setTimeout(() => {{
                            console.log('DEBUG: After timeout - tooltip dimensions:', {{
                                width: tooltip.offsetWidth,
                                height: tooltip.offsetHeight,
                                computedWidth: window.getComputedStyle(tooltip).width,
                                hasExpandedClass: tooltip.classList.contains('expanded')
                            }});
                        }}, 100);
                    }});
                    
                    // Also add mousedown and mouseup for additional debugging
                    expandButton.addEventListener('mousedown', function(e) {{
                        console.log('DEBUG: Expand button mousedown');
                    }});
                    
                    expandButton.addEventListener('mouseup', function(e) {{
                        console.log('DEBUG: Expand button mouseup');
                    }});
                    
                    // Test if button is actually clickable
                    expandButton.addEventListener('mouseover', function(e) {{
                        console.log('DEBUG: Expand button mouseover - button is hoverable');
                    }});
                    
                    // Add test click handler to see if ANY click events fire
                    expandButton.addEventListener('click', function(e) {{
                        console.log('DEBUG: ===== SECOND CLICK HANDLER FIRED =====');
                    }}, true); // Use capture phase
                    
                    // Prevent tooltip hiding on button area events
                    expandButton.addEventListener('mouseenter', function(e) {{
                        console.log('DEBUG: Expand button mouseenter - stopping event propagation');
                        e.stopPropagation();
                        // Clear any hide timers when hovering over buttons
                        if (window.tooltipHideTimer) {{
                            clearTimeout(window.tooltipHideTimer);
                            window.tooltipHideTimer = null;
                        }}
                    }});
                    
                    pinButton.addEventListener('mouseenter', function(e) {{
                        console.log('DEBUG: Pin button mouseenter - stopping event propagation'); 
                        e.stopPropagation();
                        // Clear any hide timers when hovering over buttons
                        if (window.tooltipHideTimer) {{
                            clearTimeout(window.tooltipHideTimer);
                            window.tooltipHideTimer = null;
                        }}
                    }});
                    
                    // Initialize pin button functionality
                    let isPinned = false;
                    pinButton.addEventListener('click', function(e) {{
                        console.log('DEBUG: Pin button clicked!', e);
                        e.preventDefault();
                        e.stopPropagation();
                        
                        isPinned = !isPinned;
                        
                        if (isPinned) {{
                            // Pin the tooltip
                            pinButton.classList.add('pinned');
                            pinButton.innerHTML = '📍'; // Filled pin
                            pinButton.title = 'Unpin tooltip';
                            
                            // Clear any hide timers
                            if (window.tooltipHideTimer) {{
                                clearTimeout(window.tooltipHideTimer);
                                window.tooltipHideTimer = null;
                            }}
                            
                            // Add pinned class to tooltip to prevent hiding
                            tooltip.classList.add('pinned');
                            console.log('DEBUG: Tooltip pinned');
                        }} else {{
                            // Unpin the tooltip
                            pinButton.classList.remove('pinned');
                            pinButton.innerHTML = '📌'; // Outline pin
                            pinButton.title = 'Pin tooltip';
                            
                            // Remove pinned class
                            tooltip.classList.remove('pinned');
                            console.log('DEBUG: Tooltip unpinned');
                        }}
                    }});
                    
                    pinButton.addEventListener('mouseover', function(e) {{
                        console.log('DEBUG: Pin button mouseover - button is hoverable');
                    }});
                    
                    // Removed else clause - always bind event listeners for debugging
                    console.log('DEBUG: Event listeners have been bound to buttons');
                    
                    console.log('DEBUG: Tooltip expand and pin functionality initialized - event listeners attached');
                    
                    // Test programmatic click to verify button functionality
                    setTimeout(function() {{
                        console.log('DEBUG: Testing programmatic button clicks...');
                        console.log('DEBUG: Expand button element at test time:', expandButton);
                        console.log('DEBUG: Pin button element at test time:', pinButton);
                        console.log('DEBUG: Are buttons still in DOM?', {{
                            'expand': document.contains(expandButton),
                            'pin': document.contains(pinButton)
                        }});
                    }}, 1000);
                }}

                // Function to enhance tooltip structure for scrolling
                function enhanceTooltipStructure() {{
                    console.log('Enhancing tooltip structure for scrolling...');
                
                    // Get the tooltip element
                    var tooltip = document.querySelector('.notes-tooltip');
                    if (!tooltip) {{
                        console.error('Tooltip element not found');
                        return false;
                    }}
                
                    // Make sure tooltip has the proper structure for scrolling
                    var tooltipContent = tooltip.querySelector('.tooltip-content');
                    if (!tooltipContent) {{
                        console.log('Creating tooltip content container');
                        tooltipContent = document.createElement('div');
                        tooltipContent.className = 'tooltip-content';
                    
                        // Move all content except title into the content container
                        Array.from(tooltip.children).forEach(child => {{
                            if (!child.classList.contains('tooltip-title')) {{
                                tooltipContent.appendChild(child);
                            }}
                        }});
                    
                        tooltip.appendChild(tooltipContent);
                    }}
                
                    // Ensure the needed sections exist in the right order
                    var tooltipTitle = tooltip.querySelector('.tooltip-title');
                    var tooltipScene = tooltipContent.querySelector('.tooltip-scene');
                    var tooltipSecondary = tooltipContent.querySelector('.tooltip-secondary');
                    var tooltipTags = tooltipContent.querySelector('.tooltip-tags');
                    var tooltipFootnote = tooltipContent.querySelector('.tooltip-footnote');
                    var tooltipHtmlNotes = tooltipContent.querySelector('.tooltip-html-notes');
                
                    // Create elements if they don't exist
                    if (!tooltipTitle) {{
                        tooltipTitle = document.createElement('div');
                        tooltipTitle.className = 'tooltip-title';
                        tooltipTitle.innerHTML = '<span class="tooltip-icon">ℹ</span><span>Annotation</span>';
                        tooltipTitle.style.cursor = 'default';
                        tooltip.insertBefore(tooltipTitle, tooltip.firstChild);
                        console.log('Created tooltip title');
                    }}
                
                    if (!tooltipScene) {{
                        tooltipScene = document.createElement('div');
                        tooltipScene.className = 'tooltip-scene';
                        tooltipContent.insertBefore(tooltipScene, tooltipContent.firstChild);
                        console.log('Created tooltip scene');
                    }}

                    // Create "Secondary Themes" container directly beneath scene
                    if (!tooltipSecondary) {{
                        tooltipSecondary = document.createElement('div');
                        tooltipSecondary.className = 'tooltip-secondary';
                        // Insert right after tooltipScene
                        if (tooltipScene && tooltipScene.nextSibling) {{
                            tooltipContent.insertBefore(tooltipSecondary, tooltipScene.nextSibling);
                        }} else {{
                            tooltipContent.appendChild(tooltipSecondary);
                        }}
                        console.log('Created tooltip secondary themes container');
                    }}
                
                    if (!tooltipTags) {{
                        tooltipTags = document.createElement('div');
                        tooltipTags.className = 'tooltip-tags';
                        // Insert after scene or as first child if no scene
                        if (tooltipSecondary) {{
                            tooltipContent.insertBefore(tooltipTags, tooltipSecondary.nextSibling);
                        }} else if (tooltipScene) {{
                            tooltipContent.insertBefore(tooltipTags, tooltipScene.nextSibling);
                        }} else {{
                            tooltipContent.insertBefore(tooltipTags, tooltipContent.firstChild);
                        }}
                        console.log('Created tooltip tags');
                    }}
                
                    if (!tooltipFootnote) {{
                        tooltipFootnote = document.createElement('div');
                        tooltipFootnote.className = 'tooltip-footnote';
                    
                        // Insert after tags, or after scene, or as first child if neither exist
                        if (tooltipTags) {{
                            tooltipContent.insertBefore(tooltipFootnote, tooltipTags.nextSibling);
                        }} else if (tooltipScene) {{
                            tooltipContent.insertBefore(tooltipFootnote, tooltipScene.nextSibling);
                        }} else {{
                            tooltipContent.insertBefore(tooltipFootnote, tooltipContent.firstChild);
                        }}
                        console.log('Created tooltip footnote');
                    }}
                
                    if (!tooltipHtmlNotes) {{
                        tooltipHtmlNotes = document.createElement('div');
                        tooltipHtmlNotes.className = 'tooltip-html-notes';
                        tooltipContent.appendChild(tooltipHtmlNotes);
                        console.log('Created tooltip HTML notes');
                    }}

                    // Create storyboard navigation element if it doesn't exist
                    var tooltipStoryboardNav = tooltipContent.querySelector('.tooltip-storyboard-nav');
                    if (!tooltipStoryboardNav) {{
                        tooltipStoryboardNav = document.createElement('div');
                        tooltipStoryboardNav.className = 'tooltip-storyboard-nav';
                        tooltipStoryboardNav.style.display = 'none';
                        tooltipStoryboardNav.innerHTML = '<div class="tooltip-navigation-buttons" style="display: flex; gap: 8px; margin-top: 8px;"><button class="storyboard-nav-button" style="flex: 1; padding: 6px 12px; background: #4a5568; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;" title="Navigate to annotation in Script Editor">Script Editor</button><button class="theme-view-nav-button" style="flex: 1; padding: 6px 12px; background: #2d3748; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;" title="Navigate to annotation in theme view">Theme View</button></div>';
                        tooltipContent.appendChild(tooltipStoryboardNav);
                        console.log('Created tooltip storyboard navigation - hidden by default');
                    }} else {{
                        // Make sure existing element is hidden by default
                        tooltipStoryboardNav.style.display = 'none';
                        console.log('Reset existing storyboard nav to hidden');
                    }}
                
                    // Ensure correct order: title, (content: scene, tags, footnote, html-notes, storyboard-nav)
                    if (tooltipScene && tooltipTags && tooltipFootnote && tooltipHtmlNotes) {{
                        // Check if reordering is needed
                        const needsReorder = 
                            (tooltipScene && tooltipScene.nextSibling !== (tooltipSecondary || tooltipTags)) ||
                            (tooltipSecondary && tooltipSecondary.nextSibling !== tooltipTags) ||
                            tooltipTags.nextSibling !== tooltipFootnote ||
                            tooltipFootnote.nextSibling !== tooltipHtmlNotes;
                    
                        if (needsReorder) {{
                            // Preserve any content
                            const sceneContent = tooltipScene.innerHTML;
                            const tagsContent = tooltipTags.innerHTML;
                            const footnoteContent = tooltipFootnote.innerHTML;
                            const htmlNotesContent = tooltipHtmlNotes.innerHTML;
                            const storyboardNavContent = tooltipStoryboardNav ? tooltipStoryboardNav.innerHTML : '<div class="tooltip-navigation-buttons" style="display: flex; gap: 8px; margin-top: 8px;"><button class="storyboard-nav-button" style="flex: 1; padding: 6px 12px; background: #4a5568; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;" title="Navigate to annotation in Script Editor">Script Editor</button><button class="theme-view-nav-button" style="flex: 1; padding: 6px 12px; background: #2d3748; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;" title="Navigate to annotation in theme view">Theme View</button></div>';
                        
                            // Clear and rebuild in correct order
                            tooltipContent.innerHTML = '';
                        
                            // Recreate with original content
                            tooltipScene = document.createElement('div');
                            tooltipScene.className = 'tooltip-scene';
                            tooltipScene.innerHTML = sceneContent;
                            tooltipContent.appendChild(tooltipScene);

                            // Recreate secondary container (empty; filled during show)
                            tooltipSecondary = document.createElement('div');
                            tooltipSecondary.className = 'tooltip-secondary';
                            tooltipContent.appendChild(tooltipSecondary);

                            tooltipTags = document.createElement('div');
                            tooltipTags.className = 'tooltip-tags';
                            tooltipTags.innerHTML = tagsContent;
                            tooltipContent.appendChild(tooltipTags);
                        
                            tooltipFootnote = document.createElement('div');
                            tooltipFootnote.className = 'tooltip-footnote';
                            tooltipFootnote.innerHTML = footnoteContent;
                            tooltipContent.appendChild(tooltipFootnote);
                        
                            tooltipHtmlNotes = document.createElement('div');
                            tooltipHtmlNotes.className = 'tooltip-html-notes';
                            tooltipHtmlNotes.innerHTML = htmlNotesContent;
                            tooltipContent.appendChild(tooltipHtmlNotes);

                            // Recreate storyboard navigation
                            tooltipStoryboardNav = document.createElement('div');
                            tooltipStoryboardNav.className = 'tooltip-storyboard-nav';
                            tooltipStoryboardNav.style.display = 'none';
                            tooltipStoryboardNav.innerHTML = storyboardNavContent;
                            tooltipContent.appendChild(tooltipStoryboardNav);
                        
                            console.log('Reordered tooltip sections');
                        }}
                    }}
                
                    console.log('Tooltip structure enhancement complete');
                    return true;
                }}
            
                // Function to handle long HTML notes content
                function wrapLongHtmlNotes() {{
                    var tooltipHtmlNotes = document.querySelector('.tooltip-html-notes');
                    if (!tooltipHtmlNotes) return;
                
                    // If HTML notes content is exceptionally long, ensure it's properly contained
                    if (tooltipHtmlNotes.scrollHeight > 250) {{
                        console.log('Long HTML notes detected, ensuring proper containment');
                    
                        // Add overflow-y and max-height directly to ensure scrolling works
                        tooltipHtmlNotes.style.overflowY = 'auto';
                        tooltipHtmlNotes.style.maxHeight = '250px';
                    
                        // Ensure inline elements don't break out of container
                        var allElements = tooltipHtmlNotes.querySelectorAll('*');
                        allElements.forEach(el => {{
                            el.style.maxWidth = '100%';
                            el.style.wordBreak = 'break-word';
                        
                            // Handle images, tables, and other potentially overflowing elements
                            if (el.tagName === 'IMG') {{
                                el.style.maxWidth = '100%';
                                el.style.height = 'auto';
                            }} else if (el.tagName === 'TABLE') {{
                                el.style.width = '100%';
                                el.style.tableLayout = 'fixed';
                            }} else if (el.tagName === 'PRE' || el.tagName === 'CODE') {{
                                el.style.whiteSpace = 'pre-wrap';
                                el.style.wordWrap = 'break-word';
                            }}
                        }});
                    }}
                }}

                // 1. Force tooltip to have highest z-index
                var tooltip = document.querySelector('.notes-tooltip');
                if (!tooltip) {{
                    console.log('Creating tooltip element as it does not exist');
                    tooltip = document.createElement('div');
                    tooltip.className = 'notes-tooltip';
                    // Updated structure for scrollable content
                    tooltip.innerHTML = '<div class="tooltip-controls"><button class="tooltip-pin-button" title="Pin tooltip">📌</button><button class="tooltip-expand-button" title="Expand tooltip">⤢</button></div><div class="tooltip-title" style="cursor: default;"><span class="tooltip-icon">ℹ</span><span>Annotation</span></div><div class="tooltip-content"><div class="tooltip-scene"></div><div class="tooltip-tags"></div><div class="tooltip-footnote"></div><div class="tooltip-html-notes"></div><div class="tooltip-storyboard-nav" style="display: none;"><div class="tooltip-navigation-buttons" style="display: flex; gap: 8px; margin-top: 8px;"><button class="storyboard-nav-button" style="flex: 1; padding: 6px 12px; background: #4a5568; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;" title="Navigate to annotation in Script Editor">Script Editor</button><button class="theme-view-nav-button" style="flex: 1; padding: 6px 12px; background: #2d3748; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;" title="Navigate to annotation in theme view">Theme View</button></div></div></div>';
                    document.body.appendChild(tooltip);
                
                    // Initialize structure
                    enhanceTooltipStructure();
                
                    // Add expand functionality
                    console.log('DEBUG: About to call initializeTooltipExpand');
                    try {{
                        initializeTooltipExpand();
                        console.log('DEBUG: Called initializeTooltipExpand successfully');
                    }} catch(error) {{
                        console.error('DEBUG: Error calling initializeTooltipExpand:', error);
                        console.error('DEBUG: Error stack:', error.stack);
                    }}
                }} else {{
                    // Ensure tooltip has the proper structure even if it already exists
                    var tooltipTitle = tooltip.querySelector('.tooltip-title');
                    if (!tooltipTitle) {{
                         tooltipTitle = document.createElement('div');
                         tooltipTitle.className = 'tooltip-title';
                         tooltipTitle.innerHTML = '<span class="tooltip-icon">ℹ</span><span>Annotation</span>';
                         tooltip.insertBefore(tooltipTitle, tooltip.firstChild); // Add title if missing
                    }}
                    tooltipTitle.style.cursor = 'default'; // Ensure cursor is default (not clickable)
                
                    // Add control buttons if they don't exist
                    if (!tooltip.querySelector('.tooltip-expand-button') || !tooltip.querySelector('.tooltip-pin-button')) {{
                        console.log('DEBUG: Creating control buttons for existing tooltip');
                        
                        // Create controls container
                        let controlsContainer = tooltip.querySelector('.tooltip-controls');
                        if (!controlsContainer) {{
                            controlsContainer = document.createElement('div');
                            controlsContainer.className = 'tooltip-controls';
                            tooltip.appendChild(controlsContainer);
                        }}
                        
                        // Don't create buttons here - they're created in initializeTooltipExpand
                        
                        console.log('DEBUG: Created control buttons for existing tooltip');
                    }} else {{
                        console.log('DEBUG: Control buttons already exist in tooltip');
                    }}
                
                    // Enhance structure
                    enhanceTooltipStructure();
                
                    // Add expand functionality
                    console.log('DEBUG: About to call initializeTooltipExpand');
                    try {{
                        initializeTooltipExpand();
                        console.log('DEBUG: Called initializeTooltipExpand successfully');
                    }} catch(error) {{
                        console.error('DEBUG: Error calling initializeTooltipExpand:', error);
                        console.error('DEBUG: Error stack:', error.stack);
                    }}
                }}

                // 2. Fix tooltip styling with !important rules
                var style = document.createElement('style');
                style.textContent = `
                    .notes-tooltip {{
                        position: fixed !important;
                        background-color: #F8F8FC !important;
                        color: #2C3333 !important;
                        border-radius: 8px !important;
                        padding: 12px !important;
                        box-shadow: 0 3px 15px rgba(0, 0, 0, 0.15) !important;
                        z-index: 9999999 !important;
                        width: 350px !important; /* Default width */
                        height: auto !important; /* Allow height to adjust to content by default */
                        max-height: 650px !important; /* Set maximum height */
                        font-family: 'Segoe UI', Arial, sans-serif !important;
                        font-size: 14px !important;
                        border: 1px solid #E6E6EF !important;
                        pointer-events: auto !important;
                        display: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                        overflow: hidden !important; /* Hide overflow on the main tooltip container */
                        transition: width 0.3s ease, height 0.3s ease !important;
                    }}

                    .notes-tooltip.visible.expanded {{
                        width: min(650px, calc(100vw - 40px)) !important; /* Responsive width, max 650px but fits on screen */
                        height: min(800px, calc(100vh - 100px)) !important; /* Responsive height, max 800px but fits on screen */
                        max-height: min(1300px, calc(100vh - 100px)) !important; /* Limit to viewport height */
                        min-height: min(800px, calc(100vh - 100px)) !important; /* Responsive minimum height */
                        min-width: min(650px, calc(100vw - 40px)) !important; /* Responsive minimum width */
                    }}
                    
                    body .notes-tooltip.visible.expanded {{
                        height: min(800px, calc(100vh - 100px)) !important; /* Extra specificity with viewport constraint */
                    }}
                    
                    .force-height-expanded {{
                        height: min(800px, calc(100vh - 100px)) !important; /* Force height with viewport constraint */
                    }}

                    .notes-tooltip.expanded .tooltip-content {{
                        min-height: min(720px, calc(100vh - 180px)) !important; /* Responsive content height */
                        height: min(720px, calc(100vh - 180px)) !important; /* Responsive content height */
                        max-height: min(calc(800px - 80px), calc(100vh - 180px)) !important; /* Account for title and padding with viewport limit */
                    }}
                    
                    .notes-tooltip.expanded .tooltip-html-notes {{
                        max-height: min(600px, calc(100vh - 200px)) !important; /* Responsive scrollable area */
                        min-height: min(500px, calc(100vh - 250px)) !important; /* Responsive minimum height */
                        height: auto !important; /* Let it grow to fill available space */
                    }}

                    /* Control buttons container */
                    .tooltip-controls {{
                        position: absolute !important;
                        top: 10px !important;
                        right: 8px !important;
                        display: flex !important;
                        gap: 0px !important;
                        z-index: 9999 !important;
                    }}

                    /* Expand button */
                    .tooltip-expand-button {{
                        width: 35px !important;
                        height: 35px !important;
                        background: none !important;
                        color: #7077A1 !important;
                        border: none !important;
                        cursor: pointer !important;
                        font-size: 20px !important;
                        display: flex !important;
                        align-items: center !important;
                        justify-content: center !important;
                        transition: color 0.2s ease !important;
                        position: relative !important;
                        flex-shrink: 0 !important;
                        top: 0px !important;
                        line-height: 1 !important;
                    }}

                    .tooltip-expand-button:hover {{
                        color: #4a5568 !important;
                        background: rgba(112, 119, 161, 0.1) !important;
                        border-radius: 6px !important;
                        transform: scale(1.1) !important;
                        transition: all 0.2s ease !important;
                    }}

                    .tooltip-expand-button.expanded {{
                        color: #4a5568 !important;
                        background: rgba(74, 85, 104, 0.15) !important;
                        border-radius: 6px !important;
                    }}

                    /* Pin button */
                    .tooltip-pin-button {{
                        width: 35px !important;
                        height: 35px !important;
                        background: none !important;
                        color: #7077A1 !important;
                        border: none !important;
                        cursor: pointer !important;
                        font-size: 20px !important;
                        display: flex !important;
                        align-items: center !important;
                        justify-content: center !important;
                        transition: color 0.2s ease !important;
                        position: relative !important;
                        flex-shrink: 0 !important;
                        line-height: 1 !important;
                    }}

                    .tooltip-pin-button:hover {{
                        color: #4a5568 !important;
                        background: rgba(112, 119, 161, 0.1) !important;
                        border-radius: 6px !important;
                        transform: scale(1.1) !important;
                        transition: all 0.2s ease !important;
                    }}

                    .tooltip-pin-button.pinned {{
                        color: #e53e3e !important;
                        background: rgba(229, 62, 62, 0.1) !important;
                        border-radius: 6px !important;
                    }}

                    .tooltip-pin-button.pinned:hover {{
                        color: #c53030 !important;
                        background: rgba(197, 48, 48, 0.15) !important;
                        border-radius: 6px !important;
                        transform: scale(1.1) !important;
                        transition: all 0.2s ease !important;
                    }}

                    .notes-tooltip.visible {{
                        display: block !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                    }}

                    /* Make sure other styles don't hide the tooltip */
                    body .notes-tooltip.visible {{
                        display: block !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                    }}

                    /* Highlight annotation spans with a subtle indicator */
                    span[data-annotation-id] {{
                        position: relative !important;
                        cursor: default !important;
                    }}

                    /* REVISED: Tooltip title styles - improved cursor and hover effect */
                    .tooltip-title {{
                        display: flex !important;
                        align-items: center !important;
                        margin-bottom: 10px !important;
                        font-weight: bold !important;
                        border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
                        padding-bottom: 8px !important;
                        color: #2D3250 !important;
                        cursor: pointer !important; /* Force pointer cursor with !important */
                        padding: 4px 6px !important; /* Add padding for better hover area */
                        border-radius: 4px !important; /* Rounded corners on hover area */
                        margin: -4px -6px 6px -6px !important; /* Compensate for padding */
                        transition: background-color 0.15s ease !important; /* Smooth transition */
                        position: sticky !important;
                        top: -12px !important; /* Offset by the tooltip's padding */
                        background-color: #F8F8FC !important; /* Match tooltip background */
                        z-index: 2 !important;
                    }}
            
                    /* NO hover effect - tooltip title should not be interactive */
                    .tooltip-title:hover {{
                        background-color: transparent !important;
                        cursor: default !important;
                    }}

                    .tooltip-icon {{
                        margin-right: 8px !important;
                        font-size: 18px !important;
                        color: #7077A1 !important;
                    }}

                    .tooltip-content {{
                        line-height: 1.5 !important;
                        overflow-wrap: break-word !important;
                        max-height: calc(400px - 24px) !important; /* Adjust for padding */
                        min-height: 100px !important; /* Minimum height to allow spacing */
                        position: relative !important;
                        display: flex !important;
                        flex-direction: column !important;
                        flex-grow: 1 !important;
                        overscroll-behavior: contain !important; /* Prevent scroll chaining to page */
                    }}

                    .tooltip-scene {{
                        font-weight: bold !important;
                        margin-bottom: 8px !important;
                        color: black !important;
                        position: sticky !important;
                        top: 30px !important; /* Position below the title */
                        background-color: #F8F8FC !important; /* Match tooltip background */
                        z-index: 1 !important;
                        padding: 4px 0 !important;
                    }}

                    .tooltip-tags {{
                        margin-bottom: 8px !important;
                        color: #6366F1 !important;
                        position: sticky !important;
                        top: 50px !important; /* Position below the scene */
                        background-color: #F8F8FC !important; /* Match tooltip background */
                        z-index: 1 !important;
                        padding: 4px 0 !important;
                        font-size: 13px !important;
                    }}

                    .tooltip-tags .tag {{
                        display: inline-block !important;
                        background: #EEF2FF !important;
                        color: #6366F1 !important;
                        padding: 2px 6px !important;
                        border-radius: 12px !important;
                        margin-right: 4px !important;
                        margin-bottom: 2px !important;
                        font-size: 12px !important;
                        border: 1px solid #C7D2FE !important;
                        cursor: pointer !important;
                        transition: background-color 0.15s ease, color 0.15s ease, border-color 0.15s ease !important;
                    }}

                    .tooltip-tags .tag:hover {{
                        background: #E0E7FF !important;
                        border-color: #A5B4FC !important;
                    }}

                    .tooltip-tags .tag.active {{
                        background: #E8F5E9 !important; /* light green */
                        color: #2E7D32 !important; /* dark green text */
                        border-color: #81C784 !important; /* green border */
                        box-shadow: 0 1px 2px rgba(46, 125, 50, 0.25) !important;
                    }}

                    .tooltip-footnote {{
                        margin-bottom: 8px !important;
                        color: #4D4D4D !important;
                        position: sticky !important;
                        top: 70px !important; /* Position below the tags */
                        background-color: #F8F8FC !important; /* Match tooltip background */
                        z-index: 1 !important;
                        padding: 4px 0 !important;
                    }}

                    .tooltip-html-notes {{
                        border-top: 3px solid rgba(0, 0, 0, 0.1) !important;
                        padding-top: 8px !important;
                        color: #333333 !important;
                        overflow-y: auto !important;
                        max-height: 500px !important; /* Limit height for scrolling */
                        margin-right: -6px !important; /* Compensate for scrollbar */
                        padding-right: 6px !important; /* Add padding for scrollbar */
                        overscroll-behavior: contain !important; /* Prevent scroll chaining to page */
                    }}

                    .tooltip-section-label {{
                        display: block !important;
                        font-size: 9px !important;
                        color: #666 !important;
                        margin-bottom: 4px !important;
                        letter-spacing: 0.3px !important;
                        text-transform: none !important;
                    }}

                    /* Style for the tooltip scrollbar */
                    .tooltip-html-notes::-webkit-scrollbar {{
                        width: 6px !important;
                    }}

                    .tooltip-html-notes::-webkit-scrollbar-track {{
                        background: #F1F1F1 !important;
                        border-radius: 3px !important;
                    }}

                    .tooltip-html-notes::-webkit-scrollbar-thumb {{
                        background: #C0C0C0 !important;
                        border-radius: 3px !important;
                    }}

                    .tooltip-html-notes::-webkit-scrollbar-thumb:hover {{
                        background: #A0A0A0 !important;
                    }}

                    .tooltip-storyboard-nav {{
                        margin-top: auto !important;
                        margin-bottom: 0 !important;
                        border-top: 1px dotted rgba(0, 0, 0, 0.1) !important;
                        padding-top: 8px !important;
                        padding-bottom: 0 !important;
                    }}

                    .storyboard-nav-button {{
                        background-color: #7077A1 !important;
                        color: white !important;
                        border: none !important;
                        padding: 6px 12px !important;
                        border-radius: 4px !important;
                        font-size: 12px !important;
                        cursor: pointer !important;
                        width: 100% !important;
                        font-family: 'Segoe UI', Arial, sans-serif !important;
                        transition: background-color 0.2s ease !important;
                    }}

                    .storyboard-nav-button:hover {{
                        background-color: #5A6389 !important;
                    }}

                    .storyboard-nav-button:active {{
                        background-color: #4A5373 !important;
                    }}
                `;
                document.head.appendChild(style);

                // Function to truncate content
                function truncateText(text, maxLength) {{
                    if (!text) return '';
                    if (text.length <= maxLength) return text;
                    return text.substring(0, maxLength) + '...';
                }}

                // Function to extract color from style string
                function extractColorFromStyle(styleString) {{
                    if (!styleString) return null;

                    // Try to extract background-color
                    const bgColorMatch = styleString.match(/background-color:\\s*([^;]+)/i);
                    if (bgColorMatch && bgColorMatch[1]) {{
                        return bgColorMatch[1].trim();
                    }}

                    // Try to extract color as fallback
                    const colorMatch = styleString.match(/color:\\s*([^;]+)/i);
                    if (colorMatch && colorMatch[1]) {{
                        return colorMatch[1].trim();
                    }}

                    return null;
                }}

                // Function to position tooltip based on preferred position
                function positionTooltip(spanRect, tooltipWidth, tooltipHeight) {{
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    let topPosition, leftPosition;

                    // Default positions based on preferred position setting
                    switch (window.tooltipPreferredPosition || "left") {{
                        case "right":
                            // Position to the right of the span
                            leftPosition = spanRect.right + 10;
                            topPosition = spanRect.top + (spanRect.height / 2) - (tooltipHeight / 2);

                            // If it would go off the right edge, place it to the left
                            if (leftPosition + tooltipWidth > viewportWidth - 10) {{
                                leftPosition = spanRect.left - tooltipWidth - 10;
                            }}
                            break;

                        case "left":
                            // Position to the left of the span
                            leftPosition = spanRect.left - tooltipWidth - 10;
                            topPosition = spanRect.top + (spanRect.height / 2) - (tooltipHeight / 2);

                            // If it would go off the left edge, place it to the right
                            if (leftPosition < 10) {{
                                leftPosition = spanRect.right + 10;
                            }}
                            break;

                        case "top":
                            // Position above the span
                            topPosition = spanRect.top - tooltipHeight - 10;
                            leftPosition = spanRect.left + (spanRect.width / 2) - (tooltipWidth / 2);

                            // If it would go off the top, place it below
                            if (topPosition < 10) {{
                                topPosition = spanRect.bottom + 10;
                            }}
                            break;

                        case "bottom":
                            // Position below the span
                            topPosition = spanRect.bottom + 10;
                            leftPosition = spanRect.left + (spanRect.width / 2) - (tooltipWidth / 2);

                            // If it would go off the bottom, place it above
                            if (topPosition + tooltipHeight > viewportHeight - 10) {{
                                topPosition = spanRect.top - tooltipHeight - 10;
                            }}
                            break;

                        default:
                            // Position to the left of the span
                            leftPosition = spanRect.left - tooltipWidth - 10;
                            topPosition = spanRect.top + (spanRect.height / 2) - (tooltipHeight / 2);

                            // If it would go off the left edge, place it to the right
                            if (leftPosition < 10) {{
                                leftPosition = spanRect.right + 10;
                            }}
                            break;
                    }}

                    // Make sure tooltip stays within viewport boundaries
                    if (topPosition < 10) {{
                        topPosition = 10;
                    }} else if (topPosition + tooltipHeight > viewportHeight - 10) {{
                        topPosition = viewportHeight - tooltipHeight - 10;
                    }}

                    if (leftPosition < 10) {{
                        leftPosition = 10;
                    }} else if (leftPosition + tooltipWidth > viewportWidth - 10) {{
                        leftPosition = viewportWidth - tooltipWidth - 10;
                    }}

                    return {{ top: topPosition, left: leftPosition }};
                }}

                // Enhanced showTooltip function with delay and control key support
                function showTooltipDirect(e) {{
                    console.log(`Enhanced showTooltipDirect called for span ${{this.getAttribute('data-annotation-id')}}`);

                    // Clear any existing show timer
                    if (window.tooltipShowTimer) {{
                        clearTimeout(window.tooltipShowTimer);
                        window.tooltipShowTimer = null;
                    }}

                    // Clear any pending hide
                    if (window.tooltipHideTimer) {{
                        clearTimeout(window.tooltipHideTimer);
                        window.tooltipHideTimer = null;
                    }}

                    // Skip if tooltips are disabled
                    if (window.tooltipsEnabled === false) {{
                        console.log("Tooltip display skipped: Tooltips are disabled");
                        return;
                    }}

                    // Skip if Ctrl is pressed and we're already showing a tooltip
                    if (window.tooltipCtrlPressed && window.activeHighlight) {{
                        console.log("Tooltip display skipped: Ctrl pressed and tooltip already visible");
                        return;
                    }}

                    const span = this;

                    // Use setTimeout to add delay before showing
                    window.tooltipShowTimer = setTimeout(function() {{
                        // Get content from attributes
                        const scene = span.getAttribute('data-scene') || '';
                        const notes = span.getAttribute('data-notes') || '';
                        const notesHtml = span.getAttribute('data-notes-html') || '';
                        const tags = span.getAttribute('data-tags') || '[]';

                        console.log("Getting tooltip content:", {{
                            scene: scene,
                            notes: notes ? notes.substring(0, 20) + '...' : 'none',
                            notesHtml: notesHtml ? notesHtml.substring(0, 20) + '...' : 'none',
                            tags: tags
                        }});

                        // Skip if no content (including tags)
                        let hasTags = false;
                        try {{
                            const tagsList = JSON.parse(tags);
                            hasTags = tagsList && tagsList.length > 0;
                        }} catch (e) {{
                            hasTags = false;
                        }}
                        
                        if (!scene && !notes && !notesHtml && !hasTags) {{
                            console.log("No content to display in tooltip, skipping");
                            return;
                        }}

                        // Make sure tooltip has proper structure
                        enhanceTooltipStructure();

                        // Update tooltip title with speech title if available
                        const tooltipTitle = tooltip.querySelector('.tooltip-title');
                        if (tooltipTitle) {{
                            // Find the closest speech article and extract the speech title
                            let speechTitle = '';
                            const speechArticle = span.closest('.speech');
                            if (speechArticle) {{
                                const speechTitleElement = speechArticle.querySelector('h2.speech-title');
                                if (speechTitleElement) {{
                                    speechTitle = speechTitleElement.textContent.trim();
                                    console.log('DEBUG: Found speech title:', speechTitle);
                                }}
                            }}
                            
                            // Update the tooltip title
                            if (speechTitle) {{
                                // Truncate to 40 characters as requested
                                const truncatedTitle = speechTitle.length > 40 ? speechTitle.substring(0, 40) + '...' : speechTitle;
                                tooltipTitle.innerHTML = `<span class="tooltip-icon">ℹ</span><span style="font-size: 11px;">${{truncatedTitle}}</span>`;
                                console.log('DEBUG: Updated tooltip title to:', truncatedTitle);
                            }} else {{
                                // Fallback to "Annotation" if no speech title
                                tooltipTitle.innerHTML = '<span class="tooltip-icon">ℹ</span><span style="font-size: 11px;">Annotation</span>';
                                console.log('DEBUG: No speech title found, using default');
                            }}
                        }}

                        // Set tooltip content
                        const tooltipContent = tooltip.querySelector('.tooltip-content');
                        const tooltipScene = tooltipContent.querySelector('.tooltip-scene');
                        const tooltipTags = tooltipContent.querySelector('.tooltip-tags');
                        const tooltipFootnote = tooltipContent.querySelector('.tooltip-footnote');
                        const tooltipHtmlNotes = tooltipContent.querySelector('.tooltip-html-notes');
                        
                        console.log('DEBUG: Tooltip elements found:', {{
                            tooltipContent: !!tooltipContent,
                            tooltipScene: !!tooltipScene,
                            tooltipTags: !!tooltipTags,
                            tooltipFootnote: !!tooltipFootnote,
                            tooltipHtmlNotes: !!tooltipHtmlNotes
                        }});

                        // Helper to get a theme color from sceneStyles or sticky header state
                        function getSceneColor(name) {{
                            if (!name) return '#FFF0B3';
                            try {{
                                if (window.sceneStyles && window.sceneStyles[name]) {{
                                    const c = extractColorFromStyle(window.sceneStyles[name]);
                                    if (c) return c;
                                }}
                                if (window.stickyHeaderState && window.stickyHeaderState.themes) {{
                                    const td = window.stickyHeaderState.themes.find(t => t.name === name);
                                    if (td && td.color) return td.color;
                                }}
                            }} catch (e) {{}}
                            return '#FFF0B3';
                        }}

                        // Build Major Theme and Secondary Themes sections
                        const tooltipSecondary = tooltipContent.querySelector('.tooltip-secondary');
                        if (scene) {{
                            const primaryColor = getSceneColor(scene);
                            tooltipScene.innerHTML = `
                                <span class="label">Themes:</span>
                                <span class="theme-chip" style="background-color: ${{primaryColor}};padding-left: 2px;padding-right: 2px;padding-top: 2px;padding-bottom: 2px;"><span class="theme-name">${{scene}}</span></span>
                            `;
                            tooltipScene.style.display = 'block';
                        }} else {{
                            tooltipScene.style.display = 'none';
                        }}

                        let secList = [];
                        try {{
                            const secAttr = span.getAttribute('data-secondary-scenes');
                            const parsed = secAttr ? JSON.parse(secAttr) : [];
                            if (Array.isArray(parsed)) secList = parsed.filter(Boolean);
                        }} catch (e) {{ secList = []; }}

                        if (tooltipSecondary) {{
                            if (secList.length > 0) {{
                                const secHtml = secList.map(name => {{
                                    const c = getSceneColor(name);
                                    return `<span class="theme-chip" style="background-color: ${{c}};padding-left: 2px;padding-right: 2px;padding-top: 2px;padding-bottom: 2px;"><span class="theme-name">${{name}}</span></span>`;
                                }}).join(', ');
                                tooltipSecondary.innerHTML = secHtml;
                                tooltipSecondary.style.display = 'block';
                                // Ensure inline font-size, color, and line-height for secondary themes as requested
                                tooltipSecondary.style.fontSize = '11px';
                                tooltipSecondary.style.color = 'black';
                                tooltipSecondary.style.lineHeight = '2.0';
                            }} else {{
                                tooltipSecondary.style.display = 'none';
                                tooltipSecondary.style.fontSize = '11px';
                                tooltipSecondary.style.color = 'black';
                                tooltipSecondary.innerHTML = '';
                            }}
                        }}

                        // Set tags
                        console.log('DEBUG: Processing tags:', tags);
                        try {{
                            const tagsList = JSON.parse(tags);
                            console.log('DEBUG: Parsed tagsList:', tagsList, 'Length:', tagsList ? tagsList.length : 'null');
                            if (tagsList && tagsList.length > 0) {{
                                const tagsHtml = tagsList.map(tag => `<span class="tag" data-tag="${{String(tag)}}">#${{tag}}</span>`).join('');
                                console.log('DEBUG: Generated tagsHtml:', tagsHtml);
                                tooltipTags.innerHTML = `<span style="font-weight: 500;">Tags: </span>${{tagsHtml}}`;
                                tooltipTags.style.display = 'block';
                                // Bind tag pill clicks to toggle filtering
                                try {{
                                    const state = (window.stickyHeaderTagState = window.stickyHeaderTagState || {{ tagStates: {{}}, availableTags: [] }});
                                    const pills = tooltipTags.querySelectorAll('.tag');
                                    pills.forEach(pill => {{
                                        const raw = pill.getAttribute('data-tag') || '';
                                        const key = raw.startsWith('#') ? raw : ('#' + raw);
                                        const updateActive = () => {{
                                            if (state.tagStates && state.tagStates[key] === 'included') pill.classList.add('active');
                                            else pill.classList.remove('active');
                                        }};
                                        updateActive();
                                        pill.addEventListener('click', function(ev) {{
                                            ev.preventDefault();
                                            ev.stopPropagation();
                                            const curr = state.tagStates ? state.tagStates[key] : 'unchecked';
                                            const next = (curr === 'included') ? 'unchecked' : 'included';
                                            if (!state.tagStates) state.tagStates = {{}};
                                            state.tagStates[key] = next;
                                            try {{
                                                state.isActive = Object.values(state.tagStates).some(s => s !== 'unchecked');
                                            }} catch (_e) {{ state.isActive = true; }}
                                            updateActive();
                                            if (typeof window.applyStickyHeaderFilters === 'function') window.applyStickyHeaderFilters();
                                            if (typeof window.filterAnnotationsByTags === 'function') window.filterAnnotationsByTags();
                                        }});
                                    }});
                                }} catch (tagsErr) {{
                                    console.warn('[DEBUG] Failed to bind tag pill clicks', tagsErr);
                                }}
                                console.log('DEBUG: Tags section set to visible');
                            }} else {{
                                console.log('DEBUG: No tags to display, hiding tags section');
                                tooltipTags.style.display = 'none';
                            }}
                        }} catch (e) {{
                            console.log('DEBUG: Error parsing tags:', e, 'Raw tags value:', tags);
                            tooltipTags.style.display = 'none';
                        }}

                        // Set footnote (notes) with a small label
                        if (notes) {{
                            tooltipFootnote.innerHTML = '<div class="tooltip-section-label">Footnotes</div><div class="tooltip-footnote-body"></div>';
                            const footBody = tooltipFootnote.querySelector('.tooltip-footnote-body');
                            footBody.textContent =  truncateText(notes, 100);
                            tooltipFootnote.style.display = 'block';
                        }} else {{
                            tooltipFootnote.style.display = 'none';
                        }}

                        // Set HTML notes directly
                        if (notesHtml) {{
                            tooltipHtmlNotes.innerHTML = '<div class="tooltip-section-label">Commentary</div>' + notesHtml;
                            tooltipHtmlNotes.style.display = 'block';
                            // Handle long HTML content
                            wrapLongHtmlNotes();
                            // Lock scroll within notes to avoid scrolling the page
                            if (typeof installNotesScrollLock === 'function') {{
                                installNotesScrollLock(tooltipHtmlNotes);
                            }}
                        }} else {{
                            tooltipHtmlNotes.style.display = 'none';
                        }}

                        // Handle storyboard navigation button
                        const tooltipStoryboardNav = tooltip.querySelector('.tooltip-storyboard-nav');
                        const storyboardNavButton = tooltip.querySelector('.storyboard-nav-button');
                        if (tooltipStoryboardNav && storyboardNavButton) {{
                            // Check if annotation exists in storyboard
                            const annotationId = span.getAttribute('data-annotation-id');
                            console.log('[DEBUG] Checking storyboard for annotation:', annotationId);
                            console.log('[DEBUG] jsHandler available:', typeof window.jsHandler !== 'undefined');
                            
                            if (annotationId && typeof window.jsHandler !== 'undefined') {{
                                try {{
                                    console.log('[DEBUG] Calling checkAnnotationInStoryboard for:', annotationId);
                                    // Check if annotation exists in storyboard content - handle Promise
                                    const result = window.jsHandler.checkAnnotationInStoryboard(annotationId);
                                    console.log('[DEBUG] Storyboard check result type:', typeof result);
                                    
                                    // Handle Promise result
                                    if (result && typeof result.then === 'function') {{
                                        console.log('[DEBUG] Result is Promise, waiting for resolution...');
                                        result.then(function(existsInStoryboard) {{
                                            console.log('[DEBUG] Promise resolved, exists in storyboard:', existsInStoryboard);
                                            handleStoryboardButtonVisibility(existsInStoryboard);
                                        }}).catch(function(error) {{
                                            console.error('[DEBUG] Promise rejected:', error);
                                            tooltipStoryboardNav.style.display = 'none';
                                        }});
                                    }} else {{
                                        console.log('[DEBUG] Direct result:', result);
                                        handleStoryboardButtonVisibility(result);
                                    }}
                                    
                                    function handleStoryboardButtonVisibility(existsInStoryboard) {{
                                        // ALWAYS show navigation buttons - Theme View should always be available
                                        console.log('[DEBUG] Always showing navigation buttons for annotation:', annotationId);
                                        tooltipStoryboardNav.style.display = 'block';
                                        console.log('[DEBUG] Navigation buttons display set to block, actual style:', tooltipStoryboardNav.style.display);
                                        
                                        // Remove any existing click listeners to avoid duplicates
                                        storyboardNavButton.onclick = null;
                                        
                                        if (existsInStoryboard) {{
                                            console.log('[DEBUG] Enabling storyboard button for annotation:', annotationId);
                                            // Enable storyboard button and restore original styling
                                            storyboardNavButton.style.opacity = '1';
                                            storyboardNavButton.style.backgroundColor = '#4a5568';
                                            storyboardNavButton.style.color = 'white';
                                            storyboardNavButton.style.cursor = 'pointer';
                                            storyboardNavButton.style.border = 'none';
                                            storyboardNavButton.disabled = false;
                                            storyboardNavButton.title = 'Navigate to annotation in Script Editor';
                                            
                                            // Add click handler for storyboard navigation
                                            storyboardNavButton.onclick = function(e) {{
                                                e.stopPropagation();
                                                console.log('Navigating to annotation in storyboard:', annotationId);
                                                if (window.jsHandler && window.jsHandler.requestStoryboardNavigation) {{
                                                    window.jsHandler.requestStoryboardNavigation(annotationId);
                                                }}
                                            }};
                                        }} else {{
                                            console.log('[DEBUG] Disabling storyboard button for annotation:', annotationId);
                                            // Make disabled storyboard button VERY obviously greyed out
                                            storyboardNavButton.style.opacity = '0.3';
                                            storyboardNavButton.style.backgroundColor = '#666666';
                                            storyboardNavButton.style.color = '#999999';
                                            storyboardNavButton.style.cursor = 'not-allowed';
                                            storyboardNavButton.style.border = '1px solid #555555';
                                            storyboardNavButton.disabled = true;
                                            storyboardNavButton.title = 'Not available - annotation not in storyboard';
                                        }}
                                    }}
                                }} catch (error) {{
                                    console.error('[DEBUG] Error checking storyboard annotation:', error);
                                    tooltipStoryboardNav.style.display = 'none';
                                }}
                            }} else {{
                                console.log('[DEBUG] Missing annotationId or jsHandler, hiding button');
                                tooltipStoryboardNav.style.display = 'none';
                            }}
                        }}

                        // Position tooltip near the span
                        const spanRect = span.getBoundingClientRect();

                        // Measure tooltip size
                        tooltip.classList.add('visible');
                        const tooltipHeight = tooltip.offsetHeight;
                        const tooltipWidth = tooltip.offsetWidth;

                        // Get position based on preferred position setting
                        const position = positionTooltip(spanRect, tooltipWidth, tooltipHeight);

                        tooltip.style.top = position.top + 'px';
                        tooltip.style.left = position.left + 'px';

                        window.activeHighlight = span; // Store the span associated with the tooltip
                        console.log(`Tooltip positioned and shown`);
                    }}, window.tooltipShowDelay || 300);
                }}

                function hideTooltipDirect(e) {{
                    console.log(`Enhanced hideTooltipDirect called for span ${{this.getAttribute('data-annotation-id')}}`);

                    // Skip hiding if Ctrl is pressed
                    if (window.tooltipCtrlPressed) {{
                        console.log("Tooltip hide skipped: Ctrl key is pressed");
                        return;
                    }}
                    
                    // Check if tooltip is pinned
                    const tooltip = document.querySelector('.notes-tooltip');
                    if (tooltip && tooltip.classList.contains('pinned')) {{
                        console.log('Tooltip hide skipped: tooltip is pinned');
                        return;
                    }}

                    // Clear any pending show timer
                    if (window.tooltipShowTimer) {{
                        clearTimeout(window.tooltipShowTimer);
                        window.tooltipShowTimer = null;
                    }}

                    // Clear any existing hide timer
                    if (window.tooltipHideTimer) {{
                        clearTimeout(window.tooltipHideTimer);
                    }}

                    // Use delay to prevent flickering during mouse movement
                    window.tooltipHideTimer = setTimeout(function() {{
                        tooltip.classList.remove('visible');
                        window.activeHighlight = null; // Clear the active highlight when hidden
                        window.tooltipHideTimer = null;
                    }}, window.tooltipHideDelay || 400);
                }}

                // 3. Add direct event handlers to all annotation spans
                var spans = document.querySelectorAll('span[data-annotation-id]');
                console.log(`Adding enhanced direct event handlers to ${{spans.length}} annotation spans`);

                spans.forEach(span => {{
                    // Remove any existing handlers first to avoid duplication
                    span.removeEventListener('mouseenter', showTooltipDirect);
                    span.removeEventListener('mouseleave', hideTooltipDirect);
                    span.removeEventListener('dblclick', selectAnnotationSpan);

                    // Add new handlers
                    span.addEventListener('mouseenter', showTooltipDirect);
                    span.addEventListener('mouseleave', hideTooltipDirect);
                    span.addEventListener('dblclick', selectAnnotationSpan);
                }});

                // Function to select the entire annotation span on double-click or navigate on Alt+double-click
                function selectAnnotationSpan(e) {{
                    console.log('DEBUG: selectAnnotationSpan called on element:', this);
                    console.log('DEBUG: Event details:', e);
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const span = this;
                    const annotationId = span.getAttribute('data-annotation-id');
                    const sceneData = span.getAttribute('data-scene');
                    
                    console.log('DEBUG: Span details - ID:', annotationId, 'Scene:', sceneData);
                    console.log('DEBUG: Span outerHTML:', span.outerHTML);
                    
                    // Check if Alt key is pressed for navigation
                    if (e.altKey && annotationId && sceneData) {{
                        console.log('DEBUG: Alt+Double-click navigation to theme view:', annotationId, sceneData);
                        
                        // Navigate to theme view using the same method as context menu
                        if (typeof window.jsHandler !== 'undefined' && typeof window.jsHandler.requestAnnotationNavigation === 'function') {{
                            console.log('DEBUG: Navigating to theme view via Alt+double-click');
                            window.jsHandler.requestAnnotationNavigation(annotationId, sceneData);
                        }} else {{
                            console.error('DEBUG: Cannot navigate - jsHandler not available');
                        }}
                        // Don't return - continue to select the text as well
                    }}
                    
                    // Select the span text (for both normal double-click and Alt+double-click)
                    console.log('DEBUG: Selecting annotation span text:', annotationId);
                    
                    // Create a range that selects the entire span content
                    const range = document.createRange();
                    range.selectNodeContents(span);
                    
                    // Clear any existing selection and select the span content
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    console.log('DEBUG: Selected annotation span text:', selection.toString());
                }};

                // 4. Also set up document-level event handlers as backup
                document.removeEventListener('mouseover', documentMouseOver);
                document.removeEventListener('mouseout', documentMouseOut);

                document.addEventListener('mouseover', documentMouseOver);
                document.addEventListener('mouseout', documentMouseOut);

                function documentMouseOver(e) {{
                    const span = e.target.closest('span[data-annotation-id]');
                    if (span) {{
                        console.log(`Document mouseover detected on span ${{span.getAttribute('data-annotation-id')}}`);
                        showTooltipDirect.call(span, e);
                    }}
                }}

                function documentMouseOut(e) {{
                    const span = e.target.closest('span[data-annotation-id]');
                    if (span) {{
                        console.log(`Document mouseout detected on span ${{span.getAttribute('data-annotation-id')}}`);
                        hideTooltipDirect.call(span, e);
                    }}
                }}

                // Add click listeners to navigation buttons
                var storyboardButton = tooltip.querySelector('.storyboard-nav-button');
                var themeViewButton = tooltip.querySelector('.theme-view-nav-button');
                
                if (storyboardButton) {{
                    storyboardButton.removeEventListener('click', handleStoryboardClick);
                    storyboardButton.addEventListener('click', handleStoryboardClick);
                    
                    // Add hover state for storyboard button
                    storyboardButton.addEventListener('mouseenter', function() {{
                        if (!this.disabled) {{
                            this.style.backgroundColor = '#2d3748';
                            this.style.transform = 'translateY(-1px)';
                            this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
                        }}
                    }});
                    
                    storyboardButton.addEventListener('mouseleave', function() {{
                        if (!this.disabled) {{
                            this.style.backgroundColor = '#4a5568';
                            this.style.transform = 'translateY(0)';
                            this.style.boxShadow = 'none';
                        }}
                    }});
                    
                    console.log("Added click listener and hover effects to storyboard button.");
                }}
                
                if (themeViewButton) {{
                    themeViewButton.removeEventListener('click', handleThemeViewClick);
                    themeViewButton.addEventListener('click', handleThemeViewClick);
                    
                    // Add hover state for theme view button
                    themeViewButton.addEventListener('mouseenter', function() {{
                        if (!this.disabled) {{
                            this.style.backgroundColor = '#1a202c';
                            this.style.transform = 'translateY(-1px)';
                            this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
                        }}
                    }});
                    
                    themeViewButton.addEventListener('mouseleave', function() {{
                        if (!this.disabled) {{
                            this.style.backgroundColor = '#2d3748';
                            this.style.transform = 'translateY(0)';
                            this.style.boxShadow = 'none';
                        }}
                    }});
                    
                    console.log("Added click listener and hover effects to theme view button.");
                }}

                function handleStoryboardClick(event) {{
                    console.log("Storyboard button clicked.");
                    event.stopPropagation();
                    
                    if (window.activeHighlight) {{
                        const span = window.activeHighlight;
                        const annotationId = span.getAttribute('data-annotation-id');
                        
                        if (annotationId && typeof window.jsHandler !== 'undefined' && typeof window.jsHandler.requestStoryboardNavigation === 'function') {{
                            console.log(`Requesting storyboard navigation to annotation ID: ${{annotationId}}`);
                            window.jsHandler.requestStoryboardNavigation(annotationId);
                        }} else {{
                            console.error("Cannot navigate to storyboard: missing annotation ID or handler");
                        }}
                    }}
                }}
                
                function handleThemeViewClick(event) {{
                    console.log("Theme view button clicked.");
                    event.stopPropagation();
                    
                    if (window.activeHighlight) {{
                        const span = window.activeHighlight;
                        const annotationId = span.getAttribute('data-annotation-id');
                        const scene = span.getAttribute('data-scene');
                        
                        if (annotationId && scene && typeof window.jsHandler !== 'undefined' && typeof window.jsHandler.requestAnnotationNavigation === 'function') {{
                            console.log(`Requesting theme view navigation to annotation ID: ${{annotationId}}, Scene: ${{scene}}`);
                            window.jsHandler.requestAnnotationNavigation(annotationId, scene);
                        }} else {{
                            console.error("Cannot navigate to theme view: missing annotation data or handler");
                        }}
                    }}
                }}

                function handleTooltipTitleClick(event) {{
                    console.log("Tooltip title clicked.");
                    event.stopPropagation(); // Prevent other click handlers (like document click)

                    if (window.activeHighlight) {{ // Use the stored activeHighlight
                        const span = window.activeHighlight;
                        const annotationId = span.getAttribute('data-annotation-id');
                        const scene = span.getAttribute('data-scene');

                        if (annotationId && scene && typeof window.jsHandler !== 'undefined' && typeof window.jsHandler.requestAnnotationNavigation === 'function') {{
                            console.log(`Requesting navigation to annotation ID: ${{annotationId}}, Scene: ${{scene}}`);
                            window.jsHandler.requestAnnotationNavigation(annotationId, scene);
                            // Optionally hide the tooltip after clicking
                            // tooltip.classList.remove('visible');
                            // window.activeHighlight = null;
                        }} else {{
                            console.error("Could not navigate: Missing annotationId, scene, or jsHandler.requestAnnotationNavigation function.", {{
                                annotationId: annotationId,
                                scene: scene,
                                jsHandlerExists: typeof window.jsHandler !== 'undefined',
                                functionExists: typeof window.jsHandler?.requestAnnotationNavigation === 'function'
                            }});
                        }}
                    }} else {{
                        console.warn("Tooltip title clicked, but no active highlight span found.");
                    }}
                }}

                // Add tooltip event handlers
                tooltip.addEventListener('mouseover', function() {{
                    console.log("Mouseover on tooltip itself");
                    if (window.tooltipHideTimer) {{
                        clearTimeout(window.tooltipHideTimer);
                        window.tooltipHideTimer = null;
                    }}
                }});

                tooltip.addEventListener('mouseout', function() {{
                    console.log("Mouseout from tooltip itself");
                    if (!window.tooltipCtrlPressed) {{
                        hideTooltipDirect.call(window.activeHighlight || this);
                    }}
                }});

                // Adjust document click handler
                document.removeEventListener('click', handleDocumentClick);
                document.addEventListener('click', handleDocumentClick);
                
                // Store right-click target for context menu
                document.addEventListener('contextmenu', function(e) {{
                    window.lastRightClickTarget = e.target;
                    console.log('DEBUG: Right-click detected on element:', e.target);
                    console.log('DEBUG: Element tagName:', e.target.tagName);
                    console.log('DEBUG: Element classes:', e.target.className);
                    
                    // Check if clicked on annotation span
                    var annotationSpan = e.target.closest('span[data-annotation-id]');
                    if (annotationSpan) {{
                        console.log('DEBUG: Found annotation span:', annotationSpan.getAttribute('data-annotation-id'));
                        console.log('DEBUG: Scene data:', annotationSpan.getAttribute('data-scene'));
                    }} else {{
                        console.log('DEBUG: No annotation span found');
                    }}
                }});
                
                // Inject transparent selection CSS with different transparency for annotations vs regular text
                if (!document.getElementById('transparent-selection-style')) {{
                    var style = document.createElement('style');
                    style.id = 'transparent-selection-style';
                    style.textContent = `
                        /* Default selection for non-highlighted text - white text with shadow */
                        ::selection {{
                            background-color: rgba(33, 150, 243, 0.6) !important;
                            color: white !important;
                            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.6), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
                        }}
                        ::-moz-selection {{
                            background-color: rgba(33, 150, 243, 0.6) !important;
                            color: white !important;
                            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.6), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
                        }}
                        
                        /* More transparent selection for annotation spans with prominent white text */
                        span[data-annotation-id]::selection {{
                            background-color: rgba(33, 150, 243, 0.2) !important;
                            color: white !important;
                            text-shadow: 0 0 6px rgba(0, 0, 0, 1.0), 0 0 12px rgba(0, 0, 0, 0.8), 0 1px 3px rgba(0, 0, 0, 1.0), 1px 1px 2px rgba(0, 0, 0, 0.9) !important;
                        }}
                        span[data-annotation-id]::-moz-selection {{
                            background-color: rgba(33, 150, 243, 0.2) !important;
                            color: white !important;
                            text-shadow: 0 0 6px rgba(0, 0, 0, 1.0), 0 0 12px rgba(0, 0, 0, 0.8), 0 1px 3px rgba(0, 0, 0, 1.0), 1px 1px 2px rgba(0, 0, 0, 0.9) !important;
                        }}
                    `;
                    document.head.appendChild(style);
                    console.log('DEBUG: Injected transparent selection CSS with prominent white text and shadows');
                }};

                function handleDocumentClick(event) {{
                    const span = event.target.closest('span[data-annotation-id]');
                    const titleClicked = event.target.closest('.tooltip-title'); // Check if the click was on the title

                    // If clicking on a span with notes, toggle tooltip, UNLESS it was the title
                    if (span && !titleClicked) {{ 
                        console.log("Click on annotation span:", span.getAttribute('data-annotation-id'));

                        // Cancel any pending hide
                        if (window.tooltipHideTimer) {{
                            clearTimeout(window.tooltipHideTimer);
                            window.tooltipHideTimer = null;
                        }}

                        // Toggle tooltip persistent state
                        if (window.activeHighlight === span && tooltip.classList.contains('visible')) {{
                            console.log("Clicked on active span again, hiding tooltip");
                            tooltip.classList.remove('visible');
                            window.activeHighlight = null;
                        }} else {{
                            console.log("Clicked on new span or inactive span, showing tooltip");
                            // Call showTooltipDirect on the *clicked* span
                            showTooltipDirect.call(span, event);
                        }}

                        // Prevent any other click handlers
                        event.stopPropagation();
                    }} else if (tooltip.classList.contains('visible') && !tooltip.contains(event.target)) {{
                        // Hide tooltip when clicking elsewhere (outside tooltip and outside title)
                        console.log("Click outside tooltip and annotation, hiding tooltip");
                        tooltip.classList.remove('visible');
                        window.activeHighlight = null;
                    }}
                    // Implicitly do nothing if the click was on the title itself
                }}

                // 5. Test the tooltip with the first annotation if available
                // Commented out to prevent automatic tooltip display during session load
                /*
                if (spans.length > 0) {{
                    console.log("Testing enhanced tooltip with first annotation span");

                    // Simulate a mouseover on the first span after a short delay
                    setTimeout(() => {{
                        const testSpan = spans[0];
                        console.log(`Simulating mouseover on span: ${{testSpan.getAttribute('data-annotation-id')}}`);

                        const fakeEvent = new MouseEvent('mouseenter', {{
                            bubbles: true,
                            cancelable: true,
                            view: window
                        }});

                        testSpan.dispatchEvent(fakeEvent);

                        // Hide after 2 seconds
                        setTimeout(() => {{
                            console.log("Hiding test tooltip");
                            tooltip.classList.remove('visible');
                            window.activeHighlight = null; // Also clear active highlight after test
                        }}, 2000);
                    }}, 500);
                }}
                */

                return {{
                    success: true,
                    spanCount: spans.length,
                    styleAdded: true,
                    message: "Enhanced tooltip fixes applied successfully with scrollable content and sticky headers"
                }};
                
                // Global double-click handler for all annotation spans (including newly created ones)
                function globalAnnotationDoubleClick(e) {{
                    const span = e.target.closest('span[data-annotation-id]');
                    if (span) {{
                        console.log('DEBUG: Global double-click detected on annotation span:', span.getAttribute('data-annotation-id'));
                        
                        // Prevent default word selection behavior
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Check for Alt+double-click navigation
                        const annotationId = span.getAttribute('data-annotation-id');
                        const sceneData = span.getAttribute('data-scene');
                        
                        if (e.altKey && annotationId && sceneData) {{
                            console.log('DEBUG: Alt+Double-click navigation to theme view:', annotationId, sceneData);
                            
                            // Navigate to theme view
                            if (typeof window.jsHandler !== 'undefined' && typeof window.jsHandler.requestAnnotationNavigation === 'function') {{
                                console.log('DEBUG: Navigating to theme view via Alt+double-click');
                                window.jsHandler.requestAnnotationNavigation(annotationId, sceneData);
                            }} else {{
                                console.error('DEBUG: Cannot navigate - jsHandler not available');
                            }}
                        }}
                        
                        // Always select the full annotation text
                        console.log('DEBUG: Selecting full annotation text for:', annotationId);
                        const range = document.createRange();
                        range.selectNodeContents(span);
                        
                        const selection = window.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(range);
                        
                        console.log('DEBUG: Selected text:', selection.toString());
                    }}
                }}
                
                document.removeEventListener('dblclick', globalAnnotationDoubleClick);
                document.addEventListener('dblclick', globalAnnotationDoubleClick);
                console.log('DEBUG: Global annotation double-click handler installed!');
                
            }})();
            """

            def handle_fix_result(result):
                if not result or not isinstance(result, dict):
                    print("Error: Invalid result from tooltip fix")
                    # Still proceed with completion to unblock dependency chains
                    try:
                        if callable(on_complete):
                            QTimer.singleShot(0, on_complete)
                    finally:
                        return

                print("\n=== TOOLTIP FIX RESULTS ===")
                if result.get('success'):
                    print(f"✅ Enhanced tooltip fixes applied successfully")
                    if "scrollable content" in result.get('message', ''):
                        print(f"✅ Scrollable tooltips with sticky headers enabled.")
                    print(f"✅ Added direct event handlers to {result.get('spanCount', 0)} annotation spans")
                    if result.get('spanCount', 0) > 0:
                        print(f"✅ Test tooltip was displayed for first annotation span")
                        print(f"⚠️ If you still don't see tooltips, try refreshing the page or recreating the web view")
                    else:
                        print(f"⚠️ No annotation spans were found. Ensure annotations are properly created")
                else:
                    print(f"❌ Failed to apply tooltip fixes: {result.get('message', 'Unknown error')}")
                print("=== END FIX RESULTS ===\n")

                # Invoke completion callback after tooltip fix (success or failure)
                try:
                    if callable(on_complete):
                        QTimer.singleShot(0, on_complete)
                except Exception as _e:
                    print(f"[DEBUG] on_complete for tooltip fix raised: {_e}")

            self.page().runJavaScript(fix_js, handle_fix_result)

    def toggle_tooltips(self, enabled=None):
        """Toggle tooltips on or off"""
        if enabled is None:
            # Toggle the current state
            self.tooltips_enabled = not getattr(self, 'tooltips_enabled', True)
        else:
            # Set to specified state
            self.tooltips_enabled = enabled
        
        # Update the JavaScript side
        js_code = f"""
        (function() {{
            // Explicitly set the value to ensure proper toggling
            window.tooltipsEnabled = {str(self.tooltips_enabled).lower()};
        
            console.log("Setting tooltipsEnabled to:", window.tooltipsEnabled);
        
            // If disabling, hide any visible tooltip
            if (!window.tooltipsEnabled) {{
                var tooltip = document.querySelector('.notes-tooltip');
                if (tooltip) tooltip.classList.remove('visible');
                window.activeHighlight = null;
                if (window.tooltipShowTimer) {{
                    clearTimeout(window.tooltipShowTimer);
                    window.tooltipShowTimer = null;
                }}
                if (window.tooltipHideTimer) {{
                    clearTimeout(window.tooltipHideTimer);
                    window.tooltipHideTimer = null;
                }}
            }}
        
            // Log for debugging
            console.log("Tooltips " + (window.tooltipsEnabled ? "enabled" : "disabled"));
        
            // Make sure all spans have tooltip cursor if enabled
            var spans = document.querySelectorAll('span[data-annotation-id]');
            spans.forEach(span => {{
                span.style.cursor = window.tooltipsEnabled ? 'help' : 'default';
            }});
        
            return window.tooltipsEnabled;
        }})();
        """
    
        def update_status(enabled):
            try:
                # Check if main window and status bar still exist
                if (hasattr(self, 'main_window') and self.main_window and 
                    hasattr(self.main_window, 'status_bar') and self.main_window.status_bar):
                    # Update status message and reset the context menu next time it's shown
                    status_message = "Tooltips enabled" if enabled else "Tooltips disabled"
                    self.main_window.status_bar.showMessage(status_message, 3000)
                    # Force refresh context menu text next time it's shown
                    self._last_tooltips_enabled = enabled
            except RuntimeError as e:
                # Main window or status bar has been deleted - this is expected during close
                print(f"[DEBUG] Status bar deleted during tooltip update: {e}")
            except Exception as e:
                print(f"[DEBUG] Unexpected error in tooltip status update: {e}")
    
        self.page().runJavaScript(js_code, update_status)
    
        # Update menu text immediately if we have access to it
        if hasattr(self, '_tooltip_action') and self._tooltip_action:
            self._tooltip_action.setText("Disable Tooltips" if self.tooltips_enabled else "Enable Tooltips")

    def set_tooltip_position(self, position):
        """Set the preferred tooltip position"""
        if position not in ["right", "left", "top", "bottom"]:
            position = "left"  # Default to left if invalid
    
        js_code = f"""
        (function() {{
            window.tooltipPreferredPosition = '{position}';
            console.log("Tooltip position set to:", window.tooltipPreferredPosition);
    
            // If a tooltip is currently visible, reposition it
            var tooltip = document.querySelector('.notes-tooltip');
            var activeHighlight = window.activeHighlight;
    
            if (tooltip && tooltip.classList.contains('visible') && activeHighlight) {{
                // Get position data
                const spanRect = activeHighlight.getBoundingClientRect();
            
                // Reset any max-height constraints temporarily to get true dimensions
                const tooltipHtmlNotes = tooltip.querySelector('.tooltip-html-notes');
                let originalMaxHeight = null;
                if (tooltipHtmlNotes) {{
                    originalMaxHeight = tooltipHtmlNotes.style.maxHeight;
                    tooltipHtmlNotes.style.maxHeight = ''; // Remove temporarily
                }}
            
                // Get dimensions for positioning
                const tooltipHeight = tooltip.offsetHeight;
                const tooltipWidth = tooltip.offsetWidth;
            
                // Restore max-height if we changed it
                if (tooltipHtmlNotes && originalMaxHeight !== null) {{
                    tooltipHtmlNotes.style.maxHeight = originalMaxHeight;
                }}
        
                // Calculate new position
                var topPosition, leftPosition;
        
                switch (window.tooltipPreferredPosition) {{
                    case "right":
                        leftPosition = spanRect.right + 10;
                        topPosition = spanRect.top + (spanRect.height / 2) - (tooltipHeight / 2);
                    
                        // If it would go off the right edge, place it to the left
                        if (leftPosition + tooltipWidth > window.innerWidth - 10) {{
                            leftPosition = spanRect.left - tooltipWidth - 10;
                        }}
                        break;
                    case "left":
                        leftPosition = spanRect.left - tooltipWidth - 10;
                        topPosition = spanRect.top + (spanRect.height / 2) - (tooltipHeight / 2);
                    
                        // If it would go off the left edge, place it to the right
                        if (leftPosition < 10) {{
                            leftPosition = spanRect.right + 10;
                        }}
                        break;
                    case "top":
                        topPosition = spanRect.top - tooltipHeight - 10;
                        leftPosition = spanRect.left + (spanRect.width / 2) - (tooltipWidth / 2);
                    
                        // If it would go off the top, place it below
                        if (topPosition < 10) {{
                            topPosition = spanRect.bottom + 10;
                        }}
                        break;
                    case "bottom":
                        topPosition = spanRect.bottom + 10;
                        leftPosition = spanRect.left + (spanRect.width / 2) - (tooltipWidth / 2);
                    
                        // If it would go off the bottom, place it above
                        if (topPosition + tooltipHeight > window.innerHeight - 10) {{
                            topPosition = spanRect.top - tooltipHeight - 10;
                        }}
                        break;
                }}
        
                // Keep within viewport - final check
                if (leftPosition < 10) leftPosition = 10;
                if (leftPosition + tooltipWidth > window.innerWidth - 10) 
                    leftPosition = window.innerWidth - tooltipWidth - 10;
                if (topPosition < 10) topPosition = 10;
                if (topPosition + tooltipHeight > window.innerHeight - 10)
                    topPosition = window.innerHeight - tooltipHeight - 10;
            
                // Apply new position
                tooltip.style.top = topPosition + 'px';
                tooltip.style.left = leftPosition + 'px';
            
                console.log("Repositioned tooltip to match new preference:", window.tooltipPreferredPosition);
            }}
    
            return window.tooltipPreferredPosition;
        }})();
        """

        def update_status(position):
            # Update status message
            self.main_window.status_bar.showMessage(f"Tooltip position set to: {position}", 3000)

        self.page().runJavaScript(js_code, update_status)

    def toggle_sticky_header(self, enabled=None):
        """Toggle sticky header on or off"""
        if enabled is None:
            # Toggle the current state
            self.sticky_header_enabled = not getattr(self, 'sticky_header_enabled', False)
        else:
            # Set to specified state
            self.sticky_header_enabled = enabled
        
        # Save to settings
        if hasattr(self, 'app_settings') and self.app_settings:
            self.app_settings.setValue("sticky_header/enabled", self.sticky_header_enabled)
            self.app_settings.sync()
        
        # Always use DOM-based sticky header (PyQt version disabled)
        if self.sticky_header_enabled:
            print("[DEBUG] Using DOM-based sticky header mode")
            self.inject_sticky_header_dom()
            # Inject permanent restore button CSS if not already done
            self.inject_restore_button_css()
        else:
            # Hide DOM header and clear all filters
            hide_dom_js = """
            (function() {
                const header = document.getElementById('scriptoria-sticky-header');
                if (header) {
                    header.remove();
                    console.log('[DEBUG] DOM sticky header removed');
                }
                
                // Clear all sticky header filters when disabling sticky header
                if (window.stickyHeaderFilters) {
                    window.stickyHeaderFilters.favorites = false;
                    window.stickyHeaderFilters.used = 0;
                    window.stickyHeaderTagState = { isActive: false, selectedTags: new Set() };
                }
                
                // Clear theme filters (exit solo mode and show all themes)
                if (window.stickyHeaderState) {
                    const state = window.stickyHeaderState;
                    state.soloTheme = null;
                    if (state.hiddenThemes) { state.hiddenThemes.clear(); }
                    // Show all highlights to fully reset theme filtering
                    if (state.themes) {
                        state.themes.forEach(theme => {
                            if (typeof window.showThemeHighlights === 'function') {
                                window.showThemeHighlights(theme.name);
                            }
                        });
                    }
                }
                
                // Remove all annotation filter classes
                document.querySelectorAll('[data-annotation-id]').forEach(annotation => {
                    annotation.classList.remove('favorites-hidden', 'used-hidden', 'unused-hidden', 'tag-filtered-hidden');
                });
                
                // Hard clear any existing scrollbar indicators immediately
                document.querySelectorAll('.scroll-indicator').forEach(el => el.remove());
                
                // Reset navigation matches
                window.currentMatchIndex = -1;
                window.matchedAnnotations = [];
                if (window.updateNavigationMenuState) { window.updateNavigationMenuState(); }
                
                console.log('[DEBUG] All sticky header filters cleared when disabling sticky header');
            })();
            """
            self.page().runJavaScript(hide_dom_js)
        
        print(f"Sticky header {'enabled' if self.sticky_header_enabled else 'disabled'} (DOM mode)")

    def update_sticky_header_size(self, size_multiplier):
        """Update the sticky header size dynamically"""
        self.sticky_header_size = size_multiplier
        
        # Check if header was visible before updating
        check_visibility_js = """
        (function() {
            const header = document.getElementById('scriptoria-sticky-header');
            return header ? header.classList.contains('visible') : false;
        })();
        """
        
        def update_with_preserved_state(was_visible):
            # Update the CSS with the new size
            if self.sticky_header_enabled:
                self.inject_sticky_header_dom()  # Re-inject with new size
                
                # Restore visibility state after injection
                if was_visible:
                    restore_visibility_js = """
                    setTimeout(() => {
                        const header = document.getElementById('scriptoria-sticky-header');
                        if (header) {
                            header.classList.add('visible');
                            console.log('[DEBUG] Sticky header visibility restored after scaling');
                        }
                    }, 100);
                    """
                    self.page().runJavaScript(restore_visibility_js)
                else:
                    # If header wasn't visible, check if it should be based on scroll position
                    trigger_scroll_check_js = """
                    setTimeout(() => {
                        if (window.domStickyHeaderScrollListener) {
                            console.log('[DEBUG] Triggering scroll check after header size change');
                            window.domStickyHeaderScrollListener();
                        }
                    }, 100);
                    """
                    self.page().runJavaScript(trigger_scroll_check_js)
        
        # Check current state and update
        if self.sticky_header_enabled:
            self.page().runJavaScript(check_visibility_js, update_with_preserved_state)
        
        # Save to settings
        if hasattr(self, 'app_settings') and self.app_settings:
            self.app_settings.setValue("sticky_header/size", self.sticky_header_size)
            self.app_settings.sync()

    def setup_scroll_detection(self):
        """Setup JavaScript scroll detection for sticky header"""
        print("[DEBUG] Setting up scroll detection for sticky header")
        js_code = """
        (function() {
            console.log('[DEBUG] Starting sticky header scroll detection setup');
            
            // Remove existing scroll listener if it exists
            if (window.stickyHeaderScrollListener) {
                document.removeEventListener('scroll', window.stickyHeaderScrollListener);
                console.log('[DEBUG] Removed existing scroll listener');
            }
            
            let scrollThreshold = 100;  // Show header after scrolling 100px
            let isHeaderVisible = false;
            
            window.stickyHeaderScrollListener = function() {
                const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                console.log('[DEBUG] Scroll detected - scrollTop:', scrollTop, 'threshold:', scrollThreshold, 'isHeaderVisible:', isHeaderVisible);
                
                if (scrollTop > scrollThreshold && !isHeaderVisible) {
                    // Show header
                    console.log('[DEBUG] Triggering show sticky header');
                    isHeaderVisible = true;
                    if (window.jsHandler) {
                        console.log('[DEBUG] Calling jsHandler.showStickyHeader()');
                        window.jsHandler.showStickyHeader();
                    } else {
                        console.error('[DEBUG] window.jsHandler not available');
                    }
                } else if (scrollTop <= scrollThreshold && isHeaderVisible) {
                    // Hide header
                    console.log('[DEBUG] Triggering hide sticky header');
                    isHeaderVisible = false;
                    if (window.jsHandler) {
                        console.log('[DEBUG] Calling jsHandler.hideStickyHeader()');
                        window.jsHandler.hideStickyHeader();
                    } else {
                        console.error('[DEBUG] window.jsHandler not available');
                    }
                }
            };
            
            // Add scroll listener
            document.addEventListener('scroll', window.stickyHeaderScrollListener);
            console.log('[DEBUG] Scroll listener added to document');
            
            // Test scroll detection immediately
            setTimeout(function() {
                const currentScroll = document.documentElement.scrollTop || document.body.scrollTop;
                console.log('[DEBUG] Current scroll position on setup:', currentScroll);
            }, 500);
            
            console.log('[DEBUG] Sticky header scroll detection initialized successfully');
        })();
        """
        
        def scroll_setup_complete(result):
            print(f"[DEBUG] Scroll detection setup complete. Result: {result}")
        
        self.page().runJavaScript(js_code, scroll_setup_complete)

    def inject_sticky_header_dom(self):
        """Inject the new DOM-based sticky header into the HTML content"""
        print("[DEBUG] Injecting DOM-based sticky header")
        
        # Calculate dynamic sizes based on multiplier
        base_padding = 12
        base_gap = 6
        base_font_size = 11
        
        dynamic_padding = base_padding * self.sticky_header_size
        dynamic_gap = base_gap * self.sticky_header_size
        dynamic_font_size = base_font_size * self.sticky_header_size
        
        # HTML and CSS for the new sticky header
        header_html_css = """
        (function() {
            console.log('[DEBUG] Starting DOM sticky header injection');
            
            // Remove existing DOM sticky header if present
            const existingHeader = document.getElementById('scriptoria-sticky-header');
            if (existingHeader) {
                existingHeader.remove();
                console.log('[DEBUG] Removed existing DOM sticky header');
                // Clear sticky menu binding state so new elements can rebind
                window._stickyMenuHandlersBound = false;
                window._stickyMenuHandlers = null;
                window._stickyMenuButton = null;
            }
            
            // Create the HTML structure
            const headerHTML = `
                <div id="scriptoria-sticky-header" class="sticky-theme-header">
                    <button id="tag-filter-btn" class="tag-filter-btn" title="Filter by Tags">
                        🏷️
                    </button>
                    <button id="favorites-filter-btn" class="tag-filter-btn" title="Filter Favorites (Showing All)">
                        ☆
                    </button>
                    <button id="used-filter-btn" class="tag-filter-btn" data-state="0" title="Filter Used (Showing All Used and Unused)">
                        ◪
                    </button>
                    <div class="header-content">
                        <div class="theme-buttons-container" id="sticky-theme-buttons">
                            <!-- Theme buttons will be populated by JavaScript -->
                        </div>
                    </div>
                    <div class="header-controls">
                        <div class="header-menu-container">
                            <button id="sticky-header-menu" class="header-menu-btn" title="Filter actions">☰</button>
                            <div id="sticky-header-menu-dropdown" class="header-menu-dropdown">
                                <div class="menu-item" id="menu-navigate-next">▼ Navigate Next Match</div>
                                <div class="menu-item" id="menu-navigate-prev">▲ Navigate Previous Match</div>
                                <div class="menu-separator"></div>
                                <div class="menu-item" id="menu-refresh-filters">⟳ Refresh Filters</div>
                                <div class="menu-item" id="menu-clear-filters">◯ Clear All Filters</div>
                            </div>
                        </div>
                        <button id="sticky-header-close" class="header-close-btn" title="Hide sticky header">×</button>
                    </div>
                </div>
            `;
            
            // Create the CSS styles
            const headerCSS = `
                <style id="scriptoria-sticky-header-styles">
                    .sticky-theme-header {
                        position: fixed;
                        top: 0;
                        left: var(--sidebar-width);
                        right: 0;
                        width: calc(100% - var(--sidebar-width));
                        background: linear-gradient(180deg, rgba(255, 255, 255, 1.0) 0%, rgba(255, 255, 255, 0.75) 100%);
                        border-bottom: 1px solid #dee2e6;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
                        z-index: 12000; /* Raised above scroll indicators and overlays */
                        transform: translateY(-100%);
                        transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
                        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                    }
                    
                    .sticky-theme-header.visible {
                        transform: translateY(0);
                    }
                    
                    .sticky-theme-header .header-content {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: DYNAMIC_PADDING_PLACEHOLDER 237px DYNAMIC_PADDING_PLACEHOLDER 192px;  /* More balanced */
                        width: 100%;
                        box-sizing: border-box;
                        position: relative;
                    }
                    
                    .tag-filter-btn {
                        width: 35px;
                        height: 35px;
                        background: transparent;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        transition: all 0.2s ease;
                        padding: 21px 21px;
                        font-size: 28px;
                        font-weight: 500;
                        z-index: 12;
                    }
                    
                    /* Original tag filter button positioning */
                    #tag-filter-btn {
                        position: absolute;
                        left: 16px;
                        top: 9px;
                    }
                    
                    .tag-filter-btn:hover {
                        background: rgba(33, 150, 243, 0.1);
                        border-color: #2196F3;
                        transform: translateY(-1px) scale(1.1);
                    }
                    
                    .tag-filter-btn.active {
                        background: rgba(33, 150, 243, 0.15);
                        border: 1px solid #2196F3;
                    }
                    
                    /* Position favorites button to the right of tag button */
                    #favorites-filter-btn {
                        position: absolute;
                        left: 57px;
                        top: 9px;
                        font-size: 22px;
                        padding-right: 15px;
                        z-index: 15;
                    }
                    
                    /* Position used button to the right of favorites button */
                    #used-filter-btn {
                        position: absolute;
                        left: 97px;
                        top: 9px;
                        font-size: 18px;
                        padding-right: 16px;
                        padding-top: 15px;
                        z-index: 15;
                    }
                    
                    /* Original tag filter button positioning */
                    #tag-filter-btn {
                        position: absolute;
                        left: 16px;
                        top: 9px;
                    }
                    
                    /* Separate styling for empty state (data-state="0") */
                    #used-filter-btn[data-state="0"] {
                        font-size: 20px;
                        padding-right: 15px;
                        padding-top: 18px;
                    }
                    
                    /* Green text for empty state only */
                    #used-filter-btn[data-state="0"] {
                        color: #4CAF50;
                    }
                    
                    /* Specific styling for favorites filter when active */
                    #favorites-filter-btn.active {
                        background: rgba(255, 215, 0, 0.15);
                        border: 1px solid #FFD700;
                        color: #FFD700;
                        padding-right: 16.5px;
                    }
                    
                    /* Specific styling for used filter states */
                    #used-filter-btn[data-state="1"] {
                        background: rgba(244, 67, 54, 0.1);
                        border: 1px solid #f44336;
                        color: #f44336;
                    }
                    
                    #used-filter-btn[data-state="2"] {
                        background: rgba(76, 175, 80, 0.15);
                        border: 1px solid #4CAF50;
                        color: #4CAF50;
                        font-size: 24px;
                        padding-top: 12px;
                    }
                    
                    /* Filter visibility classes (work like theme-hidden) */
                    .favorites-hidden {
                        border: 1px dashed #ccc !important;
                        background-color: #e8e8e8 !important;
                    }
                    
                    .used-hidden {
                        border: 1px dashed #ccc !important;
                        background-color: #e8e8e8 !important;
                    }
                    
                    .unused-hidden {
                        border: 1px dashed #ccc !important;
                        background-color: #e8e8e8 !important;
                    }
                    
                    .tag-filtered-hidden {
                        border: 1px dashed #ccc !important;
                        background-color: #e8e8e8 !important;
                    }
                    
                    /* Dim pseudo-element icons for all hidden filter states */
                    .favorites-hidden::before, .favorites-hidden::after,
                    .used-hidden::before, .used-hidden::after,
                    .unused-hidden::before, .unused-hidden::after, 
                    .tag-filtered-hidden::before, .tag-filtered-hidden::after,
                    .theme-hidden::before, .theme-hidden::after {
                        opacity: 0.3 !important;
                    }
                    
                    .theme-buttons-container {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 8.12px;
                        justify-content: center;
                        align-items: center;
                        flex: 1;
                        overflow-x: auto;
                        scrollbar-width: thin;
                        scrollbar-color: #ccc transparent;
                        max-width: calc(100% - 20px);
                        padding-top: 2px;
                    }
                    
                    .theme-buttons-container::-webkit-scrollbar {
                        height: 4px;
                    }
                    
                    .theme-buttons-container::-webkit-scrollbar-track {
                        background: transparent;
                    }
                    
                    .theme-buttons-container::-webkit-scrollbar-thumb {
                        background: #ccc;
                        border-radius: 2px;
                    }
                    
                    .sticky-theme-btn {
                        padding: 4px 8px;
                        border: 1px solid #ccc;
                        border-radius: 4px;
                        background: #fff;
                        color: #333;
                        font-size: DYNAMIC_FONT_SIZE_PLACEHOLDER;
                        font-weight: 500;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        white-space: nowrap;
                        user-select: none;
                        min-height: 24px;
                        display: flex;
                        align-items: center;
                    }
                    
                    .sticky-theme-btn:hover {
                        border-color: #666;
                        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                        transform: translateY(-1px);
                    }
                    
                    .sticky-theme-btn.theme-hidden {
                        opacity: 0.5;
                        background: #e8e8e8;
                        text-decoration: line-through;
                    }
                    
                    .sticky-theme-btn.solo-mode {
                        border: 2px solid #ff6b35;
                        box-shadow: 0 0 6px rgba(255, 107, 53, 0.3);
                        font-weight: 600;
                    }
                    
                    .header-controls {
                        position: absolute;
                        right: 16px;
                        top: 50%;
                        transform: translateY(-50%);
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    }
                    
                    .header-close-btn {
                        width: 24px;
                        height: 24px;
                        border: none;
                        background: #f8f9fa;
                        color: #666;
                        border-radius: 50%;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: bold;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        transition: all 0.2s ease;
                    }
                    
                    .header-menu-container {
                        position: relative;
                        display: inline-block;
                    }
                    
                    .header-menu-btn {
                        width: 35px;
                        height: 35px;
                        border: none;
                        background: #f8f9fa;
                        color: #666;
                        border-radius: 50%;
                        cursor: pointer;
                        font-size: 16px;
                        font-weight: bold;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        transition: all 0.2s ease;
                        padding-bottom: 4px;
                    }
                    
                    .header-menu-btn:hover, .header-close-btn:hover {
                        background: #e9ecef;
                        color: #495057;
                        transform: scale(1.1);
                    }
                    
                    .header-menu-dropdown {
                        display: none;
                        position: absolute;
                        top: 100%;
                        right: 0;
                        background: white;
                        border: 1px solid #ddd;
                        border-radius: 4px;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                        z-index: 12010; /* Ensure menu sits above sticky header and indicators */
                        min-width: 160px;
                        margin-top: 4px;
                    }
                    
                    .header-menu-dropdown.show {
                        display: block;
                    }
                    
                    .menu-item {
                        padding: 8px 12px;
                        cursor: pointer;
                        border-bottom: 1px solid #eee;
                        font-size: 13px;
                        color: #333;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        transition: background-color 0.2s ease;
                    }
                    
                    .menu-item:last-child {
                        border-bottom: none;
                    }
                    
                    .menu-item:hover {
                        background-color: #f8f9fa;
                    }
                    
                    .menu-separator {
                        height: 1px;
                        background: #e0e0e0;
                        margin: 4px 0;
                    }
                    
                    
                    .restore-btn {
                        background: rgba(255, 255, 255, 0.95);
                        border: 2px solid #007acc;
                        border-radius: 12px;
                        padding: 12px 16px;
                        cursor: pointer;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.25);
                        transition: all 0.2s ease;
                        font-size: 16px;
                        font-weight: bold;
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        min-width: 60px;
                        min-height: 40px;
                    }
                    
                    .restore-btn:hover {
                        background: rgba(255, 255, 255, 0.95);
                        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                        transform: translateY(-1px);
                    }
                    
                    .restore-icon {
                        font-size: 18px;
                    }
                    
                    /* Responsive design */
                    @media (max-width: 768px) {
                        .sticky-theme-header {
                            left: 0;
                            width: 100%;
                        }
                        
                        .sticky-theme-header .header-content {
                            padding: 8.5px 12px;
                        }
                        
                        .sticky-theme-btn {
                            padding: 3px 6px;
                            font-size: 10px;
                        }
                        
                        .header-controls {
                            right: 12px;
                        }
                        
                    }
                    
                    /* Tag Filter Dialog Styles */
                    .tag-filter-dialog-overlay {
                        position: relative;
                        display: inline-block;
                        z-index: 10002;
                        opacity: 0;
                        transition: opacity 0.3s ease;
                        pointer-events: none;
                    }
                    
                    .tag-filter-dialog-overlay.visible {
                        opacity: 1;
                        pointer-events: auto;
                    }
                    
                    .tag-filter-dialog {
                        position: absolute;
                        top: 100%;
                        left: 0;
                        transform: translateY(-10px) scale(0.9);
                        background: rgba(255, 255, 255, 0.98);
                        backdrop-filter: blur(10px);
                        border-radius: 12px;
                        box-shadow: 0 8px 32px rgba(0,0,0,0.15);
                        z-index: 10003;
                        padding: 24px;
                        min-width: 400px;
                        max-width: 500px;
                        max-height: 70vh;
                        display: flex;
                        flex-direction: column;
                        opacity: 0;
                        transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
                        margin-top: 5px;
                    }
                    
                    .tag-filter-dialog.visible {
                        transform: translateY(0) scale(1);
                        opacity: 1;
                    }
                    
                    .tag-filter-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 20px;
                        padding-bottom: 16px;
                        border-bottom: 1px solid #e0e0e0;
                    }
                    
                    .tag-filter-title {
                        font-size: 18px;
                        font-weight: 600;
                        color: #333;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    }
                    
                    .tag-filter-close {
                        background: none;
                        border: none;
                        font-size: 24px;
                        color: #666;
                        cursor: pointer;
                        padding: 0;
                        width: 30px;
                        height: 30px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 50%;
                        transition: all 0.2s ease;
                    }
                    
                    .tag-filter-close:hover {
                        background: #f0f0f0;
                        color: #333;
                    }
                    
                    .tag-filter-controls {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 16px;
                        gap: 12px;
                    }
                    
                    .tag-filter-mode {
                        display: flex;
                        background: #f8f9fa;
                        border-radius: 6px;
                        padding: 2px;
                        gap: 0;
                    }
                    
                    .mode-toggle-btn {
                        flex: 1;
                        padding: 6px 12px;
                        border: none;
                        background: transparent;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 500;
                        color: #666;
                        transition: all 0.2s ease;
                        white-space: nowrap;
                    }
                    
                    .mode-toggle-btn:hover {
                        background: rgba(33, 150, 243, 0.1);
                        color: #2196F3;
                    }
                    
                    .mode-toggle-btn.active {
                        background: #2196F3;
                        color: white;
                        box-shadow: 0 1px 3px rgba(33, 150, 243, 0.3);
                    }
                    
                    .tag-filter-mode {
                        display: flex;
                        gap: 8px;
                        align-items: center;
                    }
                    
                    .tag-filter-mode-btn {
                        padding: 6px 12px;
                        border: 1px solid #dee2e6;
                        background: white;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 13px;
                        transition: all 0.2s ease;
                    }
                    
                    .tag-filter-mode-btn.active {
                        background: #2196F3;
                        color: white;
                        border-color: #2196F3;
                    }
                    
                    .tag-filter-mode-btn:hover:not(.active) {
                        background: #f5f5f5;
                    }
                    
                    .tag-filter-actions {
                        display: flex;
                        gap: 8px;
                    }
                    
                    .tag-filter-action-btn {
                        padding: 4px 8px;
                        border: 1px solid #dee2e6;
                        background: white;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                        transition: all 0.2s ease;
                    }
                    
                    .tag-filter-action-btn:hover {
                        background: #f0f0f0;
                    }
                    
                    .tag-filter-list {
                        flex: 1;
                        overflow-y: auto;
                        border: 1px solid #e0e0e0;
                        border-radius: 8px;
                        padding: 8px;
                        background: #fafafa;
                        margin-bottom: 20px;
                        display: grid;
                        grid-template-columns: 1fr 1fr;
                        gap: 4px;
                        max-height: 400px;
                    }
                    
                    .tag-filter-item {
                        display: flex;
                        align-items: center;
                        padding: 4px 8px;
                        background: white;
                        border-radius: 4px;
                        border: 1px solid #e8e8e8;
                        transition: all 0.2s ease;
                    }
                    
                    .tag-filter-item:hover {
                        background: #f8f9fa;
                        border-color: #2196F3;
                    }
                    
                    .tag-filter-checkbox {
                        width: 18px;
                        height: 18px;
                        margin-right: 6px;
                        cursor: pointer;
                        position: relative;
                        border: 2px solid #ccc;
                        border-radius: 3px;
                        background: white;
                        transition: all 0.2s ease;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        font-weight: bold;
                        color: white;
                        user-select: none;
                    }
                    
                    .tag-filter-checkbox.checked {
                        background: #2196F3;
                        border-color: #2196F3;
                    }
                    
                    .tag-filter-checkbox.excluded {
                        background: #f44336;
                        border-color: #f44336;
                    }
                    
                    .tag-filter-label {
                        flex: 1;
                        cursor: pointer;
                        font-size: 14px;
                        color: #333;
                    }
                    
                    .tag-filter-footer {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        position: relative;
                    }
                    
                    .tag-filter-status {
                        font-size: 12px;
                        color: #666;
                        flex: 1;
                    }
                    
                    .tag-filter-buttons {
                        display: flex;
                        gap: 10px;
                        margin-left: auto;
                    }
                    
                    .tag-filter-btn {
                        padding: 17px 16px;
                        border-radius: 19px;
                        border: none;
                        cursor: pointer;
                        font-size: 23px;
                        font-weight: 500;
                        transition: all 0.2s ease;
                        padding-top: 12px;
                        padding-right: 14px;
                    }
                    
                    .tag-filter-btn.primary {
                        background: #2196F3;
                        color: white;
                    }
                    
                    .tag-filter-btn.primary:hover {
                        background: #1976D2;
                        transform: translateY(-1px);
                        box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
                    }
                    
                    .tag-filter-btn.secondary {
                        background: #f5f5f5;
                        color: #333;
                        border: 1px solid #dee2e6;
                    }
                    
                    .tag-filter-btn.secondary:hover {
                        background: #e8e8e8;
                    }
                    
                    .tag-filter-no-tags {
                        text-align: center;
                        padding: 40px;
                        color: #999;
                        font-size: 14px;
                    }
                    
                    /* Medium screen adjustments */
                    @media (max-width: 1024px) {
                        .sticky-theme-header {
                            left: 250px;
                            width: calc(100% - 250px);
                        }
                    }
                </style>
            `;
            
            // Insert CSS and HTML into the document with DOM-ready guards and a retry
            let injectedNow = false;
            try {
                if (document.head) {
                    document.head.insertAdjacentHTML('beforeend', headerCSS);
                } else {
                    console.warn('[DEBUG] document.head not ready; deferring CSS injection');
                }
                if (document.body) {
                    document.body.insertAdjacentHTML('afterbegin', headerHTML);
                    injectedNow = true;
                    console.log('[DEBUG] Sticky header injected at body level with sidebar offset');
                } else {
                    console.warn('[DEBUG] document.body not ready; deferring header injection');
                }
            } catch (e) {
                console.error('[DEBUG] Sticky header injection error (initial):', e);
            }

            if (!injectedNow) {
                // Retry shortly once DOM nodes are available
                setTimeout(function() {
                    try {
                        if (document.head && !document.getElementById('scriptoria-sticky-header-styles')) {
                            document.head.insertAdjacentHTML('beforeend', headerCSS);
                        }
                        if (document.body && !document.getElementById('scriptoria-sticky-header')) {
                            document.body.insertAdjacentHTML('afterbegin', headerHTML);
                            console.log('[DEBUG] Sticky header injected on retry');
                        }
                        if (document.getElementById('scriptoria-sticky-header')) {
                            window.stickyHeaderDOM = document.getElementById('scriptoria-sticky-header');
                            window.stickyHeaderTagState = window.stickyHeaderTagState || {
                                tagStates: {},
                                isActive: false,
                                availableTags: [],
                                strictMode: true
                            };
                        }
                    } catch (e) {
                        console.error('[DEBUG] Sticky header injection error (retry):', e);
                    }
                }, 100);
                return false;
            }

            // Get the header element for later use
            window.stickyHeaderDOM = document.getElementById('scriptoria-sticky-header');
            
            // Initialize tag filter state (idempotent)
            window.stickyHeaderTagState = window.stickyHeaderTagState || {
                tagStates: {}, // Object to track tri-state: 'unchecked', 'included', 'excluded'
                isActive: false,
                availableTags: [],
                strictMode: true // Default to strict (AND) mode
            };
            
            // Tag filter dialog functions
            window.createTagFilterDialog = function() {
                // Remove existing dialog if present
                const existingOverlay = document.getElementById('tag-filter-overlay');
                if (existingOverlay) {
                    existingOverlay.remove();
                }
                
                const state = window.stickyHeaderTagState;
                // Ensure availableTags is always an array
                if (!state.availableTags) {
                    state.availableTags = [];
                }
                // Initialize tagStates if it doesn't exist
                if (!state.tagStates) {
                    state.tagStates = {};
                }
                
                // Create overlay and dialog HTML
                const dialogHTML = `
                    <div id="tag-filter-overlay" class="tag-filter-dialog-overlay">
                        <div class="tag-filter-dialog">
                            <div class="tag-filter-header">
                                <div class="tag-filter-title">
                                    <span>🏷️</span>
                                    <span>Filter by Tags</span>
                                </div>
                                <button class="tag-filter-close">×</button>
                            </div>
                            
                            <div class="tag-filter-controls">
                                <div class="tag-filter-mode">
                                    <button class="mode-toggle-btn ${state.strictMode ? 'active' : ''}" data-mode="strict">Strict</button>
                                    <button class="mode-toggle-btn ${!state.strictMode ? 'active' : ''}" data-mode="loose">Loose</button>
                                </div>
                                <div class="tag-filter-actions">
                                    <button class="tag-filter-action-btn" id="select-all-tags">Select All</button>
                                    <button class="tag-filter-action-btn" id="clear-all-tags">Clear All</button>
                                </div>
                            </div>
                            
                            <div class="tag-filter-list" id="tag-filter-list">
                                ${state.availableTags && state.availableTags.length > 0 ? 
                                    state.availableTags.map(tag => {
                                        const tagId = tag.replace('#', '');
                                        const tagState = state.tagStates ? (state.tagStates[tag] || 'unchecked') : 'unchecked';
                                        
                                        // Set the checkbox appearance based on state
                                        let checkboxClass = '';
                                        let checkboxContent = '';
                                        let checkboxStyle = '';
                                        
                                        if (tagState === 'included') {
                                            checkboxClass = 'checked';
                                            checkboxContent = '✓';
                                            checkboxStyle = 'background: #2196F3; border-color: #2196F3; color: white;';
                                        } else if (tagState === 'excluded') {
                                            checkboxClass = 'excluded';
                                            checkboxContent = '✕';
                                            checkboxStyle = 'background: #f44336; border-color: #f44336; color: white;';
                                        } else {
                                            checkboxStyle = 'background: white; border-color: #ccc;';
                                        }
                                        
                                        return `
                                            <div class="tag-filter-item">
                                                <div class="tag-filter-checkbox ${checkboxClass}" 
                                                     data-tag="${tag}"
                                                     data-state="${tagState}"
                                                     style="${checkboxStyle}">
                                                    ${checkboxContent}
                                                </div>
                                                <label class="tag-filter-label" data-tag="${tag}">${tag}</label>
                                            </div>
                                        `;
                                    }).join('') :
                                    '<div class="tag-filter-no-tags">No tags available. Create tags in the Tag Manager first.</div>'
                                }
                            </div>
                            
                            <div class="tag-filter-footer">
                                <div class="tag-filter-status">
                                    <span id="tag-included-count">0</span> included, <span id="tag-excluded-count">0</span> excluded
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Get the tag filter button to position relative to it
                const tagFilterBtn = document.getElementById('tag-filter-btn');
                if (!tagFilterBtn) {
                    console.error('Tag filter button not found');
                    return;
                }
                
                // Insert dialog into DOM relative to the button
                tagFilterBtn.parentElement.insertAdjacentHTML('beforeend', dialogHTML);
                
                // Get dialog elements
                const overlay = document.getElementById('tag-filter-overlay');
                const dialog = overlay.querySelector('.tag-filter-dialog');
                
                // Position the overlay relative to button
                const buttonRect = tagFilterBtn.getBoundingClientRect();
                const containerRect = tagFilterBtn.parentElement.getBoundingClientRect();
                
                // Calculate position relative to container
                overlay.style.position = 'absolute';
                overlay.style.left = (buttonRect.left - containerRect.left) + 'px';
                overlay.style.top = (buttonRect.bottom - containerRect.top) + 'px';
                
                // Setup event listeners
                setupTagFilterListeners(overlay, dialog);
                
                // Add backdrop click handler
                const handleBackdropClick = (e) => {
                    if (!dialog.contains(e.target) && !tagFilterBtn.contains(e.target)) {
                        window.closeTagFilterDialog();
                        document.removeEventListener('click', handleBackdropClick);
                    }
                };
                
                // Show dialog with animation
                requestAnimationFrame(() => {
                    overlay.classList.add('visible');
                    dialog.classList.add('visible');
                    // Add backdrop click listener after a longer delay to prevent immediate closure
                    setTimeout(() => {
                        document.addEventListener('click', handleBackdropClick);
                    }, 300);
                });
            };
            
            window.setupTagFilterListeners = function(overlay, dialog) {
                const state = window.stickyHeaderTagState;
                
                // Close button
                dialog.querySelector('.tag-filter-close').addEventListener('click', () => {
                    closeTagFilterDialog();
                });
                
                // Tri-state checkbox click handler
                dialog.querySelectorAll('.tag-filter-checkbox, .tag-filter-label').forEach(elem => {
                    elem.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const checkbox = elem.classList.contains('tag-filter-checkbox') ? 
                            elem : elem.previousElementSibling;
                        const tag = checkbox.dataset.tag;
                        const currentState = checkbox.dataset.state || 'unchecked';
                        
                        // Cycle through states: unchecked -> included -> excluded -> unchecked
                        let newState;
                        if (!currentState || currentState === 'unchecked') {
                            newState = 'included';
                            checkbox.classList.remove('excluded');
                            checkbox.classList.add('checked');
                            checkbox.style.background = '#2196F3';
                            checkbox.style.borderColor = '#2196F3';
                            checkbox.innerHTML = '✓';
                            checkbox.style.color = 'white';
                        } else if (currentState === 'included') {
                            newState = 'excluded';
                            checkbox.classList.remove('checked');
                            checkbox.classList.add('excluded');
                            checkbox.style.background = '#f44336';
                            checkbox.style.borderColor = '#f44336';
                            checkbox.innerHTML = '✕';
                            checkbox.style.color = 'white';
                        } else {
                            newState = 'unchecked';
                            checkbox.classList.remove('excluded');
                            checkbox.classList.remove('checked');
                            checkbox.style.background = 'white';
                            checkbox.style.borderColor = '#ccc';
                            checkbox.innerHTML = '';
                        }
                        
                        checkbox.dataset.state = newState;
                        state.tagStates[tag] = newState;
                        updateTagFilterCount();
                        
                        // Apply filter instantly
                        applyTagFilter();
                    });
                });
                
                // Select All / Clear All
                document.getElementById('select-all-tags').addEventListener('click', () => {
                    dialog.querySelectorAll('.tag-filter-checkbox').forEach(cb => {
                        cb.dataset.state = 'included';
                        cb.classList.remove('excluded');
                        cb.classList.add('checked');
                        cb.style.background = '#2196F3';
                        cb.style.borderColor = '#2196F3';
                        cb.innerHTML = '✓';
                        cb.style.color = 'white';
                        state.tagStates[cb.dataset.tag] = 'included';
                    });
                    updateTagFilterCount();
                    applyTagFilter(); // Apply instantly
                });
                
                document.getElementById('clear-all-tags').addEventListener('click', () => {
                    dialog.querySelectorAll('.tag-filter-checkbox').forEach(cb => {
                        cb.dataset.state = 'unchecked';
                        cb.classList.remove('excluded');
                        cb.classList.remove('checked');
                        cb.style.background = 'white';
                        cb.style.borderColor = '#ccc';
                        cb.innerHTML = '';
                        state.tagStates[cb.dataset.tag] = 'unchecked';
                    });
                    updateTagFilterCount();
                    applyTagFilter(); // Apply instantly
                });
                
                // Filter mode toggle button handlers
                dialog.querySelectorAll('.mode-toggle-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const mode = btn.dataset.mode;
                        state.strictMode = mode === 'strict';
                        
                        // Update button states
                        dialog.querySelectorAll('.mode-toggle-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        console.log('[DEBUG] Filter mode changed to:', state.strictMode ? 'strict' : 'loose');
                        // Immediately reapply filters with new mode
                        applyTagFilter();
                    });
                });
                
                // Click outside to close
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        closeTagFilterDialog();
                    }
                });
                
                // Initial count
                updateTagFilterCount();
            };
            
            window.updateTagFilterCount = function() {
                const state = window.stickyHeaderTagState;
                let includedCount = 0;
                let excludedCount = 0;
                
                if (state.tagStates) {
                    Object.values(state.tagStates).forEach(tagState => {
                        if (tagState === 'included') includedCount++;
                        else if (tagState === 'excluded') excludedCount++;
                    });
                }
                
                const includedSpan = document.getElementById('tag-included-count');
                const excludedSpan = document.getElementById('tag-excluded-count');
                if (includedSpan) includedSpan.textContent = includedCount;
                if (excludedSpan) excludedSpan.textContent = excludedCount;
            };
            
            window.closeTagFilterDialog = function() {
                const overlay = document.getElementById('tag-filter-overlay');
                if (overlay) {
                    const dialog = overlay.querySelector('.tag-filter-dialog');
                    overlay.classList.remove('visible');
                    dialog.classList.remove('visible');
                    setTimeout(() => overlay.remove(), 300);
                }
            };
            
            window.applyTagFilter = function() {
                const state = window.stickyHeaderTagState;
                
                // Ensure tagStates exists
                if (!state.tagStates) {
                    state.tagStates = {};
                }
                
                // Check if any filters are active
                const hasFilters = Object.values(state.tagStates).some(s => s !== 'unchecked');
                
                // Update button state
                const filterBtn = document.getElementById('tag-filter-btn');
                if (hasFilters) {
                    state.isActive = true;
                    filterBtn.classList.add('active');
                    const included = Object.values(state.tagStates).filter(s => s === 'included').length;
                    const excluded = Object.values(state.tagStates).filter(s => s === 'excluded').length;
                    filterBtn.title = `Filtering: ${included} included, ${excluded} excluded`;
                } else {
                    state.isActive = false;
                    filterBtn.classList.remove('active');
                    filterBtn.title = 'Filter by Tags';
                }
                
                // Apply filtering to annotations using combined filtering
                if (window.applyStickyHeaderFilters) {
                    window.applyStickyHeaderFilters();
                } else {
                    filterAnnotationsByTags();
                }
                
                console.log('[DEBUG] Tag filter applied:', {
                    tagStates: state.tagStates,
                    active: state.isActive
                });
                
                // Debug: Log filter state to console
                const included = Object.values(state.tagStates).filter(s => s === 'included').length;
                const excluded = Object.values(state.tagStates).filter(s => s === 'excluded').length;
                
                console.log(`[DEBUG] TAG FILTER APPLIED - Included: ${included}, Excluded: ${excluded}, Active: ${state.isActive}`);
            };
            
            window.filterAnnotationsByTags = function() {
                // Use the combined filter function instead
                if (window.applyStickyHeaderFilters) {
                    window.applyStickyHeaderFilters();
                    return;
                }
                
                // Fallback to original tag-only filtering if combined function not available
                const state = window.stickyHeaderTagState;
                const annotations = document.querySelectorAll('[data-annotation-id]');
                
                // Get included and excluded tags (normalize by removing # prefix)
                const includedTags = [];
                const excludedTags = [];
                if (state.tagStates) {
                    Object.entries(state.tagStates).forEach(([tag, tagState]) => {
                        const normalizedTag = tag.startsWith('#') ? tag.substring(1) : tag;
                        if (tagState === 'included') includedTags.push(normalizedTag);
                        else if (tagState === 'excluded') excludedTags.push(normalizedTag);
                    });
                }
                
                // Check if any filters are active
                state.isActive = includedTags.length > 0 || excludedTags.length > 0;
                
                let totalAnnotations = 0;
                let shownAnnotations = 0;
                let hiddenAnnotations = 0;
                let debugDetails = [];
                
                annotations.forEach(span => {
                    totalAnnotations++;
                    const tagsAttr = span.getAttribute('data-tags');
                    const annotationId = span.getAttribute('data-annotation-id') || 'unknown';
                    let annotationTags = [];
                    
                    // Handle missing data-tags attribute
                    if (tagsAttr === null || tagsAttr === undefined) {
                        annotationTags = [];
                    } else {
                        try {
                            annotationTags = JSON.parse(tagsAttr) || [];
                        } catch (e) {
                            console.error('Error parsing tags:', e);
                            annotationTags = [];
                        }
                    }
                    
                    // Convert to set for easier comparison (keep original format - no # prefix)
                    const annoTagSet = new Set(annotationTags);
                    
                    let shouldShow = true;
                    let reason = 'no filters active';
                    
                    if (state.isActive) {
                        // If annotation has NO TAGS and any filter is active, hide it
                        if (annoTagSet.size === 0) {
                            shouldShow = false;
                            reason = 'no tags when filter active';
                        } else {
                            // Check excluded tags first (they take precedence)
                            if (excludedTags.length > 0) {
                                const hasExcludedTag = excludedTags.some(tag => annoTagSet.has(tag));
                                if (hasExcludedTag) {
                                    shouldShow = false;
                                    reason = 'has excluded tag';
                                }
                            }
                            
                            // Check included tags based on strict/loose mode
                            if (shouldShow && includedTags.length > 0) {
                                if (state.strictMode) {
                                    // Strict mode: annotation must have ALL included tags (AND logic)
                                    const hasAllIncludedTags = includedTags.every(tag => annoTagSet.has(tag));
                                    if (!hasAllIncludedTags) {
                                        shouldShow = false;
                                        reason = 'missing required tag (strict mode)';
                                    } else {
                                        reason = 'has all required tags (strict mode)';
                                    }
                                } else {
                                    // Loose mode: annotation must have ANY included tag (OR logic)
                                    const hasAnyIncludedTag = includedTags.some(tag => annoTagSet.has(tag));
                                    if (!hasAnyIncludedTag) {
                                        shouldShow = false;
                                        reason = 'missing any included tag (loose mode)';
                                    } else {
                                        reason = 'has included tag (loose mode)';
                                    }
                                }
                            }
                        }
                    }
                    
                    // Log detailed debug for first 10 annotations AND any that are being shown
                    if (debugDetails.length < 10 || shouldShow) {
                        debugDetails.push({
                            id: annotationId.substring(0, 8),
                            tags: Array.from(annoTagSet),
                            show: shouldShow,
                            reason: reason
                        });
                    }
                    
                    if (shouldShow) {
                        shownAnnotations++;
                    } else {
                        hiddenAnnotations++;
                    }
                    
                    if (shouldShow) {
                        // Remove tag filtering class
                        span.classList.remove('tag-filtered');
                        
                        // Only restore full visibility if ALSO not hidden by theme
                        if (!span.classList.contains('theme-hidden')) {
                            // Use the same logic as sticky header showThemeHighlights
                            const scene = span.getAttribute('data-scene');
                            const themes = window.stickyHeaderState?.themes || [];
                            const themeColor = themes.find(t => t.name === scene)?.color || '#FFF0B3';
                            
                            span.style.opacity = '1.0';
                            span.style.border = '';
                            span.style.backgroundColor = themeColor;
                            span.style.color = '';
                        }
                        // If theme-hidden, keep it hidden even if tag filter passes
                    } else {
                        // Hide annotation due to tag filter
                        span.classList.add('tag-filtered');
                        span.style.opacity = '0.3';
                        span.style.backgroundColor = '#e8e8e8';
                        span.style.border = '1px dashed #ccc';
                        span.style.color = '#666'; // Dimmed text color
                    }
                });
                
                // Send detailed debug results to console
                console.log('[FILTER RESULTS] Total:', totalAnnotations, 'Shown:', shownAnnotations, 'Hidden:', hiddenAnnotations);
                console.log('[FILTER RESULTS] Mode:', state.strictMode ? 'Strict (AND)' : 'Loose (OR)', 'Included tags:', includedTags, 'Excluded tags:', excludedTags);
                console.log('[ANNOTATION DETAILS] First 5 annotations:');
                debugDetails.forEach(detail => {
                    console.log(`  ${detail.id}: tags=[${detail.tags.join(',')}] show=${detail.show} reason="${detail.reason}"`);
                });
            };
            
            // Setup tag filter button click handler
            const tagFilterBtn = document.getElementById('tag-filter-btn');
            if (tagFilterBtn) {
                tagFilterBtn.addEventListener('click', () => {
                    window.createTagFilterDialog();
                });
            }
            
            // Initialize filter states
            window.stickyHeaderFilters = window.stickyHeaderFilters || {
                favorites: false,
                used: 0  // 0 = show all, 1 = show unused, 2 = show used
            };
            
            // Setup favorites filter button (works like theme toggle)
            const favoritesBtn = document.getElementById('favorites-filter-btn');
            if (favoritesBtn) {
                favoritesBtn.addEventListener('click', () => {
                    window.toggleFavoritesFilter();
                });
            }
            
            // Setup used filter button (tri-state like ThemeViewSearch)
            const usedBtn = document.getElementById('used-filter-btn');
            if (usedBtn) {
                usedBtn.addEventListener('click', () => {
                    window.cycleUsedFilter();
                });
            }
            
            // Favorites filter functions (like theme system)
            window.toggleFavoritesFilter = function() {
                const favoritesBtn = document.getElementById('favorites-filter-btn');
                const isActive = window.stickyHeaderFilters.favorites;
                
                if (isActive) {
                    // Turn off favorites filter - show all
                    window.stickyHeaderFilters.favorites = false;
                    favoritesBtn.classList.remove('active');
                    favoritesBtn.innerHTML = '☆';  // Empty star
                    favoritesBtn.title = 'Filter Favorites (Showing All)';
                } else {
                    // Turn on favorites filter - hide non-favorites
                    window.stickyHeaderFilters.favorites = true;
                    favoritesBtn.classList.add('active');
                    favoritesBtn.innerHTML = '★';  // Filled star
                    favoritesBtn.title = 'Filter Favorites (Showing Favorites Only)';
                }
                
                // Apply all filters including scrollbar indicators update
                if (window.applyStickyHeaderFilters) {
                    window.applyStickyHeaderFilters();
                }
            };
            
            window.showAllByFavorites = function() {
                const annotations = document.querySelectorAll('[data-annotation-id]');
                annotations.forEach(annotation => {
                    annotation.classList.remove('favorites-hidden');
                });
                console.log('[DEBUG] Showing all annotations (favorites filter off)');
            };
            
            window.hideNonFavorites = function() {
                const annotations = document.querySelectorAll('[data-annotation-id]');
                annotations.forEach(annotation => {
                    const isFavorite = annotation.getAttribute('data-favorite') === 'true';
                    if (!isFavorite) {
                        annotation.classList.add('favorites-hidden');
                    } else {
                        annotation.classList.remove('favorites-hidden');
                    }
                });
                console.log('[DEBUG] Hiding non-favorite annotations');
            };
            
            // Used filter functions (tri-state like theme system)
            window.cycleUsedFilter = function() {
                const usedBtn = document.getElementById('used-filter-btn');
                window.stickyHeaderFilters.used = (window.stickyHeaderFilters.used + 1) % 3;
                
                if (window.stickyHeaderFilters.used === 0) {  // Show all
                    usedBtn.setAttribute('data-state', '0');
                    usedBtn.innerHTML = '◪';  // Empty square box
                    usedBtn.title = 'Filter Used (Showing All Used and Unused)';
                } else if (window.stickyHeaderFilters.used === 1) {  // Show unused
                    usedBtn.setAttribute('data-state', '1');
                    usedBtn.innerHTML = '☐';  // Empty square
                    usedBtn.title = 'Filter Used (Showing Unused)';
                } else {  // Show used
                    usedBtn.setAttribute('data-state', '2');
                    usedBtn.innerHTML = '■';  // Filled square
                    usedBtn.title = 'Filter Used (Showing Used)';
                }
                
                // Apply all filters including scrollbar indicators update
                if (window.applyStickyHeaderFilters) {
                    window.applyStickyHeaderFilters();
                }
            };
            
            window.showAllByUsage = function() {
                const annotations = document.querySelectorAll('[data-annotation-id]');
                annotations.forEach(annotation => {
                    annotation.classList.remove('used-hidden', 'unused-hidden');
                });
                console.log('[DEBUG] Showing all annotations (used filter off)');
            };
            
            window.hideUsedAnnotations = function() {
                const annotations = document.querySelectorAll('[data-annotation-id]');
                annotations.forEach(annotation => {
                    const isUsed = annotation.getAttribute('data-used') === 'true';
                    if (isUsed) {
                        annotation.classList.add('used-hidden');
                        annotation.classList.remove('unused-hidden');
                    } else {
                        annotation.classList.remove('used-hidden', 'unused-hidden');
                    }
                });
                console.log('[DEBUG] Hiding used annotations');
            };
            
            window.hideUnusedAnnotations = function() {
                const annotations = document.querySelectorAll('[data-annotation-id]');
                annotations.forEach(annotation => {
                    const isUsed = annotation.getAttribute('data-used') === 'true';
                    if (!isUsed) {
                        annotation.classList.add('unused-hidden');
                        annotation.classList.remove('used-hidden');
                    } else {
                        annotation.classList.remove('used-hidden', 'unused-hidden');
                    }
                });
                console.log('[DEBUG] Hiding unused annotations');
            };
            
            // Combined filter application (respects all filter types like themes do)
            window.applyStickyHeaderFilters = function() {
                // Apply favorites filter
                if (window.stickyHeaderFilters.favorites) {
                    window.hideNonFavorites();
                } else {
                    window.showAllByFavorites();
                }
                
                // Apply used filter
                if (window.stickyHeaderFilters.used === 1) {
                    window.hideUsedAnnotations();
                } else if (window.stickyHeaderFilters.used === 2) {
                    window.hideUnusedAnnotations();
                } else {
                    window.showAllByUsage();
                }
                
                // Apply tag filters directly (avoid recursion)
                if (window.stickyHeaderTagState && window.stickyHeaderTagState.isActive) {
                    const state = window.stickyHeaderTagState;
                    const annotations = document.querySelectorAll('[data-annotation-id]');
                    const tagStates = state.tagStates;
                    const strictMode = state.strictMode;
                    
                    if (Object.keys(tagStates).length > 0) {
                        // Remove # prefix from tag names for comparison
                        const includedTags = Object.keys(tagStates)
                            .filter(tag => tagStates[tag] === 'included')
                            .map(tag => tag.replace(/^#/, ''));
                        const excludedTags = Object.keys(tagStates)
                            .filter(tag => tagStates[tag] === 'excluded')
                            .map(tag => tag.replace(/^#/, ''));
                        
                        let totalAnnotations = 0;
                        let hiddenAnnotations = 0;
                        let shownAnnotations = 0;
                        
                        annotations.forEach(annotation => {
                            totalAnnotations++;
                            const annotationId = annotation.getAttribute('data-annotation-id');
                            const rawTags = annotation.getAttribute('data-tags');
                            let annotationTags = [];
                            try {
                                annotationTags = rawTags ? JSON.parse(rawTags) : [];
                            } catch (e) {
                                // Fallback to comma-separated if not JSON
                                annotationTags = (rawTags || '').split(',').map(t => t.trim()).filter(t => t);
                            }
                            let shouldHide = false;
                            
                            // Debug the first few annotations
                            if (totalAnnotations <= 3) {
                                console.log(`[DEBUG] Annotation ${annotationId}: rawTags='${rawTags}', parsed=[${annotationTags.join(',')}]`);
                            }
                            
                            // Check excluded tags first
                            const hasExcludedTag = excludedTags.some(tag => annotationTags.includes(tag));
                            if (hasExcludedTag) {
                                shouldHide = true;
                            } else if (includedTags.length > 0) {
                                if (strictMode) {
                                    // AND mode - must have ALL included tags
                                    const hasAllIncluded = includedTags.every(tag => annotationTags.includes(tag));
                                    if (!hasAllIncluded) shouldHide = true;
                                } else {
                                    // OR mode - must have AT LEAST ONE included tag
                                    const hasSomeIncluded = includedTags.some(tag => annotationTags.includes(tag));
                                    if (!hasSomeIncluded) shouldHide = true;
                                }
                            }
                            
                            if (shouldHide) {
                                annotation.classList.add('tag-filtered-hidden');
                                hiddenAnnotations++;
                            } else {
                                annotation.classList.remove('tag-filtered-hidden');
                                shownAnnotations++;
                            }
                        });
                        
                        console.log(`[DEBUG] Tag filtering results: ${shownAnnotations} shown, ${hiddenAnnotations} hidden, ${totalAnnotations} total`);
                        console.log(`[DEBUG] Filter criteria: included=[${includedTags.join(',')}], excluded=[${excludedTags.join(',')}], strict=${strictMode}`);
                    }
                } else {
                    // Clear all tag filtering when not active
                    const annotations = document.querySelectorAll('[data-annotation-id]');
                    annotations.forEach(annotation => {
                        annotation.classList.remove('tag-filtered-hidden');
                    });
                }
                
                // Update navigation menu state after applying filters
                if (window.updateNavigationMenuState) {
                    window.updateNavigationMenuState();
                }
                
                // Update scrollbar indicators after applying filters
                if (window.updateScrollbarIndicators) {
                    window.updateScrollbarIndicators();
                }
                
                console.log('[DEBUG] All sticky header filters applied');
            };
            
            console.log('[DEBUG] Tag filter system initialized');
            console.log('[DEBUG] DOM sticky header HTML and CSS injected successfully');
            return { success: true, element: 'scriptoria-sticky-header' };
        })();
        """
        
        # Replace placeholders with actual dynamic values
        header_html_css = header_html_css.replace('DYNAMIC_PADDING_PLACEHOLDER', f'{dynamic_padding}px')
        header_html_css = header_html_css.replace('DYNAMIC_GAP_PLACEHOLDER', f'{dynamic_gap}px')
        header_html_css = header_html_css.replace('DYNAMIC_FONT_SIZE_PLACEHOLDER', f'{dynamic_font_size}px')
        
        
        # Don't append to the JavaScript - inject CSS separately
        
        def injection_complete(result):
            if result and result.get('success'):
                print(f"[DEBUG] DOM sticky header injection completed successfully")
                
                
                # Setup the new JavaScript-based scroll detection
                self.setup_dom_scroll_detection()
                # Ensure menu bindings are attached once
                try:
                    self.ensure_dom_sticky_header_bindings()
                except Exception as _e:
                    print(f"[DEBUG] ensure_dom_sticky_header_bindings error: {_e}")
                # Populate with current themes if available
                if hasattr(self, 'scene_styles') and self.scene_styles:
                    self.populate_dom_sticky_header_themes()
                # Populate with current tags if available
                if hasattr(self, 'parent') and self.parent():
                    self.populate_dom_sticky_header_tags()
            else:
                print(f"[DEBUG] DOM sticky header injection failed: {result}")
        
        self.page().runJavaScript(header_html_css, injection_complete)

    def inject_restore_button_css(self):
        """Inject permanent restore button CSS and HTML that never changes"""
        restore_injection = """
        (function() {
            // Remove any existing restore button styles and HTML
            const existingStyle = document.getElementById('scriptoria-restore-button-permanent');
            if (existingStyle) existingStyle.remove();
            
            const existingButton = document.getElementById('sticky-header-restore');
            if (existingButton) existingButton.remove();
            
            // Create restore button HTML separately from header
            const restoreButton = document.createElement('div');
            restoreButton.id = 'sticky-header-restore';
            restoreButton.innerHTML = `
                <button class="restore-btn" title="Show sticky header">
                    Show Header
                </button>
            `;
            document.body.appendChild(restoreButton);
            
            // Add permanent restore button CSS
            const style = document.createElement('style');
            style.id = 'scriptoria-restore-button-permanent';
            style.textContent = `
                #sticky-header-restore {
                    position: fixed !important;
                    top: 15px !important;
                    right: 30px !important;
                    z-index: 10001 !important;
                    opacity: 0 !important;
                    transform: translateY(-20px) !important;
                    transition: all 0.3s ease !important;
                    pointer-events: none !important;
                    margin: 0 !important;
                    padding: 0 !important;
                    width: auto !important;
                    height: auto !important;
                }
                
                #sticky-header-restore.visible {
                    opacity: 1 !important;
                    transform: translateY(0) !important;
                    pointer-events: auto !important;
                }
                
                .restore-btn {
                    background: transparent !important;
                    border: 2px solid #007acc !important;
                    border-radius: 12px !important;
                    padding: 12px 16px !important;
                    color: #007acc !important;
                    font-weight: bold !important;
                    font-size: 11px !important;
                    cursor: pointer !important;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
                    transition: all 0.2s ease !important;
                    white-space: nowrap !important;
                    display: flex !important;
                    align-items: center !important;
                    gap: 6px !important;
                    text-decoration: none !important;
                }
                
                .restore-btn:hover {
                    background: rgba(255, 255, 255, 0.1) !important;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
                    transform: translateY(-1px) !important;
                }
                
                @media (max-width: 768px) {
                    #sticky-header-restore {
                        right: 20px !important;
                    }
                }
            `;
            document.head.appendChild(style);
            console.log('[DEBUG] Permanent restore button CSS and HTML injected');
        })();
        """
        self.page().runJavaScript(restore_injection)

    def update_restore_button_transparency(self):
        """Update restore button transparency immediately"""
        transparency_update = """
        (function() {
            const restoreBtn = document.querySelector('#sticky-header-restore .restore-btn');
            if (restoreBtn) {
                restoreBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                console.log('[DEBUG] Restore button transparency updated');
            }
        })();
        """
        self.page().runJavaScript(transparency_update)

    def setup_dom_scroll_detection(self):
        """Setup pure JavaScript scroll detection for DOM-based sticky header"""
        print("[DEBUG] Setting up DOM-based scroll detection")
        
        scroll_js = """
        (function() {
            console.log('[DEBUG] Setting up DOM sticky header scroll detection');
            
            // Remove existing scroll listener if present
            if (window.domStickyHeaderScrollListener) {
                document.removeEventListener('scroll', window.domStickyHeaderScrollListener);
                console.log('[DEBUG] Removed existing DOM scroll listener');
            }
            
            const header = document.getElementById('scriptoria-sticky-header');
            if (!header) {
                console.error('[DEBUG] Sticky header DOM element not found');
                return { success: false, error: 'Header element not found' };
            }
            
            let scrollThreshold = 100;
            let isHeaderVisible = false;
            
            // Define the scroll listener function
            window.domStickyHeaderScrollListener = function() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                
                if (scrollTop > scrollThreshold && !isHeaderVisible) {
                    // Show header with smooth animation
                    header.classList.add('visible');
                    isHeaderVisible = true;
                    console.log('[DEBUG] DOM sticky header shown at scroll:', scrollTop);
                } else if (scrollTop <= scrollThreshold && isHeaderVisible) {
                    // Hide header with smooth animation  
                    header.classList.remove('visible');
                    isHeaderVisible = false;
                    console.log('[DEBUG] DOM sticky header hidden at scroll:', scrollTop);
                }
            };
            
            // Add the scroll listener
            document.addEventListener('scroll', window.domStickyHeaderScrollListener, { passive: true });
            
            
            // Setup close button functionality
            const closeBtn = document.getElementById('sticky-header-close');
            const restoreTab = document.getElementById('sticky-header-restore');
            const restoreBtn = restoreTab ? restoreTab.querySelector('.restore-btn') : null;
            
            if (closeBtn) {
                closeBtn.addEventListener('click', function() {
                    header.classList.remove('visible');
                    isHeaderVisible = false;
                    // Show restore button
                    if (restoreTab) {
                        setTimeout(() => restoreTab.classList.add('visible'), 300);
                    }
                    // Disable scroll detection until restored
                    document.removeEventListener('scroll', window.domStickyHeaderScrollListener);
                    console.log('[DEBUG] Sticky header manually closed');
                });
            }
            
            // Setup hamburger menu functionality
            const menuBtn = document.getElementById('sticky-header-menu');
            const menuDropdown = document.getElementById('sticky-header-menu-dropdown');
            const menuRefresh = document.getElementById('menu-refresh-filters');
            const menuClear = document.getElementById('menu-clear-filters');
            const menuNavigateNext = document.getElementById('menu-navigate-next');
            const menuNavigatePrev = document.getElementById('menu-navigate-prev');
            
            if (menuBtn && menuDropdown) {
                // NOTE: Menu toggle/close handlers are bound centrally in ensure_dom_sticky_header_bindings()
                // to avoid duplicate bindings causing immediate open/close behavior.
                
                // Refresh filters menu item
                if (menuRefresh) {
                    menuRefresh.addEventListener('click', function() {
                        console.log('[DEBUG] Refresh filters menu item clicked');
                        menuDropdown.classList.remove('show');
                        menuDropdown.style.display = '';
                        
                        // Refresh all active filters
                        if (window.applyStickyHeaderFilters) {
                            console.log('[DEBUG] Refreshing all filters');
                            window.applyStickyHeaderFilters();
                        } else if (window.stickyHeaderTagState && window.stickyHeaderTagState.isActive) {
                            console.log('[DEBUG] Refreshing tag filters');
                            window.filterAnnotationsByTags();
                        }
                        
                        // Refresh theme filters by reapplying current theme visibility states
                        if (window.stickyHeaderState) {
                            const state = window.stickyHeaderState;
                            
                            // Reapply solo mode if active
                            if (state.soloTheme) {
                                console.log('[DEBUG] Refreshing solo mode for:', state.soloTheme);
                                window.enterSoloMode(state.soloTheme);
                            } else {
                                // Reapply hidden themes
                                if (state.hiddenThemes && state.hiddenThemes.size > 0) {
                                    console.log('[DEBUG] Refreshing hidden themes:', Array.from(state.hiddenThemes));
                                    state.hiddenThemes.forEach(themeName => {
                                        window.hideThemeHighlights(themeName);
                                    });
                                }
                                
                                // Ensure visible themes are shown
                                if (state.themes) {
                                    state.themes.forEach(theme => {
                                        if (!state.hiddenThemes.has(theme.name)) {
                                            window.showThemeHighlights(theme.name);
                                        }
                                    });
                                }
                            }
                        }
                        
                        console.log('[DEBUG] Filter refresh completed');
                    });
                }
                
                // Mobile filter menu items
                const menuTagFilter = document.getElementById('menu-tag-filter');
                const menuFavoritesFilter = document.getElementById('menu-favorites-filter');
                const menuUsedFilter = document.getElementById('menu-used-filter');
                
                if (menuTagFilter) {
                    menuTagFilter.addEventListener('click', function() {
                        console.log('[DEBUG] Mobile tag filter menu clicked');
                        menuDropdown.classList.remove('show');
                        const tagBtn = document.getElementById('tag-filter-btn');
                        if (tagBtn) tagBtn.click();
                    });
                }
                
                if (menuFavoritesFilter) {
                    menuFavoritesFilter.addEventListener('click', function() {
                        console.log('[DEBUG] Mobile favorites filter menu clicked');
                        menuDropdown.classList.remove('show');
                        const favBtn = document.getElementById('favorites-filter-btn');
                        if (favBtn) favBtn.click();
                    });
                }
                
                if (menuUsedFilter) {
                    menuUsedFilter.addEventListener('click', function() {
                        console.log('[DEBUG] Mobile used filter menu clicked');
                        menuDropdown.classList.remove('show');
                        const usedBtn = document.getElementById('used-filter-btn');
                        if (usedBtn) usedBtn.click();
                    });
                }
                
                // Clear filters menu item
                if (menuClear) {
                    menuClear.addEventListener('click', function() {
                        console.log('[DEBUG] Clear filters menu item clicked');
                        menuDropdown.classList.remove('show');
                        menuDropdown.style.display = '';
                        
                        // Clear all filters
                        if (window.stickyHeaderTagState) {
                            window.stickyHeaderTagState.tagStates = {};
                            window.stickyHeaderTagState.isActive = false;
                            
                            // Update tag filter button state
                            const filterBtn = document.getElementById('tag-filter-btn');
                            if (filterBtn) {
                                filterBtn.classList.remove('active');
                                filterBtn.title = 'Filter by Tags';
                            }
                        }
                        
                        // Clear favorites and used filters (like theme system)
                        if (window.stickyHeaderFilters) {
                            // Clear favorites filter
                            if (window.stickyHeaderFilters.favorites) {
                                window.stickyHeaderFilters.favorites = false;
                                const favBtn = document.getElementById('favorites-filter-btn');
                                if (favBtn) {
                                    favBtn.classList.remove('active');
                                    favBtn.innerHTML = '☆';  // Empty star
                                    favBtn.title = 'Filter Favorites (Showing All)';
                                }
                                window.showAllByFavorites();
                            }
                            
                            // Clear used filter
                            if (window.stickyHeaderFilters.used !== 0) {
                                window.stickyHeaderFilters.used = 0;
                                const usedBtn = document.getElementById('used-filter-btn');
                                if (usedBtn) {
                                    usedBtn.setAttribute('data-state', '0');
                                    usedBtn.innerHTML = '◪';  // Empty square box
                                    usedBtn.title = 'Filter Used (Showing All Used and Unused)';
                                }
                                window.showAllByUsage();
                            }
                        }
                        
                        // Ensure theme filter state is reset before applying combined filters
                        if (window.stickyHeaderState) {
                            const state = window.stickyHeaderState;
                            state.soloTheme = null;
                            if (state.hiddenThemes) { state.hiddenThemes.clear(); }
                            // Remove any theme-hidden classes from buttons
                            document.querySelectorAll('#sticky-theme-buttons .sticky-theme-btn').forEach(btn => btn.classList.remove('theme-hidden','solo-mode'));
                            // Show all highlights to fully reset theme filtering
                            if (state.themes) {
                                state.themes.forEach(theme => {
                                    if (typeof window.showThemeHighlights === 'function') {
                                        window.showThemeHighlights(theme.name);
                                    }
                                });
                            }
                        }

                        // Apply cleared filters using the combined filter function
                        if (window.applyStickyHeaderFilters) {
                            window.applyStickyHeaderFilters();
                        } else if (window.filterAnnotationsByTags) {
                            window.filterAnnotationsByTags();
                        }

                        // Hard clear any existing scrollbar indicators immediately
                        document.querySelectorAll('.scroll-indicator').forEach(el => el.remove());
                        // Reset navigation matches
                        window.currentMatchIndex = -1;
                        window.matchedAnnotations = [];
                        if (window.updateNavigationMenuState) { window.updateNavigationMenuState(); }
                        
                        console.log('[DEBUG] All filters cleared');
                        
                        // Clear theme filters (exit solo mode and show all themes)
                        if (window.stickyHeaderState) {
                            const state = window.stickyHeaderState;
                            
                            // Exit solo mode if active
                            if (state.soloTheme) {
                                window.exitSoloMode();
                                console.log('[DEBUG] Solo mode cleared');
                            }
                            
                            // Show all hidden themes
                            if (state.hiddenThemes && state.hiddenThemes.size > 0) {
                                const hiddenThemes = Array.from(state.hiddenThemes);
                                state.hiddenThemes.clear();
                                
                                hiddenThemes.forEach(themeName => {
                                    window.showThemeHighlights(themeName);
                                    const button = document.querySelector(`[data-theme="${themeName}"]`);
                                    if (button) {
                                        button.classList.remove('theme-hidden');
                                    }
                                });
                                console.log('[DEBUG] Hidden themes cleared:', hiddenThemes);
                            }
                        }
                        
                        console.log('[DEBUG] All filters cleared');
                    });
                }
                
                // Navigate Next Match menu item
                if (menuNavigateNext) {
                    menuNavigateNext.addEventListener('click', function() {
                        console.log('[DEBUG] Navigate next match clicked');
                        // Don't close menu - allow multiple navigation clicks
                        window.navigateToNextMatch();
                    });
                }
                
                // Navigate Previous Match menu item
                if (menuNavigatePrev) {
                    menuNavigatePrev.addEventListener('click', function() {
                        console.log('[DEBUG] Navigate previous match clicked');
                        // Don't close menu - allow multiple navigation clicks
                        window.navigateToPreviousMatch();
                    });
                }
            }
            
            // Complementary color function for navigation highlighting
            function getComplementaryColorJSInjection(color) {
                console.log("Getting complementary color for:", color);
    
                // Extract RGB components
                let r, g, b;
    
                try {
                    // Handle rgba or rgb format
                    const rgbMatch = color.match(/rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([\\d.]+)\\s*)?\\)/i);
                    if (rgbMatch) {
                        r = parseInt(rgbMatch[1], 10);
                        g = parseInt(rgbMatch[2], 10);
                        b = parseInt(rgbMatch[3], 10);
                    }
                    // Handle hex format
                    else if (color.match(/#[0-9a-f]{3,6}/i)) {
                        let hex = color.replace(/^#/, '');
                        if (hex.length === 3) {
                            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                        }
                        r = parseInt(hex.substring(0, 2), 16);
                        g = parseInt(hex.substring(2, 4), 16);
                        b = parseInt(hex.substring(4, 6), 16);
                    }
                    // Handle color names
                    else {
                        const colorMap = {
                            'yellow': [255, 255, 0], 'lightyellow': [255, 255, 224], 'gold': [255, 215, 0],
                            'orange': [255, 165, 0], 'red': [255, 0, 0], 'pink': [255, 192, 203],
                            'purple': [128, 0, 128], 'blue': [0, 0, 255], 'lightblue': [173, 216, 230],
                            'green': [0, 128, 0], 'lightgreen': [144, 238, 144], 'white': [255, 255, 255],
                            'black': [0, 0, 0], 'gray': [128, 128, 128], 'brown': [165, 42, 42]
                        };
                        const lowerColor = color.toLowerCase();
                        for (const [name, rgb] of Object.entries(colorMap)) {
                            if (lowerColor.includes(name)) {
                                [r, g, b] = rgb;
                                break;
                            }
                        }
                        if (r === undefined) {
                            [r, g, b] = [255, 255, 240]; // Default to light yellow
                        }
                    }
        
                    // Convert RGB to HSL
                    function rgbToHsl(r, g, b) {
                        r /= 255; g /= 255; b /= 255;
                        const max = Math.max(r, g, b);
                        const min = Math.min(r, g, b);
                        let h, s, l = (max + min) / 2;
        
                        if (max === min) {
                            h = s = 0; // achromatic
                        } else {
                            const d = max - min;
                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                            switch (max) {
                                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                                case g: h = (b - r) / d + 2; break;
                                case b: h = (r - g) / d + 4; break;
                            }
                            h /= 6;
                        }
                        return [h * 360, s, l];
                    }
        
                    // Convert HSL to RGB
                    function hslToRgb(h, s, l) {
                        h /= 360;
                        function hue2rgb(p, q, t) {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1/6) return p + (q - p) * 6 * t;
                            if (t < 1/2) return q;
                            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        }
        
                        if (s === 0) {
                            r = g = b = l; // achromatic
                        } else {
                            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                            const p = 2 * l - q;
                            r = hue2rgb(p, q, h + 1/3);
                            g = hue2rgb(p, q, h);
                            b = hue2rgb(p, q, h - 1/3);
                        }
                        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
                    }
        
                    if (r !== undefined && g !== undefined && b !== undefined) {
                        console.log("Original RGB:", r, g, b);
                        
                        // Convert to HSL
                        const [h, s, l] = rgbToHsl(r, g, b);
                        console.log("HSL:", h, s, l);
                        
                        // Calculate complementary hue (opposite on color wheel)
                        let compHue = (h + 180) % 360;
                        
                        // Enhance saturation and adjust lightness for better visibility
                        let compSat = Math.min(1, s + 0.2); // Boost saturation slightly
                        let compLight = l < 0.5 ? Math.min(0.7, l + 0.3) : Math.max(0.3, l - 0.3); // Ensure good contrast
                        
                        // Convert back to RGB
                        const [compR, compG, compB] = hslToRgb(compHue, compSat, compLight);
                        console.log("Complementary RGB:", compR, compG, compB);
                        
                        return `rgba(${compR}, ${compG}, ${compB}, 0.9)`;
                    }
                } catch (e) {
                    console.error("Error calculating complementary color:", e);
                }
    
                // Fallback to vibrant blue
                return 'rgba(0, 100, 255, 0.9)';
            }

            // Navigation functionality
            window.currentMatchIndex = -1;
            window.matchedAnnotations = [];
            
            // Function to check if any filters are active
            window.hasActiveFilters = function() {
                // Check tag filters
                if (window.stickyHeaderTagState && window.stickyHeaderTagState.isActive) {
                    return true;
                }
                
                // Check favorites filter
                if (window.stickyHeaderFilters && window.stickyHeaderFilters.favorites) {
                    return true;
                }
                
                // Check used filter (0 = show all, 1 = show only used, 2 = show only unused)
                if (window.stickyHeaderFilters && window.stickyHeaderFilters.used !== 0) {
                    return true;
                }
                
                // Check theme filters (hidden themes or solo mode)
                if (window.stickyHeaderState) {
                    const state = window.stickyHeaderState;
                    if (state.soloTheme || (state.hiddenThemes && state.hiddenThemes.size > 0)) {
                        return true;
                    }
                }
                
                return false;
            };
            
            // Function to get all visible annotations that match current filters
            window.getMatchedAnnotations = function() {
                const annotations = document.querySelectorAll('[data-annotation-id]');
                const matched = [];
                
                annotations.forEach(function(annotation) {
                    // Check if annotation is currently visible (not filtered out)
                    const computedStyle = window.getComputedStyle(annotation);
                    if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
                        // Also check if annotation is not hidden by any filter classes
                        const isFilteredOut = annotation.classList.contains('tag-filtered-hidden') ||
                                            annotation.classList.contains('favorites-hidden') ||
                                            annotation.classList.contains('used-hidden') ||
                                            annotation.classList.contains('unused-hidden') ||
                                            annotation.classList.contains('theme-hidden');
                        
                        if (!isFilteredOut) {
                            const rect = annotation.getBoundingClientRect();
                            if (rect.height > 0) {
                                matched.push({
                                    element: annotation,
                                    id: annotation.getAttribute('data-annotation-id'),
                                    top: annotation.offsetTop
                                });
                            }
                        }
                    }
                });
                
                // Sort by document order (top position)
                matched.sort((a, b) => a.top - b.top);
                return matched;
            };
            
            // Function to find current position in matched annotations
            window.getCurrentMatchIndex = function() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const currentViewCenter = scrollTop + windowHeight / 2;
                
                for (let i = 0; i < window.matchedAnnotations.length; i++) {
                    const annotation = window.matchedAnnotations[i];
                    if (annotation.top > currentViewCenter) {
                        return i - 1; // Return previous annotation index
                    }
                }
                
                return window.matchedAnnotations.length - 1; // Return last annotation if at bottom
            };
            
            // Function to scroll to and highlight an annotation (same as theme view)
            window.scrollToAndHighlightAnnotation = function(annotation) {
                if (!annotation || !annotation.element) return;
                
                // Clean up any existing highlights
                if (window.cleanupHighlights) {
                    window.cleanupHighlights();
                }
                
                // Scroll to the annotation
                annotation.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Apply highlight animation (same as theme view selection)
                const span = annotation.element;
                const bgColor = window.getComputedStyle(span).backgroundColor;
                const complementaryColor = getComplementaryColorJSInjection(bgColor);
                
                span.style.boxShadow = '0 0 10px 3px ' + complementaryColor;
                span.classList.add('annotation-highlight');
                
                // Store fade start timer
                const fadeStartTime = setTimeout(() => {
                    span.classList.add('annotation-highlight-fadeout');
                    
                    setTimeout(() => {
                        span.style.boxShadow = '';
                        span.classList.remove('annotation-highlight', 'annotation-highlight-fadeout');
                        if (window.activeHighlights) {
                            window.activeHighlights.delete(span);
                        }
                    }, 2000);
                }, 1500);
                
                // Track the highlight
                if (!window.activeHighlights) {
                    window.activeHighlights = new Map();
                }
                window.activeHighlights.set(span, fadeStartTime);
                
                console.log(`[DEBUG] Navigated to annotation: ${annotation.id}`);
            };
            
            // Navigate to next match function
            window.navigateToNextMatch = function() {
                if (!window.hasActiveFilters()) {
                    console.log('[DEBUG] No active filters - navigation disabled');
                    return;
                }
                
                window.matchedAnnotations = window.getMatchedAnnotations();
                if (window.matchedAnnotations.length === 0) {
                    console.log('[DEBUG] No matching annotations found');
                    return;
                }
                
                const currentIndex = window.getCurrentMatchIndex();
                let nextIndex = currentIndex + 1;
                
                // Wrap around to beginning if at end
                if (nextIndex >= window.matchedAnnotations.length) {
                    nextIndex = 0;
                }
                
                window.currentMatchIndex = nextIndex;
                window.scrollToAndHighlightAnnotation(window.matchedAnnotations[nextIndex]);
            };
            
            // Navigate to previous match function
            window.navigateToPreviousMatch = function() {
                if (!window.hasActiveFilters()) {
                    console.log('[DEBUG] No active filters - navigation disabled');
                    return;
                }
                
                window.matchedAnnotations = window.getMatchedAnnotations();
                if (window.matchedAnnotations.length === 0) {
                    console.log('[DEBUG] No matching annotations found');
                    return;
                }
                
                const currentIndex = window.getCurrentMatchIndex();
                let prevIndex = currentIndex - 1;
                
                // Wrap around to end if at beginning
                if (prevIndex < 0) {
                    prevIndex = window.matchedAnnotations.length - 1;
                }
                
                window.currentMatchIndex = prevIndex;
                window.scrollToAndHighlightAnnotation(window.matchedAnnotations[prevIndex]);
            };
            
            // Function to update menu item states based on active filters
            window.updateNavigationMenuState = function() {
                const hasFilters = window.hasActiveFilters();
                
                if (menuNavigateNext) {
                    if (hasFilters) {
                        menuNavigateNext.classList.remove('disabled');
                        menuNavigateNext.style.opacity = '1';
                        menuNavigateNext.style.pointerEvents = 'auto';
                    } else {
                        menuNavigateNext.classList.add('disabled');
                        menuNavigateNext.style.opacity = '0.5';
                        menuNavigateNext.style.pointerEvents = 'none';
                    }
                }
                
                if (menuNavigatePrev) {
                    if (hasFilters) {
                        menuNavigatePrev.classList.remove('disabled');
                        menuNavigatePrev.style.opacity = '1';
                        menuNavigatePrev.style.pointerEvents = 'auto';
                    } else {
                        menuNavigatePrev.classList.add('disabled');
                        menuNavigatePrev.style.opacity = '0.5';
                        menuNavigatePrev.style.pointerEvents = 'none';
                    }
                }
                
                // Update scrollbar indicators when menu state changes
                window.updateScrollbarIndicators();
            };
            
            // Scrollbar Indicators System
            window.updateScrollbarIndicators = function() {
                console.log('[DEBUG] Updating scrollbar indicators');
                
                // Remove existing indicators
                document.querySelectorAll('.scroll-indicator').forEach(el => el.remove());
                
                // Only show indicators when filters are active
                if (!window.hasActiveFilters()) {
                    console.log('[DEBUG] No active filters - hiding scrollbar indicators');
                    return;
                }
                
                // Get visible annotations
                const visibleAnnotations = window.getMatchedAnnotations();
                if (visibleAnnotations.length === 0) {
                    console.log('[DEBUG] No visible annotations - no indicators to show');
                    return;
                }
                
                // Calculate document dimensions
                const documentHeight = Math.max(
                    document.body.scrollHeight,
                    document.documentElement.scrollHeight
                );
                const viewportHeight = window.innerHeight;
                
                console.log(`[DEBUG] Creating ${visibleAnnotations.length} scrollbar indicators`);
                console.log(`[DEBUG] Document height: ${documentHeight}px, Viewport height: ${viewportHeight}px`);
                
                // Calculate scrollable height
                const scrollableHeight = documentHeight - viewportHeight;
                
                // Account for scrollbar arrow buttons and track margins
                // Scrollbar has ~12px arrows at top/bottom plus some margin
                const scrollbarArrowHeight = 12; // Height of up/down arrow buttons
                const scrollbarMargin = 2; // Small margin at top/bottom of track
                const scrollbarTrackOffset = scrollbarArrowHeight + scrollbarMargin;
                const availableTrackHeight = viewportHeight - (2 * scrollbarTrackOffset);
                
                
                // Create indicators for each visible annotation
                visibleAnnotations.forEach((annotation, index) => {
                    
                    // Position indicator based on annotation's actual position in document
                    // This represents WHERE the annotation is, not where we scroll to see it
                    const annotationRatio = annotation.top / documentHeight;
                    
                    // Add a small adjustment to push the position further down
                    const adjustedRatio = annotationRatio + 0.002; // Push down by 0.2% of document
                    
                    // Convert to scrollbar track position
                    const scrollRatio = adjustedRatio;
                    const trackPosition = scrollbarTrackOffset + (scrollRatio * availableTrackHeight);
                    const position = (trackPosition / viewportHeight) * 100;
                    
                    console.log(`[DEBUG] Annotation ${index}:`);
                    console.log(`  - annotation.top: ${annotation.top}px`);
                    console.log(`  - documentHeight: ${documentHeight}px`);
                    console.log(`  - annotationRatio: ${annotationRatio.toFixed(6)}`);
                    console.log(`  - trackPosition: ${trackPosition.toFixed(2)}px`);
                    console.log(`  - final position: ${position.toFixed(2)}%`);
                    console.log(`  - indicator pixel position: ${(position/100 * viewportHeight).toFixed(2)}px from top`);
                    
                    const scene = annotation.element.getAttribute('data-scene') || 'default';
                    
                    // Get theme color for this annotation
                    let themeColor = '#FFF0B3'; // Default yellow
                    if (window.stickyHeaderState && window.stickyHeaderState.themes) {
                        const themeData = window.stickyHeaderState.themes.find(t => t.name === scene);
                        if (themeData) {
                            themeColor = themeData.color;
                        }
                    }
                    
                    const indicator = document.createElement('div');
                    indicator.className = 'scroll-indicator';
                    indicator.style.cssText = `
                        position: fixed;
                        right: 2px;
                        width: 12px;
                        height: 8px;
                        background-color: ${themeColor};
                        border: 1px solid rgba(0,0,0,0.3);
                        border-radius: 2px;
                        z-index: 25000; /* Above sticky header and menus */
                        pointer-events: auto; /* Allow click interactions */
                        top: ${position}%;
                        box-shadow: 0 1px 2px rgba(0,0,0,0.2);
                        cursor: pointer;
                        transition: all 0.2s ease;
                    `;
                    
                    // Add hover effect
                    indicator.addEventListener('mouseenter', function() {
                        this.style.width = '15px';
                        this.style.right = '0px';
                        this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.4)';
                    });
                    
                    indicator.addEventListener('mouseleave', function() {
                        this.style.width = '12px';
                        this.style.right = '2px';
                        this.style.boxShadow = '0 1px 2px rgba(0,0,0,0.2)';
                    });
                    
                    // Click to scroll to annotation
                    indicator.addEventListener('click', function() {
                        annotation.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        window.scrollToAndHighlightAnnotation(annotation);
                        
                        // Log actual scroll position after scrollIntoView completes
                        setTimeout(() => {
                            const actualScrollTop = window.pageYOffset || document.documentElement.scrollTop;
                            const actualScrollRatio = scrollableHeight > 0 ? (actualScrollTop / scrollableHeight) : 0;
                            const actualPosition = actualScrollRatio * 100;
                            
                            console.log(`[SCROLL DEBUG] After clicking indicator ${index}:`);
                            console.log(`[SCROLL DEBUG] - Actual scroll position: ${actualScrollTop}px`);
                            console.log(`[SCROLL DEBUG] - Actual scroll ratio: ${actualScrollRatio.toFixed(4)}`);
                            console.log(`[SCROLL DEBUG] - Actual indicator position should be: ${actualPosition.toFixed(1)}%`);
                            console.log(`[SCROLL DEBUG] - Current indicator position is: ${position.toFixed(1)}%`);
                            console.log(`[SCROLL DEBUG] - Difference: ${(actualPosition - position).toFixed(1)}%`);
                        }, 500); // Wait for smooth scroll to complete
                    });
                    
                    // Add tooltip showing scene name and position
                    indicator.title = `${scene} (${index + 1}/${visibleAnnotations.length})`;
                    
                    document.body.appendChild(indicator);
                });
                
                console.log('[DEBUG] Scrollbar indicators updated');
            };
            
            // Update menu state initially and whenever filters change
            window.updateNavigationMenuState();
            
            // Update indicators on window resize to recalculate positions
            window.addEventListener('resize', function() {
                setTimeout(window.updateScrollbarIndicators, 100);
            });
            
            // Update indicators on scroll to handle dynamic content
            let scrollTimeout;
            window.addEventListener('scroll', function() {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(function() {
                    if (window.hasActiveFilters()) {
                        window.updateScrollbarIndicators();
                    }
                }, 200);
            });
            
            // Setup restore button functionality
            if (restoreBtn) {
                restoreBtn.addEventListener('click', function() {
                    header.classList.add('visible');
                    isHeaderVisible = true;
                    // Hide restore button
                    restoreTab.classList.remove('visible');
                    // Re-enable scroll detection
                    document.addEventListener('scroll', window.domStickyHeaderScrollListener, { passive: true });
                    console.log('[DEBUG] Sticky header manually restored');
                });
            }
            
            console.log('[DEBUG] DOM sticky header scroll detection setup complete');
            return { success: true, threshold: scrollThreshold };
        })();
        """
        
        def scroll_setup_complete(result):
            if result and result.get('success'):
                print(f"[DEBUG] DOM scroll detection setup successful with threshold: {result.get('threshold')}px")
            else:
                print(f"[DEBUG] DOM scroll detection setup failed: {result}")
        
        self.page().runJavaScript(scroll_js, scroll_setup_complete)

    def ensure_dom_sticky_header_bindings(self):
        """Idempotently ensure sticky header menu bindings exist after re-loads/re-injections."""
        js = """
        (function() {
            try {
                const header = document.getElementById('scriptoria-sticky-header');
                if (!header) return { ok: false, reason: 'no-header' };
                const menuBtn = document.getElementById('sticky-header-menu');
                const menuDropdown = document.getElementById('sticky-header-menu-dropdown');
                if (!menuBtn || !menuDropdown) return { ok: false, reason: 'no-menu' };

                // If handlers were bound to a previous button instance, unbind and allow rebind
                if (window._stickyMenuHandlersBound && window._stickyMenuButton && window._stickyMenuButton !== menuBtn) {
                    try {
                        const prevBtn = window._stickyMenuButton;
                        const prevHandlers = window._stickyMenuHandlers || {};
                        if (prevBtn && prevHandlers.onMenuClick) prevBtn.removeEventListener('click', prevHandlers.onMenuClick);
                        if (prevHandlers.onDocClick) document.removeEventListener('click', prevHandlers.onDocClick);
                        if (prevHandlers.onKey) document.removeEventListener('keydown', prevHandlers.onKey);
                    } catch (e) {
                        console.warn('[DEBUG] Failed to remove previous sticky menu handlers:', e);
                    }
                    window._stickyMenuHandlersBound = false;
                    window._stickyMenuHandlers = null;
                    window._stickyMenuButton = null;
                }

                // Bind once guards
                if (!window._stickyMenuHandlersBound) {
                    // Toggle handler
                    const onMenuClick = function(e){
                        e.stopPropagation();
                        const willShow = !menuDropdown.classList.contains('show');
                        menuDropdown.classList.toggle('show');
                        if (willShow) menuDropdown.style.display = 'block';
                        else menuDropdown.style.display = '';
                        console.log('[DEBUG] ensure bindings: menu toggled', willShow);
                    };
                    menuBtn.addEventListener('click', onMenuClick);

                    // Outside click handler
                    const onDocClick = function(e){
                        if (!menuBtn.contains(e.target) && !menuDropdown.contains(e.target)) {
                            menuDropdown.classList.remove('show');
                            menuDropdown.style.display = '';
                        }
                    };
                    document.addEventListener('click', onDocClick);

                    // Escape to close
                    const onKey = function(e){
                        if (e.key === 'Escape' && menuDropdown.classList.contains('show')) {
                            menuDropdown.classList.remove('show');
                            menuDropdown.style.display = '';
                        }
                    };
                    document.addEventListener('keydown', onKey);

                    window._stickyMenuHandlersBound = true;
                    window._stickyMenuHandlers = { onMenuClick, onDocClick, onKey };
                    window._stickyMenuButton = menuBtn;
                    console.log('[DEBUG] ensure bindings: handlers bound');
                    return { ok: true, bound: true };
                }
                return { ok: true, bound: false };
            } catch (e) {
                return { ok: false, error: String(e) };
            }
        })();
        """
        self.page().runJavaScript(js)

    def populate_dom_sticky_header_themes(self, scene_styles=None):
        """Populate the DOM sticky header with theme buttons"""
        print("[DEBUG] Populating DOM sticky header with theme buttons")
        
        if not scene_styles:
            scene_styles = getattr(self, 'scene_styles', {})
        
        if not scene_styles:
            print("[DEBUG] No scene styles available for DOM sticky header")
            return
        
        # Convert theme data to JavaScript format
        import json
        themes_data = []
        
        for i, (theme_name, theme_style) in enumerate(scene_styles.items()):
            if i >= 12:  # Max 12 themes
                break
                
            # Extract color from style
            import re
            color_match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+)', theme_style)
            theme_color = color_match.group(1) if color_match else '#FFF0B3'
            
            # Use same hotkey logic as Python code
            if i < 9:
                hotkey = str(i + 1)
            elif i == 9:
                hotkey = "0"
            elif i == 10:
                hotkey = "-"
            elif i == 11:
                hotkey = "+"
            
            themes_data.append({
                'name': theme_name,
                'color': theme_color,
                'hotkey': hotkey
            })
        
        themes_json = json.dumps(themes_data)
        
        populate_js = f"""
        (function() {{
            console.log('[DEBUG] Populating DOM sticky header with themes');
            
            const container = document.getElementById('sticky-theme-buttons');
            const header = document.getElementById('scriptoria-sticky-header');
            
            if (!container || !header) {{
                console.error('[DEBUG] DOM sticky header elements not found');
                return {{ success: false, error: 'Header elements not found' }};
            }}
            
            const themes = {themes_json};
            console.log('[DEBUG] Processing themes:', themes);
            
            // Clear existing buttons
            container.innerHTML = '';
            
            // State management
            window.stickyHeaderState = window.stickyHeaderState || {{
                hiddenThemes: new Set(),
                soloTheme: null,
                clickTimeouts: new Map(),
                themes: []
            }};
            
            // Store themes in global state for tag filtering access
            window.stickyHeaderState.themes = themes;
            
            // Create theme buttons
            themes.forEach((theme, index) => {{
                const button = document.createElement('button');
                button.className = 'sticky-theme-btn';
                button.dataset.theme = theme.name;
                button.dataset.hotkey = theme.hotkey;
                button.style.backgroundColor = theme.color;
                button.textContent = `${{theme.hotkey}}: ${{theme.name}}`;
                button.title = `Theme: ${{theme.name}} (Click to toggle, Double-click for solo mode)`;
                
                // Single click - toggle visibility, with solo-to-multi conversion
                // Double click - solo mode  
                button.addEventListener('click', function(e) {{
                    const themeName = this.dataset.theme;
                    const state = window.stickyHeaderState;
                    
                    // Check for double-click
                    if (state.clickTimeouts.has(themeName)) {{
                        // This is a double-click - solo mode
                        clearTimeout(state.clickTimeouts.get(themeName));
                        state.clickTimeouts.delete(themeName);
                        
                        if (state.soloTheme === themeName) {{
                            // Exit solo mode
                            exitSoloMode();
                        }} else {{
                            // Enter solo mode
                            enterSoloMode(themeName);
                        }}
                    }} else {{
                        // Single click - set timeout for double-click detection
                        const timeout = setTimeout(() => {{
                            state.clickTimeouts.delete(themeName);
                            // If currently in solo mode and user clicks a different theme,
                            // convert SOLO -> MULTI selection (keep solo theme + clicked theme visible, hide others)
                            if (state.soloTheme && state.soloTheme !== themeName) {{
                                const keep = new Set([state.soloTheme, themeName]);
                                const prevSolo = state.soloTheme;
                                state.soloTheme = null;
                                // Reset and rebuild hidden set for buttons only
                                state.hiddenThemes = new Set();
                                themes.forEach(t => {{
                                    const btn = container.querySelector(`[data-theme="${{t.name}}"]`);
                                    if (keep.has(t.name)) {{
                                        btn.classList.remove('theme-hidden', 'solo-mode');
                                    }} else {{
                                        btn.classList.add('theme-hidden');
                                        btn.classList.remove('solo-mode');
                                        state.hiddenThemes.add(t.name);
                                    }}
                                }});
                                // Apply element-level visibility: show items matching ANY kept theme
                                (function() {{
                                    const anns = document.querySelectorAll('[data-annotation-id]');
                                    anns.forEach(el => {{
                                        let match = false;
                                        // primary
                                        const primary = el.getAttribute('data-scene') || '';
                                        if (keep.has(primary)) match = true;
                                        else {{
                                            const secAttr = el.getAttribute('data-secondary-scenes');
                                            if (secAttr) {{
                                                try {{
                                                    const list = JSON.parse(secAttr) || [];
                                                    if (Array.isArray(list)) {{
                                                        for (const tn of keep) {{ if (list.indexOf(tn) !== -1) {{ match = true; break; }} }}
                                                    }}
                                                }} catch (e) {{}}
                                            }}
                                        }}
                                        if (match) {{
                                            el.classList.remove('theme-hidden');
                                            el.classList.add('theme-visible');
                                            el.style.border = '';
                                        }} else {{
                                            el.classList.remove('theme-visible');
                                            el.classList.add('theme-hidden');
                                            el.style.border = '1px dashed #ccc';
                                            el.style.backgroundColor = '#e8e8e8';
                                        }}
                                    }});
                                }})();
                                if (window.updateScrollbarIndicators) {{ window.updateScrollbarIndicators(); }}
                                console.log('[DEBUG] Converted solo mode to multi-theme selection:', Array.from(keep));
                                return; // do not proceed with normal toggle for this click
                            }}

                            // Single click action - toggle visibility
                            toggleThemeVisibility(themeName);
                        }}, 300);
                        
                        state.clickTimeouts.set(themeName, timeout);
                    }}
                }});
                
                container.appendChild(button);
            }});

            // Reapply existing filter state (solo or hidden) after buttons are built
            (function reapplyThemeVisibility() {{
                try {{
                    const state = window.stickyHeaderState;
                    if (!state) return;
                    // If solo mode is active, re-enter it to restore visibility
                    if (state.soloTheme) {{
                        if (typeof enterSoloMode === 'function') {{
                            enterSoloMode(state.soloTheme);
                            console.log('[DEBUG] Reapplied solo mode after repopulate:', state.soloTheme);
                            return;
                        }}
                    }}
                    // Otherwise, reapply hidden themes
                    if (state.hiddenThemes && state.hiddenThemes.size > 0) {{
                        themes.forEach(theme => {{
                            const btn = container.querySelector(`[data-theme="${{theme.name}}"]`);
                            if (state.hiddenThemes.has(theme.name)) {{
                                btn && btn.classList.add('theme-hidden');
                                if (typeof hideThemeHighlights === 'function') hideThemeHighlights(theme.name);
                            }} else {{
                                btn && btn.classList.remove('theme-hidden');
                                if (typeof showThemeHighlights === 'function') showThemeHighlights(theme.name);
                            }}
                        }});
                        if (window.updateScrollbarIndicators) {{ window.updateScrollbarIndicators(); }}
                        console.log('[DEBUG] Reapplied hidden theme filters after repopulate:', Array.from(state.hiddenThemes));
                    }}
                }} catch (e) {{
                    console.log('[DEBUG] Error reapplying theme visibility after repopulate:', e);
                }}
            }})()
            
            // Define theme visibility functions
            window.toggleThemeVisibility = function(themeName) {{
                const state = window.stickyHeaderState;
                const button = container.querySelector(`[data-theme="${{themeName}}"]`);
                
                if (state.hiddenThemes.has(themeName)) {{
                    // Show theme
                    state.hiddenThemes.delete(themeName);
                    button.classList.remove('theme-hidden');
                    showThemeHighlights(themeName);
                    console.log('[DEBUG] Showing theme:', themeName);
                }} else {{
                    // Hide theme
                    state.hiddenThemes.add(themeName);
                    button.classList.add('theme-hidden');
                    hideThemeHighlights(themeName);
                    console.log('[DEBUG] Hiding theme:', themeName);
                }}
                
                // Update scrollbar indicators after toggling theme visibility
                if (window.updateScrollbarIndicators) {{
                    window.updateScrollbarIndicators();
                }}
                
                // Update navigation menu state after toggling theme visibility
                if (window.updateNavigationMenuState) {{
                    window.updateNavigationMenuState();
                }}
            }};
            
            window.enterSoloMode = function(themeName) {{
                const state = window.stickyHeaderState;
                state.soloTheme = themeName;
                // Update buttons (UI only)
                themes.forEach(theme => {{
                    const button = container.querySelector(`[data-theme="${{theme.name}}"]`);
                    if (theme.name === themeName) {{
                        button.classList.add('solo-mode');
                        button.classList.remove('theme-hidden');
                    }} else {{
                        button.classList.add('theme-hidden');
                        button.classList.remove('solo-mode');
                        state.hiddenThemes.add(theme.name);
                    }}
                }});
                // Apply element-level visibility strictly to solo theme matches (primary or secondary)
                (function() {{
                    const anns = document.querySelectorAll('[data-annotation-id]');
                    anns.forEach(el => {{
                        let match = false;
                        const primary = el.getAttribute('data-scene') || '';
                        if (primary === themeName) match = true;
                        else {{
                            const secAttr = el.getAttribute('data-secondary-scenes');
                            if (secAttr) {{
                                try {{
                                    const list = JSON.parse(secAttr) || [];
                                    if (Array.isArray(list) && list.indexOf(themeName) !== -1) match = true;
                                }} catch (e) {{}}
                            }}
                        }}
                        if (match) {{
                            el.classList.remove('theme-hidden');
                            el.classList.add('theme-visible');
                            el.style.border = '';
                        }} else {{
                            el.classList.remove('theme-visible');
                            el.classList.add('theme-hidden');
                            el.style.border = '1px dashed #ccc';
                            el.style.backgroundColor = '#e8e8e8';
                        }}
                    }});
                }})();
                if (window.updateScrollbarIndicators) {{ window.updateScrollbarIndicators(); }}
                
                // Update navigation menu state after entering solo mode
                if (window.updateNavigationMenuState) {{
                    window.updateNavigationMenuState();
                }}
                
                console.log('[DEBUG] Entered solo mode for theme:', themeName);
            }};
            
            window.exitSoloMode = function() {{
                const state = window.stickyHeaderState;
                state.soloTheme = null;
                state.hiddenThemes.clear();
                
                // Restore all themes to visible state
                themes.forEach(theme => {{
                    const button = container.querySelector(`[data-theme="${{theme.name}}"]`);
                    button.classList.remove('solo-mode', 'theme-hidden');
                    showThemeHighlights(theme.name);
                }});
                
                // Update scrollbar indicators after exiting solo mode
                if (window.updateScrollbarIndicators) {{
                    window.updateScrollbarIndicators();
                }}
                
                // Update navigation menu state after exiting solo mode
                if (window.updateNavigationMenuState) {{
                    window.updateNavigationMenuState();
                }}
                
                console.log('[DEBUG] Exited solo mode');
            }};
            
            // Helpers for theme visibility with secondary scenes support
            function getThemeColorFor(sceneName) {{
                const td = window.stickyHeaderState && window.stickyHeaderState.themes
                    ? window.stickyHeaderState.themes.find(t => t.name === sceneName)
                    : null;
                return td ? td.color : '#FFF0B3';
            }}

            function getElementsForTheme(themeName) {{
                const primary = Array.from(document.querySelectorAll(`[data-scene="${{themeName}}"]`));
                const secondaryCandidates = Array.from(document.querySelectorAll('[data-secondary-scenes]'));
                const secondary = secondaryCandidates.filter(el => {{
                    try {{
                        const attr = el.getAttribute('data-secondary-scenes');
                        if (!attr) return false;
                        const list = JSON.parse(attr);
                        return Array.isArray(list) && list.indexOf(themeName) !== -1;
                    }} catch (e) {{ return false; }}
                }});
                // Merge unique
                const all = new Set();
                primary.forEach(el => all.add(el));
                secondary.forEach(el => all.add(el));
                return Array.from(all);
            }}

            // Theme highlight visibility functions (support primary + secondary scenes)
            window.showThemeHighlights = function(themeName) {{
                const elements = getElementsForTheme(themeName);
                elements.forEach(element => {{
                    element.classList.remove('theme-hidden');
                    element.classList.add('theme-visible');

                    // Restore styles if not tag-filtered hidden
                    element.style.opacity = '1.0';
                    element.style.border = '';
                    // Restore background to primary scene color (not the shown theme if it's secondary)
                    const primaryScene = element.getAttribute('data-scene') || '';
                    const colorToApply = getThemeColorFor(primaryScene || themeName);
                    element.style.backgroundColor = colorToApply;
                }});
            }};

            window.hideThemeHighlights = function(themeName) {{
                const elements = getElementsForTheme(themeName);
                elements.forEach(element => {{
                    element.classList.remove('theme-visible');
                    element.classList.add('theme-hidden');
                    // Apply hidden styling - subtle grey
                    element.style.border = '1px dashed #ccc';
                    element.style.backgroundColor = '#e8e8e8';
                }});
            }};
            
            
            console.log('[DEBUG] DOM sticky header populated with', themes.length, 'themes');
            return {{ success: true, themeCount: themes.length }};
        }})();
        """
        
        def populate_complete(result):
            if result and result.get('success'):
                print(f"[DEBUG] DOM sticky header populated with {result.get('themeCount')} themes")
                # Reset attempts counter on success
                setattr(self, '_sticky_theme_populate_attempts', 0)
            else:
                print(f"[DEBUG] DOM sticky header population failed: {result}")
                # Retry a few times if header not ready yet
                attempts = getattr(self, '_sticky_theme_populate_attempts', 0)
                if attempts < 10:
                    setattr(self, '_sticky_theme_populate_attempts', attempts + 1)
                    QTimer.singleShot(120, lambda: self.populate_dom_sticky_header_themes(scene_styles))
                else:
                    print("[DEBUG] Giving up populating sticky header themes after retries")
        
        self.page().runJavaScript(populate_js, populate_complete)

    def populate_dom_sticky_header_tags(self, tags=None):
        """Populate the DOM sticky header with available tags for filtering"""
        print("[DEBUG] Populating DOM sticky header with tags")
        
        # Get tags from main window if not provided
        if tags is None:
            # Try to get from parent window
            parent = self.parent()
            if parent and hasattr(parent, 'tags'):
                tags = parent.tags
                print(f"[DEBUG] Found {len(tags)} tags from parent window")
            # Try to get from main_window attribute
            elif hasattr(self, 'main_window') and hasattr(self.main_window, 'tags'):
                tags = self.main_window.tags
                print(f"[DEBUG] Found {len(tags)} tags from main_window")
            else:
                print("[DEBUG] No tags available for DOM sticky header")
                tags = []
        
        # Convert tags to JavaScript format
        import json
        tags_json = json.dumps(tags)
        
        populate_tags_js = f"""
        (function() {{
            console.log('[DEBUG] Updating available tags for sticky header filter');
            
            // Update the tag state with available tags
            if (window.stickyHeaderTagState) {{
                window.stickyHeaderTagState.availableTags = {tags_json};
                console.log('[DEBUG] Available tags updated:', window.stickyHeaderTagState.availableTags);
                
                // Update button tooltip with tag count
                const filterBtn = document.getElementById('tag-filter-btn');
                if (filterBtn) {{
                    const tagCount = window.stickyHeaderTagState.availableTags.length;
                    if (tagCount > 0) {{
                        filterBtn.title = 'Filter by Tags (' + tagCount + ' available)';
                    }} else {{
                        filterBtn.title = 'Filter by Tags (No tags available)';
                    }}
                }}
                
                return {{ success: true, tagCount: window.stickyHeaderTagState.availableTags.length }};
            }} else {{
                console.error('[DEBUG] stickyHeaderTagState not initialized');
                return {{ success: false, error: 'Tag state not initialized' }};
            }}
        }})();
        """
        
        def populate_tags_complete(result):
            if result and result.get('success'):
                print(f"[DEBUG] DOM sticky header tags updated with {result.get('tagCount')} tags")
                setattr(self, '_sticky_tag_populate_attempts', 0)
            else:
                print(f"[DEBUG] DOM sticky header tag update failed: {result}")
                attempts = getattr(self, '_sticky_tag_populate_attempts', 0)
                if attempts < 10:
                    setattr(self, '_sticky_tag_populate_attempts', attempts + 1)
                    QTimer.singleShot(120, lambda: self.populate_dom_sticky_header_tags(tags))
                else:
                    print("[DEBUG] Giving up populating sticky header tags after retries")
        
        self.page().runJavaScript(populate_tags_js, populate_tags_complete)

    def show_sticky_header(self):
        """Show the sticky header if enabled"""
        print(f"[DEBUG] ========= SHOW_STICKY_HEADER CALLED =========")
        print(f"[DEBUG] show_sticky_header called - enabled: {self.sticky_header_enabled}, has_header: {hasattr(self, 'sticky_header')}")
        print(f"[DEBUG] Method reached successfully from JavaScript callback")
        
        if self.sticky_header_enabled and hasattr(self, 'sticky_header'):
            print(f"[DEBUG] Showing sticky header - scene_styles count: {len(self.scene_styles)}")
            
            # Prevent duplicate show calls when already visible
            if self.sticky_header.isVisible():
                print(f"[DEBUG] Sticky header already visible, skipping duplicate show")
                return
            
            # Themes will be updated in positioning callback with overflow info
            
            # Update title if we can get the document title
            try:
                doc_title = self.main_window.windowTitle() if hasattr(self, 'main_window') else "Scriptoria"
                self.sticky_header.update_title(doc_title)
            except:
                pass
            
            # Calculate geometry dynamically based on current navigation width
            if True:  # Always recalculate to handle dynamic layouts
                # Calculate optimal centering based on content and available space
                parent_width = self.width()
                
                # Calculate required width for all theme buttons dynamically
                num_themes = len(self.scene_styles)
                button_spacing = 4   # Spacing between buttons
                
                # Calculate total width needed based on actual button content
                total_button_width = 0
                theme_names = list(self.scene_styles.keys())
                hotkeys = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '+']
                
                for i, theme_name in enumerate(theme_names):
                    if i < len(hotkeys):
                        hotkey = hotkeys[i]
                        text = f"{hotkey}: {theme_name}"
                        
                        # Use temporary button to calculate width
                        temp_btn = QPushButton()
                        temp_btn.setText(text)
                        font_metrics = temp_btn.fontMetrics()
                        text_width = font_metrics.horizontalAdvance(text)
                        
                        padding = 16
                        min_width = 80
                        max_width = 300
                        button_width = max(min_width, min(text_width + padding, max_width))
                        total_button_width += button_width
                
                required_width = total_button_width + ((num_themes - 1) * button_spacing) if num_themes > 0 else 0
                
                print(f"[DEBUG] Simple centering: parent={parent_width}, themes={num_themes}, required={required_width}")
                
                # Define the centering function first
                def center_header_with_nav_width(nav_width):
                    nav_width = nav_width or 200  # Default fallback
                    
                    # CACHE the nav width for future use
                    self.sticky_header._cached_nav_width = nav_width
                    print(f"[DEBUG] CACHED nav width: {nav_width}")
                    
                    # Calculate available space after navigation
                    available_space = parent_width - nav_width
                    
                    # Center the header in the available space with some padding
                    padding = 50
                    header_width = available_space - (padding * 2)
                    header_left = nav_width + padding
                    
                    print(f"[DEBUG] Nav-aware centering: nav={nav_width}, available={available_space}, header_left={header_left}, width={header_width}")
                    
                    # Check if theme buttons overflow
                    content_overflows = required_width > header_width
                    
                    # Update themes with overflow information
                    self.sticky_header.update_themes(self.scene_styles, content_overflows)
                    
                    # Store the fixed geometry
                    self.sticky_header._fixed_x = header_left
                    self.sticky_header._fixed_width = header_width
                    self.sticky_header._fixed_geometry_set = True
                    
                    self.sticky_header.setGeometry(header_left, 0, header_width, 50)
                    
                    # Force scroll area to update its size
                    self.sticky_header.update_scroll_area_size()
                    
                    # Show the header
                    self.sticky_header.show_header()
                    print("[DEBUG] Header show_header() called with nav-aware centering")

                # OPTIMIZED: Use cached navigation width if available
                def get_nav_width_and_center():
                    """Get navigation width to properly center the header (with caching)"""
                    
                    # Use cached value if available to avoid JavaScript execution
                    if self.sticky_header._cached_nav_width is not None:
                        print(f"[DEBUG] USING CACHED nav width: {self.sticky_header._cached_nav_width}")
                        center_header_with_nav_width(self.sticky_header._cached_nav_width)
                        return
                    
                    print("[DEBUG] CACHE MISS: Fetching nav width via JavaScript")
                    js_code = """
                    (function() {
                        var navElement = document.querySelector('.navigation') || 
                                       document.querySelector('#navigation') ||
                                       document.querySelector('nav') ||
                                       document.querySelector('.nav');
                        
                        var navWidth = 0;
                        if (navElement) {
                            navWidth = navElement.getBoundingClientRect().width;
                        }
                        
                        console.log('[DEBUG] Navigation width:', navWidth);
                        return navWidth;
                    }})();// close function wrapper with escaped brace
                    """
                    
                    self.page().runJavaScript(js_code, center_header_with_nav_width)
                
                get_nav_width_and_center()
                return  # Exit early since positioning is handled in callback
            else:
                # Use stored fixed geometry
                self.sticky_header.setGeometry(self.sticky_header._fixed_x, 0, self.sticky_header._fixed_width, 50)
                print(f"[DEBUG] Using FIXED geometry: x={self.sticky_header._fixed_x}, width={self.sticky_header._fixed_width}")
            
            self.sticky_header.show_header()
            print("[DEBUG] Header show_header() called")
        else:
            if not self.sticky_header_enabled:
                print("[DEBUG] Sticky header not enabled in settings")
            if not hasattr(self, 'sticky_header'):
                print("[DEBUG] Sticky header widget not found")
            
    def hide_sticky_header(self):
        """Hide the sticky header"""
        print(f"[DEBUG] hide_sticky_header called - has_header: {hasattr(self, 'sticky_header')}")
        if hasattr(self, 'sticky_header'):
            self.sticky_header.hide_header()
            print("[DEBUG] Header hide_header() called")
            
    def toggle_theme_highlights_visibility(self, theme_name, is_visible):
        """Toggle the visual visibility of highlights for a specific theme"""
        print(f"[DEBUG] Toggling theme '{theme_name}' visibility: {is_visible}")
        
        # Create CSS to hide/show highlights based on data-scene attribute
        action = "show" if is_visible else "hide"
        js_is_visible = "true" if is_visible else "false"  # Convert Python bool to JS bool
        
        # Get the correct color for this theme from scene_styles
        theme_color = None
        if hasattr(self, 'scene_styles') and self.scene_styles:
            if theme_name in self.scene_styles:
                import re
                style_str = self.scene_styles[theme_name]
                match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{{6}}|[a-zA-Z]+);', style_str)
                if match:
                    theme_color = match.group(1)
        
        # If we couldn't get the color from scene_styles, try from sticky header's themes dict
        if not theme_color and hasattr(self, 'sticky_header') and self.sticky_header:
            for hotkey, theme_data in self.sticky_header.themes.items():
                if theme_data['name'] == theme_name:
                    theme_color = theme_data['color']
                    break
        
        # Fallback color
        if not theme_color:
            theme_color = "#FFF0B3"
        
        # Escape theme name for JavaScript
        import json
        theme_name_escaped = json.dumps(theme_name)
        
        js_code = f"""
        (function() {{
            console.log('Toggling theme ' + {theme_name_escaped} + ' visibility: {js_is_visible}');
            console.log('Theme color for restoration: {theme_color}');
            
            // Find all elements with data-scene attribute matching this theme
            const themeName = {theme_name_escaped};
            const elements = document.querySelectorAll('[data-scene="' + themeName + '"]');
            console.log('Found ' + elements.length + ' elements with theme ' + {theme_name_escaped});
            
            // Apply visual changes to hide/show the highlights
            elements.forEach(function(element) {{
                if ({js_is_visible}) {{
                    // Show: restore normal appearance and original background color
                    element.style.opacity = '1.0';
                    element.style.filter = 'none';
                    element.style.border = '';
                    
                    // Restore the correct theme background color
                    element.style.backgroundColor = '{theme_color}';
                    
                    element.classList.remove('theme-hidden');
                    element.classList.add('theme-visible');
                }} else {{
                    // Hide: keep text fully readable, only gray out the background highlight
                    element.style.opacity = '1.0';  // Keep text fully readable
                    element.style.filter = 'none';  // No filter on text
                    element.style.border = '1px dashed #ccc';
                    element.style.backgroundColor = '#e8e8e8';  // Light gray background instead of theme color
                    element.classList.remove('theme-visible');
                    element.classList.add('theme-hidden');
                }}
            }});
            
            // Update any existing color key if present
            const colorKey = document.querySelector('.color-key');
            if (colorKey) {{
                const keyItems = colorKey.querySelectorAll('.key-item');
                keyItems.forEach(function(item) {{
                    const itemText = item.textContent.trim();
                    if (itemText.includes(themeName)) {{
                        if ({js_is_visible}) {{
                            item.style.opacity = '1.0';
                            item.style.textDecoration = 'none';
                        }} else {{
                            item.style.opacity = '0.4';
                            item.style.textDecoration = 'line-through';
                        }}
                    }}
                }});
            }}
            
            return {{
                theme: themeName,
                action: '{action}',
                elementsAffected: elements.length,
                visible: {js_is_visible}
            }};
        }})();
        """
        
        def handle_visibility_result(result):
            if result:
                elements_count = result.get('elementsAffected', 0)
                action = result.get('action', 'unknown')
                theme = result.get('theme', 'unknown')
                
                status_msg = f"Theme '{theme}' {action}: {elements_count} highlights affected"
                self.main_window.status_bar.showMessage(status_msg, 3000)
                print(f"[DEBUG] {status_msg}")
            else:
                print("[DEBUG] No result returned from visibility toggle JavaScript")
        
        # Execute the JavaScript
        self.page().runJavaScript(js_code, handle_visibility_result)

    def resizeEvent(self, event):
        """Handle resize events to reposition sticky header"""
        super().resizeEvent(event)
        if (hasattr(self, 'sticky_header') and 
            self.sticky_header_enabled and 
            self.sticky_header.isVisible()):
            # Use QTimer to prevent excessive recalculations during rapid resize
            if not hasattr(self, '_header_resize_timer'):
                self._header_resize_timer = QTimer()
                self._header_resize_timer.setSingleShot(True)
                self._header_resize_timer.timeout.connect(self.recalculate_header_position)
            
            self._header_resize_timer.stop()
            self._header_resize_timer.start(50)  # 50ms delay for responsiveness

    def recalculate_header_position(self):
        """Recalculate header position based on current navigation width"""
        if not (hasattr(self, 'sticky_header') and self.sticky_header_enabled):
            return
            
        print("[DEBUG] Recalculating header position due to resize")
        
        parent_width = self.width()
        
        # Calculate required width for all theme buttons dynamically (same as show_sticky_header)
        num_themes = len(self.scene_styles) if hasattr(self, 'scene_styles') else 0
        button_spacing = 4   # Spacing between buttons
        
        # Calculate total width needed based on actual button content
        total_button_width = 0
        if hasattr(self, 'scene_styles') and self.scene_styles:
            theme_names = list(self.scene_styles.keys())
            hotkeys = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '+']
            
            for i, theme_name in enumerate(theme_names):
                if i < len(hotkeys):
                    hotkey = hotkeys[i]
                    text = f"{hotkey}: {theme_name}"
                    
                    # Use temporary button to calculate width
                    temp_btn = QPushButton()
                    temp_btn.setText(text)
                    font_metrics = temp_btn.fontMetrics()
                    text_width = font_metrics.horizontalAdvance(text)
                    
                    padding = 16
                    min_width = 80
                    max_width = 300
                    button_width = max(min_width, min(text_width + padding, max_width))
                    total_button_width += button_width
        
        required_width = total_button_width + ((num_themes - 1) * button_spacing) if num_themes > 0 else 0
        
        print(f"[DEBUG] RESIZE: Nav-aware centering: parent={parent_width}, themes={num_themes}, required={required_width}")
        
        # Get navigation width to calculate proper centering for resize
        js_code = """
        (function() {
            var navElement = document.querySelector('.navigation') || 
                           document.querySelector('#navigation') ||
                           document.querySelector('nav') ||
                           document.querySelector('.nav');
            
            var navWidth = 0;
            if (navElement) {
                navWidth = navElement.getBoundingClientRect().width;
            }
            
            console.log('[DEBUG] RESIZE: Navigation width:', navWidth);
            return navWidth;
        })();
        """
        
        def recenter_header_with_nav_width(nav_width):
            nav_width = nav_width or 200  # Default fallback
            
            # Calculate available space after navigation
            available_space = parent_width - nav_width
            
            # Center the header in the available space with some padding
            padding = 50
            header_width = available_space - (padding * 2)
            header_left = nav_width + padding
            
            print(f"[DEBUG] RESIZE: Nav-aware centering: nav={nav_width}, available={available_space}, header_left={header_left}, width={header_width}")
            
            # Check if theme buttons overflow
            content_overflows = required_width > header_width
            
            # Update themes with overflow information
            self.sticky_header.update_themes(self.scene_styles, content_overflows)
            
            # Update stored geometry
            self.sticky_header._fixed_x = header_left
            self.sticky_header._fixed_width = header_width
            
            # Reposition the header
            self.sticky_header.setGeometry(header_left, 0, header_width, 50)
            self.sticky_header.update_scroll_area_size()  # Update scroll area too
        
        self.page().runJavaScript(js_code, recenter_header_with_nav_width)

    def eventFilter(self, obj, event):
        """Handle keyboard events for tooltip control using the Shift key and theme hotkeys"""
        if event.type() == QEvent.Type.KeyPress:
            key = event.key()
            print(f"Python eventFilter: KeyPress detected - Key: {key}, Text: {event.text()}")
            
            # Handle Shift key for tooltip persistence
            if key == Qt.Key.Key_Shift:
                # When Shift is pressed, make the current tooltip persistent
                self.page().runJavaScript(
                    "window.tooltipShiftPressed = true; "
                    "console.log('Shift key pressed, tooltips will persist');"
                )
                return True
            

        elif event.type() == QEvent.Type.KeyRelease and event.key() == Qt.Key.Key_Shift:
            # When Shift is released, allow tooltips to hide normally
            self.page().runJavaScript(
                """
                window.tooltipShiftPressed = false; 
                console.log('Shift key released, tooltips will hide normally');

                // If no tooltip is showing, do nothing
                var tooltip = document.querySelector('.notes-tooltip');
                if (!tooltip || !tooltip.classList.contains('visible')) return;
        
                // If mouse isn't over tooltip or annotation, hide tooltip
                var activeSpan = window.activeHighlight;
                var rect = tooltip.getBoundingClientRect();
                var mouseX = event.clientX;
                var mouseY = event.clientY;
                var isMouseOverTooltip = (
                    mouseX >= rect.left && mouseX <= rect.right &&
                    mouseY >= rect.top && mouseY <= rect.bottom
                );
        
                if (!isMouseOverTooltip && activeSpan) {
                    var spanRect = activeSpan.getBoundingClientRect();
                    var isMouseOverSpan = (
                        mouseX >= spanRect.left && mouseX <= spanRect.right && 
                        mouseY >= spanRect.top && mouseY <= spanRect.bottom
                    );
            
                    if (!isMouseOverSpan) {
                        // Hide tooltip after a delay
                        if (window.tooltipHideTimer) clearTimeout(window.tooltipHideTimer);
                        window.tooltipHideTimer = setTimeout(function() {
                            tooltip.classList.remove('visible');
                            window.activeHighlight = null;
                        }, window.tooltipHideDelay || 400);
                    }
                }
                """
            )
            return True

        # Otherwise, pass the event along
        return super().eventFilter(obj, event)


    def back(self):
        # Override the back function to do nothing
        pass
    
    def forward(self):
        # Override the forward function to do nothing
        pass

    def handle_annotation_update(self, annotation_json):
        """
        Update the DOM elements when an annotation is updated.
        Ensures notes_html and other attributes are properly reflected in the HTML.
        """
        print(f"DEBUG: handle_annotation_update called with annotation_json: {annotation_json[:100]}...")
        try:
            annotation = json.loads(annotation_json)
            annotation_id = annotation.get('id')
            print(f"DEBUG: Processing annotation update for ID: {annotation_id}")
            if not annotation_id:
                print("Warning: No annotation ID found in update")
                return
            
            # Extract relevant data
            notes = annotation.get('notes', '')
            notes_html = annotation.get('notes_html', '')
            used = annotation.get('used', False)
            favorite = annotation.get('favorite', False)
            tags = annotation.get('tags', [])
            has_secondary = 'secondary_scenes' in annotation
            secondary_scenes = annotation.get('secondary_scenes', [])
        
            # Escape HTML for JavaScript inclusion
            def escape_js_string(s):
                return (
                    str(s).replace('\\', '\\\\')
                         .replace('"', '\\"')
                         .replace("'", "\\'")
                         .replace('\n', '\\n')
                         .replace('\r', '\\r')
                )
        
            # Escape all values for JavaScript
            notes_escaped = escape_js_string(notes)
            notes_html_escaped = escape_js_string(notes_html)
            used_str = str(used).lower()
            favorite_str = str(favorite).lower()
            tags_json_escaped = json.dumps(tags).replace('\\', '\\\\').replace('"', '\\"')
            secondary_scenes_json_escaped = json.dumps(secondary_scenes).replace('\\', '\\\\').replace('"', '\\"') if has_secondary else ''
            print(f"DEBUG[handle_annotation_update]: has_secondary={has_secondary} secondary_scenes={secondary_scenes}")
            print(f"DEBUG: tags_json_escaped: {tags_json_escaped}")
        
            # Create a simpler version of the JavaScript code with no fancy template literals
            js_code = '''
                (function() {
                    var hasSecondary = ''' + ('true' if has_secondary else 'false') + ''';
                    var secondaryScenesJson = "''' + secondary_scenes_json_escaped + '''";
                    console.log('[HAU] hasSecondary:', hasSecondary, 'secondaryScenesJson:', secondaryScenesJson);
                    // Try multiple selector approaches to find all spans with this annotation ID
                
                    // Approach 1: Using attribute selector with ID
                    let spans = document.querySelectorAll('span[data-annotation-id="''' + annotation_id + '''"]');
                    console.log("Found spans with direct ID selector:", spans.length);
                
                    // Approach 2: If previous approach fails, find all annotation spans and filter
                    if (spans.length === 0) {
                        spans = document.querySelectorAll('span[data-annotation-id]');
                        console.log("Found all spans with data-annotation-id:", spans.length);
                    
                        // Filter manually
                        spans = Array.from(spans).filter(span => span.getAttribute('data-annotation-id') === "''' + annotation_id + '''");
                        console.log("After filtering, found spans:", spans.length);
                    }
                
                    let count = 0;
                
                    spans.forEach(span => {
                        console.log("Updating span:", span);
                    
                        // Update the attributes
                        span.setAttribute('data-notes', "''' + notes_escaped + '''");
                        span.setAttribute('data-notes-html', "''' + notes_html_escaped + '''");
                        span.setAttribute('data-used', "''' + used_str + '''");
                        span.setAttribute('data-favorite', "''' + favorite_str + '''");
                        span.setAttribute('data-tags', "''' + tags_json_escaped + '''");
                        if (hasSecondary) {
                            console.log('[HAU] Setting data-secondary-scenes for', '""" + annotation_id + """', 'to', secondaryScenesJson);
                            span.setAttribute('data-secondary-scenes', secondaryScenesJson);
                        }
                        
                        // Apply used annotation border styling
                        if ("''' + used_str + '''" === "true") {{
                            span.style.border = "5px solid #2E7D32";
                        }} else {{
                            span.style.border = "";
                        }}
                        console.log('DEBUG: Updated data-tags attribute to:', "''' + tags_json_escaped + '''");
                        console.log('DEBUG: Updated data-secondary-scenes attribute to:', "''' + secondary_scenes_json_escaped + '''");
                    
                        console.log("Updated span attributes for annotation ID: ''' + annotation_id + '''");
                        count++;
                    });
                
                    // If no spans were found, log details for debugging
                    if (count === 0) {
                        console.error("No spans found for annotation ID: ''' + annotation_id + '''");
                        console.log("All annotation spans in document:");
                        let allSpans = document.querySelectorAll('span[data-annotation-id]');
                        console.log("Total annotation spans: " + allSpans.length);
                        allSpans.forEach(span => {
                            console.log("Span ID:", span.getAttribute('data-annotation-id'), "Text:", span.textContent);
                        });
                    } else {
                        console.log("Updated " + count + " spans for annotation ID: ''' + annotation_id + '''");
                    }
                
                    return count;
                })();
            '''
        
            # Run the JavaScript and log the result
            self.page().runJavaScript(js_code, lambda count: 
                print(f"Updated {count} DOM elements for annotation {annotation_id}")
            )
            
        except json.JSONDecodeError as e:
            print(f"Error parsing annotation JSON: {e}")
        except Exception as e:
            print(f"Error updating annotation in DOM: {e}")

    # ===== Secondary Theme Helpers =====
    def _sanitize_secondary_scenes(self, annotation):
        """Ensure annotation['secondary_scenes'] is a valid, deduped list, excluding the primary scene."""
        try:
            if not isinstance(annotation, dict):
                return
            primary = annotation.get('scene')
            sec = annotation.get('secondary_scenes')
            if not isinstance(sec, list):
                sec = [] if sec is None else list(sec) if isinstance(sec, (set, tuple)) else []
            valid = set(self.scene_styles.keys()) if hasattr(self, 'scene_styles') else set()
            cleaned = []
            seen = set()
            for s in sec:
                if s == primary:
                    continue
                if s in valid and s not in seen:
                    seen.add(s)
                    cleaned.append(s)
            annotation['secondary_scenes'] = cleaned
        except Exception as e:
            print(f"DEBUG: _sanitize_secondary_scenes error: {e}")

    def toggle_secondary_scene_for_annotation(self, annotation_id, scene, enabled):
        """Add/remove a secondary scene and propagate DOM + signals immediately. Menu should stay open."""
        try:
            target = None
            for a in self.annotations:
                if a.get('id') == annotation_id:
                    target = a
                    break
            if not target:
                print(f"DEBUG: toggle_secondary_scene_for_annotation: annotation {annotation_id} not found")
                return
            if scene == target.get('scene'):
                # Primary is not allowed as secondary
                return
            sec = target.get('secondary_scenes')
            print(f"DEBUG[toggle_secondary]: before toggle id={annotation_id} scene='{scene}' enabled={enabled} current={sec}")
            if not isinstance(sec, list):
                sec = []
            if enabled and scene not in sec:
                sec.append(scene)
            if not enabled and scene in sec:
                sec = [s for s in sec if s != scene]
            target['secondary_scenes'] = sec
            self._sanitize_secondary_scenes(target)
            print(f"DEBUG[toggle_secondary]: after sanitize id={annotation_id} set={target.get('secondary_scenes')}")
            # Emit update so Theme View/Storyboard pick up change
            try:
                payload = {
                    'id': target.get('id'),
                    'text': target.get('text', ''),
                    'notes': target.get('notes', ''),
                    'notes_html': target.get('notes_html', ''),
                    'used': target.get('used', False),
                    'favorite': target.get('favorite', False),
                    'tags': target.get('tags', []),
                    'secondary_scenes': target.get('secondary_scenes', [])
                }
                print(f"DEBUG[toggle_secondary]: emitting annotation_updated payload={payload}")
                self.annotation_updated.emit(json.dumps(payload))
            except Exception as _e:
                print(f"DEBUG: emit annotation_updated failed: {_e}")
            # Also update DOM attributes directly
            try:
                payload = {
                    'id': target.get('id'),
                    'notes': target.get('notes', ''),
                    'notes_html': target.get('notes_html', ''),
                    'used': target.get('used', False),
                    'favorite': target.get('favorite', False),
                    'tags': target.get('tags', []),
                    'secondary_scenes': target.get('secondary_scenes', [])
                }
                print(f"DEBUG[toggle_secondary]: calling handle_annotation_update with payload={payload}")
                self.handle_annotation_update(json.dumps(payload))
            except Exception as _e:
                print(f"DEBUG: direct DOM update for secondary_scenes failed: {_e}")
            
            # **TARGETED THEME VIEW UPDATE**: Refresh the specific annotation in theme view
            try:
                if hasattr(self, 'main_window') and hasattr(self.main_window, 'refresh_annotation_in_theme_view'):
                    print(f"DEBUG[toggle_secondary]: calling targeted theme view refresh for {annotation_id}")
                    self.main_window.refresh_annotation_in_theme_view(annotation_id)
                else:
                    print(f"DEBUG[toggle_secondary]: main_window or refresh method not available for targeted update")
            except Exception as _e:
                print(f"DEBUG: targeted theme view refresh failed: {_e}")
            
            # Mark changes pending if main_window available
            try:
                if hasattr(self, 'main_window') and hasattr(self.main_window, 'mark_changes_pending'):
                    self.main_window.mark_changes_pending()
            except Exception:
                pass
        except Exception as e:
            print(f"DEBUG: toggle_secondary_scene_for_annotation error: {e}")

    def initialize_web_view(self, ok):
        """Initialize web view after page loads"""
        if not ok:
            return
        
        init_js = '''
            // Set up QWebChannel immediately - synchronous approach
            if (typeof QWebChannel === "undefined") {
                console.error("QWebChannel not loaded!");
                false;
            } else {
                if (typeof window.webChannelInitialized === "undefined") {
                    new QWebChannel(qt.webChannelTransport, function(channel) {
                        window.jsHandler = channel.objects.jsHandler;
                
                        // Initialize variables
                        window.isEditMode = false;
                        // Don't initialize hotkeysEnabled here - let enable_hotkeys() manage it
                
                        // Set up content change listener when DOM is ready
                        if (document.body) {
                            document.body.addEventListener('input', function() {
                                if (window.isEditMode) {
                                    window.jsHandler.contentChangedFromJs(document.documentElement.outerHTML);
                                }
                            });
                            document.body.contentEditable = 'false';
                        }
                
                        // Signal that initialization is complete
                        window.webChannelInitialized = true;
                
                        console.log('QWebChannel initialized synchronously');
                    });
                }
                
                // Return true to indicate the script was executed successfully
                true;
            }
        '''

        def init_complete(success):
            if success:
                self.make_editable()
                self.set_edit_mode(False)
                self.enable_hotkeys(True)

                # Run tooltip fixes first, then inject sticky header in completion callback
                def after_tooltips():
                    # Inject secondary scene chips and initialize with current colors
                    try:
                        self.inject_secondary_theme_chips()
                    except Exception as e:
                        print(f"[DEBUG] inject_secondary_theme_chips error: {e}")

                    # Setup DOM-based sticky header only after tooltip fix completion
                    # Skip sticky header initialization during session loading - let session load handle it
                    main_window = self.parent()
                    is_loading_session = getattr(main_window, 'is_loading_session', False) if main_window else False
                    
                    if self.sticky_header_enabled and not is_loading_session:
                        print("[DEBUG] Initializing DOM-based sticky header after tooltip fix")
                        try:
                            self.inject_sticky_header_dom()
                            # Inject permanent restore button CSS once
                            self.inject_restore_button_css()
                            # Apply transparency update
                            self.update_restore_button_transparency()
                        except Exception as e:
                            print(f"[DEBUG] Sticky header injection sequence error: {e}")

                        # Populate tags for filtering (themes are populated by reinitialize/load flow)
                        try:
                            if hasattr(self, 'parent') and self.parent():
                                self.populate_dom_sticky_header_tags()
                        except Exception as e:
                            print(f"[DEBUG] populate_dom_sticky_header_tags error: {e}")
                    elif is_loading_session:
                        print("[DEBUG] Skipping sticky header initialization during session loading")

                # Fix tooltips and then continue with sticky header
                self.fix_tooltips(on_complete=after_tooltips)

        self.page().runJavaScript(init_js, init_complete)

    def fix_tooltips(self, on_complete=None):
        """Fix tooltip functionality, then call optional on_complete callback"""
        self.debug_and_fix_tooltips(on_complete=on_complete)

    def inject_secondary_theme_chips(self):
        """Inject JS/CSS to render scene-colored chips for data-secondary-scenes and keep them in sync."""
        js_code = r"""
        (function() {
            try {
                // Create or reuse style for chips
                let style = document.getElementById('secondary-chips-style');
                if (!style) {
                    style = document.createElement('style');
                    style.id = 'secondary-chips-style';
                    style.textContent = `
                        span[data-annotation-id] { position: relative; }
                        .secondary-chips { position: absolute; top: -9px; left: -6px; display: inline-flex; gap: 2px; z-index: 101; pointer-events: none; }
                        .secondary-chip { width: 10px; height: 10px; border-radius: 50%; border: 1px solid #2C3333; box-shadow: 0 1px 2px rgba(0,0,0,0.2); pointer-events: auto; transition: transform 0.12s ease, box-shadow 0.12s ease; }
                        .secondary-chip:hover { transform: scale(1.2); box-shadow: 0 1px 4px rgba(0,0,0,0.35); }
                    `;
                    if (document.head) {
                        document.head.appendChild(style);
                    } else {
                        console.warn('[Chips] document.head not ready; deferring style injection');
                        setTimeout(function(){
                            try {
                                if (document.head && !document.getElementById('secondary-chips-style')) {
                                    document.head.appendChild(style);
                                }
                            } catch(e) {
                                console.error('[Chips] deferred style injection failed', e);
                            }
                        }, 100);
                    }
                }

                // Global color map sourced from scene_styles (Python)
                window.themeColorMap = window.themeColorMap || {};

                // Util: extract background-color from a full CSS style string
                function extractBg(styleStr) {
                    if (!styleStr || typeof styleStr !== 'string') return null;
                    const m = styleStr.match(/background-color\s*:\s*([^;]+);?/i);
                    return m ? m[1].trim() : null;
                }

                // Define/updateSceneStyles hook (called from Python)
                window.updateSceneStyles = function(stylesJsonStr) {
                    try {
                        const obj = JSON.parse(stylesJsonStr);
                        const next = {};
                        Object.keys(obj || {}).forEach(name => {
                            const color = extractBg(obj[name]) || '#ccc';
                            next[name] = color;
                        });
                        window.themeColorMap = next;
                        // After updating colors, refresh chips to pick up new colors/names
                        if (typeof window.refreshAllSecondaryChips === 'function') {
                            window.refreshAllSecondaryChips();
                        }
                    } catch (e) {
                        console.warn('updateSceneStyles failed', e);
                    }
                }

                function getColorForScene(name) {
                    return (window.themeColorMap && window.themeColorMap[name]) || '#ccc';
                }

                function ensureChipsContainer(span) {
                    let container = span.querySelector(':scope > .secondary-chips');
                    if (!container) {
                        container = document.createElement('span');
                        container.className = 'secondary-chips';
                        span.appendChild(container);
                    }
                    return container;
                }

                function parseSecondaryAttr(span) {
                    const raw = span.getAttribute('data-secondary-scenes');
                    if (!raw) return [];
                    try {
                        const list = JSON.parse(raw);
                        return Array.isArray(list) ? list.filter(v => typeof v === 'string' && v.trim()) : [];
                    } catch (_e) {
                        return [];
                    }
                }

                function hasInfoIcon(span) {
                    const notes = span.getAttribute('data-notes');
                    const notesHtml = span.getAttribute('data-notes-html');
                    const notesOk = notes && notes !== '' && notes !== 'null';
                    const htmlOk = notesHtml && notesHtml !== '' && notesHtml !== 'null';
                    return !!(notesOk || htmlOk);
                }

                function computeChipsLeft(span) {
                    const hasInfo = hasInfoIcon(span);
                    const hasStar = span.getAttribute('data-favorite') === 'true';
                    if (hasInfo && hasStar) return 24; // leave room for two 12px icons (-5..7 and 9..21)
                    if (hasInfo || hasStar) return 10; // leave room for one icon at primary slot (-5..7)
                    return -6; // default alignment
                }

                function renderSecondaryChipsForSpan(span) {
                    if (!(span && span.nodeType === 1)) return;
                    if (!span.matches('span[data-annotation-id]')) return;
                    const scenes = parseSecondaryAttr(span);
                    // If empty, remove container if present
                    let container = span.querySelector(':scope > .secondary-chips');
                    if (!scenes.length) {
                        if (container) container.remove();
                        return;
                    }
                    container = ensureChipsContainer(span);
                    // Rebuild content diff-simply: clear then append
                    container.textContent = '';
                    // Position to avoid pseudo elements
                    try {
                        container.style.top = '-9px';
                        container.style.left = computeChipsLeft(span) + 'px';
                    } catch (_e) {}
                    scenes.forEach(sceneName => {
                        const chip = document.createElement('span');
                        chip.className = 'secondary-chip';
                        chip.title = sceneName;
                        chip.style.backgroundColor = getColorForScene(sceneName);
                        container.appendChild(chip);
                    });
                }

                window.renderSecondaryChipsForSpan = renderSecondaryChipsForSpan;

                window.refreshAllSecondaryChips = function() {
                    const spans = document.querySelectorAll('span[data-annotation-id][data-secondary-scenes]');
                    spans.forEach(renderSecondaryChipsForSpan);
                }

                // Observe attribute changes and new nodes
                if (!window.__secondaryChipsObserver) {
                    const obs = new MutationObserver(records => {
                        for (const rec of records) {
                            if (rec.type === 'attributes' && (
                                rec.attributeName === 'data-secondary-scenes' ||
                                rec.attributeName === 'data-notes' ||
                                rec.attributeName === 'data-notes-html' ||
                                rec.attributeName === 'data-favorite')) {
                                renderSecondaryChipsForSpan(rec.target);
                            } else if (rec.type === 'childList') {
                                rec.addedNodes && rec.addedNodes.forEach(node => {
                                    if (node.nodeType === 1) {
                                        if (node.matches && node.matches('span[data-annotation-id]')) {
                                            renderSecondaryChipsForSpan(node);
                                        }
                                        const inner = node.querySelectorAll ? node.querySelectorAll('span[data-annotation-id][data-secondary-scenes]') : [];
                                        inner.forEach(renderSecondaryChipsForSpan);
                                    }
                                });
                            }
                        }
                    });
                    obs.observe(document.body || document.documentElement, { subtree: true, childList: true, attributes: true, attributeFilter: ['data-secondary-scenes', 'data-notes', 'data-notes-html', 'data-favorite'] });
                    window.__secondaryChipsObserver = obs;
                }

                // Initial pass
                window.refreshAllSecondaryChips();

                return { ok: true, chips: document.querySelectorAll('.secondary-chip').length };
            } catch (e) {
                console.error('inject_secondary_theme_chips error', e);
                return { ok: false, error: String(e) };
            }
        })();
        """

        def after_inject(res):
            if isinstance(res, dict) and res.get('ok'):
                print(f"[Chips] Injected. Initial chips: {res.get('chips')}")
            else:
                print(f"[Chips] Injection failed: {res}")
            # Push current scene_styles into the page so chips pick up correct colors
            try:
                self.update_scene_styles_in_js()
            except Exception as e:
                print(f"[Chips] Failed to update scene styles: {e}")

        self.page().runJavaScript(js_code, after_inject)

    def _attach_tooltip_listeners_to_new_spans(self):
        """Lightweight method to attach tooltip event listeners to newly created spans"""
        print("Attaching tooltip listeners to new spans...")
        
        lightweight_js = """
        (function() {
            console.log('Attaching tooltip listeners to new spans...');
            
            // Only attach listeners if tooltip functions exist
            if (typeof showTooltipDirect === 'undefined' || typeof hideTooltipDirect === 'undefined') {
                console.log('Tooltip functions not available, skipping listener attachment');
                return false;
            }
            
            // Find spans that don't have listeners attached yet
            const spans = document.querySelectorAll('span[data-annotation-id]');
            let newSpansCount = 0;
            
            spans.forEach(span => {
                // Check if listeners are already attached (simple heuristic)
                if (!span.hasAttribute('data-tooltip-listeners-attached')) {
                    // Attach event listeners
                    span.addEventListener('mouseenter', showTooltipDirect);
                    span.addEventListener('mouseleave', hideTooltipDirect);
                    span.addEventListener('dblclick', selectAnnotationSpan);
                    span.setAttribute('data-tooltip-listeners-attached', 'true');
                    newSpansCount++;
                }
            });
            
            console.log('Attached listeners to', newSpansCount, 'new spans');
            return { success: true, newSpansCount: newSpansCount };
        })();
        """
        
        def handle_result(result):
            if result and result.get('success'):
                print(f"Successfully attached tooltip listeners to {result.get('newSpansCount', 0)} new spans")
            else:
                print("Failed to attach tooltip listeners to new spans")
        
        self.page().runJavaScript(lightweight_js, handle_result)

    def update_scene_styles_in_js(self):
        """Send the current scene styles to JavaScript"""
        if not hasattr(self, 'scene_styles') or not self.scene_styles:
            print("No scene styles available to update")
            return

        try:
            import json
            # Convert scene styles to JSON string
            scene_styles_json = json.dumps(self.scene_styles)
        
            # Execute JavaScript to update scene styles
            update_js = f"if (window.updateSceneStyles) {{ window.updateSceneStyles('{scene_styles_json}'); }}"
        
            print(f"Updating scene styles in JavaScript with {len(self.scene_styles)} styles")
            self.page().runJavaScript(update_js)
        except Exception as e:
            print(f"Error updating scene styles in JavaScript: {e}")


    def search_selected_text(self):
        """Handle F1 shortcut to go to the selected annotation in theme view"""
        current_item = self.currentItem()
        if not current_item:
            return

        # Get the annotation ID directly from the item
        annotation_id = current_item.data(Qt.ItemDataRole.UserRole)
        if annotation_id:
            # Go directly to the annotation in theme view
            self.select_annotation_in_theme_view(annotation_id)
        else:
            print("No annotation ID found for the current item")

    def _handle_search_selection(self, selected_text):
        """Process selected text for search"""
        if selected_text and selected_text.strip():
            self.request_theme_search(selected_text)

    def make_editable(self):
        js_code = '''
            if (typeof window.webChannelInitialized === "undefined") {
                // If not initialized, wait and try again
                setTimeout(function() {
                    if (document.body) {
                        document.body.contentEditable = 'false';
                    }
                    window.isEditMode = false;
                    window.hotkeysEnabled = false;
                }, 100);
            } else {
                if (document.body) {
                    document.body.contentEditable = 'false';
                }
                window.isEditMode = false;
                window.hotkeysEnabled = false;
            }
            true;
        '''
        self.page().runJavaScript(js_code)

    def auto_select_single_paragraph(self, scene, selection_info=None):
        """
        Simplified version that identifies if a p tag is in the selection,
        and constrains the selection to be within that p tag without expanding.
    
        Args:
            scene: The scene to assign
            selection_info: Optional dict containing the original selection range information
        """
        js_code = '''
            (function() {
                // Get current selection
                var selection = window.getSelection();
                if (!selection || selection.rangeCount === 0) {
                    console.log("DEBUG: No valid selection found");
                    return { success: false, error: "No valid selection" };
                }
    
                var range = selection.getRangeAt(0);
                var originalText = range.toString();
        
                console.log("DEBUG: Auto-selecting within a p tag");
                console.log("DEBUG: Original selection:", originalText);
            
                // Find all P tags that intersect with the selection
                var paragraphs = [];
                var allParagraphs = document.querySelectorAll('p');
            
                for (var i = 0; i < allParagraphs.length; i++) {
                    if (range.intersectsNode(allParagraphs[i])) {
                        paragraphs.push(allParagraphs[i]);
                    }
                }
            
                console.log("DEBUG: Found", paragraphs.length, "intersecting paragraphs");
            
                if (paragraphs.length === 0) {
                    console.log("DEBUG: No paragraphs intersect with the selection");
                    return { 
                        success: false, 
                        error: "No paragraph (p tag) intersects with your selection" 
                    };
                }
            
                // If multiple paragraphs intersect, use the one with the most overlap
                var targetParagraph = paragraphs[0];
            
                if (paragraphs.length > 1) {
                    var bestOverlap = 0;
                
                    for (var i = 0; i < paragraphs.length; i++) {
                        var p = paragraphs[i];
                        var tempRange = document.createRange();
                        tempRange.selectNodeContents(p);
                    
                        // Calculate overlap with current selection
                        var pText = p.textContent;
                        var selText = originalText;
                    
                        // Simple approach: check if paragraph contains selection
                        if (pText.includes(selText)) {
                            targetParagraph = p;
                            break;
                        }
                    
                        // Calculate how much of the selection is in this paragraph
                        var overlap = 0;
                        for (var j = 1; j <= Math.min(selText.length, pText.length); j++) {
                            if (pText.includes(selText.substring(0, j))) {
                                overlap = j;
                            }
                        }
                    
                        if (overlap > bestOverlap) {
                            bestOverlap = overlap;
                            targetParagraph = p;
                        }
                    }
                }
            
                console.log("DEBUG: Using target paragraph:", targetParagraph);
            
                // Create a new range that preserves the selection within the paragraph
                var newRange = document.createRange();
            
                // Find the exact position of the selection text within the paragraph
                var pText = targetParagraph.textContent;
                var startPos = pText.indexOf(originalText);
            
                if (startPos >= 0) {
                    // Found exact match in paragraph
                    console.log("DEBUG: Found exact match at position", startPos);
                
                    // Find the text node and offset containing this position
                    var currentPos = 0;
                    var startNode = null;
                    var startOffset = 0;
                    var endNode = null;
                    var endOffset = 0;
                
                    var walker = document.createTreeWalker(targetParagraph, NodeFilter.SHOW_TEXT);
                
                    while (walker.nextNode()) {
                        var textNode = walker.currentNode;
                        var nodeText = textNode.textContent;
                    
                        // Check if this node contains start position
                        if (startNode === null && currentPos + nodeText.length > startPos) {
                            startNode = textNode;
                            startOffset = startPos - currentPos;
                        }
                    
                        // Check if this node contains end position
                        if (startNode !== null && currentPos + nodeText.length >= startPos + originalText.length) {
                            endNode = textNode;
                            endOffset = startPos + originalText.length - currentPos;
                            break;
                        }
                    
                        currentPos += nodeText.length;
                    }
                
                    if (startNode && endNode) {
                        newRange.setStart(startNode, startOffset);
                        newRange.setEnd(endNode, endOffset);
                        console.log("DEBUG: Set range using exact text position");
                    } else {
                        // Fallback: use selection's relative position within paragraph
                        console.log("DEBUG: Couldn't find exact text nodes, using relative position");
                        newRange.setStart(range.startContainer, range.startOffset);
                        newRange.setEnd(range.endContainer, range.endOffset);
                    }
                
                } else {
                    // No exact match, try to constrain existing selection
                    console.log("DEBUG: No exact match found, constraining existing selection");
                
                    // Check if start and end are within the paragraph
                    var startIsWithin = targetParagraph.contains(range.startContainer);
                    var endIsWithin = targetParagraph.contains(range.endContainer);
                
                    // If both start and end are within paragraph, keep them
                    if (startIsWithin && endIsWithin) {
                        newRange.setStart(range.startContainer, range.startOffset);
                        newRange.setEnd(range.endContainer, range.endOffset);
                        console.log("DEBUG: Both start and end are within paragraph");
                    }
                    // If only start is within, adjust end
                    else if (startIsWithin) {
                        newRange.setStart(range.startContainer, range.startOffset);
                    
                        // Set end to end of paragraph
                        var lastNode = null;
                        var walker = document.createTreeWalker(targetParagraph, NodeFilter.SHOW_TEXT);
                        while (walker.nextNode()) {
                            lastNode = walker.currentNode;
                        }
                    
                        if (lastNode) {
                            newRange.setEnd(lastNode, lastNode.length);
                        } else {
                            newRange.setEnd(targetParagraph, targetParagraph.childNodes.length);
                        }
                    
                        console.log("DEBUG: Only start is within paragraph");
                    }
                    // If only end is within, adjust start
                    else if (endIsWithin) {
                        // Set start to beginning of paragraph
                        var firstNode = null;
                        var walker = document.createTreeWalker(targetParagraph, NodeFilter.SHOW_TEXT);
                        if (walker.nextNode()) {
                            firstNode = walker.currentNode;
                        }
                    
                        if (firstNode) {
                            newRange.setStart(firstNode, 0);
                        } else {
                            newRange.setStart(targetParagraph, 0);
                        }
                    
                        newRange.setEnd(range.endContainer, range.endOffset);
                        console.log("DEBUG: Only end is within paragraph");
                    }
                    // If neither is within, select as much overlap as possible
                    else {
                        // Just select the parts of our selection that overlap with paragraph
                        newRange.selectNodeContents(targetParagraph);
                        console.log("DEBUG: Neither start nor end is within paragraph");
                    }
                }
            
                // Verify that the new selection is actually different and within the paragraph
                if (!targetParagraph.contains(newRange.startContainer) || 
                    !targetParagraph.contains(newRange.endContainer)) {
                    console.log("DEBUG: Failed to constrain selection within the paragraph");
                    return { 
                        success: false, 
                        error: "Could not constrain selection to paragraph" 
                    };
                }
            
                // Apply the new selection
                selection.removeAllRanges();
                selection.addRange(newRange);
            
                var newText = newRange.toString();
                console.log("DEBUG: New selection:", newText.substring(0, 50) + "...");
            
                // Check that we haven't massively altered the selection
                if (newText.length > originalText.length * 3 && originalText.length > 10) {
                    console.log("DEBUG: New selection is too different from original");
                    return { 
                        success: false, 
                        error: "The adjusted selection would be too different from your original selection" 
                    };
                }
            
                return {
                    success: true,
                    originalText: originalText,
                    newText: newText,
                    paragraphTag: targetParagraph.tagName,
                    paragraphClass: targetParagraph.className
                };
            })();
        '''

        def handle_auto_select_result(result):
            if result and isinstance(result, dict) and result.get('success'):
                print(f"DEBUG: Auto-selection successfully applied")
                print(f"DEBUG: Original: '{result.get('originalText', '')[:50]}...'")
                print(f"DEBUG: New selection: '{result.get('newText', '')[:50]}...'")
        
                # Show a brief notification to the user
                QTimer.singleShot(0, lambda: self.main_window.status_bar.showMessage(
                    f"Auto-selected text within paragraph", 3000))
        
                # Now we call assign_to_scene with the is_auto_fix_attempt flag set to True
                QTimer.singleShot(100, lambda: self.assign_to_scene("", scene, is_auto_fix_attempt=True))
            else:
                error_msg = "Unknown error" if not isinstance(result, dict) else result.get('error', 'Unknown error')
                print(f"DEBUG: Auto-selection failed: {error_msg}")
            
                QMessageBox.warning(
                    self,
                    "Auto-Selection Failed",
                    f"Could not automatically adjust the selection. {error_msg}"
                )

        self.page().runJavaScript(js_code, handle_auto_select_result)

    def set_edit_mode(self, editable):
        print(f"Python: set_edit_mode called with editable={editable}")
        js_code = f'''
            if (typeof window.webChannelInitialized === "undefined") {{
                // If not initialized, set up basic properties
                if (document.body) {{
                    document.body.contentEditable = '{str(editable).lower()}';
                }}
                window.isEditMode = {str(editable).lower()};
            }} else {{
                if (document.body) {{
                    document.body.contentEditable = '{str(editable).lower()}';
                }}
                window.isEditMode = {str(editable).lower()};
            }}
            true;
        '''
    
        self.page().runJavaScript(js_code)
    
        if editable:
            # Disable hotkeys in Edit Mode
            self.enable_hotkeys(False)
        else:
            # Enable hotkeys in Highlight Mode
            self.enable_hotkeys(True)

    def enable_hotkeys(self, enable):
        print(f"Python: enable_hotkeys called with enable={enable}")
        if enable:
            # Adjusted to ensure hotkey 11 is '-' and hotkey 12 is '+'
            key_scene_map = {
                str((i % 10) + 1 if i < 9 else ('-' if i == 10 else '+')): scene
                for i, scene in enumerate(self.scene_styles.keys()) if i < 12
            }
            key_scene_map_json = json.dumps(key_scene_map)

            js_code = f'''
                if (typeof window.webChannelInitialized === "undefined") {{
                    setTimeout(function() {{
                        setupHotkeys();
                    }}, 100);
                }} else {{
                    setupHotkeys();
                }}
        
                function setupHotkeys() {{
                    console.log('JS: setupHotkeys called, enabling hotkeys');
                    window.hotkeysEnabled = true;
                    window.keyThemeMap = {key_scene_map_json};
                    console.log('JS: hotkeysEnabled set to:', window.hotkeysEnabled);
                    console.log('JS: keyThemeMap set to:', window.keyThemeMap);
        
                    if (!window.hotkeyHandler) {{
                        window.hotkeyHandler = function(event) {{
                            console.log('JS hotkeyHandler: Key pressed:', event.key);
                            console.log('JS hotkeyHandler: hotkeysEnabled:', window.hotkeysEnabled);
                            
                            if (!window.hotkeysEnabled) {{
                                console.log('JS hotkeyHandler: Hotkeys disabled, returning');
                                return;
                            }}
                    
                            var key = event.key;
                            console.log('JS hotkeyHandler: Checking key:', key);
                            console.log('JS hotkeyHandler: keyThemeMap:', window.keyThemeMap);
                            console.log('JS hotkeyHandler: Key in map:', key in window.keyThemeMap);
                            
                            if (key in window.keyThemeMap) {{
                                event.preventDefault();
                                var selectedText = window.getSelection().toString();
                                console.log('JS hotkeyHandler: Selected text:', selectedText);
                                if (selectedText.trim() !== '') {{
                                    console.log('JS hotkeyHandler: Calling assignThemeFromJs');
                                    window.jsHandler.assignThemeFromJs(selectedText, key);
                                }} else {{
                                    console.log('JS hotkeyHandler: No text selected');
                                }}
                            }} else if (key === 'Delete' || key === 'Backspace') {{
                                event.preventDefault();
                                var selectedText = window.getSelection().toString();
                                if (selectedText.trim() !== '') {{
                                    window.jsHandler.removeHighlightFromJs(selectedText);
                                }}
                            }} else {{
                                console.log('JS hotkeyHandler: Key not in theme map or delete keys');
                            }}
                        }};
                    }}
                    document.addEventListener('keydown', window.hotkeyHandler);
                }}
                true;
            '''
        else:
            js_code = '''
                console.log('JS: Disabling hotkeys');
                window.hotkeysEnabled = false;
                console.log('JS: hotkeysEnabled set to:', window.hotkeysEnabled);
                if (window.hotkeyHandler) {
                    document.removeEventListener('keydown', window.hotkeyHandler);
                    console.log('JS: Removed keydown event listener');
                }
                true;
            '''

        self.page().runJavaScript(js_code)


    def setHtml(self, html, baseUrl=None):
        # Reset tooltip initialization flag when new content is loaded
        self._tooltips_initialized = False
        
        # Inject transparent selection CSS early into HTML content
        selection_css = '''
        <style id="transparent-selection-style">
            /* Default selection for non-highlighted text - white text with shadow */
            ::selection {
                background-color: rgba(33, 150, 243, 0.6) !important;
                color: white !important;
                text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.6), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
            }
            ::-moz-selection {
                background-color: rgba(33, 150, 243, 0.6) !important;
                color: white !important;
                text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.6), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
            }
            
            /* More transparent selection for annotation spans with prominent white text */
            span[data-annotation-id]::selection {
                background-color: rgba(33, 150, 243, 0.2) !important;
                color: white !important;
                text-shadow: 0 0 6px rgba(0, 0, 0, 1.0), 0 0 12px rgba(0, 0, 0, 0.8), 0 1px 3px rgba(0, 0, 0, 1.0), 1px 1px 2px rgba(0, 0, 0, 0.9) !important;
            }
            span[data-annotation-id]::-moz-selection {
                background-color: rgba(33, 150, 243, 0.2) !important;
                color: white !important;
                text-shadow: 0 0 6px rgba(0, 0, 0, 1.0), 0 0 12px rgba(0, 0, 0, 0.8), 0 1px 3px rgba(0, 0, 0, 1.0), 1px 1px 2px rgba(0, 0, 0, 0.9) !important;
            }
        </style>
        '''
        
        # Inject CSS early in the head section
        if '<head>' in html:
            html = html.replace('<head>', '<head>' + selection_css)
        elif '<html>' in html:
            html = html.replace('<html>', '<html><head>' + selection_css + '</head>')
        else:
            html = selection_css + html
        
        # Ensure QWebChannel script is included in all HTML content
        if '<script src="qrc:///qtwebchannel/qwebchannel.js"></script>' not in html:
            insert_pos = html.find('</head>')
            if insert_pos == -1:
                insert_pos = html.find('<body')
                if insert_pos == -1:
                    # No head or body tag, add at the beginning
                    html = '''
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
                            <script>
                                document.addEventListener("DOMContentLoaded", function() {
                                    if (typeof QWebChannel !== "undefined") {
                                        new QWebChannel(qt.webChannelTransport, function(channel) {
                                            window.jsHandler = channel.objects.jsHandler;
                                            window.webChannelInitialized = true;
                                        });
                                    }
                                });
                            </script>
                        </head>
                        <body>
                    ''' + html + '''
                        </body>
                        </html>
                    '''
                else:
                    # Insert before body
                    html = html[:insert_pos] + '<head><script src="qrc:///qtwebchannel/qwebchannel.js"></script></head>' + html[insert_pos:]
            else:
                # Insert before </head>
                html = html[:insert_pos] + '<script src="qrc:///qtwebchannel/qwebchannel.js"></script>' + html[insert_pos:]
    
        # Call parent's setHtml with modified content
        if baseUrl is None:
            super().setHtml(html)
        else:
            super().setHtml(html, baseUrl)

    def check_content(self):
        """Periodically check content for changes"""
        def safe_content_callback(html):
            try:
                # Check if object still exists before emitting
                if hasattr(self, 'content_changed'):
                    self.content_changed.emit(html)
            except RuntimeError as e:
                # Object has been deleted - this is expected during close
                print(f"[DEBUG] TranscriptWebView deleted during content check: {e}")
            except Exception as e:
                print(f"[DEBUG] Unexpected error in content check callback: {e}")
        
        try:
            self.page().toHtml(safe_content_callback)
        except RuntimeError:
            # Page or widget already deleted
            pass

    def on_content_changed(self, html_content):
        """Handle content changes"""
        self.content_changed.emit(html_content)

    def handle_content_change(self):
        def safe_change_callback(html):
            try:
                if hasattr(self, 'content_changed'):
                    self.content_changed.emit(html)
            except RuntimeError as e:
                print(f"[DEBUG] TranscriptWebView deleted during content change: {e}")
            except Exception as e:
                print(f"[DEBUG] Unexpected error in content change callback: {e}")
        
        try:
            self.page().toHtml(safe_change_callback)
        except RuntimeError:
            pass

    def handle_assign_scene(self, selected_text, key_char):
        # Map key characters to scenes
        key_scene_map = {str((i % 10) + 1 if i < 9 else 0): scene for i, scene in enumerate(self.scene_styles.keys()) if i < 10}
        scene = key_scene_map.get(key_char)
        if scene:
            self.assign_to_scene(selected_text, scene)

    def handle_remove_highlight(self, selected_text):
        self.remove_highlight(selected_text)


    def show_settings_dialog(self):
        """Show settings dialog for tooltip and footnote configuration"""
        # Create a settings dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Settings")
        dialog.setMinimumWidth(450)
        dialog.setMinimumHeight(350)
        layout = QVBoxLayout(dialog)
    
        # Create tabs
        tabs = QTabWidget()
        tooltip_tab = QWidget()
        sticky_header_tab = QWidget()
        footnotes_tab = QWidget()
        tabs.addTab(tooltip_tab, "Tooltips")
        tabs.addTab(sticky_header_tab, "Sticky Header")
        tabs.addTab(footnotes_tab, "Footnotes")
    
        # Set up tooltip tab
        tooltip_layout = QVBoxLayout(tooltip_tab)
        tooltip_group = QGroupBox("Tooltip Settings")
        tooltip_group_layout = QVBoxLayout(tooltip_group)
    
        # Enable/disable tooltips
        tooltip_enable_cb = QCheckBox("Enable Tooltips")
        tooltip_enable_cb.setChecked(self.tooltips_enabled)
        tooltip_group_layout.addWidget(tooltip_enable_cb)
    
        # Tooltip position
        position_layout = QHBoxLayout()
        position_layout.addWidget(QLabel("Tooltip Position:"))
        position_combo = QComboBox()
        position_combo.addItems(["Left", "Right", "Top", "Bottom"])
    
        # Store the combo box as an instance variable to prevent deletion
        self._temp_position_combo = position_combo
    
        # Get the current position from JavaScript and set it BEFORE showing the dialog
        current_js = '''
        window.tooltipPreferredPosition || "left"
        '''
    
        # Default to "left" initially
        position_index = 0  # Default to "left" (index 0)
        position_combo.setCurrentIndex(position_index)
    
        def set_position_combo(position):
            try:
                if hasattr(self, '_temp_position_combo') and self._temp_position_combo:
                    position_index = {"left": 0, "right": 1, "top": 2, "bottom": 3}.get(position.lower(), 0)
                    self._temp_position_combo.setCurrentIndex(position_index)
            except RuntimeError as e:
                print(f"Warning: Could not set position combo: {e}")
    
        # Run JavaScript to get current position
        self.page().runJavaScript(current_js, set_position_combo)
    
        position_layout.addWidget(position_combo)
        tooltip_group_layout.addLayout(position_layout)
        tooltip_layout.addWidget(tooltip_group)
        tooltip_layout.addStretch()
    
        # Set up sticky header tab
        sticky_header_layout = QVBoxLayout(sticky_header_tab)
        sticky_header_group = QGroupBox("Sticky Header Settings")
        sticky_header_group_layout = QVBoxLayout(sticky_header_group)
        
        # Enable/disable sticky header
        sticky_header_enable_cb = QCheckBox("Enable Sticky Theme Header")
        sticky_header_enable_cb.setChecked(self.sticky_header_enabled)
        sticky_header_group_layout.addWidget(sticky_header_enable_cb)
        
        # Header size slider
        size_layout = QHBoxLayout()
        size_layout.addWidget(QLabel("Header Size:"))
        
        # Size slider (0.5x to 2.0x)
        size_slider = QSlider(Qt.Orientation.Horizontal)
        size_slider.setMinimum(50)   # 0.5x
        size_slider.setMaximum(200)  # 2.0x
        size_slider.setValue(int(self.sticky_header_size * 100))  # Convert to percentage
        size_slider.setTickPosition(QSlider.TickPosition.TicksBelow)
        size_slider.setTickInterval(25)  # Ticks every 0.25x
        
        # Size label
        size_value_label = QLabel(f"{self.sticky_header_size:.1f}x")
        size_value_label.setMinimumWidth(40)
        
        # Update label and header size when slider changes
        def update_size_label(value):
            size_multiplier = value / 100.0
            size_value_label.setText(f"{size_multiplier:.1f}x")
            # Update the header size in real-time
            if self.sticky_header_enabled:
                self.update_sticky_header_size(size_multiplier)
            
        size_slider.valueChanged.connect(update_size_label)
        
        size_layout.addWidget(size_slider)
        size_layout.addWidget(size_value_label)
        sticky_header_group_layout.addLayout(size_layout)
        
        # Enable/disable controls based on main checkbox
        def on_sticky_header_enabled_toggled(checked):
            size_slider.setEnabled(checked)
            size_value_label.setEnabled(checked)
            
        sticky_header_enable_cb.toggled.connect(on_sticky_header_enabled_toggled)
        on_sticky_header_enabled_toggled(self.sticky_header_enabled)  # Set initial state
        
        sticky_header_layout.addWidget(sticky_header_group)
        sticky_header_layout.addStretch()
    
        # Set up footnotes tab
        footnotes_layout = QVBoxLayout(footnotes_tab)
    
        # Add enable/disable checkbox at the top
        footnotes_enable_cb = QCheckBox("Enable Auto-Fill for New Highlights")
        footnotes_enable_cb.setChecked(self.app_settings.value("footnotes/enabled", False, type=bool))
        footnotes_layout.addWidget(footnotes_enable_cb)
    
        footnotes_group = QGroupBox("Default Footnote Population")
        footnotes_group_layout = QVBoxLayout(footnotes_group)
    
        footnotes_description = QLabel(
            "Choose what text should be automatically added to footnotes when creating new highlights:"
        )
        footnotes_description.setWordWrap(True)
        footnotes_group_layout.addWidget(footnotes_description)
    
        # Connect the checkbox to enable/disable the group
        footnotes_enable_cb.toggled.connect(footnotes_group.setEnabled)
    
        # Create radio buttons for footnote options
        footnote_options = [
            "Section Divider and Header",
            "Header Only",
            "Section Divider Only",
            "Custom"
        ]
    
        footnote_radio_buttons = []
        for option in footnote_options:
            radio = QRadioButton(option)
            footnote_radio_buttons.append(radio)
            footnotes_group_layout.addWidget(radio)
    
        # Custom text field
        custom_layout = QHBoxLayout()
        custom_layout.addWidget(QLabel("Custom Text:"))
        custom_text = QLineEdit()
        custom_text.setPlaceholderText("Enter custom text to use for all notes")
        custom_layout.addWidget(custom_text)
        footnotes_group_layout.addLayout(custom_layout)
    
        # Load saved settings for footnotes
        saved_option = self.app_settings.value("footnotes/default_option", "Header Only")
        for radio in footnote_radio_buttons:
            if radio.text() == saved_option:
                radio.setChecked(True)
                break
        else:
            # Default to Header Only if nothing saved
            footnote_radio_buttons[1].setChecked(True)
    
        custom_text.setText(self.app_settings.value("footnotes/custom_text", ""))
    
        # Enable/disable custom text field based on radio button
        def update_custom_field():
            custom_text.setEnabled(footnote_radio_buttons[3].isChecked())
    
        for radio in footnote_radio_buttons:
            radio.toggled.connect(update_custom_field)
    
        # Initial state
        update_custom_field()
    
        # Set initial state of footnotes group based on checkbox
        footnotes_group.setEnabled(footnotes_enable_cb.isChecked())
    
        footnotes_layout.addWidget(footnotes_group)
        footnotes_layout.addStretch()
    
        # Add the tabs to the layout
        layout.addWidget(tabs)
    
        # Add buttons
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)
    
        # Show the dialog
        result = dialog.exec()
    
        # Clean up the temporary reference
        if hasattr(self, '_temp_position_combo'):
            self._temp_position_combo = None
    
        if result == QDialog.DialogCode.Accepted:
            # Save settings
        
            # Tooltips
            self.tooltips_enabled = tooltip_enable_cb.isChecked()
            self.toggle_tooltips(self.tooltips_enabled)
        
            # Sticky Header
            self.sticky_header_enabled = sticky_header_enable_cb.isChecked()
            self.sticky_header_size = size_slider.value() / 100.0  # Convert from percentage to multiplier
            self.toggle_sticky_header(self.sticky_header_enabled)
        
            position_map = ["left", "right", "top", "bottom"]
            selected_position = position_map[position_combo.currentIndex()]
            self.set_tooltip_position(selected_position)
        
            # Footnotes
            selected_option = next((radio.text() for radio in footnote_radio_buttons if radio.isChecked()), "Header Only")
            custom_value = custom_text.text() if custom_text.isEnabled() else ""
        
            # Save to QSettings
            self.app_settings.setValue("tooltips/enabled", tooltip_enable_cb.isChecked())
            self.app_settings.setValue("tooltips/position", selected_position)
            self.app_settings.setValue("sticky_header/enabled", sticky_header_enable_cb.isChecked())
            self.app_settings.setValue("sticky_header/size", self.sticky_header_size)
            self.app_settings.setValue("footnotes/enabled", footnotes_enable_cb.isChecked())
            self.app_settings.setValue("footnotes/default_option", selected_option)
            self.app_settings.setValue("footnotes/custom_text", custom_value)
            self.app_settings.sync()
        
            # Show confirmation message
            self.main_window.status_bar.showMessage("Settings saved successfully", 3000)

    def contextMenuEvent(self, event):
        """Handle right-click context menu"""
        js_code = '''
            var selectedText = window.getSelection().toString();
            var isEditMode = window.isEditMode || false;
            var tooltipsEnabled = window.tooltipsEnabled !== false; // Default to true if undefined
            
            // Get the right-clicked element from the last stored context menu target
            var annotationId = null;
            var sceneData = null;
            var secondaryData = null;
            var hasStoryboard = false;
            
            // Check if we have a stored right-click target
            if (window.lastRightClickTarget) {
                var annotationSpan = window.lastRightClickTarget.closest('span[data-annotation-id]');
                if (annotationSpan) {
                    annotationId = annotationSpan.getAttribute('data-annotation-id');
                    sceneData = annotationSpan.getAttribute('data-scene');
                    secondaryData = annotationSpan.getAttribute('data-secondary-scenes');
                }
            }
            
            // Return data without storyboard check first, we'll handle that async
            [selectedText, isEditMode, tooltipsEnabled, annotationId, sceneData, secondaryData];
        '''

        cursor_pos = event.globalPos()

        def handle_selection(result):
            if not result:
                return
        
            # Backward compatible unpack (support older shape with 5 items)
            selected_text = result[0]
            is_edit_mode = result[1]
            tooltips_enabled = result[2]
            annotation_id = result[3] if len(result) > 3 else None
            scene_data = result[4] if len(result) > 4 else None
            annotation_secondary_attr = result[5] if len(result) > 5 else None
            has_selection = selected_text.strip() != ""
            has_annotation = annotation_id is not None
        
            # Store current tooltip state for menu display
            self.tooltips_enabled = tooltips_enabled
    
            menu = QMenu(self)
            menu.setStyleSheet("""
                QMenu {
                    background-color: white;
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    padding: 4px;
                }
                QMenu::item {
                    padding: 8px 24px 8px 8px;
                    border-radius: 2px;
                    icon-size: 16px;
                }
                QMenu::item:selected {
                    background-color: #e3f2fd;
                    color: #2C4952;
                }
                QMenu::icon {
                    padding-left: 8px;
                }
                QMenu::separator {
                    height: 1px;
                    background: #e0e0e0;
                    margin: 4px 0;
                }
            """)

            if is_edit_mode:
                # Edit mode menu items remain the same
                format_menu = menu.addMenu("Format")
                # Text style submenu
                style_menu = format_menu.addMenu("Style")
                bold_action = style_menu.addAction("Bold")
                italic_action = style_menu.addAction("Italic")
                underline_action = style_menu.addAction("Underline")
            
                # Font size submenu
                size_menu = format_menu.addMenu("Size")
                sizes = ['Small', 'Normal', 'Large', 'Very Large']
                size_actions = [size_menu.addAction(size) for size in sizes]
        
                # Color submenu
                color_menu = format_menu.addMenu("Color")
                text_color_action = color_menu.addAction("Text Color")
                background_color_action = color_menu.addAction("Background Color")
        
                # Alignment submenu
                align_menu = format_menu.addMenu("Align")
                align_left = align_menu.addAction("Left")
                align_center = align_menu.addAction("Center")
                align_right = align_menu.addAction("Right")
        
                menu.addSeparator()
        
                # Basic editing actions
                cut_action = menu.addAction("Cut")
                copy_action = menu.addAction("Copy")
                paste_action = menu.addAction("Paste")
                menu.addSeparator()
                clear_format_action = menu.addAction("Clear Formatting")
        
                # Connect actions to JavaScript commands
                bold_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('bold', false, null);"))
                italic_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('italic', false, null);"))
                underline_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('underline', false, null);"))
        
                def set_font_size(size):
                    size_map = {'Small': 2, 'Normal': 3, 'Large': 4, 'Very Large': 5}
                    self.page().runJavaScript(f"document.execCommand('fontSize', false, '{size_map[size]}');")
        
                for action, size in zip(size_actions, sizes):
                    action.triggered.connect(lambda checked, s=size: set_font_size(s))
        
                def pick_color(for_background=False):
                    color = QColorDialog.getColor()
                    if color.isValid():
                        if for_background:
                            self.page().runJavaScript(f"document.execCommand('backColor', false, '{color.name()}');")
                        else:
                            self.page().runJavaScript(f"document.execCommand('foreColor', false, '{color.name()}');")
        
                text_color_action.triggered.connect(lambda: pick_color(False))
                background_color_action.triggered.connect(lambda: pick_color(True))
        
                align_left.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('justifyLeft', false, null);"))
                align_center.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('justifyCenter', false, null);"))
                align_right.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('justifyRight', false, null);"))
        
                cut_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('cut', false, null);"))
                copy_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('copy', false, null);"))
                paste_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('paste', false, null);"))
                clear_format_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('removeFormat', false, null);"))
        
            elif has_selection:
                # Selection menu for highlight mode (existing code)
                if selected_text.strip():
                    # Create ordered scene menu items with color indicators
                    ordered_scenes = list(self.scene_styles.keys())
                    for scene in ordered_scenes:
                        # Get the index for hotkey display
                        scene_index = ordered_scenes.index(scene)
                        
                        # Determine hotkey display (matching the hotkey system)
                        if scene_index < 9:
                            hotkey = str(scene_index + 1)
                        elif scene_index == 9:
                            hotkey = '0'
                        elif scene_index == 10:
                            hotkey = '-'
                        elif scene_index == 11:
                            hotkey = '+'
                        else:
                            hotkey = ''
                        
                        # Format action text with hotkey in brackets
                        if hotkey:
                            action_text = f'[{hotkey}] "{scene}"'
                        else:
                            action_text = f'"{scene}"'
                        
                        action = QAction(action_text, menu)
                        match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', self.scene_styles[scene])
                        bg_color = match.group(1) if match else '#FFFFFF'
                
                        # Create colored icon
                        pixmap = QPixmap(16, 16)
                        painter = QPainter(pixmap)
                        painter.fillRect(0, 0, 16, 16, QColor(bg_color))
                        painter.setPen(QColor('#e0e0e0'))
                        painter.drawRect(0, 0, 15, 15)
                        painter.end()
                
                        action.setIcon(QIcon(pixmap))
                        action.triggered.connect(lambda checked, s=scene: self.assign_to_scene(selected_text, s))
                        menu.addAction(action)

                    # Place Secondary Themes submenu above Remove Highlight
                    if has_annotation and annotation_id and scene_data:
                        try:
                            ann_obj = None
                            for a in self.annotations:
                                if a.get('id') == annotation_id:
                                    ann_obj = a
                                    break
                            if ann_obj:
                                secondary_menu = QMenu('Add Secondary Theme', menu)
                                ordered_scenes = list(self.scene_styles.keys())
                                primary_scene = ann_obj.get('scene')
                                # Determine current secondaries from DOM attribute if available; fallback to Python model
                                current_secs = []
                                if annotation_secondary_attr:
                                    try:
                                        current_secs = json.loads(annotation_secondary_attr) if annotation_secondary_attr else []
                                    except Exception:
                                        # best-effort parsing
                                        txt = (annotation_secondary_attr or '').strip()
                                        if txt.startswith('[') and txt.endswith(']'):
                                            parts = [p.strip().strip('"\'') for p in txt[1:-1].split(',') if p.strip()]
                                            current_secs = parts
                                if not isinstance(current_secs, list) or not current_secs:
                                    current_secs = ann_obj.get('secondary_scenes', []) if isinstance(ann_obj.get('secondary_scenes'), list) else []
                                print(f"DEBUG[contextMenu]: id={annotation_id} DOM secondary='{annotation_secondary_attr}' parsed={current_secs} model={ann_obj.get('secondary_scenes', [])}")
                                for s in ordered_scenes:
                                    # Row widget with checkbox and color chip
                                    row_widget = QWidget()
                                    row_layout = QHBoxLayout(row_widget)
                                    row_layout.setContentsMargins(8, 2, 8, 2)
                                    row_layout.setSpacing(6)
                                    # Color chip for scene
                                    try:
                                        style_str = self.scene_styles.get(s, '')
                                        m = re.search(r'background-color:\s*([^;]+)', style_str)
                                        bg_color = m.group(1) if m else '#FFFFFF'
                                    except Exception:
                                        bg_color = '#FFFFFF'
                                    chip = QLabel()
                                    chip.setFixedSize(12, 12)
                                    chip.setToolTip(s)
                                    chip.setStyleSheet(f"background-color: {bg_color}; border: 1px solid #2C3333; border-radius: 6px;")
                                    cb = QCheckBox(s)
                                    cb.setChecked(s in current_secs)
                                    if s == primary_scene:
                                        cb.setEnabled(False)
                                        cb.setToolTip('Already primary')
                                    # Connect without closing menu
                                    cb.toggled.connect(lambda state, sid=annotation_id, scene_name=s: self.toggle_secondary_scene_for_annotation(sid, scene_name, state))
                                    row_layout.addWidget(chip)
                                    row_layout.addWidget(cb)
                                    action = QWidgetAction(secondary_menu)
                                    action.setDefaultWidget(row_widget)
                                    secondary_menu.addAction(action)
                                menu.addMenu(secondary_menu)
                        except Exception as _e:
                            print(f"DEBUG: Failed to build Secondary Theme menu (pre-remove placement): {_e}")
            
                    menu.addSeparator()
                    remove_action = menu.addAction('Remove Highlight')
                    remove_action.triggered.connect(lambda: self.storyboard_aware_remove_highlight(selected_text))
                    
                    menu.addSeparator()
                    
                    # Add navigation options if right-clicked on an annotation (moved here)
                    if has_annotation and annotation_id and scene_data:
                        # Create Navigate submenu
                        navigate_submenu = QMenu('Navigate to', menu)
                        
                        # Add Script Editor navigation
                        storyboard_action = navigate_submenu.addAction('Script Editor')
                        storyboard_action.triggered.connect(lambda: self.navigate_to_storyboard(annotation_id))
                        
                        # Add Theme View navigation
                        theme_view_action = navigate_submenu.addAction('Theme View')
                        theme_view_action.triggered.connect(lambda: self.navigate_to_theme_view(annotation_id, scene_data))
                        
                        # Add the submenu to the main menu
                        menu.addMenu(navigate_submenu)
                    
                    # Create AI submenu
                    ai_submenu = QMenu('Scriptoria AI', menu)
                    
                    # Add submenu options
                    quick_summary_action = ai_submenu.addAction('Quick Summary')
                    quick_summary_action.triggered.connect(lambda: self.handle_quick_summary_from_menu(selected_text))
                    
                    quick_explain_action = ai_submenu.addAction('Quick Explain')
                    quick_explain_action.triggered.connect(lambda: self.handle_quick_explain_from_menu(selected_text))
                    
                    ask_question_action = ai_submenu.addAction('Chat with AI')
                    ask_question_action.triggered.connect(lambda: self.handle_ai_query_from_menu(selected_text))
                    
                    quick_custom_action = ai_submenu.addAction('Preset Prompt')
                    quick_custom_action.triggered.connect(lambda: self.handle_quick_custom_from_menu(selected_text))
                    
                    live_voice_chat_action = ai_submenu.addAction('Voice Chat')
                    live_voice_chat_action.triggered.connect(lambda: self.handle_live_voice_chat_from_menu(selected_text))
                    
                    # Add the submenu to the main menu
                    menu.addMenu(ai_submenu)
                    
                    # Add Copy Caption action
                    copy_caption_action = menu.addAction('Copy Caption')
                    # Check if cleaner tab has text to determine if action should be enabled
                    cleaner_has_text = self.check_cleaner_tab_has_text()
                    copy_caption_action.setEnabled(cleaner_has_text)
                    if not cleaner_has_text:
                        copy_caption_action.setText('Copy Caption (No cleaned text available)')
                    copy_caption_action.triggered.connect(lambda: self.handle_copy_caption_from_menu(selected_text))
                    
            else:
                # NEW: Right-click menu when no text is selected
                # Add undo option if available
                if self._undo_stack:
                    current_time = time.time()
                    last_undo = self._undo_stack[-1]
                    if current_time - last_undo['ts'] <= 300:  # Within 5 minutes
                        undo_action = menu.addAction("Undo Last Removal (Ctrl+Z)")
                        undo_action.triggered.connect(self.undo_last_removal)
                
                # Add redo option if available
                # TEMPORARILY DISABLED - DOM corruption issue
                # if self._redo_stack:
                #     current_time = time.time()
                #     last_redo = self._redo_stack[-1]
                #     if current_time - last_redo['ts'] <= 300:  # Within 5 minutes
                #         redo_action = menu.addAction("Redo Last Action (Ctrl+Shift+Z)")
                #         redo_action.triggered.connect(self.redo_last_action)
                
                # Add separator if we added any undo options (redo temporarily disabled)
                if (self._undo_stack and time.time() - self._undo_stack[-1]['ts'] <= 300):
                    menu.addSeparator()
                
                # Simplified to just "Debug Tooltips", CSS Fix, and Settings
                debug_action = menu.addAction("Debug Tooltips")
                debug_action.triggered.connect(self.debug_and_fix_tooltips)
                
                # Re-enable: Update CSS for notes/favorite indicators (Favorite Star Fix)
                # update_css_action = menu.addAction("Inject Favorite Star Fix (Notes CSS)")
                # update_css_action.triggered.connect(self.inject_updated_notes_css)
            
                # Add settings action
                settings_action = menu.addAction("Settings...")
                settings_action.triggered.connect(self.show_settings_dialog)
    
    
            menu.exec(cursor_pos)

        self.page().runJavaScript(js_code, handle_selection)
        
    def navigate_to_storyboard(self, annotation_id):
        """Navigate to annotation in storyboard using the same method as tooltip buttons"""
        print(f"DEBUG: Context menu navigate_to_storyboard called with annotation_id: {annotation_id}")
        
        js_code = f'''
            console.log("Context menu: Navigating to storyboard for annotation: {annotation_id}");
            if (typeof window.jsHandler !== 'undefined' && typeof window.jsHandler.requestStoryboardNavigation === 'function') {{
                window.jsHandler.requestStoryboardNavigation("{annotation_id}");
            }} else {{
                console.error("Cannot navigate to storyboard: jsHandler not available");
            }}
        '''
        self.page().runJavaScript(js_code)
    
    def navigate_to_theme_view(self, annotation_id, scene_data):
        """Navigate to annotation in theme view using the same method as tooltip buttons"""
        js_code = f'''
            console.log("Context menu: Navigating to theme view for annotation: {annotation_id}, scene: {scene_data}");
            if (typeof window.jsHandler !== 'undefined' && typeof window.jsHandler.requestAnnotationNavigation === 'function') {{
                window.jsHandler.requestAnnotationNavigation("{annotation_id}", "{scene_data}");
            }} else {{
                console.error("Cannot navigate to theme view: jsHandler not available");
            }}
        '''
        self.page().runJavaScript(js_code)

   

    def request_theme_search(self, text):
        """Request a search in the theme view with the selected text"""
        self.search_requested.emit(text)

    def check_cleaner_tab_has_text(self):
        """Check if the cleaner tab's 'Cleaned Text Without Timecodes' section has text"""
        try:
            cleaner_text = self.main_window.cleaner_output_text.toPlainText().strip()
            return bool(cleaner_text)
        except AttributeError:
            return False

    def handle_copy_caption_from_menu(self, selected_text):
        """Handle Copy Caption request from context menu - uses smart text extraction"""
        if not selected_text.strip():
            return
        
        # Use smart copy logic similar to OrderListWidget
        smart_text = self.smart_copy_text_from_webview(selected_text)
        QApplication.clipboard().setText(smart_text)
        
        # Show status message
        if hasattr(self.main_window, 'status_bar'):
            self.main_window.status_bar.showMessage(f'Copied caption: "{smart_text[:30]}{"..." if len(smart_text) > 30 else ""}"', 3000)

    def smart_copy_text_from_webview(self, selected_text):
        """Smart text extraction with cleaner tab matching logic for webview text"""
        # Clean the selected text (remove HTML if any)
        clean_text = self.extract_clean_text_from_selection(selected_text)
        
        # Get cleaner tab text
        cleaner_text = self.get_cleaner_tab_text()
        
        # If no cleaner text, return first 25 chars as fallback
        if not cleaner_text:
            return clean_text[:25] if clean_text else ""
        
        # Split cleaner text into lines
        cleaner_lines = [line.strip() for line in cleaner_text.splitlines() if line.strip()]
        
        # Try 25-character matching
        segments_25 = self.extract_text_segments(clean_text, 25)
        for segment in segments_25:
            if self.find_text_on_single_line(segment, cleaner_lines):
                return segment
        
        # Fallback to 8-character matching
        segments_8 = self.extract_text_segments(clean_text, 8)
        for segment in segments_8:
            if self.find_text_on_single_line(segment, cleaner_lines):
                return segment
        
        # Final fallback: first 25 characters
        return clean_text[:25] if clean_text else ""

    def extract_clean_text_from_selection(self, text_content):
        """Extract clean text from selected text content"""
        import re
        # For webview selections, text is usually already clean, but remove any HTML that might be present
        plain_text = re.sub(r'<[^>]*>', '', text_content)
        return plain_text.strip()

    def get_cleaner_tab_text(self):
        """Get the text from the cleaner tab's 'Cleaned Text Without Timecodes' section."""
        try:
            cleaner_text = self.main_window.cleaner_output_text.toPlainText().strip()
            return cleaner_text
        except AttributeError:
            return ""

    def extract_text_segments(self, clean_text, char_count):
        """Extract sequential text segments of specified character count."""
        segments = []
        if len(clean_text) < char_count:
            return [clean_text] if clean_text else []
        
        for i in range(len(clean_text) - char_count + 1):
            segment = clean_text[i:i + char_count]
            if segment.strip():  # Only add non-empty segments
                segments.append(segment)
        
        return segments

    def find_text_on_single_line(self, search_text, cleaner_lines):
        """Check if search_text exists as a continuous string on any single line."""
        if not search_text or not cleaner_lines:
            return False
        
        for line in cleaner_lines:
            line_clean = line.strip()
            if search_text in line_clean:
                return True
        return False

    def handle_menu_creation(self, is_edit_mode, selected_text, menu, cursor_pos):
        """Create appropriate menu based on edit mode"""
        if is_edit_mode:
            # Edit mode menu items
            format_menu = menu.addMenu("Format")
        
            # Text style submenu
            style_menu = format_menu.addMenu("Style")
            bold_action = style_menu.addAction("Bold")
            italic_action = style_menu.addAction("Italic")
            underline_action = style_menu.addAction("Underline")
        
            # Font size submenu
            size_menu = format_menu.addMenu("Size")
            sizes = ['Small', 'Normal', 'Large', 'Very Large']
            size_actions = [size_menu.addAction(size) for size in sizes]
        
            # Color submenu
            color_menu = format_menu.addMenu("Color")
            text_color_action = color_menu.addAction("Text Color")
            background_color_action = color_menu.addAction("Background Color")
        
            # Alignment submenu
            align_menu = format_menu.addMenu("Align")
            align_left = align_menu.addAction("Left")
            align_center = align_menu.addAction("Center")
            align_right = align_menu.addAction("Right")
        
            menu.addSeparator()
        
            # Basic editing actions
            cut_action = menu.addAction("Cut")
            copy_action = menu.addAction("Copy")
            paste_action = menu.addAction("Paste")
            menu.addSeparator()
            clear_format_action = menu.addAction("Clear Formatting")
        
            # Connect actions to JavaScript commands
            bold_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('bold', false, null);"))
            italic_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('italic', false, null);"))
            underline_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('underline', false, null);"))
        
            def set_font_size(size):
                size_map = {'Small': 2, 'Normal': 3, 'Large': 4, 'Very Large': 5}
                self.page().runJavaScript(f"document.execCommand('fontSize', false, '{size_map[size]}');")
        
            for action, size in zip(size_actions, sizes):
                action.triggered.connect(lambda checked, s=size: set_font_size(s))
        
            def pick_color(for_background=False):
                color = QColorDialog.getColor()
                if color.isValid():
                    if for_background:
                        self.page().runJavaScript(f"document.execCommand('backColor', false, '{color.name()}');")
                    else:
                        self.page().runJavaScript(f"document.execCommand('foreColor', false, '{color.name()}');")
        
            text_color_action.triggered.connect(lambda: pick_color(False))
            background_color_action.triggered.connect(lambda: pick_color(True))
        
            align_left.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('justifyLeft', false, null);"))
            align_center.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('justifyCenter', false, null);"))
            align_right.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('justifyRight', false, null);"))
        
            cut_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('cut', false, null);"))
            copy_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('copy', false, null);"))
            paste_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('paste', false, null);"))
            clear_format_action.triggered.connect(lambda: self.page().runJavaScript("document.execCommand('removeFormat', false, null);"))
        
        else:
            # Highlight mode menu items
            if selected_text.strip():
                # Create ordered scene menu items with color indicators
                ordered_scenes = list(self.scene_styles.keys())
                for scene in ordered_scenes:
                    action = QAction(f'Assign to "{scene}"', menu)
                    match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', self.scene_styles[scene])
                    bg_color = match.group(1) if match else '#FFFFFF'
                
                    # Create colored icon
                    pixmap = QPixmap(16, 16)
                    painter = QPainter(pixmap)
                    painter.fillRect(0, 0, 16, 16, QColor(bg_color))
                    painter.setPen(QColor('#e0e0e0'))
                    painter.drawRect(0, 0, 15, 15)
                    painter.end()
                
                    action.setIcon(QIcon(pixmap))
                    action.triggered.connect(lambda checked, s=scene: self.assign_to_scene(selected_text, s))
                    menu.addAction(action)
            
                menu.addSeparator()
                remove_action = menu.addAction('Remove Highlight')
                remove_action.triggered.connect(lambda: self.remove_highlight(selected_text))
                
                menu.addSeparator()
                
                # Create AI submenu
                ai_submenu = QMenu('Ask AI', menu)
                
                # Add submenu options
                quick_summary_action = ai_submenu.addAction('Quick Summarize')
                quick_summary_action.triggered.connect(lambda: self.handle_quick_summary_from_menu(selected_text))
                
                ask_question_action = ai_submenu.addAction('Ask Question')
                ask_question_action.triggered.connect(lambda: self.handle_ai_query_from_menu(selected_text))
                
                # Add the submenu to the main menu
                menu.addMenu(ai_submenu)
            else:
                # Create default context menu
                menu.addAction("Back")

        menu.exec(cursor_pos)

    def calculate_user_facing_order_number(self, internal_order, annotations=None):
        """
        Calculate the user-facing order number based on internal order number.
    
        Args:
            internal_order: The internal order number (0-indexed)
            annotations: Optional list of annotations, defaults to self.annotations
        
        Returns:
            The user-facing order number (1-indexed, excluding dividers)
        """
        if annotations is None:
            annotations = self.annotations
        
        # Count dividers before this order
        divider_count = sum(1 for a in annotations 
                            if a.get('divider') == True and a.get('order', 0) < internal_order)
    
        # Convert from 0-indexed to 1-indexed and subtract dividers
        return internal_order - divider_count + 1
    
    def show_processing_cursor(self):
        """Show processing cursor for immediate visual feedback"""
        print("🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥")
        print("🖱️🖱️🖱️ CURSOR CHANGE STARTING NOW!!! 🖱️🖱️🖱️")
        print("⚡⚡⚡ SETTING WAIT CURSOR ON ENTIRE APPLICATION!!! ⚡⚡⚡")
        print("🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥")
        
        from PyQt6.QtCore import Qt
        from PyQt6.QtWidgets import QApplication
        
        try:
            print("🚀🚀🚀 CALLING QApplication.setOverrideCursor(WaitCursor)!!! 🚀🚀🚀")
            # Set cursor on the entire application
            QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
            print("✅✅✅ WAIT CURSOR SET SUCCESSFULLY!!! ✅✅✅")
            
            # Force process events to make cursor change visible immediately
            QApplication.processEvents()
            print("💫💫💫 PROCESS EVENTS CALLED - CURSOR SHOULD BE SPINNING NOW!!! 💫💫💫")
            
        except Exception as e:
            print(f"❌❌❌ CURSOR SET FAILED!!! ERROR: {e} ❌❌❌")
        
        print("🎯🎯🎯 CURSOR CHANGE METHOD COMPLETED!!! 🎯🎯🎯")
        
        # Auto-restore cursor after 5 seconds as fallback
        from PyQt6.QtCore import QTimer
        QTimer.singleShot(5000, self.hide_processing_cursor)
    
    def hide_processing_cursor(self):
        """Restore normal cursor after processing completes"""
        print("🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢")
        print("🔄🔄🔄 CURSOR RESTORE STARTING NOW!!! 🔄🔄🔄")
        print("🏁🏁🏁 PROCESSING COMPLETE - RESTORING NORMAL CURSOR!!! 🏁🏁🏁")
        print("🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢🟢")
        
        from PyQt6.QtWidgets import QApplication
        
        try:
            print("🔙🔙🔙 CALLING QApplication.restoreOverrideCursor()!!! 🔙🔙🔙")
            # Restore global application cursor
            QApplication.restoreOverrideCursor()
            print("🎉🎉🎉 NORMAL CURSOR RESTORED SUCCESSFULLY!!! 🎉🎉🎉")
            
            # Force process events
            QApplication.processEvents()
            print("✨✨✨ PROCESS EVENTS CALLED - CURSOR SHOULD BE NORMAL NOW!!! ✨✨✨")
            
        except Exception as e:
            print(f"💥💥💥 CURSOR RESTORE FAILED!!! ERROR: {e} 💥💥💥")
        
        print("🏆🏆🏆 CURSOR RESTORE METHOD COMPLETED!!! 🏆🏆🏆")

    def assign_to_scene(self, text, scene, is_auto_fix_attempt=False):
        """
        Assign selected text to a scene, supporting partial reassignment.
        If the selection intersects with more than one existing annotation,
        or includes line breaks, block the assignment and do not proceed.
    
        Args:
            text: Text to assign
            scene: Scene to assign to
            is_auto_fix_attempt: Flag to prevent infinite loops with auto-fix
                                 and skip confirmation dialog when true
        """

        # JavaScript for checking if a removal is necessary (does not modify content)
        removal_check_js = '''
            (function() {
                try {
                    console.log("Starting removal check JavaScript execution");

                    var selection = window.getSelection();
    
                    if (selection.rangeCount === 0) {
                        console.log("No selection detected.");
                        return { blocked: true, reason: "no-selection" };
                    }

                    var range = selection.getRangeAt(0);
                    
                    // Note: Temporary highlight will be applied AFTER user confirmation
                    // to avoid showing it during the dialog interaction
                    var spans = document.querySelectorAll('span[data-annotation-id]');
                    var intersectingSpans = Array.from(spans).filter(span => range.intersectsNode(span));

                    if (intersectingSpans.length > 0) {
                        console.log("Existing highlights detected, requiring removal.");
                        var annotationIds = new Set(intersectingSpans.map(span => span.getAttribute('data-annotation-id')));
                        return {
                            requiresRemoval: true,
                            annotationIds: Array.from(annotationIds),
                            selectionInfo: {
                                text: range.toString()
                            }
                        };
                    }

                    // Function to check if the selection contains any block-level elements or explicit line breaks
                    function containsLineBreak(range) {
                        console.log("Checking for line breaks in selection");
                        var container = range.commonAncestorContainer;
                        console.log("Common ancestor container:", container);
                
                        var walker = document.createTreeWalker(
                            container,
                            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
                            {
                                acceptNode: function(node) {
                                    if (node.nodeType === Node.ELEMENT_NODE) {
                                        var display = window.getComputedStyle(node).display;
                                        if (display === 'block' || display === 'flex' || display === 'grid' || display === 'inline-block') {
                                            console.log("Found block-level element:", node);
                                            return NodeFilter.FILTER_ACCEPT;
                                        }
                                        if (node.tagName === 'BR') {
                                            console.log("Found <br> element:", node);
                                            return NodeFilter.FILTER_ACCEPT;
                                        }
                                    } else if (node.nodeType === Node.TEXT_NODE) {
                                        if (node.textContent.includes('\\n')) {
                                            console.log("Found newline character in text node:", node);
                                            return NodeFilter.FILTER_SKIP;
                                        }
                                    }
                                    return NodeFilter.FILTER_SKIP;
                                }
                            },
                            false
                        );

                        var blockingNodes = [];
                        var node;
                        while(node = walker.nextNode()) {
                            if (range.intersectsNode(node)) {
                                console.log("Node intersects selection:", node);
                                var nodeInfo = {
                                    tagName: node.tagName || '#text',
                                    textContent: node.textContent.trim().substring(0, 100),
                                    id: node.id || null,
                                    className: node.className || null
                                };
                                blockingNodes.push(nodeInfo);
                            }
                        }
                
                        console.log("Line break check result:", blockingNodes.length > 0 ? blockingNodes : false);
                        return blockingNodes.length > 0 ? blockingNodes : false;
                    }

                    // Check for explicit line breaks in the selection
                    var lineBreakNodes = containsLineBreak(range);
                    if (lineBreakNodes) {
                        console.log("Selection across paragraph (block-element) detected. Blocking Assignment.");
                        return { 
                            blocked: true, 
                            reason: "line-break",
                            debugInfo: {
                                type: "line-break",
                                nodes: lineBreakNodes
                            }
                        };
                    }

                    console.log("No existing highlights detected.");
                    return {
                        requiresRemoval: false,
                        selectionInfo: {
                            text: range.toString()
                        }
                    };
                } catch (error) {
                    console.error("Error in removal check:", error);
                    return {
                        blocked: true,
                        reason: "error",
                        debugInfo: { message: error.toString() }
                    };
                }
            })();
        '''


        removal_js = '''
            (function() {
                console.log("🚀 REMOVAL_JS STARTED! 🚀");
                try {
                    console.log("✅ Inside try block! ✅");
                    var scrollPos = window.pageYOffset;
                    console.log("📍 Got scroll position:", scrollPos);
                    
                    // ==========================================================
                    // 🧹 CLEANUP: Remove any temporary elements
                    // ==========================================================
                    console.log("🧹 STARTING TEMP CLEANUP! 🧹");
                    
                    
                    
                    
                    // Clean up window references
                    
                    console.log("✨ TEMP CLEANUP COMPLETE! ✨");
                    // ==========================================================
                    // 🧹 END OF CLEANUP
                    // ==========================================================
                    
                    var selection = window.getSelection();
                    

                    // --- Helper functions moved to the top of removal_js ---
                    function isLineBreakNode(node) {
                        console.log("Checking if node is linebreak node:", node);
                        return node.nodeType === Node.TEXT_NODE && /^\\n+$/.test(node.textContent);
                    }

                    function normalizeLineBreaks(text) {
                        console.log("Normalizing linebreaks for text:", text);
                        return text.replace(/\\n{3,}/g, '\\n\\n');
                    }
                
                    // Capture initial selection info before any modifications
                    var initialSelectionInfo = null;
                    if (selection.rangeCount > 0) {
                        var range = selection.getRangeAt(0);
                        initialSelectionInfo = {
                            text: range.toString(),
                            startContainerPath: getXPath(range.startContainer),
                            startOffset: range.startOffset,
                            endContainerPath: getXPath(range.endContainer),
                            endOffset: range.endOffset,
                            context: getTextContext(
                                range.startContainer,
                                range.startOffset,
                                range.toString().length
                            ),
                            location: {
                                containerPath: getXPath(getNearestBlockAncestor(range.startContainer)),
                                offset: range.startOffset,
                                length: range.toString().length,
                                blockContext: true
                            }
                        };
                    }

                    var range = selection.getRangeAt(0);
                    console.log("Selection range:", range);

                    // Enhanced node handling functions
                    function splitTextNode(node, offset) {
                        console.log("Splitting text node at offset:", offset);
                        console.log("Original text content:", node.textContent);
                    
                        // Preserve exact whitespace
                        const text = node.textContent;
                        const leftPart = text.substring(0, offset);
                        const rightPart = text.substring(offset);
                    
                        console.log("Left part:", JSON.stringify(leftPart));
                        console.log("Right part:", JSON.stringify(rightPart));
                    
                        // Create new nodes with exact content
                        const leftNode = document.createTextNode(leftPart);
                        const rightNode = document.createTextNode(rightPart);
                    
                        // Replace original node
                        const parent = node.parentNode;
                        parent.insertBefore(leftNode, node);
                        parent.insertBefore(rightNode, node);
                        parent.removeChild(node);
                    
                        console.log("Split complete. New nodes created.");
                        return [leftNode, rightNode];
                    }

                    function getNearestBlockAncestor(node) {
                        console.log("Getting nearest block ancestor for node:", node);
                        if (!node) {
                            console.log("Node is null, returning null");
                            return null;
                        }

                        let current = node;
                        // Handle text nodes first
                        while (current && current.nodeType === Node.TEXT_NODE) {
                            current = current.parentNode;
                        }
                        // Then find the nearest block element
                        while (current && !/^(P|DIV|ARTICLE|SECTION|H[1-6])$/i.test(current.nodeName)) {
                            current = current.parentNode;
                        }
                    
                        console.log("Nearest block ancestor found:", current);
                        return current || node.parentNode;
                    }

                    function getXPath(node) {
                        console.log("Getting XPath for node:", node);
                        if (!node || !node.parentNode) {
                            console.log("Node or parent is null, returning empty path");
                            return '';
                        }
                    
                        // For text nodes, get a more precise path including position
                        if (node.nodeType === Node.TEXT_NODE) {
                            const parent = node.parentNode;
                            const children = parent.childNodes;
                            let index = 0;
                            let textIndex = 0;
                        
                            for (let i = 0; i < children.length; i++) {
                                if (children[i] === node) {
                                    textIndex = index + 1;
                                    break;
                                }
                                if (children[i].nodeType === Node.TEXT_NODE) {
                                    index++;
                                }
                            }
                        
                            if (textIndex > 0) {
                                const parentPath = getXPath(parent);
                                const xpath = parentPath + '/text()[' + textIndex + ']';
                                console.log("Generated XPath for text node:", xpath);
                                return xpath;
                            }
                        }
                    
                        // For elements with IDs
                        if (node.id) {
                            console.log("Node has ID, using ID-based XPath");
                            return '//*[@id="' + node.id + '"]';
                        }
                    
                        // Count preceding siblings with same tag name
                        let count = 1;
                        let sibling = node.previousSibling;
                    
                        while (sibling) {
                            if (sibling.nodeType === Node.ELEMENT_NODE && 
                                sibling.nodeName === node.nodeName) {
                                count++;
                            }
                            sibling = sibling.previousSibling;
                        }
                    
                        const xpath = getXPath(node.parentNode) + '/' + 
                                    node.nodeName.toLowerCase() + '[' + count + ']';
                        console.log("Generated XPath:", xpath);
                        return xpath;
                    }

                    function getTextContext(node, offset, length) {
                        console.log("Getting text context for node:", node, "offset:", offset, "length:", length);
                    
                        // Get the containing block
                        const blockContainer = getNearestBlockAncestor(node);
                        if (!blockContainer) {
                            console.log("No block container found");
                            return { before: '', text: '', after: '' };
                        }

                        const fullText = blockContainer.textContent;
                        console.log("Full text of block container:", fullText);

                        // Find position within the full text
                        let accumulatedOffset = 0;
                        let targetNode = node;
                        const walker = document.createTreeWalker(blockContainer, NodeFilter.SHOW_TEXT);
                    
                        while (walker.nextNode() && walker.currentNode !== node) {
                            accumulatedOffset += walker.currentNode.textContent.length;
                        }

                        const absoluteOffset = accumulatedOffset + offset;
                        const contextSize = 100; // Increased context size

                        const beforeText = fullText.substring(Math.max(0, absoluteOffset - contextSize), absoluteOffset);
                        const text = fullText.substring(absoluteOffset, absoluteOffset + length);
                        const afterText = fullText.substring(absoluteOffset + length, 
                                                    Math.min(fullText.length, absoluteOffset + length + contextSize));

                        console.log("Text context - before:", beforeText, "text:", text, "after:", afterText);
                        return {
                            before: beforeText,
                            text: text,
                            after: afterText
                        };
                    }

                    function cleanupTextNodes(node) {
                        console.log("Entering cleanupTextNodes for node:", node);
                        if (!node) {
                            console.log("Node is null, skipping cleanup");
                            return;
                        }

                        // Skip if node is inside a highlight span
                        if (node.parentElement && node.parentElement.hasAttribute("data-annotation-id")) {
                            console.log("Skipping node inside highlight span");
                            return;
                        }

                        if (node.nodeType === Node.TEXT_NODE) {
                            console.log("Processing text node:", node.textContent);
                            const prevNode = node.previousSibling;
                            if (prevNode && prevNode.nodeType === Node.TEXT_NODE) {
                                // Don't merge if either node is a pure linebreak node
                                if (!isLineBreakNode(node) && !isLineBreakNode(prevNode)) {
                                    const prevText = prevNode.textContent;
                                    const currText = node.textContent;
            
                                    // Check for double spaces (preserve from original)
                                    const hasTrailingSpace = prevText.endsWith(' ');
                                    const hasLeadingSpace = currText.startsWith(' ');
            
                                    let mergedText;
                                    if (hasTrailingSpace && hasLeadingSpace) {
                                        console.log("Detected double space, removing one");
                                        mergedText = prevText + currText.substring(1);
                                    } else {
                                        mergedText = prevText + currText;
                                    }

                                    // Apply normalization after merging
                                    mergedText = normalizeLineBreaks(mergedText);
            
                                    console.log("Merging text nodes:", 
                                        JSON.stringify(prevText), "+", 
                                        JSON.stringify(currText), "=", 
                                        JSON.stringify(mergedText));
                
                                    prevNode.textContent = mergedText;
                                    node.parentNode.removeChild(node);
                                } else {
                                    console.log("Skipping merge due to linebreak node");
                                }
                            }
                        } else if (node.hasChildNodes()) {
                            console.log("Processing children of node:", node);
                            [...node.childNodes].forEach(childNode => {
                                cleanupTextNodes(childNode);
                            });
                        }
                    }

                    function createHighlightSpan(text, scene, annotationId, notes = '', used = 'false', favorite = 'false', storyboard = {'order': 0}, order = null) {
                        console.log("Creating highlight span for text:", text);
                        const span = document.createElement('span');
                        // Only trim if there's actual leading/trailing whitespace
                        const needsTrim = text.startsWith(' ') || text.endsWith(' ');
                        span.textContent = needsTrim ? text.trim() : text;
                        span.style.backgroundColor = '#FFF0B3';
                        span.setAttribute('data-scene', scene);
                        span.setAttribute('data-annotation-id', annotationId);
                        span.setAttribute('data-notes', notes);
                        span.setAttribute('data-used', used);
                        span.setAttribute('data-favorite', favorite);
                        
                        // Apply used annotation border styling
                        if (used === "true") {{
                            span.style.border = "5px solid #2E7D32";
                        }}
    
                        // Always set storyboard with at least the default value
                        span.setAttribute('data-storyboard', JSON.stringify(storyboard));
    
                        if (order !== null && order !== undefined) {
                            span.setAttribute('data-order', order.toString());
                        }
                        
                        // Add double-click event listener for split/reassigned spans
                        span.addEventListener('dblclick', function(e) {
                            console.log('DEBUG: Double-click on split/reassigned annotation span:', annotationId);
                            
                            // Prevent default word selection behavior
                            e.preventDefault();
                            e.stopPropagation();
                            
                            // Check for Alt+double-click navigation
                            if (e.altKey && annotationId && scene) {
                                console.log('DEBUG: Alt+Double-click navigation to theme view:', annotationId, scene);
                                
                                // Navigate to theme view
                                if (typeof window.jsHandler !== 'undefined' && typeof window.jsHandler.requestAnnotationNavigation === 'function') {
                                    console.log('DEBUG: Navigating to theme view via Alt+double-click');
                                    window.jsHandler.requestAnnotationNavigation(annotationId, scene);
                                } else {
                                    console.error('DEBUG: Cannot navigate - jsHandler not available');
                                }
                            }
                            
                            // Always select the full annotation text
                            console.log('DEBUG: Selecting full annotation text for:', annotationId);
                            const range = document.createRange();
                            range.selectNodeContents(span);
                            
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(range);
                            
                            console.log('DEBUG: Selected text:', selection.toString());
                        });
                        
                        console.log("Created span with attributes and double-click handler:", span.outerHTML);
                        return span;
                    }

                    // Function to check if the selection contains any block-level elements or explicit line breaks
                    function containsLineBreak(range) {
                        console.log("Checking for line breaks in selection");
                        var container = range.commonAncestorContainer;
                        console.log("Common ancestor container:", container);
                    
                        var walker = document.createTreeWalker(
                            container,
                            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
                            {
                                acceptNode: function(node) {
                                    if (node.nodeType === Node.ELEMENT_NODE) {
                                        var display = window.getComputedStyle(node).display;
                                        if (display === 'block' || display === 'flex' || display === 'grid' || display === 'inline-block') {
                                            console.log("Found block-level element:", node);
                                            return NodeFilter.FILTER_ACCEPT;
                                        }
                                        if (node.tagName === 'BR') {
                                            console.log("Found <br> element:", node);
                                            return NodeFilter.FILTER_ACCEPT;
                                        }
                                    } else if (node.nodeType === Node.TEXT_NODE) {
                                        if (node.textContent.includes('\\n')) {
                                            console.log("Found newline character in text node:", node);
                                            return NodeFilter.FILTER_SKIP;
                                        }
                                    }
                                    return NodeFilter.FILTER_SKIP;
                                }
                            },
                            false
                        );

                        var blockingNodes = [];
                        var node;
                        while(node = walker.nextNode()) {
                            if (range.intersectsNode(node)) {
                                console.log("Node intersects selection:", node);
                                var nodeInfo = {
                                    tagName: node.tagName || '#text',
                                    textContent: node.textContent.trim(),
                                    id: node.id || null,
                                    className: node.className || null
                                };
                                blockingNodes.push(nodeInfo);
                            }
                        }
                    
                        console.log("Line break check result:", blockingNodes.length > 0 ? blockingNodes : false);
                        return blockingNodes.length > 0 ? blockingNodes : false;
                    }

                    // Check for explicit line breaks in the selection
                    var lineBreakNodes = containsLineBreak(range);
                    if (lineBreakNodes) {
                        console.log("Selection across paragraph (block-element) detected. Blocking Assignment.");
                        return { 
                            blocked: true, 
                            reason: "line-break",
                            debugInfo: {
                                type: "line-break",
                                nodes: lineBreakNodes
                            }
                        };
                    }

                    // Enhanced selection info with context
                    var contextInfo = getTextContext(
                        range.startContainer,
                        range.startOffset,
                        range.toString().length
                    );

                    var selectionInfo = {
                        text: range.toString(),
                        startContainerPath: getXPath(range.startContainer),
                        startOffset: range.startOffset,
                        endContainerPath: getXPath(range.endContainer),
                        endOffset: range.endOffset,
                        context: contextInfo,
                        location: {
                            containerPath: getXPath(getNearestBlockAncestor(range.startContainer)),
                            offset: range.startOffset,
                            length: range.toString().length,
                            blockContext: true
                        }
                    };

                    console.log("Selection Info:", selectionInfo);

                    var spans = document.querySelectorAll('span[data-annotation-id]');
                    console.log("Found spans:", spans);
                    var intersectingSpans = [];
                    spans.forEach(function(span) {
                        if (range.intersectsNode(span)) {
                            console.log("Span intersects selection:", span);
                            intersectingSpans.push(span);
                        }
                    });

                    console.log("Intersecting spans:", intersectingSpans);

                    var results = {
                        removedSpans: [],
                        updatedSpans: [],
                        scrollPos: scrollPos,
                        selectionInfo: selectionInfo,
                        debugInfo: null
                    };

                    if (intersectingSpans.length === 0) {
                        console.log("No intersecting spans found.");
                        return results;
                    }

                    var annotationIds = new Set();
                    intersectingSpans.forEach(function(span) {
                        var annId = span.getAttribute('data-annotation-id');
                        if (annId) {
                            console.log("Adding annotation ID to set:", annId);
                            annotationIds.add(annId);
                        }
                    });

                    console.log("Unique annotation IDs found:", annotationIds);

                    if (annotationIds.size > 1) {
                        console.log("Multiple annotation IDs found. Blocking assignment.");
                        return { 
                            blocked: true, 
                            reason: "multiple-annotations",
                            debugInfo: {
                                type: "multiple-annotations",
                                annotationIds: Array.from(annotationIds)
                            }
                        };
                    }

                    function generateUUID() {
                        console.log("Generating UUID");
                        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                            var r = Math.random() * 16 | 0,
                                v = c == 'x' ? r : (r & 0x3 | 0x8);
                            return v.toString(16);
                        });
                    }

                    var completelyContains = intersectingSpans.every(function(span) {
                        console.log("Checking if selection completely contains span:", span);
                        const contains = range.toString().includes(span.textContent);
                        console.log("Completely contains result:", contains);
                        return contains;
                    });

                    console.log("Selection completely contains all intersecting spans:", completelyContains);

                    if (completelyContains) {
                        console.log("Handling complete removal of spans");
                        intersectingSpans.forEach(function(span) {
                            console.log("Processing span for complete removal:", span);
                            var annotationId = span.getAttribute('data-annotation-id');
                            // When collecting span info for removal:
                            var spanInfo = {
                                annotationId: annotationId,
                                scene: span.getAttribute('data-scene'),
                                text: span.textContent,
                                notes: span.getAttribute('data-notes') || '',
                                notes_html: span.getAttribute('data-notes-html') || '',
                                style: span.getAttribute('style') || '',
                                used: span.getAttribute('data-used') || 'false',
                                favorite: span.getAttribute('data-favorite') || 'false',
                                storyboard: JSON.parse(span.getAttribute('data-storyboard') || '{"order": 0}'), // FIXED: using : instead of =
                                order: span.getAttribute('data-order') ? parseInt(span.getAttribute('data-order')) : null,
                                completeRemoval: true,
                                context: getTextContext(span.firstChild, 0, span.textContent.length)
                            };
    
                            console.log("Span info for removal:", spanInfo);

                            // Create a single text node with the exact content
                            var textNode = document.createTextNode(span.textContent);
                            console.log("Created replacement text node with content:", textNode.textContent);
                        
                            span.parentNode.replaceChild(textNode, span);
                            console.log("Replaced span with text node");
                        
                            results.removedSpans.push(spanInfo);
                            console.log("Added span info to removedSpans");
                        });
                    } else {
                        console.log("Handling partial removal of spans");
                        intersectingSpans.forEach(function(span) {
                            console.log("Processing span for partial removal:", span);
                            var annotationId = span.getAttribute('data-annotation-id');
                            // When collecting span info for removal:
                            var spanInfo = {
                                annotationId: annotationId,
                                scene: span.getAttribute('data-scene'),
                                text: span.textContent,
                                notes: span.getAttribute('data-notes') || '',
                                notes_html: span.getAttribute('data-notes-html') || '',
                                style: span.getAttribute('style') || '',
                                used: span.getAttribute('data-used') || 'false',
                                favorite: span.getAttribute('data-favorite') || 'false',
                                storyboard: JSON.parse(span.getAttribute('data-storyboard') || '{"order": 0}'), // FIXED: using : instead of =
                                order: span.getAttribute('data-order') ? parseInt(span.getAttribute('data-order')) : null,
                                completeRemoval: true,
                                context: getTextContext(span.firstChild, 0, span.textContent.length)
                            };

                            console.log("Span info for partial removal:", spanInfo);

                            var parent = span.parentNode;
                            var spanText = span.textContent;
                            var startOffsetInSpan = 0;
                            var endOffsetInSpan = spanText.length;

                            // Calculate precise offsets
                            if (range.startContainer === span.firstChild || span.contains(range.startContainer)) {
                                startOffsetInSpan = range.startOffset;
                            }
                            if (range.endContainer === span.firstChild || span.contains(range.endContainer)) {
                                endOffsetInSpan = range.endOffset;
                            }

                            // Ensure offsets are within bounds
                            startOffsetInSpan = Math.max(0, Math.min(spanText.length, startOffsetInSpan));
                            endOffsetInSpan = Math.max(0, Math.min(spanText.length, endOffsetInSpan));

                            console.log("Start offset in span:", startOffsetInSpan, "End offset in span:", endOffsetInSpan);

                            var leftText = spanText.substring(0, startOffsetInSpan);
                            var middleText = spanText.substring(startOffsetInSpan, endOffsetInSpan);
                            var rightText = spanText.substring(endOffsetInSpan);

                            console.log("Split text parts - Left:", JSON.stringify(leftText), 
                                      "Middle:", JSON.stringify(middleText), 
                                      "Right:", JSON.stringify(rightText));

                            // Create left span if needed
                            if (leftText) {
                                console.log("Creating left span");
                                // With:
                                var leftSpan = span.cloneNode(false);
                                leftSpan.textContent = leftText;
                                leftSpan.setAttribute('data-notes', span.getAttribute('data-notes') || '');
                                leftSpan.setAttribute('data-used', span.getAttribute('data-used') || 'false');
                                leftSpan.setAttribute('data-favorite', span.getAttribute('data-favorite') || 'false');
                                // Carry over secondary scenes
                                try {
                                    var secAttr = span.getAttribute('data-secondary-scenes');
                                    leftSpan.setAttribute('data-secondary-scenes', secAttr ? secAttr : '[]');
                                } catch (_e) { console.log('WARN: could not carry secondary scenes to left span', _e); }
                                parent.insertBefore(leftSpan, span);
                                // Attach dblclick + tooltip listeners to the new left span
                                try {
                                    if (typeof selectAnnotationSpan === 'function') {
                                        leftSpan.addEventListener('dblclick', selectAnnotationSpan);
                                    }
                                    if (typeof showTooltipDirect === 'function') {
                                        leftSpan.addEventListener('mouseenter', showTooltipDirect);
                                    }
                                    if (typeof hideTooltipDirect === 'function') {
                                        leftSpan.addEventListener('mouseleave', hideTooltipDirect);
                                    }
                                    leftSpan.setAttribute('data-tooltip-listeners-attached', 'true');
                                    console.log("Attached event listeners to left span:", leftSpan.getAttribute('data-annotation-id'));
                                } catch (e) {
                                    console.log("WARN: Could not attach listeners to left span:", e);
                                }
                                console.log("Inserted left span:", leftSpan);
                                results.updatedSpans.push({
                                    text: leftText,
                                    annotationId: annotationId,
                                    scene: spanInfo.scene,
                                    isOriginal: true,
                                    context: getTextContext(leftSpan.firstChild, 0, leftText.length)
                                });
                            }

                            // Create middle text node
                            if (middleText) {
                                console.log("Creating middle text node");
                                var textNode = document.createTextNode(normalizeLineBreaks(middleText));  // Add normalizeLineBreaks here
                                parent.insertBefore(textNode, span);
                                console.log("Inserted middle text node:", textNode);
                            }

                            // Create right span if needed
                            if (rightText) {
                                console.log("Creating right span");
                                // With:
                                var rightSpan = span.cloneNode(false);
                                rightSpan.textContent = rightText;
                                rightSpan.setAttribute('data-notes', span.getAttribute('data-notes') || '');
                                rightSpan.setAttribute('data-used', span.getAttribute('data-used') || 'false');
                                rightSpan.setAttribute('data-favorite', span.getAttribute('data-favorite') || 'false');
                                // Carry over secondary scenes
                                try {
                                    var secAttrR = span.getAttribute('data-secondary-scenes');
                                    rightSpan.setAttribute('data-secondary-scenes', secAttrR ? secAttrR : '[]');
                                } catch (_e) { console.log('WARN: could not carry secondary scenes to right span', _e); }
                                var newId = generateUUID();
                                rightSpan.setAttribute('data-annotation-id', newId);
                                parent.insertBefore(rightSpan, span);
                                // Attach dblclick + tooltip listeners to the new right span
                                try {
                                    if (typeof selectAnnotationSpan === 'function') {
                                        rightSpan.addEventListener('dblclick', selectAnnotationSpan);
                                    }
                                    if (typeof showTooltipDirect === 'function') {
                                        rightSpan.addEventListener('mouseenter', showTooltipDirect);
                                    }
                                    if (typeof hideTooltipDirect === 'function') {
                                        rightSpan.addEventListener('mouseleave', hideTooltipDirect);
                                    }
                                    rightSpan.setAttribute('data-tooltip-listeners-attached', 'true');
                                    console.log("Attached event listeners to right span:", rightSpan.getAttribute('data-annotation-id'));
                                } catch (e) {
                                    console.log("WARN: Could not attach listeners to right span:", e);
                                }
                                console.log("Inserted right span:", rightSpan);
                                results.updatedSpans.push({
                                    text: rightText,
                                    annotationId: newId,
                                    scene: spanInfo.scene,
                                    isNew: true,
                                    context: getTextContext(rightSpan.firstChild, 0, rightText.length)
                                });
                            }

                            console.log("Removing original span");
                            parent.removeChild(span);
                            results.removedSpans.push(spanInfo);
                            console.log("Added span info to removedSpans");
                        });
                    }

                    console.log("Calling cleanupTextNodes with common ancestor container:", range.commonAncestorContainer);
                    cleanupTextNodes(range.commonAncestorContainer);
                    console.log("Finished cleanupTextNodes");
                
                    selection.removeAllRanges();
                    console.log("Returning results:", results);
                    return results;

                } catch (error) {
                    console.error("Error in assign_to_scene:", error);
                    return {
                        removedSpans: [],
                        updatedSpans: [],
                        scrollPos: window.pageYOffset,
                        selectionInfo: null,
                        debugInfo: {
                            type: "error",
                            message: error.toString()
                        }
                    };
                }
            })();
        '''

        def handle_removal_check(results):
            """
            Handles the results of the initial removal check.
            If removal is required, prompt the user before proceeding, respecting their choice regarding storyboard data.
            """
            print(f"Removal check results: {json.dumps(results, indent=2)}")

            if not results.get('requiresRemoval'):
                print("🚨🚨🚨 PATH 1: NO REMOVAL REQUIRED - CALLING CURSOR METHOD!!! 🚨🚨🚨")
                print("No removal required. Proceeding with annotation creation.")
                
                # Show processing cursor for immediate feedback
                print("🔍 DEBUG: About to call show_processing_cursor()")
                self.show_processing_cursor()
                print("🔍 DEBUG: show_processing_cursor() call completed")
                
                self.page().runJavaScript(removal_js, lambda r: handle_removal_and_reassign(r, scene))
                return

            annotation_ids = results.get('annotationIds', [])
            if len(annotation_ids) == 1:
                annotation_id = annotation_ids[0]
                old_anno = next((a for a in self.annotations if a.get('id') == annotation_id), None)

                # Check if there's any metadata worth transferring
                has_metadata = False
                if old_anno:
                    if (old_anno.get('notes') or 
                        old_anno.get('notes_html') or
                        old_anno.get('favorite') or 
                        old_anno.get('used') or
                        (old_anno.get('storyboard') and any(old_anno['storyboard'].get(k) for k in ['order', 'text', 'strikethrough_segments']))):
                        has_metadata = True

                    # Always preserve secondary_scenes regardless of whether other metadata exists
                    try:
                        sec = old_anno.get('secondary_scenes', [])
                        if isinstance(sec, list) and sec:
                            existing_pm = getattr(self, 'preserved_metadata_for_reassign', None) or {}
                            existing_list = existing_pm.get('secondary_scenes', []) or []
                            merged = []
                            seen = set()
                            for s in (existing_list + sec):
                                if s not in seen:
                                    seen.add(s)
                                    merged.append(s)
                            existing_pm['secondary_scenes'] = merged
                            self.preserved_metadata_for_reassign = existing_pm
                    except Exception as _e:
                        print(f"DEBUG: pre-preserve secondary_scenes failed: {_e}")

                # Skip the confirmation dialog if this is an auto-fix attempt
                if is_auto_fix_attempt:
                    print("Auto-fix attempt detected, skipping confirmation dialog")
                    # Still preserve metadata if needed
                    if has_metadata:
                        preserved_metadata = {
                            'notes': old_anno.get('notes', ''),
                            'notes_html': old_anno.get('notes_html', ''),
                            'used': old_anno.get('used', False),
                            'favorite': old_anno.get('favorite', False),
                            'speech_title': old_anno.get('speech_title', ''),
                            'tags': old_anno.get('tags', []),
                            'secondary_scenes': old_anno.get('secondary_scenes', [])
                        }
    
                        # Preserve storyboard if available
                        if isinstance(old_anno.get('storyboard'), dict):
                            preserved_metadata['storyboard'] = old_anno['storyboard']
    
                        # Preserve order if available
                        if old_anno.get('order') is not None:
                            preserved_metadata['order'] = old_anno['order']
    
                        # Ensure secondary_scenes is present and list
                        try:
                            if 'secondary_scenes' not in preserved_metadata:
                                preserved_metadata['secondary_scenes'] = old_anno.get('secondary_scenes', [])
                            elif isinstance(old_anno.get('secondary_scenes'), list):
                                # Union without duplicates
                                exist = preserved_metadata.get('secondary_scenes') or []
                                union = []
                                seen = set()
                                for s in (exist + old_anno.get('secondary_scenes', [])):
                                    if s not in seen:
                                        seen.add(s)
                                        union.append(s)
                                preserved_metadata['secondary_scenes'] = union
                        except Exception as _e:
                            print(f"DEBUG: merging secondary_scenes (auto-fix) failed: {_e}")
                        # Add/merge secondary_scenes for reassignment preservation
                        try:
                            existing = preserved_metadata.get('secondary_scenes', []) if preserved_metadata else []
                            if old_anno and isinstance(old_anno.get('secondary_scenes'), list):
                                merged = []
                                seen = set()
                                for s in (existing + old_anno.get('secondary_scenes', [])):
                                    if s not in seen:
                                        seen.add(s)
                                        merged.append(s)
                                preserved_metadata['secondary_scenes'] = merged
                        except Exception as _e:
                            print(f"DEBUG: merging secondary_scenes (dialog) failed: {_e}")
                        self.preserved_metadata_for_reassign = preserved_metadata

                    # Proceed directly with the reassignment
                    
                    # Show processing cursor for immediate feedback
                    self.show_processing_cursor()
                    
                    self.page().runJavaScript(removal_js, lambda r: handle_removal_and_reassign(r, scene))
                    return

                if has_metadata:
                    # Show combined dialog for removal confirmation and metadata
                    dialog = QDialog(self)
                    dialog.setWindowTitle("Confirm Reassignment")
                    layout = QVBoxLayout()

                    # Add warning message
                    warning_label = QLabel("The original annotation will be divided or changed. Preserve metadata?")
                    warning_label.setWordWrap(True)
                    layout.addWidget(warning_label)

                    # Add metadata section if we have metadata
                    checkboxes = {}
                    if old_anno:
                        metadata_items = []
                        if old_anno.get('notes') or old_anno.get('notes_html'):
                            metadata_items.append('notes')
                        if old_anno.get('favorite'):
                            metadata_items.append('favorite')
                        if old_anno.get('used'):
                            metadata_items.append('used')
                        if old_anno.get('storyboard') and any(old_anno['storyboard'].get(k) for k in ['order', 'text', 'strikethrough_segments']):
                            metadata_items.append('storyboard')
                        if old_anno.get('order') is not None:
                            metadata_items.append('order')

                        # Notes checkbox with truncated text preview
                        if 'notes' in metadata_items:
                            notes_layout = QHBoxLayout()
                            notes_cb = XMarkCheckBox("Notes")
                            notes_cb.setChecked(True)

                            # Add truncated notes text if available
                            notes_text = old_anno.get('notes', '')
                            if notes_text:
                                truncated_notes = self.truncate_storyboard_text(notes_text, 30)
                                notes_cb.setText(f"Notes: [{truncated_notes}]")
                                # Add tooltip with full notes text
                                notes_cb.setToolTip(f"Notes: {notes_text}")

                            checkboxes['notes'] = notes_cb
                            notes_layout.addWidget(notes_cb)
                            layout.addLayout(notes_layout)

                        # Used checkbox
                        if 'used' in metadata_items:
                            used_layout = QHBoxLayout()
                            used_cb = XMarkCheckBox("Used")
                            used_cb.setChecked(True)
                            checkboxes['used'] = used_cb
                            used_layout.addWidget(used_cb)
                            layout.addLayout(used_layout)

                        # Favorite checkbox
                        if 'favorite' in metadata_items:
                            favorite_layout = QHBoxLayout()
                            favorite_cb = XMarkCheckBox("Favorite")
                            favorite_cb.setChecked(True)
                            checkboxes['favorite'] = favorite_cb
                            favorite_layout.addWidget(favorite_cb)
                            layout.addLayout(favorite_layout)

                        # Storyboard / order
                        if 'storyboard' in metadata_items or 'order' in metadata_items:
                            storyboard_container = QVBoxLayout()
                            storyboard_layout = QHBoxLayout()

                            # Get the order number to display
                            order_num = None
                            if old_anno.get('storyboard', {}).get('order') is not None:
                                order_num = old_anno['storyboard']['order']
                            elif old_anno.get('order') is not None:
                                order_num = old_anno['order']

                            # Create label with order number if available
                            if order_num is not None:
                                # Calculate user-facing order number
                                user_facing_order = self.calculate_user_facing_order_number(order_num)
                                storyboard_cb = XMarkCheckBox(f"Script Editor Data (#{user_facing_order})")
                            else:
                                storyboard_cb = XMarkCheckBox("Script Editor Data")

                            storyboard_cb.setChecked(True)
                            checkboxes['storyboard'] = storyboard_cb

                            # Add detailed view button next to "Script Editor Data" checkbox
                            detailed_view_btn = QPushButton("Detailed View")
                            detailed_view_btn.setFixedWidth(100)
                            detailed_view_btn.setToolTip("Show detailed preview of text splitting options")
                            detailed_view_btn.setStyleSheet("""
                                QPushButton {
                                    background-color: #f0f0f0;
                                    border: 1px solid #ccc;
                                    border-radius: 4px;
                                    font-size: 11px;
                                    padding: 4px;
                                }
                                QPushButton:hover {
                                    background-color: #e0e0e0;
                                }
                            """)

                            storyboard_layout.addWidget(storyboard_cb)
                            storyboard_layout.addWidget(detailed_view_btn)
                            storyboard_container.addLayout(storyboard_layout)

                            # Sub-options layout with indentation
                            sub_options_layout = QVBoxLayout()
                            sub_options_layout.setContentsMargins(20, 0, 0, 0)  # Left margin for indentation

                            # Text preservation checkbox
                            if old_anno.get('storyboard', {}).get('text'):
                                # Create a horizontal layout for checkbox
                                text_layout = QHBoxLayout()

                                text_cb = XMarkCheckBox("Preserve Original Text")
                                text_cb.setChecked(False)
                                truncated_text = self.truncate_storyboard_text(old_anno['storyboard']['text'])
                                text_cb.setText(f"Preserve Original Text: [{truncated_text}]")
                                checkboxes['storyboard_text'] = text_cb
                                text_layout.addWidget(text_cb)
                                sub_options_layout.addLayout(text_layout)

                                storyboard_cb.toggled.connect(text_cb.setEnabled)

                            def show_full_text():
                                # Get the original storyboard text and metadata
                                storyboard_text = old_anno['storyboard']['text']
                                original_order = old_anno.get('storyboard', {}).get('order')
                                if original_order is None:
                                    # Also check top-level order as fallback
                                    original_order = old_anno.get('order')
                                strikethrough_segments = old_anno.get('storyboard', {}).get('strikethrough_segments', {})
                                positional_strikethrough = old_anno.get('storyboard', {}).get('positional_strikethrough', {})

                                # Access selection info from the removal_check_results
                                selection_info = results.get('selectionInfo', {})
                                selected_text = selection_info.get('text', '')

                                # For split annotations, we'll use the full original text.
                                original_text = old_anno.get('text', '')

                                text_dialog = QDialog(dialog)
                                text_dialog.setWindowTitle("Script Editor Conflict Resolution")
                                text_dialog.setMinimumWidth(800)
                                text_dialog.setMinimumHeight(500)

                                # Main layout
                                dialog_layout = QVBoxLayout(text_dialog)
                                if original_order is None:
                                    info_label = QLabel("This annotation is not in the Script Editor but has associated text data.")
                                else:
                                    info_label = QLabel("This annotation is in the Script Editor. How should it be handled?")
                                info_label.setStyleSheet("font-weight: bold; font-size: 14px; color: #2C4952;")
                                dialog_layout.addWidget(info_label)

                                # Add settings panel at the top
                                settings_panel = QWidget()
                                settings_layout = QHBoxLayout(settings_panel)
                                settings_layout.setContentsMargins(0, 5, 0, 10)

                                # Create toggles for formatting options
                                preserve_header_cb = XMarkCheckBox("Preserve Header")
                                preserve_header_cb.setChecked(True)

                                # Check if there's a header and disable the checkbox if none
                                has_header = False
                                header_html = None
                                patterns = [
                                    r'(<div><b\s+style=[\'"].*?background-color:.*?[\'"]>(.*?)</b></div>)',
                                    r'(<div><b>(.*?)</b></div>)',
                                    r'(<b\s*.*?>(.*?)</b>)'
                                ]

                                for pattern in patterns:
                                    match = re.search(pattern, storyboard_text, re.DOTALL | re.IGNORECASE)
                                    if match:
                                        has_header = True
                                        header_html = match.group(1)
                                        break

                                preserve_header_cb.setEnabled(has_header)
                                preserve_header_cb.setChecked(has_header)
                                if not has_header:
                                    preserve_header_cb.setText("Preserve Header (None Found)")
                                    preserve_header_cb.setStyleSheet("color: #888;")

                                # Create strikethrough toggle
                                preserve_strike_cb = XMarkCheckBox("Preserve Strikethroughs") 
                                preserve_strike_cb.setChecked(True)

                                # Check if there are any strikethrough segments
                                has_strikethroughs = bool(strikethrough_segments)
                                preserve_strike_cb.setEnabled(has_strikethroughs)
                                preserve_strike_cb.setChecked(has_strikethroughs)
                                if not has_strikethroughs:
                                    preserve_strike_cb.setText("Preserve Strikethroughs (None Found)")
                                    preserve_strike_cb.setStyleSheet("color: #888;")

                                # Add original order indicator with user-facing number
                                if original_order is None:
                                    order_label = QLabel("Script Editor Text")
                                else:
                                    user_facing_order = self.calculate_user_facing_order_number(original_order)
                                    order_label = QLabel(f"Script Editor Entry #{user_facing_order}")
                                order_label.setStyleSheet("font-weight: bold; color: #555; margin-right: 15px;")

                                settings_layout.addWidget(order_label)
                                settings_layout.addWidget(preserve_header_cb)
                                settings_layout.addWidget(preserve_strike_cb)
                                settings_layout.addStretch()

                                dialog_layout.addWidget(settings_panel)

                                # Create the splitter for side-by-side comparison
                                splitter = QSplitter(Qt.Orientation.Horizontal)

                                # LEFT SIDE (Preserve current text)
                                preserve_widget = QWidget()
                                preserve_layout = QVBoxLayout(preserve_widget)

                                preserve_title = QLabel("✅ Preserve Text (Checked)")
                                preserve_title.setStyleSheet("font-weight: bold; color: #1976D2; font-size: 12px;")
                                preserve_layout.addWidget(preserve_title)

                                checked_explanation = QLabel("The original Script Editor entry remains intact.")
                                checked_explanation.setWordWrap(True)
                                checked_explanation.setStyleSheet("margin-bottom: 10px;")
                                preserve_layout.addWidget(checked_explanation)

                                # Use user-facing order number
                                if original_order is None:
                                    preserve_label = QLabel("Script Editor Text (single, unchanged):")
                                else:
                                    user_facing_order = self.calculate_user_facing_order_number(original_order)
                                    preserve_label = QLabel(f"Script Editor Entry #{user_facing_order} (single, unchanged):")
                                preserve_label.setStyleSheet("font-weight: bold;")
                                preserve_layout.addWidget(preserve_label)

                                # Create text display with strikethrough formatting applied
                                preserve_text = QTextEdit()
                                preserve_text.setReadOnly(True)

                                # Helper function to apply strikethrough and header formatting with hybrid approach.
                                def apply_formatting(text, apply_strikethrough=True, apply_header=True, original_range=None):
                                    """
                                    Applies header and strikethrough formatting to the input text.

                                    Handles context-specific strikethroughs using base words with specific hierarchical context matching.
                                    Handles non-context strikethroughs using exact segment keys.
                                    Context-specific handling does not fall back to non-context methods.
                                    """
                                    content_text = text if text is not None else ""
                                    processed_text_for_strikes = content_text

                                    # --- Header Handling (No changes) ---
                                    current_header_html = None
                                    if header_html:
                                        try:
                                            temp_escaped_header = re.escape(header_html)
                                            match = re.match(rf'\s*{temp_escaped_header}\s*', content_text, re.DOTALL | re.IGNORECASE)
                                            if match:
                                                current_header_html = match.group(0)
                                                processed_text_for_strikes = content_text[match.end():]
                                            else:
                                                current_header_html = None
                                        except Exception as re_err:
                                             print(f"Warning: Regex error during header matching: {re_err}")
                                             current_header_html = None

                                    # --- Strikethrough Application ---
                                    strike_segments_to_apply = []
                                    if apply_strikethrough and strikethrough_segments:
                                        context_segments_to_process = {}
                                        non_context_segments_to_process = {}
                                        processed_keys_context = set()

                                        # Categorize segments (No changes)
                                        for segment_key, is_struck in strikethrough_segments.items():
                                            if not is_struck or not segment_key: continue
                                            is_context_specific_segment = False
                                            data = None
                                            if positional_strikethrough and segment_key in positional_strikethrough:
                                                data = positional_strikethrough[segment_key]
                                                if isinstance(data, dict):
                                                    if data.get("is_context_specific") or \
                                                       data.get("context_before", "").strip() or \
                                                       data.get("context_after", "").strip():
                                                        is_context_specific_segment = True
                                                else: data = None
                                            if is_context_specific_segment and data: context_segments_to_process[segment_key] = data
                                            else:
                                                if segment_key not in context_segments_to_process: non_context_segments_to_process[segment_key] = True

                                        # --- 1. Process CONTEXT-SPECIFIC segments ---
                                        for segment_key, data in context_segments_to_process.items():
                                            processed_keys_context.add(segment_key)

                                            # <<< Base Word Logic (No changes) >>>
                                            base_word = data.get('base_word', segment_key)
                                            if not base_word or base_word == segment_key:
                                                match_key = re.match(r'^(.+)_(\d+)$', segment_key)
                                                if match_key: base_word = match_key.group(1)
                                            if not base_word: continue

                                            # --- START: find_with_context definition REPLACED with your provided code ---
                                            def find_with_context(base_word, text, context_data): # Parameters match the call signature
                                                context_before = context_data.get("context_before", "")
                                                context_after = context_data.get("context_after", "")

                                                # Strip any HTML tags from stored contexts if they somehow made it in
                                                context_before = re.sub(r'<[^>]+>', '', context_before)
                                                context_after = re.sub(r'<[^>]+>', '', context_after)

                                                print(f"  Looking for segment '{base_word}' with cleaned contexts:")
                                                print(f"    Context before: '{context_before}'")
                                                print(f"    Context after: '{context_after}'")

                                                # Try with 10-character context first
                                                req_prefix_10 = context_before[-10:] if len(context_before) >= 10 else context_before
                                                req_suffix_10 = context_after[:10] if len(context_after) >= 10 else context_after

                                                # Fall back to 6-character context
                                                req_prefix_6 = context_before[-6:] if len(context_before) >= 6 else context_before
                                                req_suffix_6 = context_after[:6] if len(context_after) >= 6 else context_after

                                                print(f"  Looking for segment '{base_word}' with these context strategies:")
                                                print(f"    Strategy 1: 10-char context before='{req_prefix_10}', after='{req_suffix_10}'")
                                                print(f"    Strategy 2: 6-char context before='{req_prefix_6}', after='{req_suffix_6}'")
                                                print(f"    Strategy 3: Only 10-char context before='{req_prefix_10}'")
                                                print(f"    Strategy 4: Only 10-char context after='{req_suffix_10}'")

                                                # Helper: search with specific prefix and suffix
                                                def find_with_specific_context(req_prefix, req_suffix):
                                                    pos = 0
                                                    while True:
                                                        try:
                                                             pos = text.find(base_word, pos) # Use 'text' (passed into find_with_context)
                                                        except Exception: return None # Safety
                                                        if pos == -1:
                                                            break # Exit loop if not found

                                                        # Check how much context is available in the 'text' being searched
                                                        has_full_prefix = pos >= len(req_prefix) if req_prefix else True
                                                        has_full_suffix = (pos + len(base_word) + len(req_suffix) <= len(text)) if req_suffix else True

                                                        # If we have full context available for both, require EXACT matches
                                                        if req_prefix and req_suffix and has_full_prefix and has_full_suffix:
                                                            actual_prefix = text[pos - len(req_prefix):pos]
                                                            actual_suffix = text[pos + len(base_word):pos + len(base_word) + len(req_suffix)]

                                                            if actual_prefix == req_prefix and actual_suffix == req_suffix:
                                                                return pos, pos + len(base_word)
                                                            else:
                                                                # Full context available but doesn't match - reject and move on
                                                                pos += 1
                                                                continue # Continue while loop

                                                        # If we don't have full context available, or one side is empty,
                                                        # then we can try more flexible matching:
                                                        prefix_ok = True
                                                        suffix_ok = True

                                                        # For prefix checking:
                                                        if req_prefix:
                                                            if has_full_prefix:
                                                                # We have enough context - require EXACT match
                                                                actual_prefix = text[pos - len(req_prefix):pos]
                                                                prefix_ok = (actual_prefix == req_prefix)
                                                            else:
                                                                # Not enough context - fall back to flexible matching
                                                                start_prefix = max(0, pos - len(req_prefix))
                                                                actual_prefix = text[start_prefix:pos]
                                                                prefix_ok = req_prefix.endswith(actual_prefix)
                                                        else:
                                                            # If req_prefix is empty, only consider this valid if at the start of text
                                                            # or preceded by sentence-ending punctuation or whitespace
                                                            if pos > 0 and text[pos-1].isalnum() and base_word[0].isalnum(): # Added check for base_word start
                                                                prefix_ok = False

                                                        # For suffix checking:
                                                        if req_suffix:
                                                            if has_full_suffix:
                                                                # We have enough context - require EXACT match
                                                                actual_suffix = text[pos + len(base_word):pos + len(base_word) + len(req_suffix)]
                                                                suffix_ok = (actual_suffix == req_suffix)
                                                            else:
                                                                # Not enough context - fall back to flexible matching
                                                                end_suffix = min(len(text), pos + len(base_word) + len(req_suffix))
                                                                actual_suffix = text[pos + len(base_word):end_suffix]
                                                                suffix_ok = req_suffix.startswith(actual_suffix)
                                                        else:
                                                            # If req_suffix is empty, only consider this valid if at the end of text
                                                            # or followed by sentence punctuation or whitespace
                                                            end_pos = pos + len(base_word)
                                                            if end_pos < len(text) and text[end_pos].isalnum() and base_word[-1].isalnum(): # Added check for base_word end
                                                                suffix_ok = False

                                                        if prefix_ok and suffix_ok:
                                                            return pos, pos + len(base_word)
                                                        pos += 1 # Move search position if flexible match failed
                                                    return None # While loop finished, no match found
                                                # --- End of find_with_specific_context definition ---


                                                # Check if we have sufficient context on both sides
                                                has_sufficient_10_prefix = len(context_before) >= 10
                                                has_sufficient_10_suffix = len(context_after) >= 10
                                                has_sufficient_6_prefix = len(context_before) >= 6
                                                has_sufficient_6_suffix = len(context_after) >= 6

                                                # STRICT HIERARCHICAL FALLBACK FOR ALL SEGMENTS:

                                                # 1. If we have full 10-char context on both sides, require exact match or HARD FAIL
                                                if has_sufficient_10_prefix and has_sufficient_10_suffix:
                                                    match = find_with_specific_context(req_prefix_10, req_suffix_10)
                                                    if match:
                                                        print(f"    Found match using Strategy 1 (10-char both contexts)")
                                                        return match
                                                    else:
                                                        print(f"    Segment failed with 10-char context - strict rejection")
                                                        return None  # HARD FAIL - no fallbacks when full 10-char context is available

                                                # 2. If we don't have 10-char but have 6-char on both sides, require exact match or HARD FAIL
                                                elif has_sufficient_6_prefix and has_sufficient_6_suffix:
                                                    match = find_with_specific_context(req_prefix_6, req_suffix_6)
                                                    if match:
                                                        print(f"    Found match using Strategy 2 (6-char both contexts)")
                                                        return match
                                                    else:
                                                        print(f"    Segment failed with 6-char context - strict rejection")
                                                        return None  # HARD FAIL - no fallbacks when full 6-char context is available

                                                # 3. Only if we don't have sufficient context on both sides, try one-sided context matches

                                                # Try with just 10-character context_before (only if it's not empty)
                                                if req_prefix_10:
                                                    match = find_with_specific_context(req_prefix_10, "")
                                                    if match:
                                                        print(f"    Found match using Strategy 3 (only 10-char context before)")
                                                        return match

                                                # Try with just 10-character context_after (only if it's not empty)
                                                if req_suffix_10:
                                                    match = find_with_specific_context("", req_suffix_10)
                                                    if match:
                                                        print(f"    Found match using Strategy 4 (only 10-char context after)")
                                                        return match

                                                # print(f"    No match found with any context strategy")
                                                # No match found
                                                return None
                                            # --- END: find_with_context definition REPLACED ---


                                            # Apply context matching using the determined base_word and the NEW find_with_context
                                            # The call signature remains the same: find_with_context(text_to_find, text_to_search_in, context_data)
                                            match_coords = find_with_context(base_word, processed_text_for_strikes, data)
                                            if match_coords:
                                                start, end = match_coords
                                                is_overlapping = False
                                                for applied_start, applied_end in strike_segments_to_apply:
                                                     if max(start, applied_start) < min(end, applied_end): is_overlapping = True; break
                                                if not is_overlapping: strike_segments_to_apply.append((start, end))
                                            # If match_coords is None (because find_with_context returned None), do nothing.

                                        # --- 2. Process NON-CONTEXT segments (No changes from previous correct version) ---
                                        non_context_keys_final = [k for k in non_context_segments_to_process if k not in processed_keys_context]
                                        # Approach A: Positional mapping (uses exact segment_key)
                                        if non_context_keys_final and original_range is not None and original_text:
                                            try:
                                                ann_start, ann_end = original_range
                                                if not (isinstance(ann_start, int) and isinstance(ann_end, int) and ann_start <= ann_end): raise ValueError("Invalid range")
                                                for segment_key in non_context_keys_final:
                                                    if not segment_key: continue
                                                    search_pos = 0
                                                    while True:
                                                        seg_start_orig = original_text.find(segment_key, search_pos)
                                                        if seg_start_orig == -1: break
                                                        seg_end_orig = seg_start_orig + len(segment_key)
                                                        if seg_end_orig > ann_start and seg_start_orig < ann_end:
                                                            overlap_start_orig = max(seg_start_orig, ann_start)
                                                            overlap_end_orig = min(seg_end_orig, ann_end)
                                                            rel_start = overlap_start_orig - ann_start
                                                            rel_end = overlap_end_orig - ann_start
                                                            rel_start = max(0, min(rel_start, len(processed_text_for_strikes)))
                                                            rel_end = max(0, min(rel_end, len(processed_text_for_strikes)))
                                                            if rel_start < rel_end:
                                                                is_overlapping = False
                                                                for applied_start, applied_end in strike_segments_to_apply:
                                                                    if max(rel_start, applied_start) < min(rel_end, applied_end): is_overlapping = True; break
                                                                if not is_overlapping: strike_segments_to_apply.append((rel_start, rel_end))
                                                        search_pos = seg_start_orig + 1
                                            except (ValueError, TypeError) as e:
                                                print(f"Warning: Problem with original_range ({original_range}). Error: {e}. Falling back.")
                                                original_range = None
                                        # Approach B: Direct Find (uses exact segment_key)
                                        if non_context_keys_final and original_range is None:
                                            for segment_key in non_context_keys_final:
                                                if not segment_key: continue
                                                pos = 0
                                                while True:
                                                    try: pos = processed_text_for_strikes.find(segment_key, pos)
                                                    except Exception: break
                                                    if pos == -1: break
                                                    start = pos
                                                    end = pos + len(segment_key)
                                                    is_overlapping = False
                                                    for applied_start, applied_end in strike_segments_to_apply:
                                                        if max(start, applied_start) < min(end, applied_end): is_overlapping = True; break
                                                    if not is_overlapping: strike_segments_to_apply.append((start, end))
                                                    pos += 1

                                        # --- 3. Apply all collected segments (No changes) ---
                                        if strike_segments_to_apply:
                                            strike_segments_to_apply.sort()
                                            merged_segments = []
                                            if strike_segments_to_apply:
                                                valid_segments = [seg for seg in strike_segments_to_apply if seg[0] < seg[1]]
                                                if valid_segments:
                                                    valid_segments.sort()
                                                    current_start, current_end = valid_segments[0]
                                                    for next_start, next_end in valid_segments[1:]:
                                                        if next_start <= current_end: current_end = max(current_end, next_end)
                                                        else: merged_segments.append((current_start, current_end)); current_start, current_end = next_start, next_end
                                                    merged_segments.append((current_start, current_end))
                                            if merged_segments:
                                                result_parts = []
                                                current_pos = 0
                                                for start, end in merged_segments:
                                                    if start < 0 or end > len(processed_text_for_strikes) or start >= end: continue
                                                    if start > current_pos: result_parts.append(processed_text_for_strikes[current_pos:start])
                                                    segment_content = processed_text_for_strikes[start:end]
                                                    segment_content_cleaned = re.sub(r'<\/?s.*?>', '', segment_content, flags=re.IGNORECASE)
                                                    if segment_content_cleaned: result_parts.append(f"<s style=\"color:#FF9999;\">{segment_content_cleaned}</s>")
                                                    current_pos = end
                                                if current_pos < len(processed_text_for_strikes): result_parts.append(processed_text_for_strikes[current_pos:])
                                                processed_text_for_strikes = "".join(result_parts)

                                    # --- Re-attach Header (No changes) ---
                                    final_output_text = processed_text_for_strikes
                                    if current_header_html and apply_header:
                                         separator = "\n" if not current_header_html.strip().endswith(("\n", "\r", "</div>", "</b>")) else ""
                                         final_output_text = current_header_html.strip() + separator + processed_text_for_strikes

                                    return final_output_text

                                # Initial formatting for preserved text (using the storyboard text)
                                formatted_preserve_text = apply_formatting(storyboard_text, preserve_strike_cb.isChecked(), preserve_header_cb.isChecked())
                                preserve_text.setHtml(formatted_preserve_text)
                                preserve_text.setStyleSheet("border: 2px solid #1976D2; background-color: #E3F2FD;")
                                preserve_layout.addWidget(preserve_text)

                                select_preserve_btn = QPushButton("Select This Option")
                                select_preserve_btn.setStyleSheet("""
                                    QPushButton {
                                        background-color: #1976D2;
                                        color: white;
                                        border-radius: 4px;
                                        padding: 8px;
                                        font-weight: bold;
                                    }
                                    QPushButton:hover {
                                        background-color: #1565C0;
                                    }
                                """)
                                preserve_layout.addWidget(select_preserve_btn)

                                # RIGHT SIDE (Split / modify text)
                                split_widget = QWidget()
                                split_layout = QVBoxLayout(split_widget)

                                split_title = QLabel("❌ Preserve Text (Unchecked)")
                                split_title.setStyleSheet("font-weight: bold; color: #FF9800; font-size: 12px;")
                                split_layout.addWidget(split_title)

                                # Build split parts along with their original text ranges.
                                text_parts = []
                                if selected_text and original_text:
                                    try:
                                        start_pos = original_text.find(selected_text)
                                        if start_pos >= 0:
                                            left_text = original_text[:start_pos].strip()
                                            end_pos = start_pos + len(selected_text)
                                            right_text = original_text[end_pos:].strip()

                                            # For parts of an annotation not in the Script Editor, don't assign order numbers
                                            if original_order is None:
                                                if left_text:
                                                    text_parts.append(("Part before selection", left_text, "#FF9800", "#FFF3E0", None, (0, start_pos)))
                                                text_parts.append(("Selected Text", selected_text, "#F44336", "#FFEBEE", None, (start_pos, end_pos)))
                                                if right_text:
                                                    text_parts.append(("Part after selection", right_text, "#4CAF50", "#E8F5E9", None, (end_pos, len(original_text))))
                                            else:
                                                # For Script Editor entries, keep the existing logic with order numbers
                                                if left_text:
                                                    text_parts.append(("Part before selection", left_text, "#FF9800", "#FFF3E0", original_order, (0, start_pos)))
                                                selected_order = original_order + (1 if left_text else 0)
                                                text_parts.append(("Selected Text", selected_text, "#F44336", "#FFEBEE", selected_order, (start_pos, end_pos)))
                                                if right_text:
                                                    text_parts.append(("Part after selection", right_text, "#4CAF50", "#E8F5E9", selected_order + 1, (end_pos, len(original_text))))
                                        else:
                                            if original_order is None:
                                                text_parts.append(("Selected Text", selected_text, "#F44336", "#FFEBEE", None, (0, len(original_text))))
                                            else:
                                                text_parts.append(("Selected Text", selected_text, "#F44336", "#FFEBEE", original_order, (0, len(original_text))))
                                    except Exception as e:
                                        if original_order is None:
                                            text_parts.append(("Selected Text", selected_text, "#F44336", "#FFEBEE", None, (0, len(original_text))))
                                        else:
                                            text_parts.append(("Selected Text", selected_text, "#F44336", "#FFEBEE", original_order, (0, len(original_text))))
                                else:
                                    if original_order is None:
                                        text_parts.append(("Selected Text", selected_text or "(No text available)", "#F44336", "#FFEBEE", None, (0, len(original_text))))
                                    else:
                                        text_parts.append(("Selected Text", selected_text or "(No text available)", "#F44336", "#FFEBEE", original_order, (0, len(original_text))))

                                non_empty_parts = sum(1 for _, t, _, _, _, _ in text_parts if t and t != "(None)")
                                is_single_part = non_empty_parts <= 1

                                if original_order is None:
                                    if is_single_part:
                                        unchecked_explanation = QLabel("The text data will be modified.")
                                    else:
                                        unchecked_explanation = QLabel(f"The text data will be split into {non_empty_parts} separate annotations.")
                                else:
                                    if is_single_part:
                                        unchecked_explanation = QLabel("The Script Editor entry will be modified.")
                                    else:
                                        unchecked_explanation = QLabel(f"The Script Editor entry will be split into {non_empty_parts} separate annotations.")
                                unchecked_explanation.setWordWrap(True)
                                unchecked_explanation.setStyleSheet("margin-bottom: 10px;")
                                split_layout.addWidget(unchecked_explanation)

                                # Create text edit fields for each split part
                                split_text_edits = []
                                if is_single_part:
                                    for i, (desc, text, border_color, bg_color, order_num, orig_range) in enumerate(text_parts, 1):
                                        if not text or text == "(None)":
                                            continue

                                        if order_num is None:
                                            anno_label = QLabel(f"Annotation {i}:")
                                        else:
                                            user_facing_order = self.calculate_user_facing_order_number(order_num)
                                            anno_label = QLabel(f"Annotation {i} (#{user_facing_order}):")

                                        anno_label.setStyleSheet("font-weight: bold;")
                                        split_layout.addWidget(anno_label)

                                        text_edit = QTextEdit()
                                        text_edit.setReadOnly(True)
                                        header_option = preserve_header_cb.isChecked() and (order_num == original_order)
                                        formatted_text = apply_formatting(text, preserve_strike_cb.isChecked(), header_option, orig_range)
                                        text_edit.setHtml(formatted_text)
                                        text_edit.setStyleSheet(f"border: 2px solid {border_color}; background-color: {bg_color};")
                                        split_layout.addWidget(text_edit)
                                        split_text_edits.append(text_edit)
                                else:
                                    for i, (desc, text, border_color, bg_color, order_num, orig_range) in enumerate(text_parts, 1):
                                        if not text or text == "(None)":
                                            continue

                                        # Apply the same logic as in the single-part case
                                        if order_num is None:
                                            anno_label = QLabel(f"Annotation {i}:")
                                        else:
                                            user_facing_order = self.calculate_user_facing_order_number(order_num)
                                            anno_label = QLabel(f"Annotation {i} (#{user_facing_order}):")

                                        anno_label.setStyleSheet("font-weight: bold;")
                                        split_layout.addWidget(anno_label)

                                        text_edit = QTextEdit()
                                        text_edit.setReadOnly(True)
                                        header_option = preserve_header_cb.isChecked() and (order_num == original_order)
                                        formatted_text = apply_formatting(text, preserve_strike_cb.isChecked(), header_option, orig_range)
                                        text_edit.setHtml(formatted_text)
                                        text_edit.setStyleSheet(f"border: 2px solid {border_color}; background-color: {bg_color};")
                                        text_edit.setMaximumHeight(100)
                                        split_layout.addWidget(text_edit)
                                        split_text_edits.append(text_edit)

                                select_split_btn = QPushButton("Select This Option")
                                select_split_btn.setStyleSheet("""
                                    QPushButton {
                                        background-color: #FF9800;
                                        color: white;
                                        border-radius: 4px;
                                        padding: 8px;
                                        font-weight: bold;
                                    }
                                    QPushButton:hover {
                                        background-color: #F57C00;
                                    }
                                """)
                                split_layout.addWidget(select_split_btn)

                                splitter.addWidget(preserve_widget)
                                splitter.addWidget(split_widget)
                                splitter.setSizes([400, 400])
                                dialog_layout.addWidget(splitter)

                                # Add events to update preview when toggles change
                                def update_previews():
                                    apply_strikethrough = preserve_strike_cb.isChecked()
                                    apply_header = preserve_header_cb.isChecked()

                                    # Update preserved text preview
                                    formatted_preserve_text = apply_formatting(storyboard_text, apply_strikethrough, apply_header)
                                    preserve_text.setHtml(formatted_preserve_text)

                                    # Update split text previews
                                    for i, (desc, text, _, _, order_num, orig_range) in enumerate(text_parts):
                                        if i < len(split_text_edits) and text and text != "(None)":
                                            header_option = preserve_header_cb.isChecked() and (order_num == original_order)
                                            formatted_text = apply_formatting(text, preserve_strike_cb.isChecked(), header_option, orig_range)
                                            split_text_edits[i].setHtml(formatted_text)

                                preserve_header_cb.toggled.connect(update_previews)
                                preserve_strike_cb.toggled.connect(update_previews)
                                update_previews()

                                # Add instructions
                                next_steps_label = QLabel("Toggle the checkboxes above to preview how formatting will be preserved. "
                                                        "After selecting an option, you'll return to the confirmation dialog.")
                                next_steps_label.setWordWrap(True)
                                next_steps_label.setStyleSheet("font-style: italic; color: #555; margin-top: 10px;")
                                dialog_layout.addWidget(next_steps_label)

                                # Connect button actions
                                def select_preserve_option():
                                    # Set the parent dialog checkbox states to match our choices
                                    # Ensure the storyboard checkbox is checked
                                    if 'storyboard' in checkboxes:
                                        checkboxes['storyboard'].setChecked(True)
                                    if 'storyboard_text' in checkboxes:
                                        checkboxes['storyboard_text'].setChecked(True)
                                    if 'storyboard_header' in checkboxes:
                                        checkboxes['storyboard_header'].setChecked(preserve_header_cb.isChecked())
                                    if 'storyboard_strike' in checkboxes:
                                        checkboxes['storyboard_strike'].setChecked(preserve_strike_cb.isChecked())
                                    text_dialog.accept()


                                def select_split_option():
                                    # Set the parent dialog checkbox states to match our choices
                                    # Ensure the storyboard checkbox is checked
                                    if 'storyboard' in checkboxes:
                                        checkboxes['storyboard'].setChecked(True)
                                    if 'storyboard_text' in checkboxes:
                                        checkboxes['storyboard_text'].setChecked(False)
                                    if 'storyboard_header' in checkboxes:
                                        checkboxes['storyboard_header'].setChecked(preserve_header_cb.isChecked())
                                    if 'storyboard_strike' in checkboxes:
                                        checkboxes['storyboard_strike'].setChecked(preserve_strike_cb.isChecked())
                                    text_dialog.accept()

                                select_preserve_btn.clicked.connect(select_preserve_option)
                                select_split_btn.clicked.connect(select_split_option)

                                # Execute the dialog
                                text_dialog.exec()


                            # Connect the detailed view button
                            detailed_view_btn.clicked.connect(show_full_text)

                            # Helper function to detect if text has a header with improved pattern matching
                            def has_header(text):
                                if not text:
                                    print("DEBUG: No text provided for header check")
                                    return False
                
                                # Broader patterns to match headers with decorative symbols and background colors
                                patterns = [
                                    # Styled headers with background-color
                                    r'<div><b\s+style=[\'"].*?background-color:.*?[\'"]>.*?</b></div>',
                                    # Simple div+b headers that might contain symbols
                                    r'<div><b>.*?</b></div>',
                                    # Just bold text (fallback case)
                                    r'<b\s*.*?>.*?</b>'
                                ]
                
                                for i, pattern in enumerate(patterns):
                                    match = re.search(pattern, text, re.DOTALL | re.IGNORECASE)
                                    if match:
                                        header_text = match.group(0)
                                        print(f"DEBUG: Header found with pattern {i+1}: {header_text[:50]}...")
                                        return True
                
                                print(f"DEBUG: No header found in text: {text[:100]}...")
                                return False

                            # Extract the header for display purposes with improved pattern matching
                            def extract_header(html_text):
                                if not html_text:
                                    print("DEBUG: No HTML text provided for header extraction")
                                    return None, None
                    
                                # Broader patterns for extraction
                                patterns = [
                                    # Styled headers with background-color
                                    r'(<div><b\s+style=[\'"].*?background-color:.*?[\'"]>(.*?)</b></div>)',
                                    # Simple div+b headers
                                    r'(<div><b>(.*?)</b></div>)',
                                    # Just bold text (fallback)
                                    r'(<b\s*.*?>(.*?)</b>)'
                                ]

                                for i, pattern in enumerate(patterns):
                                    match = re.search(pattern, html_text, re.DOTALL | re.IGNORECASE)
                                    if match:
                                        html_header = match.group(1)
                                        # Get the content inside the <b> tags, which might include decorative symbols
                                        inner_text = match.group(2)
                                        print(f"DEBUG: Extracted header with pattern {i+1}: HTML={html_header[:50]}..., Text={inner_text}")
                                        return html_header, inner_text
                                        
#                                 print("DEBUG: No header pattern matched during extraction")
                                return None, None

                            # Check if there's a header and add the checkbox if so
                            storyboard_text = old_anno.get('storyboard', {}).get('text', '')
#                             print(f"\nDEBUG: Checking for header in storyboard text: {storyboard_text[:100]}...")

                            # Try different approaches to find the header
                            header_found = False
                            html_header = None
                            header_text = None

                            # First check in storyboard text
                            if storyboard_text and has_header(storyboard_text):
                                header_found = True
                                html_header, header_text = extract_header(storyboard_text)
                                print(f"DEBUG: Found header in storyboard text: {header_text}")

                            # If not found in storyboard text, check original text
                            if not header_found or not html_header:
                                original_text = old_anno.get('text', '')
                                if original_text and has_header(original_text):
                                    header_found = True
                                    html_header, header_text = extract_header(original_text)
                                    print(f"DEBUG: Found header in original text: {header_text}")

                            # If header found by any method, create the checkbox
                            if header_found and html_header and header_text:
                                # Clean up the header text for display - remove decorative symbols
                                # Since symbols can be various Unicode characters, we'll just keep alphanumeric and basic punctuation
                                display_text = header_text
                                if len(display_text) >= 2:
                                    # Check if first and last characters are non-alphanumeric (likely decorators)
                                    if not display_text[0].isalnum() and not display_text[-1].isalnum():
                                        # If they're the same character, they're likely matching decorators
                                        if display_text[0] == display_text[-1]:
                                            # Remove the decorator characters
                                            display_text = display_text[1:-1]
                
                                print(f"DEBUG: Creating header checkbox for header: {display_text}")
                                header_layout = QHBoxLayout()
                                header_cb = XMarkCheckBox("Preserve Header")  # Changed from standard QCheckBox
                                header_cb.setChecked(True)
                
                                # Truncate header text if too long
                                if len(display_text) > 25:
                                    display_header = display_text[:22] + "..."
                                else:
                                    display_header = display_text
                    
                                header_cb.setText(f"Preserve Header: [{display_header}]")
                                checkboxes['storyboard_header'] = header_cb
                                header_layout.addWidget(header_cb)
                
                                # Add tooltip to show full header text
                                header_cb.setToolTip(f"Header: {display_text}")
                
                                sub_options_layout.addLayout(header_layout)
                
                                # FIX: Only link to storyboard checkbox, not text checkbox
                                storyboard_cb.toggled.connect(lambda checked: header_cb.setEnabled(checked))
                                header_cb.setEnabled(storyboard_cb.isChecked())  # Initial state
                            else:
                                print("DEBUG: No header found or couldn't extract header information")

                            # Strikethrough preservation checkbox
                            if old_anno.get('storyboard', {}).get('strikethrough_segments'):
                                strike_cb = XMarkCheckBox("Preserve Strikethroughs")  # Changed from standard QCheckBox
                                strike_cb.setChecked(True)
                                checkboxes['storyboard_strike'] = strike_cb
                                sub_options_layout.addWidget(strike_cb)
                                # FIX: Only link to storyboard checkbox
                                storyboard_cb.toggled.connect(lambda checked: strike_cb.setEnabled(checked))
                                strike_cb.setEnabled(storyboard_cb.isChecked())  # Initial state

                            storyboard_container.addLayout(sub_options_layout)
                            layout.addLayout(storyboard_container)

                    # Add buttons
                    button_box = QHBoxLayout()
                    ok_button = QPushButton("OK")
                    cancel_button = QPushButton("Cancel")

                    ok_button.clicked.connect(dialog.accept)
                    cancel_button.clicked.connect(dialog.reject)

                    button_box.addWidget(ok_button)
                    button_box.addWidget(cancel_button)
                    layout.addLayout(button_box)

                    dialog.setLayout(layout)
                    result = dialog.exec()

                    if result == QDialog.DialogCode.Accepted:
                        preserved_metadata = None
                        if checkboxes:
                            preserved_metadata = {}
                            for key, checkbox in checkboxes.items():
                                if checkbox.isChecked():
                                    if key == 'notes':
                                        notes_value = old_anno.get('notes', '')
                                        notes_html_value = old_anno.get('notes_html', '')
                                        preserved_metadata['notes'] = notes_value
                                        preserved_metadata['notes_html'] = notes_html_value
                                        print(f"🔍 PRESERVING NOTES: notes='{notes_value}', notes_html='{notes_html_value}'")
                                    elif key == 'storyboard':
                                        # Initialize storyboard structure (always preserve order)
                                        storyboard_data = {
                                            'order': old_anno.get('storyboard', {}).get('order'),
                                            'text': '',  # Default empty
                                            'strikethrough_segments': {}  # Default empty
                                        }
                                        # Only preserve text if sub-checkbox exists and is checked
                                        text_checkbox = checkboxes.get('storyboard_text')
                                        if text_checkbox and text_checkbox.isChecked():
                                            storyboard_data['text'] = old_anno.get('storyboard', {}).get('text', '')
                                            preserved_metadata['preserve_original_annotation'] = True

                                        strike_checkbox = checkboxes.get('storyboard_strike')
                                        if strike_checkbox:
                                            if strike_checkbox.isChecked():
                                                original_segments = old_anno.get('storyboard', {}).get('strikethrough_segments', {})
                                                original_positional = old_anno.get('storyboard', {}).get('positional_strikethrough', {})
                                                if original_segments:
                                                    preserved_metadata['strikethrough_segments'] = original_segments
                                                if original_positional:
                                                    preserved_metadata['positional_strikethrough'] = original_positional
                                                print(f"DEBUG: Preserving strikethrough segments: {original_segments}")
                                                print(f"DEBUG: Preserving positional strikethrough: {original_positional}")
                                            else:
                                                # User chose not to preserve
                                                if 'strikethrough_segments' in preserved_metadata:
                                                    preserved_metadata.pop('strikethrough_segments')
                                                preserved_metadata['preserve_strikethroughs'] = False
                                                print("DEBUG: User chose NOT to preserve strikethroughs - actively removing")

                
                                        # FIX: Preserve header independently of text checkbox
                                        header_checkbox = checkboxes.get('storyboard_header')
                                        if header_checkbox and header_checkbox.isChecked():
                                            print("DEBUG: Header preservation checkbox checked")
                                            # Try to extract header from storyboard text first
                                            storyboard_text = old_anno.get('storyboard', {}).get('text', '')
                                            html_header, header_text = extract_header(storyboard_text)
                    
                                            # If not found in storyboard text, try original text
                                            if not html_header and old_anno.get('text'):
                                                original_text = old_anno.get('text', '')
                                                html_header, header_text = extract_header(original_text)
                    
                                            if html_header:
                                                print(f"DEBUG: Found header to preserve: {header_text}")
                                                # Store header directly in preserved_metadata
                                                preserved_metadata['header'] = {
                                                    'html': html_header,
                                                    'text': header_text
                                                }
                                                print(f"DEBUG: Stored header for later application: {html_header}")
                                            else:
                                                print("DEBUG: No header found to preserve")
                                        else:
                                            print("DEBUG: Header preservation not selected or checkbox not found")

                                        preserved_metadata['storyboard'] = storyboard_data
                
                                        # Also preserve the regular order if it exists
                                        order_value = old_anno.get('order')
                                        if order_value is not None:
                                            preserved_metadata['order'] = order_value
                                    else:
                                        preserved_metadata[key] = old_anno.get(key, False)

                        self.preserved_metadata_for_reassign = preserved_metadata

                        # If "Preserve Text" is unchecked, call apply_changes_lite only if the dialog exists
                        current_text_unchecked = False
                        if old_anno and 'storyboard' in old_anno and 'text' in old_anno['storyboard']:
                            text_checkbox = checkboxes.get('storyboard_text')
                            if text_checkbox and not text_checkbox.isChecked():
                                current_text_unchecked = True

                        if current_text_unchecked:
                            print("Preserve Text is unchecked; calling apply_changes_lite on existing StoryboardDialog (if any).")
                            main_window = self.main_window
                            if main_window and hasattr(main_window, 'storyboard_dialog') and main_window.storyboard_dialog:
                                print("Using existing StoryboardDialog instance")
                                main_window.storyboard_dialog.apply_changes_lite()
                            else:
                                print("StoryboardDialog not available, skipping apply_changes_lite() call.")

                        print("User confirmed the reassignment.")
                        
                        # Show processing cursor for immediate feedback
                        self.show_processing_cursor()
                        
                        self.page().runJavaScript(removal_js, lambda r: handle_removal_and_reassign(r, scene))
                    else:
                        print("User canceled the reassignment.")
                        return
                else:
                    # No metadata to transfer - show simple confirmation
                    msg_box = QMessageBox(self)
                    msg_box.setIcon(QMessageBox.Icon.Question)
                    msg_box.setWindowTitle("Confirm Reassignment")
                    msg_box.setText("The original annotation will be divided or deleted.")
                    msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)

                    if msg_box.exec() == QMessageBox.StandardButton.Yes:
                        print("User confirmed the reassignment.")
                        
                        # =================================================================
                        # 🎯 APPLY IMMEDIATE VISUAL FEEDBACK AT POINT OF NO RETURN
                        # =================================================================
                        self.page().runJavaScript(removal_js, lambda r: handle_removal_and_reassign(r, scene))
                    else:
                        print("User canceled the reassignment.")
                        return
            else:
                # Multiple spans case - show simple confirmation if not auto-fix
                if is_auto_fix_attempt:
                    print("Auto-fix attempt detected, skipping confirmation dialog for multiple spans")
                    
                    # Show processing cursor for immediate feedback
                    self.show_processing_cursor()
                    
                    self.page().runJavaScript(removal_js, lambda r: handle_removal_and_reassign(r, scene))
                    return
                
                msg_box = QMessageBox(self)
                msg_box.setIcon(QMessageBox.Icon.Question)
                msg_box.setWindowTitle("Confirm Reassignment")
                msg_box.setText("The original annotation will be divided or deleted.")
                msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)

                if msg_box.exec() == QMessageBox.StandardButton.Yes:
                    print("User confirmed the reassignment.")
                    
                    # Show processing cursor for immediate feedback
                    self.show_processing_cursor()
                    
                    self.page().runJavaScript(removal_js, lambda r: handle_removal_and_reassign(r, scene))
                else:
                    print("User canceled the reassignment.")
                    return

        def handle_removal_and_reassign(results, scene, is_auto_fix_attempt=False):
            """
            Handles the results of the initial removal check.
            If removal is required, prompt the user before proceeding, respecting their choice regarding storyboard data.
            """
            print("💥💥💥💥💥💥💥💥💥💥💥💥 HANDLE_REMOVAL_AND_REASSIGN START 💥💥💥💥💥💥💥💥💥💥💥💥")
            print(f"💥 results available: {bool(results)}, scene: {scene}, is_auto_fix_attempt: {is_auto_fix_attempt}")
            print("💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥")
            print("\n=== HANDLE REMOVAL AND REASSIGN START ===")
            #print(f"Removal results: {json.dumps(results, indent=2) if results else 'None'}")
            
            # Initialize tracking for targeted theme view updates
            self._reassignment_removed_ids = []
            self._reassignment_updated_annotations = []
            self._reassignment_added_annotations = []
            
            # Initialize selection tracking for batch operations
            self._pending_selections = []  # List of (annotation_id, list_widget, matching_index) tuples
            self._selections_cleared = False  # Track if we've cleared selections once
            
            # Clear selections across all tabs in theme view BEFORE operation starts
            if hasattr(self.main_window, 'clear_all_tab_selections'):
                self.main_window.clear_all_tab_selections()
                self._selections_cleared = True
                print("DEBUG: Cleared all theme view selections at start of handle_removal_and_reassign")
            
            # Flag to prevent double emission during reassignment
            self._in_reassignment_context = True
            self.main_window._in_reassignment_context = True
            print(f"🟢🟢🟢 FLAG SET TO TRUE on {type(self).__name__} and {type(self.main_window).__name__}")
            
            # Also set flag on storyboard dialog to prevent premature apply_changes_lite
            if hasattr(self.main_window, 'storyboard_dialog') and self.main_window.storyboard_dialog:
                self.main_window.storyboard_dialog._in_reassignment_context = True
                print("[DEBUG] Set reassignment context flag on storyboard dialog")
            
            # Sanity check: Count annotations before operation
            initial_annotation_count = len(self.annotations)
            print(f"DEBUG: Initial annotation count: {initial_annotation_count}")

            # Check if this is a normal assignment (no removal required)
            is_normal_assignment = not results or not results.get('removedSpans')

            # Check for blocked state due to line breaks
            if results and results.get('blocked') and results.get('reason') == "line-break":
                reason = results.get('reason')
                debug_info = results.get('debugInfo', {})

                # If this is already an auto-fix attempt, don't offer auto-fix again
                # This prevents infinite loops
                if is_auto_fix_attempt:
                    msg_box = QMessageBox(self)
                    msg_box.setIcon(QMessageBox.Icon.Warning)
                    msg_box.setWindowTitle("Cannot Assign Scene")
                    msg_box.setText("Auto-fix was unable to properly adjust the selection. Please try selecting text manually within a single paragraph.")
                    msg_box.setStandardButtons(QMessageBox.StandardButton.Ok)
                    msg_box.exec()
                    return

                # Regular dialog with auto-fix option for first attempt
                msg_box = QMessageBox(self)
                msg_box.setIcon(QMessageBox.Icon.Warning)
                msg_box.setWindowTitle("Cannot Assign Scene")

                formatted_message = "<p style='font-weight: bold; font-size: 12pt;'>Highlights cannot span multiple block elements</p>"
                formatted_message += "<p>Please adjust your selection manually, or use Auto Fix.</p>"

                msg_box.setText(formatted_message)
                msg_box.setTextFormat(Qt.TextFormat.RichText)

                # Add detailed text about the line breaks
                nodes = debug_info.get('nodes', [])
                debug_message = "Block elements detected in the following elements:\n"
                for node in nodes:
                    tag = node.get('tagName')
                    text = node.get('textContent')
                    node_id = node.get('id')
                    class_name = node.get('className')
                    debug_message += f"- <{tag}> with text '{text[:100]}...'"
                    if node_id:
                        debug_message += f", id='{node_id}'"
                    if class_name:
                        debug_message += f", class='{class_name}'"
                    debug_message += "\n"
                msg_box.setDetailedText(debug_message)

                auto_fix_button = msg_box.addButton("Auto Fix", QMessageBox.ButtonRole.YesRole)
                msg_box.setDefaultButton(auto_fix_button)
                cancel_button = msg_box.addButton(QMessageBox.StandardButton.Cancel)
                auto_fix_button.setStyleSheet("QPushButton { font-weight: bold; }")

                msg_box.exec()

                if msg_box.clickedButton() == auto_fix_button:
                    # Call the auto-selection function with flag to prevent infinite loops
                    self.auto_select_single_paragraph(scene, results.get('selectionInfo'))
                return

            had_changes = False  # Initialize at the start
            header_to_apply = None  # Always initialize

            # Get the flag from preserved_metadata (if available) indicating if "Preserve Text" is checked
            use_current_text = False
            if hasattr(self, 'preserved_metadata_for_reassign'):
                use_current_text = self.preserved_metadata_for_reassign.get('preserve_original_annotation', False)
                print(f"Using current text flag from preserved metadata: {use_current_text}")

            if not results:
                selection_info = results.get('selectionInfo') if isinstance(results, dict) else None
                text_to_highlight = selection_info.get('text') if selection_info else ''
                if not text_to_highlight:
                    print("No text to highlight, skipping annotation creation")
                    return
                print(f"No removal results. Selection info: {json.dumps(selection_info, indent=2) if selection_info else 'None'}")
                self.create_new_annotation_and_highlight(text_to_highlight, scene, selection_info)
                return

            if results.get('blocked'):
                reason = results.get('reason')
                debug_info = results.get('debugInfo', {})
                msg_box = QMessageBox(self)
                msg_box.setIcon(QMessageBox.Icon.Warning)
                msg_box.setWindowTitle("Cannot Assign Scene")
                if reason == "line-break":
                    msg_box.setText("Highlight cannot span multiple block elements. Please adjust your selection.")
                    nodes = debug_info.get('nodes', [])
                    debug_message = "Block elements detected in the following elements:\n"
                    for node in nodes:
                        tag = node.get('tagName')
                        text = node.get('textContent')
                        node_id = node.get('id')
                        class_name = node.get('className')
                        debug_message += f"- <{tag}> with text '{text}'"
                        if node_id:
                            debug_message += f", id='{node_id}'"
                        if class_name:
                            debug_message += f", class='{class_name}'"
                        debug_message += "\n"
                    msg_box.setDetailedText(debug_message)
                elif reason == "multiple-annotations":
                    msg_box.setText("Selection includes multiple different highlights. Please handle them individually.")
                    annotation_ids = debug_info.get('annotationIds', [])
                    debug_message = "Multiple annotation IDs detected:\n" + ", ".join(annotation_ids)
                    msg_box.setDetailedText(debug_message)
                else:
                    msg_box.setText("Cannot assign scene due to an unknown reason.")
                    debug_type = debug_info.get('type', 'unknown')
                    debug_message = f"Debug Info Type: {debug_type}"
                    if 'message' in debug_info:
                        debug_message += f"\nMessage: {debug_info.get('message')}"
                    msg_box.setDetailedText(debug_message)
                msg_box.setStandardButtons(QMessageBox.StandardButton.Ok)
                msg_box.exec()
                return

            removed_spans = results.get('removedSpans', [])
            updated_spans = results.get('updatedSpans', [])
            scroll_pos = results.get('scrollPos', 0)
            selection_info = results.get('selectionInfo')

            print(f"\nSelection Info: {json.dumps(selection_info, indent=2) if selection_info else 'None'}")
            print(f"\nRemoved Spans: {json.dumps(removed_spans, indent=2)}")
            print(f"\nUpdated Spans: {json.dumps(updated_spans, indent=2)}")
            
            # 🔍 RIGHT-END SELECTION DEBUG
            if updated_spans:
                print("🔍🔍🔍 RIGHT-END SELECTION DEBUG START 🔍🔍🔍")
                for span in updated_spans:
                    print(f"🔍 Updated span ID: {span.get('annotationId')}")
                    print(f"🔍 Original annotation ID from removed: {removed_spans[0].get('annotationId') if removed_spans else 'None'}")
                    print(f"🔍 IDs match (should be True for update): {span.get('annotationId') == (removed_spans[0].get('annotationId') if removed_spans else None)}")
                    print(f"🔍 Span has isOriginal: {span.get('isOriginal', 'NOT SET')}")
                    print(f"🔍 Span text: '{span.get('text', '')[:50]}...'")
                print("🔍🔍🔍 RIGHT-END SELECTION DEBUG END 🔍🔍🔍")
                
                # Add stack trace to see how we got here
                print("📍📍📍 STACK TRACE TO RIGHT-END SELECTION POINT 📍📍📍")
                import traceback
                traceback.print_stack()
                print("📍📍📍 END STACK TRACE 📍📍📍")

            # Map original annotations for metadata preservation
            old_annotations_by_id = {anno['id']: anno for anno in self.annotations}

            # Retrieve and then remove preserved metadata
            preserved_metadata = getattr(self, 'preserved_metadata_for_reassign', None)
            if hasattr(self, 'preserved_metadata_for_reassign'):
                delattr(self, 'preserved_metadata_for_reassign')

            # --- Early Backup: Capture full original strikethrough segments ---
            original_strike_backup = {}
            original_positional_backup = {}  # Backup for positional strikethrough data
            for span_info in removed_spans:
                annotation_id = span_info.get('annotationId')
                if not annotation_id:
                    continue
                old_anno = old_annotations_by_id.get(annotation_id)
                if old_anno and isinstance(old_anno.get('storyboard'), dict):
                    original_strike_backup[annotation_id] = copy.deepcopy(old_anno['storyboard'].get('strikethrough_segments', {}))
                    # Also backup positional strikethrough data
                    original_positional_backup[annotation_id] = copy.deepcopy(old_anno['storyboard'].get('positional_strikethrough', {}))

            # --- Helper Functions ---
            def is_beginning_of_text(part_text, original_text):
                """Check if a text part appears at the beginning of the original text."""
                if not part_text or not original_text:
                    return False
                clean_part = part_text.strip()
                clean_original = original_text.strip()
                begins_with = clean_original.startswith(clean_part)
                print(f"DEBUG: Checking if '{clean_part}' is at beginning of '{clean_original}': {begins_with}")
                return begins_with

            def extract_header_from_text(text):
                """Extract header HTML from the beginning of text if present."""
                if not text:
                    print("DEBUG: Empty text provided to extract_header_from_text")
                    return None, text

                # Print first 150 chars for debugging
#                 print(f"DEBUG: EXTRACTING HEADER FROM: {repr(text[:150])}")

                # Improved patterns that match your StoryboardHeaderDialog output exactly
                header_patterns = [
                    # Match header with style attribute - prioritize exact pattern from StoryboardHeaderDialog
                    r'^(\s*<div>\s*<b\s+style=[\'"]background-color:\s*[^\'";]+;?[\'"]>\s*.*?\s*</b>\s*</div>)(\s*\n?)',
                    # Match header with style attribute - more general version
                    r'^(\s*<div>\s*<b\s+style=[\'"][^\'"]*background-color:[^\'"]*[\'"]>\s*.*?\s*</b>\s*</div>)(\s*\n?)',
                    # Simple div+b headers without style
                    r'^(\s*<div>\s*<b>\s*.*?\s*</b>\s*</div>)(\s*\n?)',
                ]

                for i, pattern in enumerate(header_patterns):
                    try:
                        match = re.match(pattern, text, re.DOTALL)
                        if match:
                            header = match.group(1)
                            separator = match.group(2) or "\n"
                            remaining_text = text[len(header) + len(separator):]
                            print(f"DEBUG: Extracted header using pattern {i+1}: {repr(header)}")
                            return header, remaining_text
                        else:
                            pass  # Pattern did not match
#                             print(f"DEBUG: Pattern {i+1} did not match")
                    except Exception as e:
                        print(f"DEBUG: Error in header pattern {i+1}: {e}")

#                 print("DEBUG: No header pattern matched")
                return None, text

            def remove_header_from_text(text):
                """Remove header from text without replacing it."""
                if not text:
                    return text
                existing_header, clean_text = extract_header_from_text(text)
                if existing_header:
                    print(f"DEBUG: Removing header: {existing_header}")
                    return clean_text
                return text

            def get_header_to_apply(preserved_metadata, text=None):
                """Get header from preserved metadata or extract from text."""
                if preserved_metadata and 'preserve_header' in preserved_metadata and not preserved_metadata['preserve_header']:
                    print("DEBUG: Header preservation is explicitly disabled")
                    return None
                if preserved_metadata and 'header' in preserved_metadata:
                    print(f"DEBUG: Using header from preserved metadata: {preserved_metadata['header']['html']}")
                    return preserved_metadata['header']['html']
                if text:
                    header, _ = extract_header_from_text(text)
                    if header:
                        print(f"DEBUG: Extracted header from text: {header}")
                        return header
                return None

            def apply_header_to_text(text, header):
                """Apply header to text content, ensuring header is at the beginning."""
                if not header:
                    return text
                if not text:
                    return header

                # First check if text already starts with the exact header
                if text.startswith(header):
                    print(f"DEBUG: Text already starts with the exact header - not adding again")
                    return text

                # Try standard extraction
                existing_header, clean_text = extract_header_from_text(text)
                if existing_header:
                    print(f"DEBUG: Removed existing header: {repr(existing_header)}")
                    text = clean_text

                result = f"{header}\n{text}"
                print(f"DEBUG: Applied header to text: {repr(result[:50])}...")
                return result

            def get_strikethrough_segments(preserved_metadata, annotation_id=None):
                """Return preserved strikethrough segments (applied directly, no splitting)."""
                if preserved_metadata and 'strikethrough_segments' in preserved_metadata:
                    return preserved_metadata['strikethrough_segments']
                if annotation_id and annotation_id in original_strike_backup:
                    return original_strike_backup[annotation_id]
                return {}

            # --- End Helpers ---

            should_preserve_header = True
            if preserved_metadata:
                # Explicitly check for preserve_header flag
                if 'preserve_header' in preserved_metadata:
                    should_preserve_header = preserved_metadata['preserve_header']
                    print(f"DEBUG: Header preservation explicitly set to: {should_preserve_header}")
                # Add logic to handle unchecked header preservation
                elif 'header' not in preserved_metadata and use_current_text:
                    # If we're preserving the original annotation (Preserve Text checked)
                    # but there's no header data, the user likely unchecked header preservation
                    should_preserve_header = False
                    print("DEBUG: PRESERVE HEADER appears to be unchecked (no header data found)")
            if should_preserve_header:
                header_to_apply = get_header_to_apply(preserved_metadata)

            # Force-merge the backup if the preserved metadata lacks the full strikethrough data.
            if preserved_metadata is None:
                preserved_metadata = {}

            # Check if strikethroughs should be preserved
            preserve_strikethroughs = True
            if preserved_metadata.get('preserve_strikethroughs') is False:
                preserve_strikethroughs = False
                print("DEBUG: User explicitly chose NOT to preserve strikethroughs")
                # Ensure strikethrough_segments is removed from preserved_metadata
                if 'strikethrough_segments' in preserved_metadata:
                    preserved_metadata.pop('strikethrough_segments')

            # Only merge strikethroughs if the user hasn't explicitly opted out
            if preserve_strikethroughs and 'strikethrough_segments' not in preserved_metadata:
                merged_segments = {}
                merged_positional = {}  # For positional strikethrough data
                for ann_id, segments in original_strike_backup.items():
                    merged_segments.update(segments)
                # Merge positional data from all source annotations
                for ann_id, positional in original_positional_backup.items():
                    merged_positional.update(positional)
                preserved_metadata['strikethrough_segments'] = merged_segments
                preserved_metadata['positional_strikethrough'] = merged_positional  # Store merged positional data

            header_applied_to_maintain_continuity = False
            is_middle_text_removal = False

            for span_info in removed_spans:
                annotation_id = span_info.get('annotationId')
                if not annotation_id:
                    continue
                old_anno = old_annotations_by_id.get(annotation_id)
                if not old_anno:
                    continue

                had_changes = True

                current_metadata = {
                    'notes': old_anno.get('notes', ''),
                    'notes_html': old_anno.get('notes_html', ''),
                    'used': old_anno.get('used', False),
                    'favorite': old_anno.get('favorite', False),
                    'speech_title': old_anno.get('speech_title', ''),
                    'tags': old_anno.get('tags', []),
                    'storyboard': old_anno.get('storyboard', {}),
                    'order': old_anno.get('order')
                }

                original_part = next((u for u in updated_spans if u.get('annotationId') == annotation_id and u.get('isOriginal')), None)
                new_parts = [u for u in updated_spans if u.get('isNew') and u.get('scene') == old_anno['scene']]

                original_text = old_anno.get('text', '')
                original_order = None
                if isinstance(old_anno.get('storyboard'), dict) and 'order' in old_anno['storyboard']:
                    original_order = old_anno['storyboard']['order']
                elif 'order' in old_anno:
                    original_order = old_anno['order']

                original_storyboard_text = ""
                if isinstance(old_anno.get('storyboard'), dict):
                    original_storyboard_text = old_anno['storyboard'].get('text', '')

                if use_current_text:
                    # If "Preserve Text" is checked, we update the original annotation's scene
                    # but preserve its storyboard text exactly as is
                    print(f"\nPreserving original annotation storyboard text for {annotation_id} (Preserve Text checked)")
                    if original_part:
                        old_anno['text'] = original_part['text']
                        old_anno['scene'] = scene  # Update to new scene
                        self._reassignment_updated_annotations.append(old_anno.copy())  # Track update
                        print(f"Updated scene to {scene} while preserving storyboard text")

                        if isinstance(old_anno.get('storyboard'), dict):
                            if should_preserve_header and header_to_apply and not header_applied_to_maintain_continuity:
                                current_text = old_anno['storyboard'].get('text', '')
                                old_anno['storyboard']['text'] = apply_header_to_text(current_text, header_to_apply)
                                print(f"DEBUG: Applied header to preserved storyboard text: {header_to_apply}")
                                header_applied_to_maintain_continuity = True
                            elif not should_preserve_header:
                                current_text = old_anno['storyboard'].get('text', '')
                                old_anno['storyboard']['text'] = remove_header_from_text(current_text)
                                print("DEBUG: Removed header from preserved storyboard text")

                            # Handle strikethrough segments based on preservation choice
                            if preserve_strikethroughs and preserved_metadata.get('strikethrough_segments'):
                                old_anno['storyboard']['strikethrough_segments'] = copy.deepcopy(preserved_metadata['strikethrough_segments'])
                                # Also preserve positional strikethrough data
                                if 'positional_strikethrough' in preserved_metadata:
                                    old_anno['storyboard']['positional_strikethrough'] = copy.deepcopy(preserved_metadata['positional_strikethrough'])
                                print("DEBUG: Applied preserved strikethrough data (both traditional and positional) to original part")
                            else:
                                # Clear existing strikethrough segments if preserve_strikethroughs is False
                                if 'strikethrough_segments' in old_anno['storyboard']:
                                    old_anno['storyboard']['strikethrough_segments'] = {}
                                    old_anno['storyboard']['positional_strikethrough'] = {}  # Clear positional data too
                                    print("DEBUG: Cleared strikethrough data from original part")

                        self.annotation_updated.emit(json.dumps(old_anno))
                    else:
                        # If original part is gone, remove the annotation
                        print(f"\nRemoving original annotation {annotation_id} (no left part)")
                        if old_anno in self.annotations:
                            self.annotations.remove(old_anno)
                            self._reassignment_removed_ids.append(annotation_id)  # Track removal
                            deletion_info = {
                                'id': annotation_id,
                                'text': old_anno.get('text', ''),
                                'scene': old_anno.get('scene', ''),
                                'notes': old_anno.get('notes', ''),
                                'notes_html': old_anno.get('notes_html', ''),
                                'used': old_anno.get('used', False),
                                'favorite': old_anno.get('favorite', False),
                                'tags': old_anno.get('tags', []),
                                'secondary_scenes': old_anno.get('secondary_scenes', []),
                                'speech_title': old_anno.get('speech_title', '')
                            }
                            self.annotation_deleted.emit(json.dumps(deletion_info))

                    # For new parts, create annotations WITHOUT storyboard entries when "Preserve Text" is checked
                    for i, np in enumerate(new_parts):
                        if not np['text'] or np['text'].strip() == '':
                            print("DEBUG: Skipping creation of annotation with empty text")
                            continue

                        print(f"DEBUG: Creating new part {i} without storyboard entry (Preserve Text checked)")
                        new_anno_id = np['annotationId']
                        new_anno = {
                            'id': new_anno_id,
                            'text': np['text'],
                            'scene': np['scene'],
                            'notes': current_metadata['notes'],
                            'notes_html': current_metadata['notes_html'],
                            'used': current_metadata['used'],
                            'favorite': current_metadata['favorite'],
                            'speech_title': current_metadata.get('speech_title', ''),
                            'tags': current_metadata.get('tags', []),
                            'secondary_scenes': old_anno.get('secondary_scenes', []),
                            'timestamp': datetime.datetime.now().isoformat()
                            # No storyboard entry when "Preserve Text" is checked for new parts
                        }
                        # Sanitize secondary_scenes (remove primary if present, filter invalid, dedupe)
                        try:
                            sec = new_anno.get('secondary_scenes') or []
                            if not isinstance(sec, list):
                                sec = []
                            sec = [s for s in sec if s != new_anno['scene']]
                            valid = set(self.scene_styles.keys())
                            sec = [s for s in sec if s in valid]
                            seen = set()
                            cleaned = []
                            for s in sec:
                                if s not in seen:
                                    seen.add(s)
                                    cleaned.append(s)
                            new_anno['secondary_scenes'] = cleaned
                        except Exception as _e:
                            print(f"DEBUG: sanitize secondary_scenes for preserved-text split failed: {_e}")
                        self.annotations.append(new_anno)
                        self._reassignment_added_annotations.append(new_anno.copy())  # Track addition
                        
                        # Emit for storyboard updates but theme view handled by targeted updates
                        print(f"DEBUG: Emitting annotation_added for storyboard sync: {new_anno['id']}")
                        print(f"🔥🔥🔥🔥🔥 ANNOTATION EMIT TRACEBACK FOR {new_anno.get('id')} 🔥🔥🔥🔥🔥")
                        import traceback
                        traceback.print_stack()
                        print(f"🔥🔥🔥🔥🔥 END EMIT TRACEBACK 🔥🔥🔥🔥🔥")
                        self.annotation_added.emit(json.dumps(new_anno))

                    continue  # Skip the rest of the processing for this span

                # If we get here, "Preserve Text" is NOT checked, so proceed with normal splitting behavior
                is_original_beginning = False
                if original_part:
                    is_original_beginning = is_beginning_of_text(original_part['text'], original_text)
                    print(f"DEBUG: Original part is at beginning: {is_original_beginning}")

                if original_part:
                    print(f"\nUpdating original annotation {annotation_id} with new text: {original_part['text']}")
                    old_anno['text'] = original_part['text']
                    self._reassignment_updated_annotations.append(old_anno.copy())  # Track update
                    if isinstance(old_anno.get('storyboard'), dict):
                        if should_preserve_header and header_to_apply and not header_applied_to_maintain_continuity:
                            old_anno['storyboard']['text'] = apply_header_to_text(original_part['text'].replace('\n', '<br>'), header_to_apply)
                            print(f"DEBUG: Applied header to updated storyboard text: {header_to_apply}")
                            header_applied_to_maintain_continuity = True
                        elif not should_preserve_header:
                            old_anno['storyboard']['text'] = remove_header_from_text(original_part['text'].replace('\n', '<br>'))
                            print("DEBUG: Removed header from storyboard text as preservation was disabled")
                        else:
                            old_anno['storyboard']['text'] = original_part['text'].replace('\n', '<br>')
                        print("DEBUG: Updating storyboard text for original part (Preserve Text unchecked)")

                        # Handle strikethrough segments based on preservation choice.
                        if preserve_strikethroughs:
                            # Use preserved metadata if available; otherwise, fallback to backup for this annotation.
                            # FIX: Create deep copies to avoid reference issues
                            old_anno['storyboard']['strikethrough_segments'] = copy.deepcopy(
                                preserved_metadata.get('strikethrough_segments', {})
                            )
                            old_anno['storyboard']['positional_strikethrough'] = copy.deepcopy(
                                preserved_metadata.get('positional_strikethrough',
                                    original_positional_backup.get(annotation_id, {})
                                )
                            )
                            print("DEBUG: Applied preserved strikethrough segments (traditional and positional) to original part")
                        else:
                            if 'strikethrough_segments' in old_anno['storyboard']:
                                old_anno['storyboard']['strikethrough_segments'] = {}
                            if 'positional_strikethrough' in old_anno['storyboard']:
                                old_anno['storyboard']['positional_strikethrough'] = {}
                            print("DEBUG: Cleared strikethrough segments from original part")
                    if 'order' in old_anno:
                        if is_original_beginning:
                            print(f"DEBUG: Keeping original order {old_anno['order']} for beginning part")
                        else:
                            old_anno['order'] = (old_anno['order'] or 0) + 1
                            print(f"DEBUG: Incremented order to {old_anno['order']} for non-beginning part")
                    if isinstance(old_anno.get('storyboard'), dict) and 'order' in old_anno['storyboard']:
                        if is_original_beginning:
                            print(f"DEBUG: Keeping original storyboard order {old_anno['storyboard']['order']} for beginning part")
                        else:
                            old_anno['storyboard']['order'] = (old_anno['storyboard']['order'] or 0) + 1
                            print(f"DEBUG: Incremented storyboard order to {old_anno['storyboard']['order']} for non-beginning part")
                    self.annotation_updated.emit(json.dumps(old_anno))

                else:
                    print(f"\nRemoving original annotation {annotation_id} (no left part)")
                    if old_anno in self.annotations:
                        self.annotations.remove(old_anno)
                        self._reassignment_removed_ids.append(annotation_id)  # Track removal
                        deletion_info = {
                            'id': annotation_id,
                            'text': old_anno.get('text', ''),
                            'scene': old_anno.get('scene', ''),
                            'notes': old_anno.get('notes', ''),
                            'notes_html': old_anno.get('notes_html', ''),
                            'used': old_anno.get('used', False),
                            'favorite': old_anno.get('favorite', False),
                            'tags': old_anno.get('tags', []),
                            'secondary_scenes': old_anno.get('secondary_scenes', []),
                            'speech_title': old_anno.get('speech_title', '')
                        }
                        self.annotation_deleted.emit(json.dumps(deletion_info))

                # Check for middle text removal case (we have both original part and new parts)
                if original_part and new_parts:
                    is_middle_text_removal = True
                    print("DEBUG: Detected middle text removal case, disabling header for new annotation")

                if new_parts:
                    had_order = (old_anno.get('order') is not None) or (isinstance(old_anno.get('storyboard'), dict) and old_anno['storyboard'].get('order') is not None)
                    if had_order:
                        original_order_val = old_anno.get('order')
                        if original_order_val is None and old_anno.get('storyboard'):
                            original_order_val = old_anno['storyboard'].get('order')
                        if original_order_val is not None:
                            insertion_point = original_order_val
                            if original_part and is_beginning_of_text(original_part['text'], original_text):
                                insertion_point += 1
                            affected_annotations = []
                            num_new_parts = len(new_parts)
                            for anno in self.annotations:
                                if anno.get('id') == old_anno.get('id'):
                                    continue
                                anno_order = anno.get('order')
                                if anno_order is None and anno.get('storyboard') and isinstance(anno['storyboard'], dict):
                                    anno_order = anno['storyboard'].get('order')
                                if anno_order is not None and anno_order >= insertion_point:
                                    affected_annotations.append(anno)
                            affected_annotations.sort(key=lambda a: a.get('order', a.get('storyboard', {}).get('order', 0)), reverse=True)
                            for anno in affected_annotations:
                                current_order = anno.get('order')
                                storyboard_order = None
                                if isinstance(anno.get('storyboard'), dict):
                                    storyboard_order = anno['storyboard'].get('order')
                                if current_order is not None:
                                    anno['order'] = current_order + num_new_parts
                                if storyboard_order is not None and anno.get('storyboard'):
                                    anno['storyboard']['order'] = storyboard_order + num_new_parts
                            for i, np in enumerate(new_parts):
                                if not np['text'] or np['text'].strip() == '':
                                    print("DEBUG: Skipping creation of annotation with empty text")
                                    continue
                                is_beginning = is_beginning_of_text(np['text'], original_text)
                                print(f"DEBUG: New part {i} '{np['text']}' is at beginning: {is_beginning}")
                                if is_beginning:
                                    new_order = original_order_val
                                    print(f"DEBUG: Assigning original order {new_order} to beginning part")
                                else:
                                    new_order = original_order_val + 1
                                    print(f"DEBUG: Assigning incremented order {new_order} to non-beginning part")
                                new_anno_id = np['annotationId']
                                new_anno = {
                                    'id': new_anno_id,
                                    'text': np['text'],
                                    'scene': np['scene'],
                                    'notes': current_metadata['notes'],
                                    'notes_html': current_metadata['notes_html'],
                                    'used': current_metadata['used'],
                                    'favorite': current_metadata['favorite'],
                                    'speech_title': current_metadata.get('speech_title', ''),
                                    'tags': current_metadata.get('tags', []),
                                    'secondary_scenes': old_anno.get('secondary_scenes', []),
                                    'timestamp': datetime.datetime.now().isoformat(),
                                    'storyboard': {
                                        'order': new_order,
                                        'text': np['text']
                                    }
                                }
                                # Sanitize secondary_scenes (remove primary if present, filter invalid, dedupe)
                                try:
                                    sec = new_anno.get('secondary_scenes') or []
                                    if not isinstance(sec, list):
                                        sec = []
                                    sec = [s for s in sec if s != new_anno['scene']]
                                    valid = set(self.scene_styles.keys())
                                    sec = [s for s in sec if s in valid]
                                    seen = set()
                                    cleaned = []
                                    for s in sec:
                                        if s not in seen:
                                            seen.add(s)
                                            cleaned.append(s)
                                    new_anno['secondary_scenes'] = cleaned
                                except Exception as _e:
                                    print(f"DEBUG: sanitize secondary_scenes for storyboard split failed: {_e}")

                                # Handle strikethrough segments based on preservation choice
                                # MODIFIED: Handle strikethrough segments and positional data SEPARATELY with deep copies
                                if preserve_strikethroughs:
                                    # Handle traditional segments with deep copy
                                    if preserved_metadata.get('strikethrough_segments'):
                                        new_anno['storyboard']['strikethrough_segments'] = copy.deepcopy(
                                            preserved_metadata['strikethrough_segments']
                                        )
                                        print(f"DEBUG: Applied {len(preserved_metadata['strikethrough_segments'])} traditional strikethrough segments")
                                    else:
                                        new_anno['storyboard']['strikethrough_segments'] = {}

                                    # Handle positional data separately from traditional segments with deep copy
                                    if preserved_metadata.get('positional_strikethrough'):
                                        new_anno['storyboard']['positional_strikethrough'] = copy.deepcopy(
                                            preserved_metadata['positional_strikethrough']
                                        )
                                        print(f"DEBUG: Applied positional strikethrough data with {len(preserved_metadata['positional_strikethrough'])} segments")
                                    else:
                                        # Check original backup as fallback
                                        positional_data = {}
                                        for ann_id, pos_data in original_positional_backup.items():
                                            positional_data.update(copy.deepcopy(pos_data))

                                        if positional_data:
                                            new_anno['storyboard']['positional_strikethrough'] = positional_data
                                            print(f"DEBUG: Applied fallback positional data with {len(positional_data)} segments")
                                        else:
                                            new_anno['storyboard']['positional_strikethrough'] = {}
                                else:
                                    # Initialize empty structures when not preserving
                                    new_anno['storyboard']['strikethrough_segments'] = {}
                                    new_anno['storyboard']['positional_strikethrough'] = {}
                                    print("DEBUG: Initialized empty strikethrough data (preserving disabled)")

                                # Apply header to beginning parts if header preservation is enabled
                                if should_preserve_header and header_to_apply and is_beginning:
                                    print(f"DEBUG: Adding header to beginning new part: {np['text'][:30]}...")
                                    new_anno['storyboard']['text'] = apply_header_to_text(np['text'].replace('\n', '<br>'), header_to_apply)
                                    header_applied_to_maintain_continuity = True
                                elif not should_preserve_header:
                                    # Ensure header is removed even from new parts
                                    new_anno['storyboard']['text'] = remove_header_from_text(np['text'].replace('\n', '<br>'))
                                else:
                                    # No header processing needed, just set text with line breaks converted
                                    new_anno['storyboard']['text'] = np['text'].replace('\n', '<br>')
                    
                                new_anno['order'] = new_order
                                self.annotations.append(new_anno)
                                self._reassignment_added_annotations.append(new_anno.copy())  # Track addition
                                
                                # Emit for storyboard updates but theme view handled by targeted updates
                                print(f"DEBUG: Emitting annotation_added for storyboard sync: {new_anno['id']}")
                                print(f"🔥🔥🔥🔥🔥 ANNOTATION EMIT TRACEBACK FOR {new_anno.get('id')} 🔥🔥🔥🔥🔥")
                        import traceback
                        traceback.print_stack()
                        print(f"🔥🔥🔥🔥🔥 END EMIT TRACEBACK 🔥🔥🔥🔥🔥")
                        self.annotation_added.emit(json.dumps(new_anno))
                    else:
                        for i, np in enumerate(new_parts):
                            if not np['text'] or np['text'].strip() == '':
                                print("DEBUG: Skipping creation of annotation with empty text")
                                continue
                            is_beginning = is_beginning_of_text(np['text'], original_text)
                            print(f"DEBUG: New part {i} '{np['text']}' is at beginning: {is_beginning}")
                            new_anno_id = np['annotationId']
                            new_anno = {
                                'id': new_anno_id,
                                'text': np['text'],
                                'scene': np['scene'],
                                'notes': current_metadata['notes'],
                                'notes_html': current_metadata['notes_html'],
                                'used': current_metadata['used'],
                                'favorite': current_metadata['favorite'],
                                'speech_title': current_metadata.get('speech_title', ''),
                                'tags': current_metadata.get('tags', []),
                                'secondary_scenes': old_anno.get('secondary_scenes', []),
                                'timestamp': datetime.datetime.now().isoformat()
                            }
                            # Sanitize secondary_scenes (remove primary if present, filter invalid, dedupe)
                            try:
                                sec = new_anno.get('secondary_scenes') or []
                                if not isinstance(sec, list):
                                    sec = []
                                sec = [s for s in sec if s != new_anno['scene']]
                                valid = set(self.scene_styles.keys())
                                sec = [s for s in sec if s in valid]
                                seen = set()
                                cleaned = []
                                for s in sec:
                                    if s not in seen:
                                        seen.add(s)
                                        cleaned.append(s)
                                new_anno['secondary_scenes'] = cleaned
                            except Exception as _e:
                                print(f"DEBUG: sanitize secondary_scenes for non-storyboard split failed: {_e}")
                            if 'storyboard' in old_anno:
                                next_order = self.get_next_script_order()
                                new_anno['storyboard'] = {
                                    'order': next_order,
                                    'text': np['text'],
                                    'strikethrough_segments': {}  # Initialize empty
                                }

                                # Assign both traditional and positional strikethrough data if preserving
                                # MODIFIED: Handle strikethrough segments and positional data SEPARATELY with deep copies
                                if preserve_strikethroughs:
                                    # Handle traditional segments with deep copy
                                    if preserved_metadata.get('strikethrough_segments'):
                                        new_anno['storyboard']['strikethrough_segments'] = copy.deepcopy(
                                            preserved_metadata['strikethrough_segments']
                                        )
                                        print(f"DEBUG: Applied {len(preserved_metadata['strikethrough_segments'])} traditional strikethrough segments")
                                    else:
                                        # Keep the empty initialization from above
                                        pass

                                    # Handle positional data separately with deep copy
                                    if preserved_metadata.get('positional_strikethrough'):
                                        new_anno['storyboard']['positional_strikethrough'] = copy.deepcopy(
                                            preserved_metadata['positional_strikethrough']
                                        )
                                        print(f"DEBUG: Applied positional strikethrough data with {len(preserved_metadata['positional_strikethrough'])} segments")
                                    else:
                                        # Use backup data as fallback
                                        positional_data = {}
                                        for ann_id, pos_data in original_positional_backup.items():
                                            positional_data.update(copy.deepcopy(pos_data))

                                        if positional_data:
                                            new_anno['storyboard']['positional_strikethrough'] = positional_data
                                            print(f"DEBUG: Applied fallback positional data with {len(positional_data)} segments")
                                        else:
                                            new_anno['storyboard']['positional_strikethrough'] = {}
                                else:
                                    # Initialize empty positional structure when not preserving
                                    new_anno['storyboard']['positional_strikethrough'] = {}
                                    print("DEBUG: Initialized empty positional strikethrough data (preserving disabled)")

                                # Apply header to beginning parts if header preservation is enabled
                                if should_preserve_header and header_to_apply and is_beginning:
                                    print(f"DEBUG: Adding header to beginning new part (no order): {np['text'][:30]}...")
                                    new_anno['storyboard']['text'] = apply_header_to_text(np['text'].replace('\n', '<br>'), header_to_apply)
                                    header_applied_to_maintain_continuity = True
                                elif not should_preserve_header:
                                    # Ensure header is removed even from new parts
                                    new_anno['storyboard']['text'] = remove_header_from_text(np['text'].replace('\n', '<br>'))
                                else:
                                    # No header processing needed, just set text with line breaks converted
                                    new_anno['storyboard']['text'] = np['text'].replace('\n', '<br>')
                    
                                if 'order' in old_anno:
                                    new_anno['order'] = next_order
                            # Sanity check: Verify annotation has required attributes
                            if not new_anno.get('id') or not new_anno.get('text'):
                                print(f"ERROR: Invalid annotation created - missing ID or text: {new_anno}")
                                continue
                                
                            # Sanity check: Verify annotation has proper class and data attributes in DOM
                            # (This would be verified by the JavaScript when highlighting)
                            
                            self.annotations.append(new_anno)
                            self._reassignment_added_annotations.append(new_anno.copy())  # Track addition
                            
                            # Emit for storyboard updates but theme view handled by targeted updates
                            print(f"DEBUG: Emitting annotation_added for storyboard sync: {new_anno['id']}")
                            print(f"🔥🔥🔥🔥🔥 ANNOTATION EMIT TRACEBACK FOR {new_anno.get('id')} 🔥🔥🔥🔥🔥")
                            import traceback
                            traceback.print_stack()
                            print(f"🔥🔥🔥🔥🔥 END EMIT TRACEBACK 🔥🔥🔥🔥🔥")
                            self.annotation_added.emit(json.dumps(new_anno))

            if had_changes:
                # Use targeted theme view updates instead of full rebuild
                main_window = self.window()
                if main_window and hasattr(main_window, 'handle_reassignment_theme_view_updates') and main_window.theme_view:
                    # Collect the changes that happened during reassignment
                    removed_ids = getattr(self, '_reassignment_removed_ids', [])
                    updated_annotations = getattr(self, '_reassignment_updated_annotations', [])
                    added_annotations = getattr(self, '_reassignment_added_annotations', [])
                    
                    print(f"DEBUG: Calling targeted reassignment update with {len(removed_ids)} removed, {len(updated_annotations)} updated, {len(added_annotations)} added")
                    main_window.handle_reassignment_theme_view_updates(removed_ids, updated_annotations, added_annotations)
                    
                    # Capture annotation IDs before clearing the tracking lists - include both updated and added
                    updated_ids = [anno.get('id') for anno in updated_annotations if anno.get('id')]
                    added_ids = [anno.get('id') for anno in added_annotations if anno.get('id')]
                    self.captured_new_annotation_ids = updated_ids + added_ids
                    print(f"=== DEBUG: Captured {len(updated_ids)} updated + {len(added_ids)} added = {len(self.captured_new_annotation_ids)} total annotation IDs: {self.captured_new_annotation_ids} ===")
                    
                    # Don't clear tracking lists yet - they're needed for selection logic in _finish_reassignment_context
                    # self._reassignment_removed_ids = []
                    # self._reassignment_updated_annotations = []
                    # self._reassignment_added_annotations = []
                else:
                    # Fallback to the existing method if targeted update not available
                    # Still capture annotation IDs for the signal - include both updated and added
                    updated_annotations = getattr(self, '_reassignment_updated_annotations', [])
                    added_annotations = getattr(self, '_reassignment_added_annotations', [])
                    updated_ids = [anno.get('id') for anno in updated_annotations if anno.get('id')]
                    added_ids = [anno.get('id') for anno in added_annotations if anno.get('id')]
                    self.captured_new_annotation_ids = updated_ids + added_ids
                    print(f"=== DEBUG: Captured {len(updated_ids)} updated + {len(added_ids)} added = {len(self.captured_new_annotation_ids)} total annotation IDs (fallback): {self.captured_new_annotation_ids} ===")
                    # Removed update_theme_view_if_available() - using targeted updates instead of full rebuild

            text_to_highlight = selection_info.get('text', '') if selection_info else ''
            if not text_to_highlight or text_to_highlight.strip() == '':
                print("DEBUG: Skipping creation of main annotation with empty or whitespace-only text")
                return

            # Always create a new annotation, regardless of "Preserve Text" setting
            print(f"\nCreating new highlight:\nText: {text_to_highlight}\nScene: {scene}")

            # Create a modified version of preserved_metadata that will control
            # whether the new annotation gets a storyboard entry
            new_annotation_metadata = preserved_metadata.copy() if preserved_metadata else {}
            
            # Gather tags from all removed annotations to ensure they transfer to the middle span
            if removed_spans:
                combined_tags = set()
                speech_title_from_removed = ''
                for span_info in removed_spans:
                    annotation_id = span_info.get('annotationId')
                    if annotation_id and annotation_id in old_annotations_by_id:
                        old_anno = old_annotations_by_id[annotation_id]
                        if 'tags' in old_anno and isinstance(old_anno['tags'], list):
                            combined_tags.update(old_anno['tags'])
                        # Gather speech_title from the first annotation that has one
                        if 'speech_title' in old_anno and old_anno['speech_title'] and not speech_title_from_removed:
                            speech_title_from_removed = old_anno['speech_title']
                
                if combined_tags:
                    new_annotation_metadata['tags'] = list(combined_tags)
                    print(f"DEBUG: Gathered tags from removed annotations for middle span: {list(combined_tags)}")
                else:
                    new_annotation_metadata['tags'] = []
                    print("DEBUG: No tags found in removed annotations")
                    
                if speech_title_from_removed:
                    new_annotation_metadata['speech_title'] = speech_title_from_removed
                    print(f"DEBUG: Gathered speech_title from removed annotations for middle span: {speech_title_from_removed}")
                else:
                    print("DEBUG: No speech_title found in removed annotations")
            else:
                new_annotation_metadata['tags'] = []

            # For normal assignments (or when "Preserve Text" is checked), skip storyboard creation
            if is_normal_assignment or use_current_text:
                print("DEBUG: Normal assignment or 'Preserve Text' is checked - creating annotation WITHOUT storyboard entry")
                # Flag used by create_new_annotation_and_highlight to skip storyboard creation
                new_annotation_metadata['skip_storyboard_creation'] = True

            # Merge secondary_scenes from preserved metadata and removed annotations for the new middle annotation
            try:
                merged_sec = []
                seen_sec = set()
                # From preserved_metadata captured earlier
                if preserved_metadata and isinstance(preserved_metadata.get('secondary_scenes'), list):
                    for s in preserved_metadata.get('secondary_scenes'):
                        if s not in seen_sec:
                            seen_sec.add(s)
                            merged_sec.append(s)
                # From removed annotations
                if removed_spans:
                    for span_info in removed_spans:
                        ann_id = span_info.get('annotationId')
                        if ann_id and ann_id in old_annotations_by_id:
                            sec_list = old_annotations_by_id[ann_id].get('secondary_scenes', [])
                            if isinstance(sec_list, list):
                                for s in sec_list:
                                    if s not in seen_sec:
                                        seen_sec.add(s)
                                        merged_sec.append(s)
                # Sanitize against current scene list and remove the new primary scene
                if merged_sec:
                    valid = set(self.scene_styles.keys())
                    merged_sec = [s for s in merged_sec if s in valid and s != scene]
                    # Dedupe preserving order (already done by seen_sec)
                    new_annotation_metadata['secondary_scenes'] = merged_sec
                    print(f"DEBUG: Merged secondary_scenes for middle annotation: {merged_sec}")
            except Exception as _e:
                print(f"DEBUG: merging secondary_scenes for middle annotation failed: {_e}")

            # Sanity check: Verify text length consistency before creating annotation
            if updated_spans or removed_spans:
                total_original_length = sum(len(span.get('text', '')) for span in removed_spans)
                total_new_length = (len(text_to_highlight or '') + 
                                  sum(len(span.get('text', '')) for span in updated_spans))
                
                print(f"DEBUG: Text length sanity check - Original: {total_original_length}, New: {total_new_length}")
                
                # Don't fail on minor differences (whitespace/normalization), but log significant issues
                if abs(total_original_length - total_new_length) > 10:
                    print(f"WARNING: Significant text length difference detected! This may indicate a splitting issue.")
                    
            new_annotation = self.create_new_annotation_and_highlight(
                text_to_highlight,
                scene,
                selection_info,
                new_annotation_metadata
            )

            # 🎯 POSITIONAL STRIKETHROUGH CONTEXT DEBUG 🎯
            if new_annotation and new_annotation_metadata:
                positional_data = new_annotation_metadata.get('positional_strikethrough', {})
                if not positional_data:
                    positional_data = new_annotation_metadata.get('positionalStrikethrough', {})
                
                if positional_data:
                    has_context = False
                    for segment_key, segment_data in positional_data.items():
                        context_before = segment_data.get('context_before', '')
                        context_after = segment_data.get('context_after', '')
                        if context_before or context_after:
                            has_context = True
                            print("🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯 POSITIONAL STRIKETHROUGH CONTEXT 🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯")
                            print(f"🎯 ANNOTATION ID: {new_annotation.get('id')}")
                            print(f"🎯 SEGMENT: '{segment_key}'")
                            print(f"🎯 CONTEXT_BEFORE: '{context_before}'")
                            print(f"🎯 CONTEXT_AFTER: '{context_after}'")
                            print("🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯")
                    
                    if not has_context:
                        print("💀💀💀💀💀💀💀💀💀💀💀💀 EMPTY POSITIONAL STRIKETHROUGH CONTEXT 💀💀💀💀💀💀💀💀💀💀💀💀")
                        print(f"💀 ANNOTATION ID: {new_annotation.get('id')}")
                        print(f"💀 HAS POSITIONAL DATA BUT NO CONTEXT_BEFORE/CONTEXT_AFTER VALUES")
                        print(f"💀 SEGMENTS: {list(positional_data.keys())}")
                        print("💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀💀")

            # Mark that changes occurred since we created a new annotation
            if new_annotation:
                had_changes = True
                # FIXED: Initialize captured_new_annotation_ids for simple annotation creation
                if not hasattr(self, 'captured_new_annotation_ids'):
                    self.captured_new_annotation_ids = []
                    print("DEBUG: Initialized captured_new_annotation_ids for simple annotation creation")
                
                # Add the annotation to the captured IDs for selection
                if new_annotation.get('id'):
                    if new_annotation['id'] not in self.captured_new_annotation_ids:
                        self.captured_new_annotation_ids.append(new_annotation['id'])
                        print(f"=== DEBUG: Added annotation {new_annotation['id']} to captured IDs. Total: {len(self.captured_new_annotation_ids)} ===")

            # Header handling for the newly created annotation (if applicable)
            if new_annotation:
                if use_current_text:
                    # Remove any storyboard entry that was created when using "Preserve Text"
                    if 'storyboard' in new_annotation:
                        del new_annotation['storyboard']
                        print("DEBUG: Removed storyboard entry from new annotation because Preserve Text is checked")
                        self.annotation_updated.emit(json.dumps(new_annotation))
                elif 'storyboard' in new_annotation:
                    # Only apply header if we should preserve headers and it hasn't been applied or removed yet
                    if should_preserve_header and header_to_apply:
                        # CRITICAL FIX: For middle text removal or when we have updated spans, NEVER apply header to the new annotation
                        if is_middle_text_removal or (len(updated_spans) > 0 and any(u.get('isOriginal') for u in updated_spans)):
                            print("DEBUG: Skipping header for new annotation due to middle text removal or split annotation")
                            # Just ensure we don't have a header on the new annotation
                            if 'text' in new_annotation['storyboard']:
                                existing_header, clean_text = extract_header_from_text(new_annotation['storyboard']['text'])
                                if existing_header:
                                    new_annotation['storyboard']['text'] = clean_text.replace('\n', '<br>')
                                    print("DEBUG: Removed header from new annotation in middle text removal case")
                            self.annotation_updated.emit(json.dumps(new_annotation))
                        # Only apply header if we haven't applied it elsewhere AND this is not a selection in a middle of existing text
                        elif not header_applied_to_maintain_continuity:
                            # No header applied yet anywhere
                            if 'text' not in new_annotation['storyboard'] or not new_annotation['storyboard']['text']:
                                new_annotation['storyboard']['text'] = text_to_highlight.replace('\n', '<br>')
                            new_annotation['storyboard']['text'] = apply_header_to_text(new_annotation['storyboard']['text'], header_to_apply)
                            print(f"DEBUG: Applied header to newly created annotation: {header_to_apply}")
                            header_applied_to_maintain_continuity = True
                            self.annotation_updated.emit(json.dumps(new_annotation))
                        else:
                            # Header already applied elsewhere, never apply it again to a user selection
                            print("DEBUG: Header already applied elsewhere, skipping for user selection")
                            # Ensure no header on the user selection
                            if 'text' in new_annotation['storyboard']:
                                existing_header, clean_text = extract_header_from_text(new_annotation['storyboard']['text'])
                                if existing_header:
                                    new_annotation['storyboard']['text'] = clean_text.replace('\n', '<br>')
                                    print("DEBUG: Removed header from user selection since it should only be on the left span")
                                    self.annotation_updated.emit(json.dumps(new_annotation))
                    elif not should_preserve_header:
                        # Explicitly remove header if preservation is disabled
                        if 'text' in new_annotation['storyboard']:
                            new_annotation['storyboard']['text'] = remove_header_from_text(new_annotation['storyboard']['text'])
                            print("DEBUG: Removed header from newly created annotation as preservation was disabled")
                            self.annotation_updated.emit(json.dumps(new_annotation))
                    elif not should_preserve_header:
                        # Explicitly remove header if preservation is disabled
                        if 'text' in new_annotation['storyboard']:
                            new_annotation['storyboard']['text'] = remove_header_from_text(new_annotation['storyboard']['text'])
                            print("DEBUG: Removed header from newly created annotation as preservation was disabled")
                            self.annotation_updated.emit(json.dumps(new_annotation))
            # Direct theme view addition only - signals handle storyboard functionality
            self.main_window.add_annotation_to_theme_view_direct(new_annotation)

            if hasattr(self.main_window, 'theme_view') and self.main_window.theme_view and hasattr(self.main_window, 'scene_tabs') and self.main_window.scene_tabs:
                ordered_scenes = list(self.scene_styles.keys())
                scene_tab_index = ordered_scenes.index(scene) if scene in ordered_scenes else len(ordered_scenes)
                self.main_window.mark_changes_pending()
                existing_tab_index = -1
                for i in range(self.main_window.scene_tabs.count()):
                    if self.main_window.scene_tabs.tabText(i) == scene:
                        existing_tab_index = i
                        scene_tab_index = existing_tab_index
                        break
                if existing_tab_index >= 0:
                    # Check if filters are active before navigation - prevent navigating to filtered annotations
                    search_widget = self.main_window.theme_view.findChild(ThemeViewSearch) if hasattr(self.main_window, 'theme_view') and self.main_window.theme_view else None
                    filters_active = False
                    
                    if search_widget:
                        active_search = bool(getattr(search_widget, 'current_search_text', "")) and getattr(search_widget, 'search_confirmed', False)
                        favorites_only = getattr(search_widget, 'favorites_only', False)
                        hide_used = getattr(search_widget, 'hide_used', 0)
                        selected_tags = getattr(search_widget, 'selected_tags', set())
                        selected_headers = getattr(search_widget, 'selected_headers', set())
                        selected_themes = getattr(search_widget, 'selected_themes', set())
                        
                        filters_active = active_search or favorites_only or hide_used != 0 or selected_tags or selected_headers or selected_themes
                        print(f"DEBUG ANNOTATION CREATION: search={active_search}, favorites={favorites_only}, hide_used={hide_used}, tags={selected_tags}, headers={selected_headers}, themes={selected_themes}, filters_active={filters_active}")
                    else:
                        print(f"DEBUG ANNOTATION CREATION: No search widget found")
                    
                    if not filters_active:
                        print(f"DEBUG: Navigation to tab {scene_tab_index} for scene {scene}")
                        
                        # Check if theme view is visible - if not, defer navigation
                        if (hasattr(self.main_window, 'theme_view') and 
                            self.main_window.theme_view and 
                            self.main_window.theme_view.isVisible()):
                            
                            # Theme view is visible - navigate immediately
                            self.main_window.scene_tabs.setCurrentIndex(scene_tab_index)
                            scene_widget = self.main_window.scene_tabs.widget(scene_tab_index)
                            if scene_widget is not None:
                                QTimer.singleShot(200, lambda: scene_widget.scrollToBottom())
                            print("DEBUG: Navigated immediately (theme view visible)")
                        else:
                            # Theme view is not visible - store navigation for later
                            self.main_window._pending_navigation = {
                                'scene': scene,
                                'scene_tab_index': scene_tab_index
                            }
                            print("DEBUG: Stored navigation for later (theme view hidden)")
                    else:
                        print(f"DEBUG: NAVIGATION SKIPPED IN ANNOTATION CREATION - Filters are active, not navigating to annotation that would be filtered")

            print("\n=== STRIKETHROUGH INVENTORY BEFORE IMPROVE_STRIKETHROUGH_AND_APPLY_CHANGES ===")
            for anno in self.annotations:
                anno_id = anno.get('id', 'unknown')
                if 'storyboard' in anno and 'strikethrough_segments' in anno['storyboard']:
                    segments = anno['storyboard']['strikethrough_segments']
                    if segments:
                        print(f"Annotation ID: {anno_id}")
                        print(f"  Text: {anno.get('text', '')[:50]}...")
                        print(f"  Strikethrough segments: {segments}")
                        if 'positional_strikethrough' in anno['storyboard']:
                            print(f"  Positional strikethrough data: {anno['storyboard']['positional_strikethrough']}")
                        print()
            print("=== END STRIKETHROUGH INVENTORY BEFORE IMPROVE_STRIKETHROUGH_AND_APPLY_CHANGES ===\n")

            self.main_window.storyboard_dialog._strikethrough_improvements_pending = True

            # Note: We'll emit the reassignment_completed signal at the end after all annotations are created
            debug_info = results.get('debugInfo')
            if debug_info:
                print("Debug Information:", debug_info)

            if had_changes and hasattr(self.main_window, 'storyboard_dialog') and self.main_window.storyboard_dialog:
                # Check if the dialog is in the process of closing
                print("DEBUG: Updating storyboard dialog with improved strikethrough handling")
                QTimer.singleShot(150, self.main_window.storyboard_dialog.apply_changes_lite)
            else:
                print("DEBUG: Skipping storyboard dialog update as no reassignment occurred or no changes made")

            # Sanity check: Verify final annotation count and consistency
            final_annotation_count = len(self.annotations)
            removed_count = len(self._reassignment_removed_ids)
            updated_count = len(self._reassignment_updated_annotations)
            added_count = len(self._reassignment_added_annotations)
            
            print(f"DEBUG: Operation summary - Initial: {initial_annotation_count}, Final: {final_annotation_count}")
            print(f"DEBUG: Changes - Removed: {removed_count}, Updated: {updated_count}, Added: {added_count}")
            
            # Emit final reassignment signal with all annotation IDs including the middle one
            if hasattr(self, 'captured_new_annotation_ids') and self.captured_new_annotation_ids:
                print(f"=== DEBUG: Final reassignment signal with all {len(self.captured_new_annotation_ids)} annotation IDs (left + right + middle): {self.captured_new_annotation_ids} ===")
                self.reassignment_completed.emit(self.captured_new_annotation_ids)      
            
            # Verify annotation IDs are unique
            annotation_ids = [anno.get('id') for anno in self.annotations if anno.get('id')]
            if len(annotation_ids) != len(set(annotation_ids)):
                print("ERROR: Duplicate annotation IDs detected after reassignment!")
                
            # Verify all annotations have required fields
            invalid_annotations = [anno for anno in self.annotations if not anno.get('id') or not anno.get('text')]
            if invalid_annotations:
                print(f"ERROR: {len(invalid_annotations)} invalid annotations found after reassignment!")
                
            # 🔧 RACE CONDITION FIX: Process reassignment completion synchronously
            # Emit the signal immediately - storyboard will check flags before we clear them
            print("🔧 SYNC FIX: Processing reassignment completion synchronously")
            
            # The reassignment_completed signal is already emitted above (line 54583)
            # Now handle the completion synchronously to avoid race conditions
            if hasattr(self.main_window, 'handle_reassignment_completed'):
                print("🔧 SYNC FIX: Calling handle_reassignment_completed directly")
                self.main_window.handle_reassignment_completed(self.captured_new_annotation_ids if hasattr(self, 'captured_new_annotation_ids') else [])
            
            # Only clear flags AFTER storyboard has been processed
            print("🔧 SYNC FIX: Clearing flags after storyboard processing")
            self._finish_reassignment_context()
            self._clear_reassignment_flag()
            
            # Restore normal cursor - processing complete
            self.hide_processing_cursor()
            
            print("💥💥💥💥💥💥💥💥💥💥💥💥 HANDLE_REMOVAL_AND_REASSIGN END 💥💥💥💥💥💥💥💥💥💥💥💥")
            print("💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥💥")
            print("=== HANDLE REMOVAL AND REASSIGN END ===\n")
            # In handle_removal_and_reassign:

            # Add our new debug code here to list annotations with strikethrough segments
            print("\n=== DEBUG: STRIKETHROUGH SEGMENTS INVENTORY ===")
            for anno in self.annotations:
                anno_id = anno.get('id', 'unknown')
                if 'storyboard' in anno and 'strikethrough_segments' in anno['storyboard']:
                    segments = anno['storyboard']['strikethrough_segments']
                    if segments:
                        print(f"Annotation ID: {anno_id}")
                        #print(f"  Text: {anno.get('text', '')[:50]}...")
                        #print(f"  Strikethrough segments: {segments}")
                        if 'positional_strikethrough' in anno['storyboard']:
                            print(f"  Positional strikethrough data: {anno['storyboard']['positional_strikethrough']}")
                        print()
            print("=== END STRIKETHROUGH SEGMENTS INVENTORY ===\n")


        # StoryboardDialog should already exist from main window initialization
        # Safety check in case initialization failed
        if self.main_window and (not hasattr(self.main_window, 'storyboard_dialog') or not self.main_window.storyboard_dialog):
            self.main_window.ensure_storyboard_dialog_hidden()

        self.page().runJavaScript(removal_check_js, lambda results: handle_removal_check(results))

    def get_next_script_order(self):
        """Find the next available order number for script editor entries"""
        max_order = 0
    
        # Find the highest existing order number
        for anno in self.annotations:
            # Check both 'order' property and storyboard order
            anno_order = anno.get('order')
            if anno_order is not None and anno_order > max_order:
                max_order = anno_order
            
            storyboard = anno.get('storyboard', {})
            if storyboard and storyboard.get('order') is not None:
                if storyboard['order'] > max_order:
                    max_order = storyboard['order']
    
        # Return the next sequential number
        return max_order + 1

    # Add the truncation function at the top
    def truncate_storyboard_text(self, text, max_length=25):
        """
        Truncates text to show first and last 25 characters with ellipsis in middle.
        Strips HTML tags for display.
        """
        import re
        text = re.sub(r'<[^>]+>', '', text)
        text = text.replace('\n', ' ').strip()

        if not text or len(text) <= (max_length * 2):
            return text
    
        start = text[:max_length]
        end = text[-max_length:]
        return f"{start}...{end}"

    def get_surrounding_context(self, selection_info):
        """Extract surrounding context from selection info."""
        if not selection_info or 'context' not in selection_info:
            return None
        
        context = selection_info.get('context', {})
        return {
            'before': context.get('before', ''),
            'text': context.get('text', ''),
            'after': context.get('after', '')
        }

    def get_next_script_order(self):
        """Find the next available order number for script editor entries"""
        max_order = 0
    
        # Find the highest existing order number
        for anno in self.annotations:
            # Check both 'order' property and storyboard order
            anno_order = anno.get('order')
            if anno_order is not None and anno_order > max_order:
                max_order = anno_order
            
            storyboard = anno.get('storyboard', {})
            if storyboard and storyboard.get('order') is not None:
                if storyboard['order'] > max_order:
                    max_order = storyboard['order']
    
        # Return the next sequential number
        return max_order + 1

    def create_new_annotation_and_highlight(self, text, scene, selection_info=None, preserved_metadata=None):
        """
        Create a new annotation for given text and scene, then highlight it.
        This function respects the skip_storyboard_creation flag in preserved_metadata.
        """
        print("⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ CREATE_NEW_ANNOTATION_AND_HIGHLIGHT START ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐")
        print(f"⭐ text length: {len(text) if text else 0}, scene: {scene}")
        print(f"⭐ selection_info available: {bool(selection_info)}, preserved_metadata available: {bool(preserved_metadata)}")
        print("⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐")
        import uuid  # ensure uuid is imported if not already

        # 🎯🔄 SHOW PROCESSING CURSOR for annotation creation
        print("🎯🔄 ANNOTATION CREATION: Showing processing cursor!")
        self.show_processing_cursor()

        print("\n=== CREATE NEW ANNOTATION AND HIGHLIGHT START ===")
        print(f"Text: {text}")
        print(f"Scene: {scene}")
        print(f"Selection Info Available: {bool(selection_info)}")
        print(f"Preserved Metadata Available: {bool(preserved_metadata)}")
        
        # Detailed debug of preserved_metadata if available
        has_substantive_content = False
        if preserved_metadata:
            print("DEBUG: Full preserved_metadata contents:")
            print(json.dumps(preserved_metadata, indent=2))
            
            # Check for substantive content in preserved_metadata - with better logic
            
            # Check for non-empty text content
            if preserved_metadata.get('notes') or preserved_metadata.get('notes_html'):
                has_substantive_content = True
                print("DEBUG: Found substantive content: notes or notes_html")
                
            # Check for non-default boolean flags
            if preserved_metadata.get('used', False) or preserved_metadata.get('favorite', False):
                has_substantive_content = True
                print("DEBUG: Found substantive content: used or favorite flags set")
                
            # Check for non-empty dictionaries with actual content (not just empty objects)
            for key in ['storyboard', 'strikethrough_segments', 'positional_strikethrough', 'positionalStrikethrough']:
                if key in preserved_metadata and preserved_metadata[key]:
                    # For dictionaries, check if they have any actual content (not just empty objects)
                    if isinstance(preserved_metadata[key], dict):
                        # First check if it's not an empty dict
                        if preserved_metadata[key] != {}:
                            # Then check if it contains any non-empty values
                            has_non_empty_values = False
                            for k, v in preserved_metadata[key].items():
                                if v and (not isinstance(v, dict) or v != {}):
                                    has_non_empty_values = True
                                    break
                            
                            if has_non_empty_values:
                                has_substantive_content = True
                                print(f"DEBUG: Found substantive content: non-empty {key} with actual values")
                    else:
                        # If it's not a dict but it has a value, consider it substantive
                        has_substantive_content = True
                        print(f"DEBUG: Found substantive content: {key} with non-dict value")
                        
            print(f"DEBUG: preserved_metadata has substantive content: {has_substantive_content}")

        # Check if this is a reassignment (skip auto-filling for reassignments)
        is_reassignment = preserved_metadata is not None
        is_substantive_reassignment = preserved_metadata is not None and has_substantive_content
        
        print(f"DEBUG: is_reassignment (original logic): {is_reassignment}")
        print(f"DEBUG: is_substantive_reassignment (new proposed logic): {is_substantive_reassignment}")
        
        # UNCOMMENT THIS LINE TO CHANGE BEHAVIOR
        is_reassignment = is_substantive_reassignment

        # Check if we should skip storyboard creation (i.e., when "Preserve Text" is checked)
        skip_storyboard = False
        if preserved_metadata and preserved_metadata.get('skip_storyboard_creation'):
            skip_storyboard = True
            print(f"DEBUG: Will skip storyboard creation because skip_storyboard_creation flag is set")

        # Check if this exact text already exists as an annotation
        existing_annotation = None
        for anno in self.annotations:
            # Skip dividers
            if anno.get('divider', False):
                continue
    
            # Check for exact text match (ignoring whitespace differences)
            if anno.get('text', '').strip() == text.strip():
                existing_annotation = anno
                print(f"\nFound existing annotation with matching text: ID={anno.get('id')}")
    
                # Check if we're just changing the scene
                if anno.get('scene') != scene:
                    print(f"Updating scene from {anno.get('scene')} to {scene}")
                    anno['scene'] = scene
                    # Sanitize secondary_scenes: ensure list, remove new primary if present, and filter invalid
                    try:
                        sec = anno.get('secondary_scenes')
                        if not isinstance(sec, list):
                            sec = [] if sec is None else list(sec) if isinstance(sec, (set, tuple)) else []
                        # Remove new primary scene if present
                        sec = [s for s in sec if s != scene]
                        # Filter to valid scenes
                        valid = set(self.scene_styles.keys())
                        sec = [s for s in sec if s in valid]
                        # Dedupe while preserving order
                        seen = set()
                        cleaned = []
                        for s in sec:
                            if s not in seen:
                                seen.add(s)
                                cleaned.append(s)
                        anno['secondary_scenes'] = cleaned
                    except Exception as _e:
                        print(f"DEBUG: sanitize secondary_scenes on scene change failed: {_e}")
                    # Preserve existing storyboard if available
                    if 'storyboard' in anno:
                        print(f"Preserving existing storyboard data: {anno['storyboard']}")
                    self.highlight_text(text, scene, anno['id'], selection_info, anno)
                    self.annotation_updated.emit(json.dumps(anno))
                    self.scenes_updated.emit()
                    print("=== UPDATED EXISTING ANNOTATION SCENE ===\n")
                    return anno
                else:
                    # Same scene, just re-highlight
                    self.highlight_text(text, scene, anno['id'], selection_info, anno)
                    print("=== RE-HIGHLIGHTED EXISTING ANNOTATION ===\n")
                    return anno

        # No existing annotation, so create a new one.
        new_annotation_id = str(uuid.uuid4())
        print(f"DEBUG: Creating new annotation with preserved_metadata: {preserved_metadata}")
        notes_from_preserved = preserved_metadata.get('notes', '') if preserved_metadata else ''
        notes_html_from_preserved = preserved_metadata.get('notes_html', '') if preserved_metadata else ''
        print(f"📝 APPLYING PRESERVED NOTES: notes='{notes_from_preserved}', notes_html='{notes_html_from_preserved}'")
        
        # Build initial secondary_scenes from preserved metadata (union across possible sources)
        preserved_secondary = []
        try:
            if preserved_metadata and isinstance(preserved_metadata.get('secondary_scenes'), list):
                preserved_secondary = preserved_metadata.get('secondary_scenes') or []
        except Exception:
            preserved_secondary = []

        # Sanitize secondary scenes against current scene list and primary
        try:
            valid = set(self.scene_styles.keys())
            preserved_secondary = [s for s in preserved_secondary if s in valid and s != scene]
            seen = set()
            tmp = []
            for s in preserved_secondary:
                if s not in seen:
                    seen.add(s)
                    tmp.append(s)
            preserved_secondary = tmp
        except Exception as _e:
            print(f"DEBUG: sanitize preserved secondary_scenes failed: {_e}")

        new_annotation = {
            'id': new_annotation_id,
            # Store raw text for the main annotation; do NOT convert newlines here
            'text': text,
            'scene': scene,
            'notes': notes_from_preserved,
            'notes_html': notes_html_from_preserved,
            'used': preserved_metadata.get('used', False) if preserved_metadata else False,
            'favorite': preserved_metadata.get('favorite', False) if preserved_metadata else False,
            'speech_title': preserved_metadata.get('speech_title', '') if preserved_metadata else '',
            'tags': preserved_metadata.get('tags', []) if preserved_metadata else [],
            'timestamp': datetime.datetime.now().isoformat(),
            'secondary_scenes': preserved_secondary
        }
        print(f"DEBUG: New annotation created with tags: {new_annotation['tags']}")

        # Only add storyboard entry if we're not skipping it
        if not skip_storyboard:
            print("DEBUG: Adding storyboard entry to new annotation")
            new_annotation['storyboard'] = {'text': text.replace('\n', '<br>')}
    
            # If preserved_metadata provides storyboard data, merge it into the new annotation.
            if preserved_metadata:
                # Merge any preserved storyboard data.
                preserved_storyboard = preserved_metadata.get('storyboard', {})
                new_annotation['storyboard'].update(preserved_storyboard)
                # Ensure storyboard text has proper line break conversion if it was preserved
                if 'text' in new_annotation['storyboard']:
                    new_annotation['storyboard']['text'] = new_annotation['storyboard']['text'].replace('\n', '<br>')
            
                # Forcefully set the full strikethrough segments from preserved metadata.
                if 'strikethrough_segments' in preserved_metadata:
                    new_annotation['storyboard']['strikethrough_segments'] = preserved_metadata['strikethrough_segments']
                    print(f"DEBUG: Preserved {len(preserved_metadata['strikethrough_segments'])} strikethrough segments")
            
                # ADDED: Also preserve positional strikethrough data 
                # ADDED: Also preserve positional strikethrough data (handle both cases)
                if 'positional_strikethrough' in preserved_metadata:
                    new_annotation['storyboard']['positional_strikethrough'] = preserved_metadata['positional_strikethrough']
                    print(f"DEBUG: Preserved positional strikethrough data with {len(preserved_metadata['positional_strikethrough'])} entries")
                elif 'positionalStrikethrough' in preserved_metadata:
                    # Convert camelCase to snake_case for consistency
                    new_annotation['storyboard']['positional_strikethrough'] = preserved_metadata['positionalStrikethrough']
                    print(f"DEBUG: Preserved positional strikethrough data (camelCase) with {len(preserved_metadata['positionalStrikethrough'])} entries")
            
                # Optionally, also preserve order if provided.
                if preserved_metadata.get('order') is not None:
                    new_annotation['order'] = preserved_metadata['order']
        else:
            print("DEBUG: Skipping storyboard entry creation because skip_storyboard_creation is True")

        # Add context information if available
        if selection_info:
            print("\nProcessing Selection Info:")
            context = selection_info.get('context', {})
            if context:
                new_annotation['context'] = {
                    'before': context.get('before', ''),
                    'text': context.get('text', ''),
                    'after': context.get('after', '')
                }
                print(f"\nStored Context in Annotation: {json.dumps(new_annotation['context'], indent=2)}")
            if 'location' in selection_info:
                new_annotation['location'] = selection_info['location']
                print(f"Stored Location in Annotation: {json.dumps(new_annotation['location'], indent=2)}")

        # Add to annotations list
        self.annotations.append(new_annotation)

        # Tooltips are now initialized automatically after content loads
    
        # DEBUG for auto_fill_notes decision
        print(f"\nDEBUG auto_fill_notes condition:")
        print(f"is_reassignment = {is_reassignment} (preserved_metadata is {None if preserved_metadata is None else 'not None'})")
        if is_substantive_reassignment != is_reassignment:
            print(f"WARNING: Possible issue detected - Preserved metadata exists but contains only control flags, not content to preserve")
        
        # Track if notes were actually filled to call theme view update if needed
        notes_filled = False
        
        # Auto-fill notes if this is not a reassignment
        if not is_reassignment:
            print("DEBUG: auto_fill_notes will be called because this is NOT a reassignment")
            print(f"DEBUG: auto_fill_notes data:")
            print(f"  - new_annotation: {json.dumps({k: v for k, v in new_annotation.items() if k != 'storyboard'}, indent=2)}")
            print(f"  - selection_info available: {bool(selection_info)}")
            if selection_info:
                print(f"  - selection_info: {json.dumps(selection_info, indent=2)}")
            
            # Store the original state to check if notes were filled
            original_notes = new_annotation.get('notes', '')
            original_notes_html = new_annotation.get('notes_html', '')
            
            # Call auto_fill_notes
            self.auto_fill_notes(new_annotation, selection_info)
            print("DEBUG: auto_fill_notes call completed")
            
            # Check if notes were actually changed
            if new_annotation.get('notes', '') != original_notes or new_annotation.get('notes_html', '') != original_notes_html:
                notes_filled = True
                print("DEBUG: Notes were actually filled with content by auto_fill_notes")
            else:
                print("DEBUG: Notes remain unchanged after auto_fill_notes call")
        else:
            print("DEBUG: auto_fill_notes will NOT be called because this IS a reassignment")
            # Added additional debug to show what would happen if we used substantive reassignment check instead
            if not is_substantive_reassignment:
                print("DEBUG: HOWEVER, auto_fill_notes WOULD be called if using substantive_reassignment check")
                print("DEBUG: This suggests 'Preserve Text' is causing auto_fill_notes to be skipped unnecessarily")
            print(f"DEBUG: preserved_metadata contains: {json.dumps({k: v for k, v in preserved_metadata.items() if k not in ['storyboard', 'strikethrough_segments', 'positional_strikethrough', 'positionalStrikethrough']}, indent=2)}")

        print("\nPassing to highlight_text:")
        print(f"Text: {text}")
        print(f"Scene: {scene}")
        print(f"Annotation ID: {new_annotation_id}")
        print(f"Selection Info Available: {bool(selection_info)}")
        if selection_info:
            print(f"Context in Selection Info: {json.dumps(selection_info.get('context', {}), indent=2)}")

        # Pass the new annotation to highlight_text to perform the actual highlighting.
        self.highlight_text(text, scene, new_annotation_id, selection_info, new_annotation)

        # If selection info exists, attach it to the annotation.
        if selection_info:
            new_annotation['selectionInfo'] = selection_info

        # Extract speech title asynchronously and emit annotation immediately
        self.extract_speech_title_for_annotation(new_annotation, text)
        
        # Check if we're in reassignment context to avoid double emission
        if not getattr(self, '_in_reassignment_context', False):
            print(f"🔥🔥🔥🔥🔥 ANNOTATION EMIT TRACEBACK FOR {new_annotation.get('id')} 🔥🔥🔥🔥🔥")
            import traceback
            traceback.print_stack()
            print(f"🔥🔥🔥🔥🔥 END EMIT TRACEBACK 🔥🔥🔥🔥🔥")
            self.annotation_added.emit(json.dumps(new_annotation))
            # Removed scenes_updated.emit() - annotation already added to theme view via add_annotation_to_theme_view_direct
        else:
            print(f"DEBUG: Skipping emission for annotation {new_annotation_id} - already handled by reassignment context")
            
            # 🔧 FIX: When skipping emission, still need to set storyboard flag for annotations with order
            if hasattr(self.main_window, 'storyboard_dialog') and self.main_window.storyboard_dialog:
                # CRITICAL: Sync storyboard data FIRST before setting flag
                self.main_window.storyboard_dialog.annotations = self.annotations
                print(f"🔧 DATA SYNC: Updated storyboard annotations list with {len(self.annotations)} annotations")
                
                # Check if this annotation should trigger storyboard update (has order info)
                annotation_has_order = (
                    new_annotation.get('order') is not None or
                    (new_annotation.get('storyboard', {}) and new_annotation.get('storyboard', {}).get('order') is not None)
                )
                
                if annotation_has_order:
                    # Set flag on BOTH objects to ensure it's found
                    self.main_window.storyboard_dialog.last_update_order_list_flag = True
                    self.last_update_order_list_flag = True  # Also set on web_view
                    print(f"🔧 REASSIGNMENT FIX: Set storyboard flag on BOTH objects for skipped annotation {new_annotation_id} with order info")
        
        # If notes were filled, update the theme view
        # if notes_filled:
        #     print("DEBUG: Calling update_theme_view_if_available() because notes were filled")
        #     try:
        #         self.update_theme_view_if_available()
        #     except Exception as e:
        #         print(f"DEBUG: Error calling update_theme_view_if_available: {str(e)}")
        
        # 🎯✅ HIDE PROCESSING CURSOR after annotation creation
        print("🎯✅ ANNOTATION CREATION: Hiding processing cursor!")
        self.hide_processing_cursor()

        print("⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ CREATE_NEW_ANNOTATION_AND_HIGHLIGHT END ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐")
        print("⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐")
        print("=== CREATE NEW ANNOTATION AND HIGHLIGHT END ===\n")
        return new_annotation

    def auto_fill_notes(self, annotation, selection_info):
        """
        Auto-fill the notes field based on settings and selection context.
    
        Args:
            annotation: The annotation dictionary to modify
            selection_info: Selection info containing context
        """
        # DEBUGGING
        print("\n============ DEBUG: AUTO-FILL NOTES START ============")
        print(f"Annotation ID: {annotation.get('id', 'unknown')}")
        print(f"Annotation Notes (before): '{annotation.get('notes', '')}'")
        print(f"Selection Info Available: {bool(selection_info)}")
        if selection_info:
            print(f"Selection Info Type: {type(selection_info)}")
            print(f"Selection Info Keys: {list(selection_info.keys()) if isinstance(selection_info, dict) else 'Not a dict'}")
    
        # Check if app_settings exists and auto-fill is enabled
        if not hasattr(self, 'app_settings'):
            print("DEBUG: CRITICAL ERROR - app_settings attribute doesn't exist")
            return
        
        if self.app_settings is None:
            print("DEBUG: CRITICAL ERROR - app_settings is None")
            return
    
        # Check if auto-fill is enabled
        enabled = self.app_settings.value("footnotes/enabled", False, type=bool)
        print(f"DEBUG: Auto-fill enabled setting: {enabled}")
    
        if not enabled:
            print("DEBUG: Auto-fill notes is disabled in settings - exiting")
            print("============ DEBUG: AUTO-FILL NOTES END ============\n")
            return
        
        # Load settings
        option = self.app_settings.value("footnotes/default_option", "Header Only")
        custom_text = self.app_settings.value("footnotes/custom_text", "")
    
        print(f"DEBUG: Auto-filling notes with option: '{option}'")
        print(f"DEBUG: Custom text setting: '{custom_text}'")
    
        # If using custom text, apply it immediately
        if option == "Custom" and custom_text:
            print(f"DEBUG: Using custom text: '{custom_text}'")
            annotation['notes'] = custom_text
            # Emit update to refresh UI
            self.annotation_updated.emit(json.dumps(annotation))
            print(f"DEBUG: Updated annotation with custom text")
            
            # Theme view update removed - handled by parent create_new_annotation_and_highlight method
            print("DEBUG: Theme view update skipped - handled by parent method to avoid rebuild")
                
            print("============ DEBUG: AUTO-FILL NOTES END ============\n")
            return
    
        # If we don't have selection info, we can't extract headers
        if not selection_info:
            print("DEBUG: No selection info available for auto-filling - exiting")
            print("============ DEBUG: AUTO-FILL NOTES END ============\n")
            return
    
        # Extract the section divider and header from the document
        print("DEBUG: About to run JavaScript to find section divider and header")
        js_code = '''
        (function() {
            console.log("DEBUG JS: Starting header/section detection");
        
            // Get selection
            var selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) {
                console.log("DEBUG JS: No selection found");
                return { error: "No selection" };
            }
        
            var range = selection.getRangeAt(0);
            console.log("DEBUG JS: Selection range found with text: " + range.toString().substring(0, 30) + "...");
        
            // Find the closest speech content element
            var speechContent = null;
            var currentNode = range.startContainer;
            var nodePath = [];
        
            // Trace the path up for debugging
            while (currentNode) {
                nodePath.push({
                    nodeType: currentNode.nodeType,
                    nodeName: currentNode.nodeName,
                    className: currentNode.className || "none", 
                    id: currentNode.id || "none"
                });
            
                if (currentNode.classList && currentNode.classList.contains('speech-content')) {
                    speechContent = currentNode;
                    console.log("DEBUG JS: Found speech-content element");
                    break;
                }
                if (currentNode.parentNode) {
                    currentNode = currentNode.parentNode;
                } else {
                    break;
                }
            }
        
            console.log("DEBUG JS: Node path traversed: ", JSON.stringify(nodePath));
        
            if (!speechContent) {
                console.log("DEBUG JS: No speech content found");
            
                // Let's try to look for it in the entire document
                var allSpeechContents = document.querySelectorAll('.speech-content');
                console.log("DEBUG JS: Total speech-content elements in document: " + allSpeechContents.length);
            
                // Document structure dump for debugging
                var docStructure = [];
                var bodyChildren = document.body.children;
                for (var i = 0; i < Math.min(bodyChildren.length, 10); i++) {
                    var child = bodyChildren[i];
                    docStructure.push({
                        index: i,
                        nodeType: child.nodeType,
                        nodeName: child.nodeName,
                        className: child.className || "none",
                        id: child.id || "none"
                    });
                }
                console.log("DEBUG JS: Document structure (first 10 children of body): ", JSON.stringify(docStructure));
            
                return { 
                    error: "No speech content found",
                    nodePathTraversed: nodePath,
                    documentStructure: docStructure
                };
            }
        
            // Find the parent speech article
            var speechArticle = speechContent.closest('.speech');
            if (!speechArticle) {
                console.log("DEBUG JS: No speech article found");
                return { 
                    error: "No speech article found",
                    speechContentFound: true
                };
            }
        
            console.log("DEBUG JS: Found speech article with className: " + speechArticle.className);
        
            // Find the header in the speech article
            var header = null;
            var speechTitle = speechArticle.querySelector('.speech-title');
            if (speechTitle) {
                header = speechTitle.textContent.trim();
                console.log("DEBUG JS: Found header: '" + header + "'");
            } else {
                console.log("DEBUG JS: No speech-title found in speech article");
            
                // Try other potential header elements
                var otherHeaders = speechArticle.querySelectorAll('h1, h2, h3, h4, h5, h6');
                if (otherHeaders.length > 0) {
                    console.log("DEBUG JS: Found " + otherHeaders.length + " other potential header elements");
                    header = otherHeaders[0].textContent.trim();
                    console.log("DEBUG JS: Using alternative header: '" + header + "'");
                }
            }
        
            // Find the section divider by looking for previous main-header-section
            var sectionDivider = null;
            var mainHeaderSection = null;
        
            // Debug: Check if we have a speechArticle container
            var speechContainer = speechArticle.closest('.speech-container');
            if (speechContainer) {
                console.log("DEBUG JS: Found speech container");
                mainHeaderSection = speechContainer.previousElementSibling;
            } else {
                console.log("DEBUG JS: No speech container found, using direct speech article previousSibling");
                mainHeaderSection = speechArticle.previousElementSibling;
            }
        
            // Track the elements we've examined for debugging
            var examinedElements = [];
        
            // Look backward through the DOM for the closest main-header-section
            while (mainHeaderSection) {
                examinedElements.push({
                    nodeType: mainHeaderSection.nodeType,
                    nodeName: mainHeaderSection.nodeName,
                    className: mainHeaderSection.className || "none",
                    id: mainHeaderSection.id || "none"
                });
            
                if (mainHeaderSection.classList && mainHeaderSection.classList.contains('main-header-section')) {
                    var mainHeader = mainHeaderSection.querySelector('.main-header');
                    if (mainHeader) {
                        sectionDivider = mainHeader.textContent.trim();
                        console.log("DEBUG JS: Found section divider: '" + sectionDivider + "'");
                        break;
                    }
                }
                mainHeaderSection = mainHeaderSection.previousElementSibling;
            }
        
            console.log("DEBUG JS: Examined " + examinedElements.length + " previous siblings");
        
            // If we still didn't find a section divider, look at the container differently
            if (!sectionDivider) {
                console.log("DEBUG JS: No section divider found in previous siblings, trying alternate method");
                var allSections = document.querySelectorAll('.main-header-section');
                console.log("DEBUG JS: Total main-header-section elements: " + allSections.length);
            
                if (allSections.length > 0) {
                    // List all sections for debugging
                    var allSectionInfo = [];
                    for (var i = 0; i < allSections.length; i++) {
                        var section = allSections[i];
                        var mainHeader = section.querySelector('.main-header');
                        allSectionInfo.push({
                            index: i,
                            text: mainHeader ? mainHeader.textContent.trim() : "No .main-header",
                            id: section.id || "none"
                        });
                    }
                    console.log("DEBUG JS: All sections found: ", JSON.stringify(allSectionInfo));
                }
            
                for (var i = 0; i < allSections.length; i++) {
                    var section = allSections[i];
                    var nextSibling = section.nextElementSibling;
                
                    while (nextSibling) {
                        if (nextSibling.contains(speechArticle)) {
                            var mainHeader = section.querySelector('.main-header');
                            if (mainHeader) {
                                sectionDivider = mainHeader.textContent.trim();
                                console.log("DEBUG JS: Found section divider (alternate method): '" + sectionDivider + "'");
                                break;
                            }
                        }
                        nextSibling = nextSibling.nextElementSibling;
                    }
                
                    if (sectionDivider) break;
                }
            }
        
            console.log("DEBUG JS: Final results - Header: '" + (header || "none") + "', Section Divider: '" + (sectionDivider || "none") + "'");
        
            return {
                sectionDivider: sectionDivider,
                header: header,
                debugInfo: {
                    examinedElements: examinedElements,
                    nodePath: nodePath
                }
            };
        })();
        '''
    
        def process_header_info(result):
            print(f"DEBUG: Received JavaScript result: {json.dumps(result, indent=2) if result else 'None'}")
            
            # Track if notes were filled to determine if we should update theme view
            notes_filled = False
            original_notes = annotation.get('notes', '')
        
            if not result or not isinstance(result, dict):
                print("DEBUG: Invalid result type - expecting dict")
                print("============ DEBUG: AUTO-FILL NOTES END ============\n")
                return
            
            if 'error' in result:
                error_msg = result.get('error', 'Unknown error')
                print(f"DEBUG: Error extracting headers: {error_msg}")
            
                # Additional debugging for document structure
                if 'nodePathTraversed' in result:
                    print(f"DEBUG: Node path traversed: {json.dumps(result['nodePathTraversed'], indent=2)}")
            
                if 'documentStructure' in result:
                    print(f"DEBUG: Document structure: {json.dumps(result['documentStructure'], indent=2)}")
                
                print("============ DEBUG: AUTO-FILL NOTES END ============\n")
                return
        
            section_divider = result.get('sectionDivider')
            header = result.get('header')
        
            print(f"DEBUG: Extracted section_divider='{section_divider}', header='{header}'")
        
            if not section_divider and not header:
                print("DEBUG: No headers found to auto-fill - nothing to do")
                print("============ DEBUG: AUTO-FILL NOTES END ============\n")
                return

            # Now this code is no longer inside the above if-block
            # and will run only if we do have at least one non-empty value

            # Update annotation with extracted information based on settings
            if option == "Section Divider and Header":
                if section_divider and header:
                    annotation['notes'] = f"{section_divider}: {header}"
                    print(f"DEBUG: Set notes to '{annotation['notes']}' (Section Divider and Header)")
                    notes_filled = True
                elif header:
                    # Treat like "Header Only" if section divider is missing
                    annotation['notes'] = header
                    print(f"DEBUG: Section divider missing - defaulting to Header Only. '{annotation['notes']}'")
                    notes_filled = True
            elif option == "Header Only" and header:
                annotation['notes'] = header
                print(f"DEBUG: Set notes to '{annotation['notes']}' (Header Only)")
                notes_filled = True
            elif option == "Section Divider Only" and section_divider:
                annotation['notes'] = section_divider
                print(f"DEBUG: Set notes to '{annotation['notes']}' (Section Divider Only)")
                notes_filled = True
            else:
                print(f"DEBUG: No matching criteria for auto-fill with option={option}")
                print("============ DEBUG: AUTO-FILL NOTES END ============\n")
                return

    
            # Emit update to refresh UI
            print(f"DEBUG: Emitting annotation update with notes='{annotation['notes']}'")
            self.annotation_updated.emit(json.dumps(annotation))
            print("DEBUG: Update emitted successfully")
    
            # Refresh this specific annotation in the theme view
            if notes_filled:
                print("DEBUG: Notes were successfully filled, refreshing annotation in theme view")
                try:
                    if hasattr(self, 'main_window') and self.main_window:
                        self.main_window.refresh_annotation_in_theme_view(annotation['id'])
                        print(f"DEBUG: Called refresh_annotation_in_theme_view for annotation {annotation['id']}")
                except Exception as e:
                    print(f"DEBUG: Error refreshing annotation in theme view: {str(e)}")
                    import traceback
                    print(f"DEBUG: Traceback: {traceback.format_exc()}")
    
            print("============ DEBUG: AUTO-FILL NOTES END ============\n")

    def extract_speech_title_for_annotation(self, annotation, highlighted_text):
        """
        Extract the speech title from the DOM for a given highlighted text.
        Adds speech_title field to the annotation.
        """
        print(f"\n============ DEBUG: EXTRACT SPEECH TITLE START ============")
        print(f"Annotation ID: {annotation.get('id', 'unknown')}")
        print(f"Highlighted text: '{highlighted_text[:50]}...' (first 50 chars)")
        
        # JavaScript to find the speech title by traversing from the highlighted span
        js_code = f"""
        (function() {{
            console.log("DEBUG: Finding speech title via DOM traversal from highlighted span");
            
            // Method 1: Find the most recently created span (which should be our highlight)
            const allSpans = document.querySelectorAll('span[data-annotation-id]');
            console.log(`DEBUG: Found ${{allSpans.length}} annotation spans total`);
            
            let targetSpan = null;
            
            // Try to find the span that contains our target text
            const targetText = {repr(highlighted_text)};
            console.log("DEBUG: Looking for span containing text:", targetText.substring(0, 50) + "...");
            
            for (let span of allSpans) {{
                if (span.textContent.includes(targetText)) {{
                    targetSpan = span;
                    console.log("DEBUG: Found target span with annotation ID:", span.getAttribute('data-annotation-id'));
                    break;
                }}
            }}
            
            // Fallback: if we can't find by text content, try the last span (most recently added)
            if (!targetSpan && allSpans.length > 0) {{
                targetSpan = allSpans[allSpans.length - 1];
                console.log("DEBUG: Using last span as fallback with ID:", targetSpan.getAttribute('data-annotation-id'));
            }}
            
            if (!targetSpan) {{
                console.log("DEBUG: No annotation span found");
                return "Unknown Speech";
            }}
            
            // Method 2: Traverse up to find the containing article.speech
            let currentElement = targetSpan;
            let speechArticle = null;
            
            while (currentElement && currentElement !== document.body) {{
                if (currentElement.tagName === 'ARTICLE' && currentElement.classList.contains('speech')) {{
                    speechArticle = currentElement;
                    console.log("DEBUG: Found containing speech article");
                    break;
                }}
                currentElement = currentElement.parentElement;
            }}
            
            if (!speechArticle) {{
                console.log("DEBUG: Could not find containing speech article");
                return "Unknown Speech";
            }}
            
            // Method 3: Find the h2.speech-title within this article
            const speechTitle = speechArticle.querySelector('h2.speech-title');
            
            if (speechTitle) {{
                const titleText = speechTitle.textContent.trim();
                console.log(`DEBUG: Found speech title: "${{titleText}}"`);
                return titleText;
            }} else {{
                console.log("DEBUG: No speech title found in article");
                return "Unknown Speech";
            }}
        }})();
        """
        
        def handle_speech_title_result(result):
            """Handle the result from JavaScript speech title extraction"""
            print(f"DEBUG: Speech title extraction result: '{result}' (type: {type(result)})")
            if result and isinstance(result, str) and result.strip():
                annotation['speech_title'] = result.strip()
                print(f"DEBUG: Added speech_title to annotation: '{result.strip()}'")
            else:
                annotation['speech_title'] = ""
                print(f"DEBUG: No speech title found, set to empty string (result was: {result})")
            
            print("============ DEBUG: EXTRACT SPEECH TITLE END ============\\n")
            
            # Additional debug: Print the annotation to verify speech_title is set
            print(f"DEBUG: Final annotation speech_title field: '{annotation.get('speech_title', 'NOT_FOUND')}'")
            
            # Force emit the annotation update to refresh UI
            print(f"DEBUG: Emitting annotation update to refresh UI with speech_title")
            self.annotation_updated.emit(json.dumps(annotation))
            
            # Update just this annotation's display in the theme view
            main_window = self.window()
            if main_window and hasattr(main_window, 'update_annotation_speech_title_in_ui'):
                print(f"DEBUG: Calling targeted speech title update for annotation {annotation['id']}")
                main_window.update_annotation_speech_title_in_ui(annotation['id'], annotation.get('speech_title', ''))
            else:
                print(f"DEBUG: Targeted update method not available")
        
        # Execute JavaScript to extract speech title
        self.page().runJavaScript(js_code, handle_speech_title_result)


    def update_theme_view_if_available(self):
        """Update the script panel if the main window and script panel are accessible."""
        main_window = self.window()
        if main_window and hasattr(main_window, 'update_theme_view'):
            main_window.update_theme_view()

    def update_current_tab_item_sizes_from_main_window(self):
        """Update the script panel if the main window and script panel are accessible."""
        main_window = self.window()
        if main_window and hasattr(main_window, 'update_current_tab_item_sizes'):
            main_window.update_current_tab_item_sizes()

    def _clear_reassignment_flag(self):
        """Clear the reassignment flag with debug output"""
        print(f"🔴🔴🔴 CLEARING REASSIGNMENT FLAG on main_window")
        setattr(self.main_window, '_in_reassignment_context', False)

    def _finish_reassignment_context(self):
        """Apply all pending selections and clear reassignment context"""
        print(f"DEBUG: *** _finish_reassignment_context CALLED ***")
        
        main_window = self.window()
        print(f"DEBUG: main_window = {main_window}")
        if main_window:
            # Use the complete captured_new_annotation_ids list which includes all annotations (left + right + middle)
            all_batch_annotation_ids = getattr(self, 'captured_new_annotation_ids', [])
            
            print(f"DEBUG: Batch operation created/updated {len(all_batch_annotation_ids)} annotations: {all_batch_annotation_ids}")
            
            if all_batch_annotation_ids:
                # Check if theme view is visible for selection
                if (hasattr(main_window, 'theme_view') and 
                    main_window.theme_view and 
                    main_window.theme_view.isVisible()):
                    
                    # Theme view is visible - execute selection immediately
                    print("DEBUG: Theme view visible - executing selection immediately")
                    
                    # Clear any stale pending selections since we're doing selection now
                    if hasattr(main_window, '_pending_selection'):
                        main_window._pending_selection = []
                    
                    # Clear all existing selections once
                    main_window.clear_all_tab_selections()
                    print("DEBUG: Cleared all selections for batch operation")
                    
                    # Select all annotations from this batch operation
                    selected_count = 0
                    for annotation_id in all_batch_annotation_ids:
                        try:
                            # Find the annotation's scene to locate the correct tab
                            annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
                            if annotation:
                                scene = annotation.get('scene', 'Unknown')
                                
                                # Find the correct tab and list widget
                                for i in range(main_window.scene_tabs.count()):
                                    tab_name = main_window.scene_tabs.tabText(i)
                                    if tab_name == scene:
                                        list_widget = main_window.scene_tabs.widget(i)
                                        if hasattr(list_widget, 'count'):
                                            # Find the item with this annotation ID
                                            for j in range(list_widget.count()):
                                                item = list_widget.item(j)
                                                if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                                                    item.setSelected(True)
                                                    selected_count += 1
                                                    print(f"DEBUG: Selected annotation {annotation_id} in scene '{scene}'")
                                                    break
                                        break
                        except Exception as e:
                            print(f"DEBUG: Failed to select annotation {annotation_id}: {e}")
                    
                    print(f"DEBUG: Successfully selected {selected_count} out of {len(all_batch_annotation_ids)} batch annotations")
                    
                else:
                    # Theme view is not visible - store selection for later
                    # Replace any existing pending selections (don't accumulate)
                    main_window._pending_selection = all_batch_annotation_ids.copy()
                    print(f"DEBUG: Theme view hidden - stored {len(all_batch_annotation_ids)} annotations for later selection (replaced any previous)")
            
            # Clear any remaining pending selections from the old system
            if hasattr(self, '_pending_selections'):
                self._pending_selections = []
                self._selections_cleared = False
                
            # Now clear the tracking lists after selection logic is complete
            self._reassignment_removed_ids = []
            self._reassignment_updated_annotations = []
            self._reassignment_added_annotations = []
            
            # Clear captured_new_annotation_ids after selection logic is complete to prevent reuse
            if hasattr(self, 'captured_new_annotation_ids'):
                self.captured_new_annotation_ids = []
                print("=== DEBUG: Cleared captured_new_annotation_ids after batch selection ===")      
        
        # Clear the reassignment context flag
        self._in_reassignment_context = False
        
        # Also clear flag on storyboard dialog
        main_window = self.window()
        if main_window and hasattr(main_window, 'storyboard_dialog') and main_window.storyboard_dialog:
            main_window.storyboard_dialog._in_reassignment_context = False
            print("[DEBUG] Cleared reassignment context flag on storyboard dialog")

    def _execute_selection(self, main_window, annotation_ids):
        """Execute selection of annotations in the theme view"""
        # Clear all existing selections once
        main_window.clear_all_tab_selections()
        print("DEBUG: Cleared all selections for batch operation")
        
        # Select all annotations from this batch operation
        selected_count = 0
        for annotation_id in annotation_ids:
            try:
                # Find the annotation's scene to locate the correct tab
                annotation = next((a for a in self.annotations if a.get('id') == annotation_id), None)
                if annotation:
                    scene = annotation.get('scene', 'Unknown')
                    
                    # Find the correct tab and list widget
                    for i in range(main_window.scene_tabs.count()):
                        tab_name = main_window.scene_tabs.tabText(i)
                        if tab_name == scene:
                            list_widget = main_window.scene_tabs.widget(i)
                            if hasattr(list_widget, 'count'):
                                # Find the item with this annotation ID
                                for j in range(list_widget.count()):
                                    item = list_widget.item(j)
                                    if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                                        item.setSelected(True)
                                        selected_count += 1
                                        print(f"DEBUG: Selected annotation {annotation_id} in scene '{scene}'")
                                        break
                            break
            except Exception as e:
                print(f"DEBUG: Failed to select annotation {annotation_id}: {e}")
        
        print(f"DEBUG: Successfully selected {selected_count} out of {len(annotation_ids)} batch annotations")

    def highlight_text(self, text, scene, annotation_id, selection_info=None, annotation=None):
        """
        Highlight text with proper targeting of the selected instance.
        Args:
            text: Text to highlight
            scene: Scene to associate with
            annotation_id: ID for the annotation
            selection_info: Optional dict containing selection range information
            annotation: The annotation object containing metadata
        """
        # Use the provided annotation instead of looking it up
        if annotation is None:
            annotation = next((anno for anno in self.annotations if anno.get('id') == annotation_id), None)

        print("=== DEBUG: Call stack ===")
        print("".join(traceback.format_stack()))
        print("\n=== DEBUG: Entering highlight_text ===")
        print(f"Text: {text}")
        print(f"Scene: {scene}")
        print(f"Annotation ID: {annotation_id}")
        print(f"Selection Info: {selection_info}")

        # NEW: Track short text highlighting operations
        is_short_text = len(text.strip()) <= 3
    
        # NEW: Store information about the recent removal operation if applicable
        recent_removal_info = getattr(self, '_recent_removal_info', None)
    
        # Before running JS code
        print(f"Running JavaScript with selection_info: {selection_info}")

        escaped_text = (
            text.replace('\\', '\\\\')
                .replace("'", "\\'")
                .replace('"', '\\"')
                .replace('\n', '\\n')
        )

        def escape_js_string(s):
            return (
                str(s).replace('\\', '\\\\')
                 .replace('"', '\\"')
                 .replace("'", "\\'")
                 .replace('\n', '\\n')
                 .replace('\r', '\\r')
            )

        style = escape_js_string(self.scene_styles.get(scene, 'background-color: yellow;'))
        notes = escape_js_string(annotation.get('notes', '') if annotation else '')
        notes_html = escape_js_string(annotation.get('notes_html', '') if annotation else '')
        used = 'true' if annotation and annotation.get('used', False) else 'false'
        favorite = 'true' if annotation and annotation.get('favorite', False) else 'false'
        speech_title = escape_js_string(annotation.get('speech_title', '') if annotation else '')
        tags = json.dumps(annotation.get('tags', []) if annotation else [])
        secondary_scenes = json.dumps(annotation.get('secondary_scenes', []) if annotation else [])

        # Process storyboard with order adjustment
        try:
            storyboard_data = annotation.get('storyboard') if annotation else {}
            if isinstance(storyboard_data, str):
                # If it's a string, try to parse it as JSON
                try:
                    storyboard_data = json.loads(storyboard_data)
                except json.JSONDecodeError:
                    print(f"Warning: Invalid storyboard JSON string: {storyboard_data}")
                    storyboard_data = {}

            if storyboard_data and isinstance(storyboard_data, dict) and storyboard_data.get('order') is not None:
                storyboard_data = dict(storyboard_data)  # Make a copy
                storyboard_data['order'] = max(0, storyboard_data['order'] - 1)

            storyboard = json.dumps(storyboard_data)
        except Exception as e:
            print(f"Error processing storyboard data: {e}")
            storyboard = json.dumps({})

        # Process separate order
        order = annotation.get('order')
        if order is not None:
            order = max(0, order - 1)
        order_json = json.dumps(order) if order is not None else 'null'

        selection_info_json = 'null'
        if selection_info:
            import copy
            sel_info_copy = copy.deepcopy(selection_info)
            selection_info_json = json.dumps({
                'text': sel_info_copy.get('text', ''),
                'startContainerPath': sel_info_copy.get('startContainerPath', ''),
                'startOffset': sel_info_copy.get('startOffset', 0),
                'endContainerPath': sel_info_copy.get('endContainerPath', ''),
                'endOffset': sel_info_copy.get('endOffset', 0),
                'context': sel_info_copy.get('context', {}),
                'location': sel_info_copy.get('location', {})
            })
    
        # NEW: Prepare recent removal info if it exists
        recent_removal_json = 'null'
        if recent_removal_info:
            recent_removal_json = json.dumps(recent_removal_info)
    
        # NEW: Determine appropriate context window size based on text length
        context_window_size = min(300, max(100, 300 - len(text.strip()) * 20))

        js_code = f'''
        (function() {{
            console.log("=== DEBUG: JavaScript Execution Started ===");
            var targetText = "{escaped_text}";
            console.log("DEBUG: targetText =", targetText);
            var scene = "{scene}";
            console.log("DEBUG: scene =", scene);
            var annotationId = "{annotation_id}";
            console.log("DEBUG: annotationId =", annotationId);
            var notes = "{notes}";
            var notes_html = "{notes_html}";
            console.log("DEBUG: notes =", notes);
            console.log("DEBUG: notes_html =", notes_html);
            var used = {used};
            var favorite = {favorite};
            var speech_title = "{speech_title}";
            var tags = {tags};
            var secondaryScenes = {secondary_scenes};
            console.log("DEBUG: favorite =", favorite);
            console.log("DEBUG: used =", used);
            console.log("DEBUG: tags =", tags);
            var style = "{style}";
            console.log("DEBUG: style =", style);
            var selectionInfo = {selection_info_json};
            console.log("DEBUG: selectionInfo =", selectionInfo);
            var storyboard = {storyboard};
            var order = {order_json};
            console.log("DEBUG: storyboard =", storyboard);
            console.log("DEBUG: order =", order);
        
            // NEW: Add short text flag
            var isShortText = {str(is_short_text).lower()};
            console.log("DEBUG: isShortText =", isShortText);
        
            // NEW: Add recent removal info
            var recentRemovalInfo = {recent_removal_json};
            console.log("DEBUG: recentRemovalInfo =", recentRemovalInfo);
        
            // NEW: Context window size
            var contextWindowSize = {context_window_size};
            console.log("DEBUG: contextWindowSize =", contextWindowSize);

            function createHighlightSpan() {{
                console.log("DEBUG: Creating highlight span with params:", {{
                    storyboard: storyboard,
                    order: order,
                    type_storyboard: typeof storyboard,
                    type_order: typeof order
                }});
                var span = document.createElement("span");

                // Get the base style and add a border that's slightly darker than the background
                var baseStyle = style;

                // Color name to hex mapping for common colors
                var colorNameMap = {{
                    'lavender': '#E6E6FA',
                    'lightblue': '#ADD8E6',
                    'lightgreen': '#90EE90',
                    'lightyellow': '#FFFFE0',
                    'lightpink': '#FFB6C1',
                    'lightcoral': '#F08080',
                    'aqua': '#00FFFF',
                    'azure': '#F0FFFF',
                    'beige': '#F5F5DC',
                    'bisque': '#FFE4C4',
                    'cornsilk': '#FFF8DC',
                    'cyan': '#00FFFF',
                    'gold': '#FFD700',
                    'ivory': '#FFFFF0',
                    'khaki': '#F0E68C',
                    'lemonchiffon': '#FFFACD',
                    'lightgoldenrodyellow': '#FAFAD2',
                    'lightgrey': '#D3D3D3',
                    'lightseagreen': '#20B2AA',
                    'lightskyblue': '#87CEFA',
                    'linen': '#FAF0E6',
                    'mintcream': '#F5FFFA',
                    'mistyrose': '#FFE4E1',
                    'moccasin': '#FFE4B5',
                    'orange': '#FFA500',
                    'orchid': '#DA70D6',
                    'palegoldenrod': '#EEE8AA',
                    'palegreen': '#98FB98',
                    'paleturquoise': '#AFEEEE',
                    'palevioletred': '#DB7093',
                    'papayawhip': '#FFEFD5',
                    'peachpuff': '#FFDAB9',
                    'pink': '#FFC0CB',
                    'plum': '#DDA0DD',
                    'powderblue': '#B0E0E6',
                    'rosybrown': '#BC8F8F',
                    'salmon': '#FA8072',
                    'seashell': '#FFF5EE',
                    'skyblue': '#87CEEB',
                    'snow': '#FFFAFA',
                    'springgreen': '#00FF7F',
                    'tan': '#D2B48C',
                    'thistle': '#D8BFD8',
                    'tomato': '#FF6347',
                    'turquoise': '#40E0D0',
                    'wheat': '#F5DEB3',
                    'white': '#FFFFFF',
                    'whitesmoke': '#F5F5F5',
                    'yellow': '#FFFF00',
                    'yellowgreen': '#9ACD32'
                }};

                // Function to convert color to hex
                function colorToHex(color) {{
                    if (!color) return '#FFF0B3';
    
                    // If already hex, return as is
                    if (color.startsWith('#')) {{
                        return color;
                    }}
    
                    // If named color, convert via map
                    if (/^[a-z]+$/i.test(color) && colorNameMap[color.toLowerCase()]) {{
                        return colorNameMap[color.toLowerCase()];
                    }}
    
                    // Handle rgb/rgba
                    var rgbMatch = color.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*[\\d.]+)?\\)/i);
                    if (rgbMatch) {{
                        var r = parseInt(rgbMatch[1], 10);
                        var g = parseInt(rgbMatch[2], 10);
                        var b = parseInt(rgbMatch[3], 10);
                        return '#' + 
                               r.toString(16).padStart(2, '0') + 
                               g.toString(16).padStart(2, '0') + 
                               b.toString(16).padStart(2, '0');
                    }}
    
                    // Default fallback
                    return '#FFF0B3';
                }}

                // Function to darken a hex color
                function darkenHexColor(hexColor, percent) {{
                    if (!hexColor.startsWith('#') || hexColor.length !== 7) {{
                        return '#999999';
                    }}
    
                    try {{
                        var r = parseInt(hexColor.slice(1, 3), 16);
                        var g = parseInt(hexColor.slice(3, 5), 16);
                        var b = parseInt(hexColor.slice(5, 7), 16);
        
                        // Darken by reducing each component
                        r = Math.max(0, Math.floor(r * (1 - percent)));
                        g = Math.max(0, Math.floor(g * (1 - percent)));
                        b = Math.max(0, Math.floor(b * (1 - percent)));
        
                        return '#' + 
                              r.toString(16).padStart(2, '0') + 
                              g.toString(16).padStart(2, '0') + 
                              b.toString(16).padStart(2, '0');
                    }} catch (e) {{
                        console.log("Error darkening color:", e);
                        return '#999999';
                    }}
                }}

                // Extract the background color and convert to border color
                var bgColorMatch = baseStyle.match(/background-color:\\s*(#[A-Fa-f0-9]{{6}}|rgba?\\([^)]+\\)|[a-zA-Z]+)/i);
                var bgColor = bgColorMatch ? bgColorMatch[1] : '#FFF0B3';

                // Convert to hex format (if not already)
                var hexBgColor = colorToHex(bgColor);

                // Create darker border color (20% darker)
                var borderColor = darkenHexColor(hexBgColor, 0.2);

                // Force our border style (overriding any existing border properties)
                // First remove any existing border properties
                baseStyle = baseStyle.replace(/border[^;]*;/g, '');

                // Add our new border and other styling properties
                baseStyle += '; border: 1px solid ' + borderColor + ';';
                baseStyle += ' border-radius: 2px; padding: 0 1px; margin: 0 1px;';

                span.setAttribute("style", baseStyle);
                span.setAttribute("data-scene", scene);
                span.setAttribute("data-annotation-id", annotationId);
                span.setAttribute("data-notes", notes);
                span.setAttribute("data-notes-html", notes_html);
                span.setAttribute("data-used", used.toString());
                span.setAttribute("data-favorite", favorite.toString());
                span.setAttribute("data-speech-title", speech_title);
                span.setAttribute("data-tags", JSON.stringify(tags));
                span.setAttribute("data-secondary-scenes", JSON.stringify(secondaryScenes));
                
                // Apply used annotation border styling
                if (used) {{
                    span.style.border = "5px solid #2E7D32";
                }} else {{
                    span.style.border = "";
                }}
                if (storyboard && storyboard !== "null") {{
                    span.setAttribute("data-storyboard", typeof storyboard === 'string' ? storyboard : JSON.stringify(storyboard));
                }}
                if (order !== undefined && order !== null && order !== "null") {{
                    span.setAttribute("data-order", order.toString());
                }} else {{
                    span.removeAttribute("data-order"); // Explicitly remove if order is invalid
                }}
                
                // Add double-click event listener for newly created spans
                span.addEventListener('dblclick', function(e) {{
                    console.log('DEBUG: Double-click on newly created annotation span:', annotationId);
                    
                    // Prevent default word selection behavior
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Check for Alt+double-click navigation
                    if (e.altKey && annotationId && scene) {{
                        console.log('DEBUG: Alt+Double-click navigation to theme view:', annotationId, scene);
                        
                        // Navigate to theme view
                        if (typeof window.jsHandler !== 'undefined' && typeof window.jsHandler.requestAnnotationNavigation === 'function') {{
                            console.log('DEBUG: Navigating to theme view via Alt+double-click');
                            window.jsHandler.requestAnnotationNavigation(annotationId, scene);
                        }} else {{
                            console.error('DEBUG: Cannot navigate - jsHandler not available');
                        }}
                    }}
                    
                    // Always select the full annotation text
                    console.log('DEBUG: Selecting full annotation text for:', annotationId);
                    const range = document.createRange();
                    range.selectNodeContents(span);
                    
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    console.log('DEBUG: Selected text:', selection.toString());
                }});
                
                console.log("DEBUG: Highlight span created with attributes and double-click handler:", span.attributes);
                return span;
            }}
        
            function isInsideSpeechContent(node) {{
                let current = node;
                while (current && current !== document.body) {{
                    if (current.classList && current.classList.contains('speech-content')) {{
                        return true;
                    }}
                    current = current.parentNode;
                }}
                return false;
            }}

            function getNodeByXPath(path) {{
                console.log("DEBUG: getNodeByXPath called with path =", path);
                if (!path) return null;
                try {{
                    var node = document.evaluate(
                        path, 
                        document, 
                        null, 
                        XPathResult.FIRST_ORDERED_NODE_TYPE, 
                        null
                    ).singleNodeValue;
                    console.log("DEBUG: Node found by XPath:", node);
                    return node;
                }} catch(e) {{
                    console.log("XPath evaluation failed:", e);
                    return null;
                }}
            }}

            function getXPathForNode(node) {{
                console.log("DEBUG: getXPathForNode called with node =", node);
                if (!node || !node.parentNode) return null;

                if (node.nodeType === Node.TEXT_NODE) {{
                    var parent = node.parentNode;
                    var siblings = parent.childNodes;
                    var textNodeIndex = 0;

                    for (var i = 0; i < siblings.length; i++) {{
                        if (siblings[i] === node) {{
                            var parentPath = getXPathForNode(parent);
                            var xpath = parentPath ? parentPath + '/text()[' + (textNodeIndex + 1) + ']' : null;
                            console.log("DEBUG: XPath for text node =", xpath);
                            return xpath;
                        }}
                        if (siblings[i].nodeType === Node.TEXT_NODE) {{
                            textNodeIndex++;
                        }}
                    }}
                }}

                if (node.id) {{
                    var xpathWithId = '//*[@id="' + node.id + '"]';
                    console.log("DEBUG: XPath with ID =", xpathWithId);
                    return xpathWithId;
                }}

                var parent = node.parentNode;
                var siblings = parent.childNodes;
                var index = Array.prototype.indexOf.call(siblings, node) + 1;
                var parentPath = getXPathForNode(parent);
                var xpath = parentPath ? parentPath + '/' + node.nodeName.toLowerCase() + '[' + index + ']' : null;
                console.log("DEBUG: XPath =", xpath);
                return xpath;
            }}

            function highlightSelection() {{
                console.log("DEBUG: highlightSelection called.");
                var selection = window.getSelection();
                console.log("DEBUG: Current selection =", selection.toString());
                if (selection.rangeCount === 0) {{
                    console.log("DEBUG: No selection ranges found.");
                    return false;
                }}

                var range = selection.getRangeAt(0);
                console.log("DEBUG: Selected range =", range.toString());
                if (range.toString().trim() !== targetText) {{
                    console.log("DEBUG: Selected text does not match targetText.");
                    return false;
                }}

                var containsBR = false;
                var commonAncestor = range.commonAncestorContainer;
                var treeWalker = document.createTreeWalker(commonAncestor, NodeFilter.SHOW_ELEMENT, {{
                    acceptNode: function(node) {{
                        if (node.tagName === 'BR') return NodeFilter.FILTER_ACCEPT;
                        return NodeFilter.FILTER_SKIP;
                    }}
                }}, false);

                while(treeWalker.nextNode()) {{
                    containsBR = true;
                    console.log("DEBUG: Found <br> tag within selection.");
                    break;
                }}

                if (containsBR) {{
                    console.log("DEBUG: Selection contains <br> tags. Splitting range.");
                    var newRanges = splitRangeAtBR(range);
                    console.log("DEBUG: New ranges after splitting =", newRanges.length);
                    newRanges.forEach(function(r, idx) {{
                        console.log(`DEBUG: Highlighting sub-range ${{idx + 1}}/${{newRanges.length}}`);
                        try {{
                            var span = createHighlightSpan();
                            r.surroundContents(span);
                            console.log("DEBUG: Sub-range highlighted successfully.");
                        }} catch(e) {{
                            console.log("Failed to highlight sub-range:", e);
                        }}
                    }});
                    return true;
                }} else {{
                    try {{
                        console.log("DEBUG: Highlighting single range.");
                        var span = createHighlightSpan();
                        range.surroundContents(span);
                        console.log("DEBUG: Range highlighted successfully.");
                        return true;
                    }} catch(e) {{
                        console.log("Failed to highlight selection:", e);
                        return false;
                    }}
                }}
            }}

            function splitRangeAtBR(range) {{
                console.log("DEBUG: splitRangeAtBR called.");
                var brs = [];
                var treeWalker = document.createTreeWalker(
                    range.commonAncestorContainer,
                    NodeFilter.SHOW_ELEMENT,
                    {{
                        acceptNode: function(node) {{
                            if (node.tagName === 'BR') return NodeFilter.FILTER_ACCEPT;
                            return NodeFilter.FILTER_SKIP;
                        }}
                    }},
                    false
                );

                while(treeWalker.nextNode()) {{
                    brs.push(treeWalker.currentNode);
                    console.log("DEBUG: <br> tag found:", treeWalker.currentNode);
                }}

                var newRanges = [];
                var currentStart = range.startContainer;
                var currentStartOffset = range.startOffset;

                brs.forEach(function(br, idx) {{
                    console.log(`DEBUG: Processing <br> tag ${{idx + 1}}/${{brs.length}}`);
                    if (br.compareDocumentPosition(range.endContainer) & Node.DOCUMENT_POSITION_PRECEDING) {{
                        console.log("DEBUG: <br> tag is after the end of the range. Skipping.");
                        return;
                    }}
                    var brRange = document.createRange();
                    brRange.setStartBefore(br);
                    brRange.setEndAfter(br);
                    console.log("DEBUG: Created brRange:", brRange.toString());

                    var beforeRange = document.createRange();
                    beforeRange.setStart(currentStart, currentStartOffset);
                    beforeRange.setEndBefore(br);
                    console.log("DEBUG: Created beforeRange:", beforeRange.toString());

                    if (beforeRange.toString().trim() !== '') {{
                        newRanges.push(beforeRange);
                        console.log("DEBUG: Added beforeRange to newRanges.");
                    }}

                    currentStart = br.nextSibling || br.parentNode;
                    currentStartOffset = 0;
                }});

                var afterRange = document.createRange();
                afterRange.setStart(currentStart, currentStartOffset);
                afterRange.setEnd(range.endContainer, range.endOffset);
                console.log("DEBUG: Created afterRange:", afterRange.toString());
                if (afterRange.toString().trim() !== '') {{
                    newRanges.push(afterRange);
                    console.log("DEBUG: Added afterRange to newRanges.");
                }}

                console.log("DEBUG: Total newRanges created =", newRanges.length);
                return newRanges;
            }}

            function findNodeByLocationInfo(locationInfo) {{
                if (!locationInfo || !locationInfo.containerPath) {{
                    return null;
                }}

                // First try the direct container path
                var container = getNodeByXPath(locationInfo.containerPath);
                if (container) {{
                    // If we found a container but it's not a text node, we need to find the text node within it
                    if (container.nodeType !== Node.TEXT_NODE) {{
                        var walker = document.createTreeWalker(
                            container,
                            NodeFilter.SHOW_TEXT,
                            {{ acceptNode: function(node) {{
                                // Skip nodes that are already part of an annotation
                                if (node.parentElement && node.parentElement.hasAttribute("data-annotation-id")) {{
                                    return NodeFilter.FILTER_SKIP;
                                }}
                                return NodeFilter.FILTER_ACCEPT;
                            }} }}
                        );
        
                        while (walker.nextNode()) {{
                            var node = walker.currentNode;
                            if (node.textContent.includes(targetText)) {{
                                container = node;
                                break;
                            }}
                        }}
                    }}
                }} else {{
                    // If direct path lookup fails, try finding any matching text content in the document
                    var walker = document.createTreeWalker(
                        document.body,
                        NodeFilter.SHOW_TEXT,
                        {{ acceptNode: function(node) {{
                            // Skip nodes that are already part of an annotation
                            if (node.parentElement && node.parentElement.hasAttribute("data-annotation-id")) {{
                                return NodeFilter.FILTER_SKIP;
                            }}
                            if (!isInsideSpeechContent(node)) {{
                                return NodeFilter.FILTER_SKIP;
                            }}
                            return NodeFilter.FILTER_ACCEPT;
                        }} }}
                    );
    
                    while (walker.nextNode()) {{
                        var node = walker.currentNode;
                        if (node.textContent.includes(targetText)) {{
                            container = node;
                            break;
                        }}
                    }}
                }}

                console.log("DEBUG: Found container node:", container);
                console.log("DEBUG: Container node type:", container ? container.nodeType : "null");
                console.log("DEBUG: Container text content:", container ? container.textContent : "null");

                return container;
            }}

            function highlightWithSelectionInfo() {{
                console.log("DEBUG: highlightWithSelectionInfo called.");
                if (!selectionInfo) {{
                    console.log("DEBUG: No selectionInfo provided.");
                    return false;
                }}

                var startContainer = getNodeByXPath(selectionInfo.startContainerPath);
                var endContainer = getNodeByXPath(selectionInfo.endContainerPath);
                console.log("DEBUG: startContainer =", startContainer);
                console.log("DEBUG: endContainer =", endContainer);

                if (!startContainer || !endContainer) {{
                    console.log("DEBUG: Start or end container not found.");
                    return false;
                }}

                try {{
                    var range = document.createRange();
                    range.setStart(startContainer, selectionInfo.startOffset);
                    range.setEnd(endContainer, selectionInfo.endOffset);
                    console.log("DEBUG: Range set with selectionInfo.");

                    var containsBR = false;
                    var treeWalker = document.createTreeWalker(range.commonAncestorContainer, NodeFilter.SHOW_ELEMENT, {{
                        acceptNode: function(node) {{
                            if (node.tagName === 'BR') return NodeFilter.FILTER_ACCEPT;
                            return NodeFilter.FILTER_SKIP;
                        }}
                    }}, false);

                    while(treeWalker.nextNode()) {{
                        containsBR = true;
                        console.log("DEBUG: <br> tag found within selectionInfo range.");
                        break;
                    }}

                    if (range.toString().trim() === targetText) {{
                        if (containsBR) {{
                            console.log("DEBUG: Range contains <br> tags. Splitting range.");
                            var newRanges = splitRangeAtBR(range);
                            console.log("DEBUG: New ranges after splitting =", newRanges.length);
                            newRanges.forEach(function(r, idx) {{
                                console.log(`DEBUG: Highlighting sub-range with selection info ${{idx + 1}}/${{newRanges.length}}`);
                                try {{
                                    var span = createHighlightSpan();
                                    r.surroundContents(span);
                                    console.log("DEBUG: Sub-range highlighted successfully with selection info.");
                                }} catch(e) {{
                                    console.log("Failed to highlight sub-range with selection info:", e);
                                }}
                            }});
                            return true;
                        }} else {{
                            console.log("DEBUG: Highlighting single range with selection info.");
                            var span = createHighlightSpan();
                            range.surroundContents(span);
                            console.log("DEBUG: Range highlighted successfully with selection info.");
                            return true;
                        }}
                    }}
                }} catch(e) {{
                    console.log("Failed to highlight with selection info:", e);
                }}
                return false;
            }}
        
            // NEW: Function to calculate context weight based on text length
            function calculateContextWeight(textLength) {{
                // More weight for shorter text (max 3x for single characters)
                return Math.min(3, Math.max(1, 4 - textLength/3));
            }}
        
            // NEW: Enhanced context scoring with support for recent modifications
            function calculateContextScore(node, expectedContext, isShortText, recentInfo) {{
                if (!expectedContext) return 0;
            
                // Base score
                let score = 0;
            
                let beforeContext = "";
                let afterContext = "";
            
                // Get surrounding context
                let current = node;
                while (current = current.previousSibling) {{
                    beforeContext = (current.textContent || current.innerText || '') + beforeContext;
                    if (beforeContext.length > contextWindowSize) break;
                }}
            
                current = node;
                while (current = current.nextSibling) {{
                    afterContext += (current.textContent || current.innerText || '');
                    if (afterContext.length > contextWindowSize) break;
                }}
            
                // Context matching scoring - scale weight based on text length
                const contextWeight = isShortText ? calculateContextWeight(targetText.length) : 1;
            
                if (expectedContext.before && beforeContext) {{
                    if (beforeContext.endsWith(expectedContext.before)) {{
                        score += 100 * contextWeight;
                    }} else if (isShortText) {{
                        // For short text, look for partial matches of the context
                        const partialBefore = expectedContext.before.substring(
                            Math.max(0, expectedContext.before.length - 20)
                        );
                        if (beforeContext.endsWith(partialBefore)) {{
                            score += 70 * contextWeight;
                        }}
                    }}
                }}
            
                if (expectedContext.after && afterContext) {{
                    if (afterContext.startsWith(expectedContext.after)) {{
                        score += 100 * contextWeight;
                    }} else if (isShortText) {{
                        // For short text, look for partial matches of the context
                        const partialAfter = expectedContext.after.substring(0, 20);
                        if (afterContext.startsWith(partialAfter)) {{
                            score += 70 * contextWeight;
                        }}
                    }}
                }}
            
                // NEW: Position scoring - sentences, paragraphs, and structural position
                // Check if the text appears at the beginning of a sentence
                if (isShortText) {{
                    const prevChar = beforeContext.charAt(beforeContext.length - 1) || '';
                    if (/[.!?\\s]/.test(prevChar)) {{
                        // Text appears after sentence-ending punctuation or whitespace
                        score += 30;
                    }}
                
                    // Check if the node is at the beginning of a paragraph
                    if (!node.previousSibling || 
                        (node.previousSibling.nodeType === Node.ELEMENT_NODE && 
                         getComputedStyle(node.previousSibling).display === 'block')) {{
                        score += 40;
                    }}
                }}
            
                // NEW: Recent modification proximity scoring
                if (recentInfo && isShortText) {{
                    try {{
                        // Check if this node is related to the recently modified content
                        const nodePath = getXPathForNode(node.parentNode);
                        const recentPath = recentInfo.parentXPath;
                    
                        // Direct parent match is highest value
                        if (nodePath === recentPath) {{
                            score += 200;
                            console.log("DEBUG: Found exact recent parent match with score +200");
                        }}
                        // Check if they share a common ancestor (partial path match)
                        else if (nodePath && recentPath && 
                                 (nodePath.startsWith(recentPath) || recentPath.startsWith(nodePath))) {{
                            score += 100;
                            console.log("DEBUG: Found common ancestor with recent modification with score +100");
                        }}
                    
                        // Check surrounding text patterns
                        if (recentInfo.siblingTexts) {{
                            // Get surrounding text of current node
                            let surroundingText = '';
                            if (node.previousSibling) {{
                                surroundingText += node.previousSibling.textContent || '';
                            }}
                            if (node.nextSibling) {{
                                surroundingText += node.nextSibling.textContent || '';
                            }}
                        
                            // Compare with recent operation context
                            if (surroundingText && recentInfo.siblingTexts.some(t => surroundingText.includes(t))) {{
                                score += 80;
                                console.log("DEBUG: Found matching surrounding text patterns with score +80");
                            }}
                        }}
                    
                        // Apply time decay - operation happening within last 3 seconds gets full weight
                        if (recentInfo.timestamp) {{
                            const elapsed = Date.now() - recentInfo.timestamp;
                            if (elapsed > 3000) {{ // 3 seconds
                                // Linear decay between 3-10 seconds
                                const decay = Math.max(0, 1 - (elapsed - 3000) / 7000);
                                score = score * decay;
                            }}
                        }}
                    }} catch (err) {{
                        console.log("Error applying recent modification scoring:", err);
                    }}
                }}
            
                return score;
            }}

            // Add this function just before findTextNodeWithContext
            function findTextNodeAcrossBoundaries(beforeNeeded, targetStr, afterNeeded) {{
                var walker = document.createTreeWalker(
                    document.body,
                    NodeFilter.SHOW_TEXT,
                    {{
                        acceptNode: function(node) {{
                            // Skip nodes that are already part of an annotation
                            if (node.parentElement && node.parentElement.hasAttribute("data-annotation-id")) {{
                                return NodeFilter.FILTER_REJECT;
                            }}
                            // Skip nodes that aren't inside speech-content
                            if (!isInsideSpeechContent(node)) {{
                                return NodeFilter.FILTER_REJECT;
                            }}
                            return NodeFilter.FILTER_ACCEPT;
                        }}
                    }}
                );

                var allSegments = [];
                var nodeMap = [];
                while (walker.nextNode()) {{
                    var nd = walker.currentNode;
                    // skip empty or whitespace-only
                    if (!nd.textContent.trim() && nd.textContent.length < 1) continue;
                    allSegments.push(nd.textContent);
                    nodeMap.push(nd);
                }}

                // Join them with a special delimiter that won't appear in normal text
                var DELIM = "␞";
                var joined = allSegments.join(DELIM);

                // We'll look for "before + target + after" in the joined string
                var pattern = (beforeNeeded || "") + targetStr + (afterNeeded || "");
                var index = joined.indexOf(pattern);
                if (index < 0) {{
                    return null;
                }}

                // If found, we must figure out exactly where the "targetStr" portion starts and ends
                var startIndex = index + (beforeNeeded ? beforeNeeded.length : 0);
                var endIndex = startIndex + targetStr.length;

                // Now we convert those indexes back into a node + offset
                function indexToNodeAndOffset(idx) {{
                    var remaining = idx;
                    for (var i = 0; i < allSegments.length; i++) {{
                        var segment = allSegments[i];
                        if (remaining <= segment.length) {{
                            return {{ nodeIndex: i, offset: remaining }};
                        }}
                        remaining -= segment.length;
                        // skip delim
                        if (remaining > 0) {{
                            // subtract delimiter length
                            remaining--;
                        }}
                    }}
                    return null;
                }}

                var startPos = indexToNodeAndOffset(startIndex);
                var endPos = indexToNodeAndOffset(endIndex);
                if (!startPos || !endPos) {{
                    return null;
                }}

                return {{
                    startNode: nodeMap[startPos.nodeIndex],
                    startOffset: startPos.offset,
                    endNode: nodeMap[endPos.nodeIndex],
                    endOffset: endPos.offset
                }};
            }}

            function findTextNodeWithContext() {{
                console.log("DEBUG: Starting findTextNodeWithContext...");
                console.log("DEBUG: Available context:", {{
                    before: selectionInfo?.context?.before || 'none',
                    text: selectionInfo?.context?.text || 'none',
                    after: selectionInfo?.context?.after || 'none'
                }});

                var beforeNeeded = selectionInfo?.context?.before || "";
                var afterNeeded = selectionInfo?.context?.after || "";
            
                // NEW: For short text, expand context window
                if (isShortText) {{
                    console.log("DEBUG: Using expanded context window for short text");
                
                    // Try cross-boundary match with a wider context window
                    var fallbackResult = findTextNodeAcrossBoundaries(beforeNeeded, targetText, afterNeeded);
                    if (fallbackResult) {{
                        console.log("DEBUG: Found cross-boundary match. Now we highlight it.");
                        return fallbackResult;
                    }}
                }} else {{
                    // Standard approach for normal text
                    var fallbackResult = findTextNodeAcrossBoundaries(beforeNeeded, targetText, afterNeeded);
                    if (fallbackResult) {{
                        console.log("DEBUG: Found cross-boundary match. Now we highlight it.");
                        return fallbackResult;
                    }}
                }}

                console.log("DEBUG: No cross-boundary match found. Will do single-node approach now.");

                // NEW: Enhanced walker approach for more thorough search
                // Process all text nodes, not just visible ones if it's a short text
                var walker = document.createTreeWalker(
                    document.body,
                    NodeFilter.SHOW_TEXT,
                    {{ acceptNode: function(node) {{
                        // Skip nodes that are already part of an annotation
                        if (node.parentElement && node.parentElement.hasAttribute("data-annotation-id")) {{
                            return NodeFilter.FILTER_SKIP;
                        }}
                        if (!isShortText && !isInsideSpeechContent(node)) {{
                            // For normal text, limit to speech content
                            return NodeFilter.FILTER_SKIP;
                        }}
                        return NodeFilter.FILTER_ACCEPT;
                    }} }}
                );

                var candidates = [];
                var bestMatch = null;
                var bestMatchScore = -1;

                while (walker.nextNode()) {{
                    var node = walker.currentNode;
                    var content = node.textContent;
                    var index = content.indexOf(targetText);

                    if (index >= 0) {{
                        console.log("DEBUG: Found potential match in node:", content);
        
                        // Get both immediate context and surrounding context
                        let beforeContext = content.substring(0, index);
                        let afterContext = content.substring(index + targetText.length);
                    
                        // Calculate score using our enhanced scoring function
                        let score = calculateContextScore(
                            node, 
                            selectionInfo?.context || {{}}, 
                            isShortText, 
                            recentRemovalInfo
                        );
                    
                        console.log("DEBUG: Match found with score:", score);
                    
                        // Add to candidates array for later processing
                        candidates.push({{
                            node: node,
                            startOffset: index,
                            endOffset: index + targetText.length,
                            score: score
                        }});
                    
                        // Also track best match for backward compatibility
                        if (score > bestMatchScore) {{
                            console.log("DEBUG: New best match found with score:", score);
                            bestMatch = {{
                                startNode: node,
                                startOffset: index,
                                endNode: node,
                                endOffset: index + targetText.length
                            }};
                            bestMatchScore = score;
                        }}
                    }}
                }}
            
                // NEW: Ambiguity detection - if we have multiple high-scoring candidates
                if (candidates.length > 1 && isShortText) {{
                    console.log("DEBUG: Multiple candidates found, checking for ambiguity");
                
                    // Sort candidates by score
                    candidates.sort((a, b) => b.score - a.score);
                
                    // Check if top candidates have similar scores (within 20%)
                    if (candidates.length >= 2 && 
                        candidates[0].score > 0 &&
                        candidates[1].score / candidates[0].score > 0.8) {{
                    
                        console.log("DEBUG: Detected ambiguous candidates with similar scores");
                        console.log("Top candidate score:", candidates[0].score);
                        console.log("Second candidate score:", candidates[1].score);
                    
                        // If we have recent removal info, use it to disambiguate
                        if (recentRemovalInfo) {{
                            console.log("DEBUG: Using recent removal info to disambiguate");
                        
                            // Apply more aggressive position-based disambiguation
                            candidates = candidates.map(candidate => {{
                                try {{
                                    // Check exact parent match using XPath
                                    const candidatePath = getXPathForNode(candidate.node.parentNode);
                                    if (candidatePath === recentRemovalInfo.parentXPath) {{
                                        console.log("DEBUG: Found exact parent match for disambiguation");
                                        candidate.score += 500; // Substantial boost
                                    }}
                                
                                    // Check by position in text
                                    if (recentRemovalInfo.position !== undefined) {{
                                        const positionMatch = Math.abs(
                                            candidate.startOffset - recentRemovalInfo.position
                                        );
                                        if (positionMatch < 5) {{ // Very close position
                                            console.log("DEBUG: Found close position match for disambiguation");
                                            candidate.score += 300;
                                        }}
                                    }}
                                }} catch (err) {{
                                    console.error("Error in disambiguation:", err);
                                }}
                                return candidate;
                            }});
                        
                            // Re-sort after disambiguation
                            candidates.sort((a, b) => b.score - a.score);
                        }}
                    }}
                
                    // Use the top candidate after disambiguation
                    if (candidates.length > 0) {{
                        bestMatch = {{
                            startNode: candidates[0].node,
                            startOffset: candidates[0].startOffset,
                            endNode: candidates[0].node,
                            endOffset: candidates[0].endOffset
                        }};
                        console.log("DEBUG: Selected best candidate with score:", candidates[0].score);
                    }}
                }}

                if (bestMatch) {{
                    console.log("DEBUG: Best single-node match found.");
                    return bestMatch;
                }} else {{
                    console.log("DEBUG: No single-node match found at all.");
                }}
                return null;
            }}
        
            function getNodePosition(node) {{
                console.log("DEBUG: getNodePosition called with node =", node);
                if (!node) return null;
                var position = 0;
                var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT);

                while (walker.nextNode()) {{
                    position++;
                    if (walker.currentNode === node) {{
                        console.log("DEBUG: Node position found:", position);
                        return position;
                    }}
                }}
                console.log("DEBUG: Node position not found.");
                return null;
            }}
        
            // NEW: Function specifically designed for finding short text
            function findAndHighlightShortText() {{
                console.log("DEBUG: Using specialized short text handling path");
            
                // Try selection info first but with enhanced context handling
                if (selectionInfo) {{
                    // Expand context window for short text
                    if (selectionInfo.context) {{
                        const expandedContext = {{
                            before: selectionInfo.context.before || "",
                            text: selectionInfo.context.text || "",
                            after: selectionInfo.context.after || ""
                        }};
                    
                        // Store original context temporarily
                        const originalContext = selectionInfo.context;
                    
                        // Replace with expanded context
                        selectionInfo.context = expandedContext;
                    
                        // Try highlight with expanded context
                        const result = highlightWithSelectionInfo();
                    
                        // Restore original context
                        selectionInfo.context = originalContext;
                    
                        if (result) {{
                            console.log("DEBUG: Successfully highlighted short text with expanded context");
                            return true;
                        }}
                    }}
                }}
            
                // Next try context-based search with enhanced context scoring
                var result = findTextNodeWithContext();
                if (result) {{
                    try {{
                        console.log("DEBUG: Highlighting found text node with enhanced context for short text");
                        var range = document.createRange();
                        range.setStart(result.startNode, result.startOffset);
                        range.setEnd(result.endNode, result.endOffset);
                    
                        // Before highlighting, store this operation for future reference
                        window.lastShortTextOperation = {{
                            text: targetText,
                            parentXPath: getXPathForNode(result.startNode.parentNode),
                            position: result.startOffset,
                            timestamp: Date.now(),
                            siblingTexts: [
                                result.startNode.previousSibling ? result.startNode.previousSibling.textContent : "",
                                result.startNode.nextSibling ? result.startNode.nextSibling.textContent : ""
                            ].filter(Boolean)
                        }};
                    
                        // Highlight the text
                        var span = createHighlightSpan();
                        range.surroundContents(span);
                    
                        // Mark the parent for temporary tracking
                        if (span.parentNode) {{
                            span.parentNode.setAttribute('data-recent-highlight', 'true');
                            // Clean up attribute after a few seconds
                            setTimeout(() => {{
                                if (span.parentNode) {{
                                    span.parentNode.removeAttribute('data-recent-highlight');
                                }}
                            }}, 5000);
                        }}
                    
                        console.log("DEBUG: Found short text highlighted successfully with enhanced context");
                        return true;
                    }} catch (e) {{
                        console.log("DEBUG: Failed to highlight short text with enhanced context:", e);
                    }}
                }}
            
                // If all else fails, try a more aggressive approach for short text
                // This is a last resort that scans for positions that match recent operations
                if (recentRemovalInfo) {{
                    console.log("DEBUG: Trying aggressive recent-operation-based search as last resort");
                
                    // Try to find the parent from the recent operation first
                    const parentNode = getNodeByXPath(recentRemovalInfo.parentXPath);
                    if (parentNode) {{
                        console.log("DEBUG: Found parent node from recent operation");
                    
                        // Look for the text within this parent
                        const walker = document.createTreeWalker(
                            parentNode,
                            NodeFilter.SHOW_TEXT,
                            null
                        );
                    
                        while (walker.nextNode()) {{
                            const node = walker.currentNode;
                            const content = node.textContent;
                            const index = content.indexOf(targetText);
                        
                            if (index >= 0) {{
                                console.log("DEBUG: Found text in parent from recent operation");
                                try {{
                                    const range = document.createRange();
                                    range.setStart(node, index);
                                    range.setEnd(node, index + targetText.length);
                                
                                    const span = createHighlightSpan();
                                    range.surroundContents(span);
                                
                                    console.log("DEBUG: Successfully highlighted text based on recent operation");
                                    return true;
                                }} catch (e) {{
                                    console.log("DEBUG: Failed to highlight using recent operation approach:", e);
                                }}
                            }}
                        }}
                    }}
                }}
            
                return false;
            }}

            function findAndHighlightText() {{
                console.log("DEBUG: findAndHighlightText called.");
            
                // NEW: Handle short text with dedicated pathway
                if (isShortText) {{
                    console.log("DEBUG: Detected short text, using specialized handling");
                    const result = findAndHighlightShortText();
                    if (result) {{
                        console.log("DEBUG: Short text successfully highlighted");
                    
                        // Store this operation for future references
                        // This helps with successive operations on short text
                        window._lastHighlightOperation = {{
                            text: targetText,
                            timestamp: Date.now()
                        }};
                    
                        return true;
                    }}
                
                    // If specialized handling fails, fall back to standard approach
                    console.log("DEBUG: Short text handling failed, falling back to standard approach");
                }}
            
                // Standard highlighting path (original logic)
                // Try selection info first (exact XPath match)
                if (highlightWithSelectionInfo()) {{
                    console.log("DEBUG: Highlighted using selectionInfo.");
                    return true;
                }}

                // Try current selection next
                if (highlightSelection()) {{
                    console.log("DEBUG: Highlighted using current selection.");
                    return true;
                }}

                // Try context-based search next
                var result = findTextNodeWithContext();
                if (result) {{
                    try {{
                        console.log("DEBUG: Highlighting found text node with context.");
                        var range = document.createRange();
                        range.setStart(result.startNode, result.startOffset);
                        range.setEnd(result.endNode, result.endOffset);
                        var span = createHighlightSpan();
                        range.surroundContents(span);
                        console.log("DEBUG: Found text highlighted successfully with context.");
                        return true;
                    }} catch (e) {{
                        console.log("DEBUG: Failed to highlight found text with context:", e);
                    }}
                }}

                // As last resort, try location-based approach
                if (selectionInfo && selectionInfo.location) {{
                    console.log("DEBUG: Trying location-based approach as last resort");
                    var container = findNodeByLocationInfo(selectionInfo.location);
                    if (container) {{
                        try {{
                            console.log("DEBUG: Found container using location info");
                            var range = document.createRange();
                            var index = container.textContent.indexOf(targetText);
                            if (index >= 0) {{
                                range.setStart(container, index);
                                range.setEnd(container, index + targetText.length);
                                var span = createHighlightSpan();
                                range.surroundContents(span);
                                console.log("DEBUG: Successfully highlighted using location info");
                                return true;
                            }}
                        }} catch(e) {{
                            console.log("DEBUG: Failed to highlight using location info:", e);
                        }}
                    }}
                }}

                console.log("DEBUG: No highlighting method succeeded.");
                return false;
            }}

            console.log("DEBUG: Initiating findAndHighlightText.");
            var highlightResult = findAndHighlightText();
        
            // NEW: Store operation information for future reference
            if (highlightResult && isShortText) {{
                // This will store the last successful operation coordinates
                // for the Python code to retrieve later
                console.log("DEBUG: Storing recent operation info for future use");
            
                // This object will be accessible by the Python host
                return {{
                    success: true,
                    recentOperationInfo: {{
                        text: targetText,
                        timestamp: Date.now(),
                        isShortText: true
                    }}
                }};
            }}
        
            console.log("DEBUG: Highlight result =", highlightResult);
            console.log("=== DEBUG: JavaScript Execution Ended ===");
            return highlightResult;
        }})();
        '''

        def handle_highlight_result(result):
            """Handle the result of the highlight operation and store information about short text operations"""
            # Check for successful result (either boolean True or dict with success: true)
            is_successful = result is True or (isinstance(result, dict) and result.get('success'))
            
            if is_successful:
                # Extract operation info if available (only for dict results)
                if isinstance(result, dict) and result.get('recentOperationInfo'):
                    # Store recent operation info for future use
                    self._recent_removal_info = result['recentOperationInfo']
                    print(f"DEBUG: Stored recent operation info: {self._recent_removal_info}")
                
                    # Set up auto-cleanup after 10 seconds
                    def cleanup_recent_info():
                        if hasattr(self, '_recent_removal_info'):
                            delattr(self, '_recent_removal_info')
                            print("DEBUG: Cleaned up recent operation info")
                
                    QTimer.singleShot(10000, cleanup_recent_info)
                
                # Apply filters to the newly created annotation (performance optimized)
                self._apply_filters_to_annotation(annotation_id, scene, annotation)
            
                print(f"Highlight successful: {result}")
            else:
                print(f"Highlight operation result: {result}")

        print("\n=== DEBUG: Exiting highlight_text ===")
        print(f"Text Highlighted: {text}")
        print(f"Scene: {scene}")
        print(f"Annotation ID: {annotation_id}")
        if selection_info:
            print(f"Context Before: {selection_info.get('context', {}).get('before', '')}")
            print(f"Text: {selection_info.get('context', {}).get('text', '')}")
            print(f"Context After: {selection_info.get('context', {}).get('after', '')}")
        else:
            print("Selection Info: None")

        self.page().runJavaScript(js_code, handle_highlight_result)

    def _apply_filters_to_annotation(self, annotation_id, scene, annotation):
        """
        Apply current active filters to a single newly created annotation (performance optimized).
        This avoids running the full filter refresh on all annotations.
        """
        if not annotation_id:
            return

        print(f"[DEBUG] Applying targeted filters to annotation {annotation_id}")

        # Get the theme's background color for proper styling
        theme_style = self.scene_styles.get(scene, 'background-color: yellow;')
        # Extract just the background color from the style string
        import re
        bg_color_match = re.search(r'background-color:\s*([^;]+)', theme_style)
        theme_bg_color = bg_color_match.group(1).strip() if bg_color_match else 'yellow'

        # Create JavaScript to apply filters only to the specific annotation
        js_code = f"""
        (function() {{
            const annotationId = "{annotation_id}";
            const scene = "{scene}";
            const themeBgColor = "{theme_bg_color}";
            const annotation = document.querySelector(`[data-annotation-id="${{annotationId}}"]`);

            if (!annotation) {{
                console.log(`[DEBUG] Annotation span not found for ID: ${{annotationId}}`);
                return false;
            }}

            console.log(`[DEBUG] Applying targeted filters to annotation ${{annotationId}} (scene: ${{scene}}, theme color:
    ${{themeBgColor}})`);

            // Clear all filter classes first
            annotation.classList.remove('tag-filtered-hidden', 'theme-hidden', 'favorites-hidden', 'used-hidden',
    'unused-hidden');

            // Start with the assumption that the annotation should be visible
            let shouldHide = false;

            // 1. Apply tag filters if active
            if (window.stickyHeaderTagState && window.stickyHeaderTagState.isActive) {{
                const tagState = window.stickyHeaderTagState;
                const tagStates = tagState.tagStates;
                const strictMode = tagState.strictMode;

                if (Object.keys(tagStates).length > 0) {{
                    const rawTags = annotation.getAttribute('data-tags');
                    let annotationTags = [];
                    try {{
                        annotationTags = rawTags ? JSON.parse(rawTags) : [];
                    }} catch (e) {{
                        annotationTags = (rawTags || '').split(',').map(t => t.trim()).filter(t => t);
                    }}

                    // Get included and excluded tags (remove # prefix)
                    const includedTags = Object.keys(tagStates)
                        .filter(tag => tagStates[tag] === 'included')
                        .map(tag => tag.replace(/^#/, ''));
                    const excludedTags = Object.keys(tagStates)
                        .filter(tag => tagStates[tag] === 'excluded')
                        .map(tag => tag.replace(/^#/, ''));

                    // Check excluded tags first
                    const hasExcludedTag = excludedTags.some(tag => annotationTags.includes(tag));
                    if (hasExcludedTag) {{
                        shouldHide = true;
                        console.log(`[DEBUG] Annotation ${{annotationId}} hidden by excluded tag`);
                    }} else if (includedTags.length > 0) {{
                        if (strictMode) {{
                            // AND mode - must have ALL included tags
                            const hasAllIncluded = includedTags.every(tag => annotationTags.includes(tag));
                            if (!hasAllIncluded) {{
                                shouldHide = true;
                                console.log(`[DEBUG] Annotation ${{annotationId}} hidden by tag filter (strict mode)`);
                            }}
                        }} else {{
                            // OR mode - must have AT LEAST ONE included tag
                            const hasSomeIncluded = includedTags.some(tag => annotationTags.includes(tag));
                            if (!hasSomeIncluded) {{
                                shouldHide = true;
                                console.log(`[DEBUG] Annotation ${{annotationId}} hidden by tag filter (loose mode)`);
                            }}
                        }}
                    }}

                    if (shouldHide) {{
                        annotation.classList.add('tag-filtered-hidden');
                    }}
                }}
            }}

            // 2. Apply favorites filter if active (only if not already hidden by tags)
            if (!shouldHide && window.stickyHeaderFilters && window.stickyHeaderFilters.favorites) {{
                const isFavorite = annotation.getAttribute('data-favorite') === 'true';
                if (!isFavorite) {{
                    shouldHide = true;
                    annotation.classList.add('favorites-hidden');
                    console.log(`[DEBUG] Annotation ${{annotationId}} hidden by favorites filter`);
                }}
            }}

            // 3. Apply used filter if active (only if not already hidden)
            if (!shouldHide && window.stickyHeaderFilters && window.stickyHeaderFilters.used !== 0) {{
                const isUsed = annotation.getAttribute('data-used') === 'true';
                if (window.stickyHeaderFilters.used === 1 && isUsed) {{
                    // Hide used annotations
                    shouldHide = true;
                    annotation.classList.add('used-hidden');
                    console.log(`[DEBUG] Annotation ${{annotationId}} hidden by used filter (hiding used)`);
                }} else if (window.stickyHeaderFilters.used === 2 && !isUsed) {{
                    // Hide unused annotations
                    shouldHide = true;
                    annotation.classList.add('unused-hidden');
                    console.log(`[DEBUG] Annotation ${{annotationId}} hidden by used filter (hiding unused)`);
                }}
            }}

            // 4. Apply theme visibility filters (only if not already hidden)
            if (!shouldHide && window.stickyHeaderState) {{
                const themeState = window.stickyHeaderState;

                // Check if theme is in solo mode and this isn't the solo theme
                if (themeState.soloTheme && scene !== themeState.soloTheme) {{
                    shouldHide = true;
                    annotation.classList.add('theme-hidden');
                    annotation.style.border = '1px dashed #ccc';
                    annotation.style.backgroundColor = '#e8e8e8';
                    console.log(`[DEBUG] Annotation ${{annotationId}} hidden by solo mode`);
                }} else if (themeState.hiddenThemes && themeState.hiddenThemes.has(scene)) {{
                    // Hide if theme is in hidden themes set
                    shouldHide = true;
                    annotation.classList.add('theme-hidden');
                    annotation.style.border = '1px dashed #ccc';
                    annotation.style.backgroundColor = '#e8e8e8';
                    console.log(`[DEBUG] Annotation ${{annotationId}} hidden by theme filter`);
                }}
            }}

            // 5. If annotation should be visible, ensure proper theme styling
            if (!shouldHide) {{
                // Remove any theme-hidden styling and restore proper theme colors
                annotation.classList.remove('theme-hidden');
                annotation.style.border = '';
                annotation.style.backgroundColor = themeBgColor; // Restore theme background color
                console.log(`[DEBUG] Annotation ${{annotationId}} is visible with theme color ${{themeBgColor}}`);
            }}

            console.log(`[DEBUG] Targeted filtering complete for annotation ${{annotationId}} - shouldHide:
    ${{shouldHide}}`);
            return true;
        }})();
        """

        def handle_filter_result(result):
            if result:
                print(f"[DEBUG] Successfully applied targeted filters to annotation {annotation_id}")
            else:
                print(f"[DEBUG] Failed to apply targeted filters to annotation {annotation_id}")

        self.page().runJavaScript(js_code, handle_filter_result)

    def log_js_result(result):
        print(f"JS Execution Result: {result}")

    def storyboard_aware_remove_highlight(self, text):
        """
        Wrapper that handles highlight removal with proper dialog prioritization:
        1. Auto-selection dialog (if needed)
        2. Storyboard conflict dialog (if needed and auto-selection not needed)
        3. Normal removal (if neither dialog is needed)

        Enhanced to handle positional strikethrough with context information.
        """
        print("DEBUG: Starting storyboard-aware removal process")

        # Create a class-level dictionary to store headers - accessible to all callbacks
        self.original_headers = {}

        # Also track positional strikethrough contexts for preservation
        self.original_strikethrough_contexts = {}

        # First check if auto-selection is needed (partial selection of multiple highlights)
        js_code = '''
            (function() {
                var selection = window.getSelection();
                if (!selection || selection.rangeCount === 0) {
                    return { needsAutoSelection: false, error: "No selection" };
                }

                var range = selection.getRangeAt(0);
                var intersectingSpans = [];
                var annotationIds = new Set();

                // Find all intersecting spans
                document.querySelectorAll('span[data-annotation-id]').forEach(function(span) {
                    if (range.intersectsNode(span)) {
                        intersectingSpans.push(span);
                        annotationIds.add(span.getAttribute('data-annotation-id'));
                    }
                });

                // If we have multiple spans with different IDs, check if any are partial
                if (annotationIds.size > 1) {
                    var partiallySelected = false;

                    intersectingSpans.forEach(function(span) {
                        var spanRange = document.createRange();
                        spanRange.selectNodeContents(span);
    
                        // Check if span is not fully contained in selection
                        if (!(
                            range.compareBoundaryPoints(Range.START_TO_START, spanRange) <= 0 &&
                            range.compareBoundaryPoints(Range.END_TO_END, spanRange) >= 0
                        )) {
                            partiallySelected = true;
                        }
                    });

                    return { 
                        needsAutoSelection: partiallySelected,
                        annotationCount: annotationIds.size
                    };
                }

                return { needsAutoSelection: false };
            })();
        '''

        def check_auto_selection(result):
            print(f"DEBUG: Auto-selection check result: {result}")

            if result and isinstance(result, dict) and result.get('needsAutoSelection'):
                print("DEBUG: Detected need for auto-selection, using normal remove_highlight")
                # Just use normal remove_highlight - it will show the auto-selection dialog
                self.remove_highlight(text)
                return
    
            # If no auto-selection needed, proceed with storyboard conflict check
            check_for_storyboard_conflicts()

        def check_for_storyboard_conflicts():
            """Check if there are storyboard conflicts and show dialog if needed"""
            js_code = '''
                (function() {
                    var selection = window.getSelection();
                    if (!selection || selection.rangeCount === 0) {
                        return { hasConflict: false, error: "No selection" };
                    }

                    var range = selection.getRangeAt(0);
                    var storyboardSpans = [];
                    var debugInfo = {
                        spanInfo: [],
                        annotationChecks: []
                    };

                    // Look for partial selections of spans with storyboard entries
                    document.querySelectorAll('span[data-annotation-id]').forEach(function(span) {
                        if (range.intersectsNode(span)) {
                            // Collect debug info about each span
                            var id = span.getAttribute('data-annotation-id');
                            var hasOrder = span.hasAttribute('data-order');
                            var hasStoryboardAttr = span.hasAttribute('data-storyboard');
                            var spanDebug = {
                                id: id,
                                hasOrder: hasOrder,
                                hasStoryboardAttr: hasStoryboardAttr,
                                orderValue: span.getAttribute('data-order'),
                                storyboardSample: span.hasAttribute('data-storyboard') 
                                    ? span.getAttribute('data-storyboard').substring(0, 50) + "..." 
                                    : "none"
                            };
                            debugInfo.spanInfo.push(spanDebug);
                
                            // Enhanced storyboard detection
                            var hasStoryboard = false;
                            var order = span.getAttribute('data-order');
                            var storyboardAttr = span.getAttribute('data-storyboard');
                
                            // Check if attributes explicitly indicate NOT in storyboard
                            if (order === "False" || order === "false" || order === "None" || order === "null") {
                                hasStoryboard = false;
                                debugInfo.annotationChecks.push({
                                    id: id,
                                    detection: "order explicitly false/none",
                                    hasStoryboard: false,
                                    orderValue: order
                                });
                            }
                            else if (storyboardAttr === "False" || storyboardAttr === "false" || storyboardAttr === "None" || storyboardAttr === "null" || storyboardAttr === "none") {
                                hasStoryboard = false;
                                debugInfo.annotationChecks.push({
                                    id: id,
                                    detection: "storyboard explicitly false/none",
                                    hasStoryboard: false,
                                    storyboardValue: storyboardAttr
                                });
                            }
                            // ONLY check for valid order number if not explicitly disabled
                            else if (order !== null && order !== "" && !isNaN(parseInt(order))) {
                                hasStoryboard = true;
                                debugInfo.annotationChecks.push({
                                    id: id,
                                    detection: "has valid order number",
                                    hasStoryboard: true,
                                    orderNumber: parseInt(order)
                                });
                            } 
                            // Second check - parse storyboard JSON to check for valid order number
                            else if (storyboardAttr && storyboardAttr !== "") {
                                try {
                                    var storyboardData = JSON.parse(storyboardAttr);
                                    if (storyboardData && typeof storyboardData === 'object' && 
                                        storyboardData.order !== null && storyboardData.order !== undefined && 
                                        !isNaN(parseInt(storyboardData.order))) {
                                        hasStoryboard = true;
                                        debugInfo.annotationChecks.push({
                                            id: id,
                                            detection: "parsed JSON with valid order",
                                            hasStoryboard: true,
                                            orderNumber: parseInt(storyboardData.order)
                                        });
                                    }
                                } catch(e) {
                                    debugInfo.annotationChecks.push({
                                        id: id,
                                        detection: "parse error",
                                        error: e.toString()
                                    });
                                }
                            }
                            // No storyboard detected
                            else {
                                debugInfo.annotationChecks.push({
                                    id: id,
                                    detection: "no storyboard detected",
                                    hasStoryboard: false
                                });
                            }
        
                            if (hasStoryboard) {
                                // Check if it's a partial selection
                                var spanRange = document.createRange();
                                spanRange.selectNodeContents(span);

                                var fullyContained = (
                                    range.compareBoundaryPoints(Range.START_TO_START, spanRange) <= 0 &&
                                    range.compareBoundaryPoints(Range.END_TO_END, spanRange) >= 0
                                );

                                if (!fullyContained) {
                                    // Calculate the intersection of user selection (range) and this span (spanRange)
                                    var intersectionRange = range.cloneRange(); // Start with user's selection

                                    // Trim intersection range to span boundaries:
                                    // If selection starts before the span, intersection starts at span's start.
                                    if (intersectionRange.compareBoundaryPoints(Range.START_TO_START, spanRange) < 0) {
                                        intersectionRange.setStart(spanRange.startContainer, spanRange.startOffset);
                                    }
                                    // If selection ends after the span, intersection ends at span's end.
                                    if (intersectionRange.compareBoundaryPoints(Range.END_TO_END, spanRange) > 0) {
                                        intersectionRange.setEnd(spanRange.endContainer, spanRange.endOffset);
                                    }

                                    var selectedTextInSpan = "";
                                    // Make sure the resulting intersection range is valid (start <= end) before getting text
                                    if (intersectionRange.compareBoundaryPoints(Range.START_TO_END, intersectionRange) <= 0) {
                                         selectedTextInSpan = intersectionRange.toString();
                                    }

                                    storyboardSpans.push({
                                        id: span.getAttribute('data-annotation-id'),
                                        text: span.textContent, // Full text of the span itself
                                        selectedTextInSpan: selectedTextInSpan // Text of the intersection
                                    });
                                }
                            }
                        }
                    });

                    return { 
                        hasConflict: storyboardSpans.length > 0,
                        storyboardSpans: storyboardSpans,
                        debugInfo: debugInfo
                    };
                })();
            '''

            def process_conflict_results(result):
                print(f"DEBUG: Storyboard conflict check result: {result}")

                if not result or not isinstance(result, dict):
                    print("DEBUG: Invalid result from conflict check")
                    self.remove_highlight(text, False, False)
                    return

                # Log debug info if available
                if 'debugInfo' in result:
                    debug_info = result['debugInfo']
                    print("\nDEBUG: Enhanced span information:")
                    for span_info in debug_info.get('spanInfo', []):
                        print(f"Span ID: {span_info.get('id')}")
                        print(f"  Has 'data-order' attribute: {span_info.get('hasOrder')}")
                        print(f"  Has 'data-storyboard' attribute: {span_info.get('hasStoryboardAttr')}")
                        print(f"  Order value: {span_info.get('orderValue')}")
                        print(f"  Storyboard data: {span_info.get('storyboardSample')}")

                    print("\nDEBUG: Storyboard detection results:")
                    for check in debug_info.get('annotationChecks', []):
                        print(f"ID: {check.get('id')}")
                        print(f"  Detection method: {check.get('detection')}")
                        print(f"  Has storyboard: {check.get('hasStoryboard')}")
                        if 'error' in check:
                            print(f"  Error: {check.get('error')}")

                # If there's NO conflict detected by the JavaScript code, let's do a second check in Python
                # This catches cases where DOM attributes aren't correctly set but Python data is present
                if not result.get('hasConflict', False):
                    # Get all annotation IDs that intersect with the selection
                    intersecting_ids = []
                    for span_info in result.get('debugInfo', {}).get('spanInfo', []):
                        span_id = span_info.get('id')
                        if span_id:
                            intersecting_ids.append(span_id)

#                     print(f"DEBUG: Intersecting IDs from JavaScript: {intersecting_ids}")

                    # Check if any of these annotations has storyboard data in Python
                    storyboard_conflict_found = False
                    affected_annotation = None

                    for anno_id in intersecting_ids:
                        for anno in self.annotations:
                            if anno.get('id') == anno_id:
                                # Check for storyboard data in Python with STRICTER checks
                                has_storyboard = False
                                header_found = False  # Initialize header_found to avoid UnboundLocalError
            
                                # ONLY check for valid numeric order - this determines storyboard membership
                                if 'order' in anno and anno['order'] is not None:
                                    order_val = str(anno['order']).strip()
                                    if order_val.isdigit():
                                        has_storyboard = True
            
                                # Then check storyboard dictionary for valid numeric order only
                                storyboard_dict = anno.get('storyboard')
                                if isinstance(storyboard_dict, dict) and storyboard_dict:
                                    if 'order' in storyboard_dict and storyboard_dict['order'] is not None:
                                        order_val = str(storyboard_dict['order']).strip()
                                        if order_val.isdigit():
                                            has_storyboard = True

                                        # IMPORTANT: Look for header in storyboard text
                                        if 'text' in anno['storyboard']:
                                            storyboard_text = anno['storyboard']['text']
#                                             print(f"DEBUG: Checking for header in storyboard text: {repr(storyboard_text[:100])}")
                        
                                            # Use extract_header_from_text function to detect headers
                                            header, text_without_header = self.extract_header_from_text(storyboard_text)
                                            if header:
                                                header_found = True
                                                print(f"DEBUG: Found header in storyboard text: {repr(header)}")
                            
                                                # Store the header in our class-level dictionary
                                                self.original_headers[anno_id] = header
                                                print(f"DEBUG: Stored header for annotation {anno_id} for later preservation")
                                        
                                        # NEW: Also check for and preserve positional strikethrough data with context
                                        if 'strikethrough_segments' in anno['storyboard'] or 'positional_strikethrough' in anno['storyboard']:
#                                             print(f"DEBUG: Found strikethrough data in storyboard for {anno_id}")
                                    
                                            # Store the positional strikethrough data for later preservation
                                            strikethrough_context = {}
                                    
                                            # First check traditional strikethrough segments
                                            if 'strikethrough_segments' in anno['storyboard']:
                                                strikethrough_context['segments'] = anno['storyboard']['strikethrough_segments']
                                        
                                            # Then check positional data with context
                                            if 'positional_strikethrough' in anno['storyboard']:
                                                strikethrough_context['positional'] = anno['storyboard']['positional_strikethrough']
                                        
                                            # Store if any data was found
                                            if strikethrough_context:
                                                self.original_strikethrough_contexts[anno_id] = strikethrough_context
#                                                 print(f"DEBUG: Stored strikethrough context for annotation {anno_id}")
        
                                    if has_storyboard:
#                                         print(f"DEBUG: Found storyboard data in Python for annotation {anno_id}")
                                        if header_found:
                                            print(f"DEBUG: Including header data for annotation {anno_id}")
                                        storyboard_conflict_found = True
                                        affected_annotation = anno
                                        break
    
                                if storyboard_conflict_found:
                                    break

                        if storyboard_conflict_found:
                            break

                    if storyboard_conflict_found and affected_annotation:
#                         print("DEBUG: Storyboard conflict detected by Python even though JavaScript didn't detect it")
                        show_storyboard_conflict_dialog(affected_annotation)
                        return

                if not result.get('hasConflict', False):
                    print("DEBUG: No storyboard conflict detected")
                    self.remove_highlight(text, False, False)
                    return

                storyboard_spans = result.get('storyboardSpans', [])
                if not storyboard_spans:
                    print("DEBUG: No storyboard spans info available")
                    self.remove_highlight(text, False, False)
                    return

                # Get full annotation data for the first affected span
                affected_id = storyboard_spans[0].get('id')
                if not affected_id:
                    print("DEBUG: No annotation ID found")
                    self.remove_highlight(text, False, False)
                    return

                affected_annotation = None
                for anno in self.annotations:
                    if anno.get('id') == affected_id:
                        affected_annotation = anno
                        break

                if not affected_annotation:
                    print(f"DEBUG: Could not find annotation with ID {affected_id}")
                    self.remove_highlight(text, False, False)
                    return

                # Verify it has storyboard data and check for headers
                has_storyboard = False
                header_found = False

                # Check for valid order number in annotation root
                if 'order' in affected_annotation:
                    order_value = affected_annotation['order']
                    if (order_value is not None and 
                        isinstance(order_value, (int, str)) and
                        str(order_value).isdigit()):
                        has_storyboard = True

                if isinstance(affected_annotation.get('storyboard'), dict):
                    # ONLY check for valid order number - this determines storyboard membership
                    order_value = affected_annotation['storyboard'].get('order')
                    if (order_value is not None and 
                        isinstance(order_value, (int, str)) and
                        str(order_value).isdigit()):
                        has_storyboard = True
    
                        # IMPORTANT: Check for header in the storyboard text
                        if 'text' in affected_annotation['storyboard']:
                            storyboard_text = affected_annotation['storyboard']['text']
#                             print(f"DEBUG: Checking for header in storyboard text: {repr(storyboard_text[:100])}")
        
                            # Use extract_header_from_text function
                            header, text_without_header = self.extract_header_from_text(storyboard_text)
                            if header:
                                header_found = True
                                print(f"DEBUG: Found header in storyboard text: {repr(header)}")
            
                                # Store the header for preservation in the class-level dictionary
                                self.original_headers[affected_id] = header
                                print(f"DEBUG: Stored header for annotation {affected_id} for later preservation")
                        
                    # NEW: Also check for and preserve positional strikethrough data with context
                    if 'strikethrough_segments' in affected_annotation['storyboard'] or 'positional_strikethrough' in affected_annotation['storyboard']:
                        print(f"DEBUG: Found strikethrough data in affected annotation {affected_id}")
                
                        # Store the positional strikethrough data for later preservation
                        strikethrough_context = {}
                
                        # First check traditional strikethrough segments
                        if 'strikethrough_segments' in affected_annotation['storyboard']:
                            strikethrough_context['segments'] = affected_annotation['storyboard']['strikethrough_segments']
                    
                        # Then check positional data with context
                        if 'positional_strikethrough' in affected_annotation['storyboard']:
                            strikethrough_context['positional'] = affected_annotation['storyboard']['positional_strikethrough']
                    
                        # Store if any data was found
                        if strikethrough_context:
                            self.original_strikethrough_contexts[affected_id] = strikethrough_context
#                             print(f"DEBUG: Stored strikethrough context for affected annotation {affected_id}")

                if not has_storyboard:
                    print("DEBUG: Annotation doesn't have storyboard data")
                    self.remove_highlight(text, False, False)
                    return

                print("DEBUG: Found storyboard annotation, showing dialog")
                if header_found:
                    print("DEBUG: Header will be preserved during highlight removal")
            
                # Call the dialog function
                try:
                    show_storyboard_conflict_dialog(affected_annotation)
                except Exception as e:
                    print(f"DEBUG: Error showing dialog: {e}")
                    # Fallback to normal removal
                    self.remove_highlight(text, False, False)

            def show_storyboard_conflict_dialog(affected_annotation):
                """Show dialog for resolving storyboard conflicts with option-based highlighting"""
                _outer_self = self # Capture self from the enclosing scope

#                 print(f"DEBUG: Starting storyboard conflict dialog for annotation: {affected_annotation.get('id')}")

                # Get the current selection synchronously 
                current_selection = ""
                try:
                    # Get selection text directly - this runs synchronously
                    js_code = '''
                        (function() {
                            var selection = window.getSelection();
                            return selection ? selection.toString() : "";
                        })();
                    '''
    
                    if hasattr(_outer_self.page(), 'mainFrame'):  # Qt5 WebKit
                        current_selection = _outer_self.page().mainFrame().evaluateJavaScript(js_code)
                    else:  # Fallback
                        current_selection = text  # Use the text parameter passed to the function
        
                    print(f"DEBUG: Got selection text synchronously: '{current_selection}'")
                except Exception as e:
#                     print(f"DEBUG: Error getting selection synchronously: {e}")
                    current_selection = text  # Fallback to the text parameter

                # ADD THIS - Extra validation to prevent false positives
                has_valid_storyboard = False

                # Check direct order attribute
                order_val = affected_annotation.get('order')
                if order_val is not None and str(order_val).strip():
                    has_valid_storyboard = True

                # Check storyboard dictionary
                storyboard_dict = affected_annotation.get('storyboard')
                if isinstance(storyboard_dict, dict) and storyboard_dict:  # Make sure it's not empty
                    if ('order' in storyboard_dict and storyboard_dict['order'] is not None and 
                        str(storyboard_dict['order']).strip()) or \
                       ('text' in storyboard_dict and storyboard_dict['text'] and 
                        storyboard_dict['text'].strip()):
                        has_valid_storyboard = True

                # Skip dialog for false positives
                if not has_valid_storyboard:
                    print("DEBUG: False positive detected - annotation has no meaningful storyboard data")
                    _outer_self.remove_highlight(text, False, False)
                    return

#                 print("DEBUG: Creating storyboard conflict dialog")
            
                try:
                    dialog_parent = _outer_self.parent() if hasattr(_outer_self, 'parent') else None
                    dialog = QDialog(dialog_parent)
                    dialog.setWindowTitle("Remove Highlight in Script Editor")
                    dialog.setMinimumWidth(600)
                    dialog.setMinimumHeight(440)
                    layout = QVBoxLayout(dialog)
                    layout.setSpacing(10)
                    layout.setContentsMargins(15, 15, 15, 15)
                
#                     print("DEBUG: Dialog created successfully")
                except Exception as e:
                    print(f"ERROR creating dialog: {e}")
                    # If we can't create the dialog, just do normal removal
                    _outer_self.remove_highlight(text, False, False)
                    return

                # --- Order Info & Basic Labels (No changes) ---
                order_val = affected_annotation.get('order')
                storyboard_dict = affected_annotation.get('storyboard')
                if order_val is None and isinstance(storyboard_dict, dict):
                    order_val = storyboard_dict.get('order')
                if order_val is not None:
                    try:
                        user_facing_order = _outer_self.calculate_user_facing_order_number(int(order_val))
                        order_label = QLabel(f"Selection is part of item #{user_facing_order} in the Script Editor.")
                        order_label.setStyleSheet("font-weight: bold; color: #000; font-size: 14pt;")
                        layout.addWidget(order_label)
                    except (ValueError, TypeError):
                        order_label = QLabel("Script Editor Entry (unknown order)")
                        order_label.setStyleSheet("font-weight: bold; color: #000; font-size: 14pt;")
                        layout.addWidget(order_label)
                # Determine which message to show based on the presence of an order number
                if (order_val is None or not str(order_val).strip()) and isinstance(storyboard_dict, dict) and storyboard_dict.get('text', '').strip():
                    info_text = "The text marked for removal is part of an item that, while not in the Script Editor, has associated text data."
                else:
                    info_text = "You are about to remove text that features in the Script Editor. How should we proceed?"

                info_label = QLabel(info_text)
                info_label.setWordWrap(True)
                info_label.setStyleSheet("color: #2C4952; font-size: 13px;")
                layout.addWidget(info_label)

                # --- Text Preview Section initial setup ---
                storyboard_text_original = ""
                strikethrough_segments = {}
                positional_strikethrough = {}
                if isinstance(storyboard_dict, dict):
                    storyboard_text_original = storyboard_dict.get('text', '') or ""
                    strikethrough_segments = storyboard_dict.get('strikethrough_segments', {}) or {}
                    positional_strikethrough = storyboard_dict.get('positional_strikethrough', {}) or {}

                # Create labels for preview section
                preview_label = QLabel("Text Preview:")
                preview_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
                layout.addWidget(preview_label)

                # Add description label
                highlight_info = QLabel("RED highlight: Text marked for removal  •  Pink text: Existing strikethroughs")
                highlight_info.setStyleSheet("color: #666; font-style: italic; font-size: 11px;")
                layout.addWidget(highlight_info)  # Changed: Adding the highlight_info label

                if 'text' in affected_annotation:
                    actual_highlight_text = affected_annotation['text']
                    print(f"DEBUG: Actual highlight text from annotation: '{actual_highlight_text[:50]}...'")
                    # Store this text for comparison in update_preview_with_highlight
                    _outer_self.current_highlight_text = actual_highlight_text
                else:
                    print("DEBUG: No text found in annotation, will rely on selection")
                    _outer_self.current_highlight_text = None

                # Create the text edit widget
                text_edit = QTextEdit()
                text_edit.setReadOnly(True)
                text_edit.setAcceptRichText(True)
                text_edit.setFixedHeight(150)
                layout.addWidget(text_edit)

                # FIXED: Define update_preview_with_highlight as a properly nested function
                def update_preview_with_highlight(show_highlighting=True):
                    try:
                        print(f"DEBUG: Updating preview with highlighting={show_highlighting}")

                        # Start with original text
                        preview_text = storyboard_text_original

                        if storyboard_text_original:
                            # --- Process strikethrough segments ---
                            strike_segments_to_apply = []  # Store (start, end) coordinates
                            processed_keys_context = set()
                            context_segments_to_process = {}
                            non_context_segments_to_process = {}

                            # 1. Categorize segments
                            if isinstance(strikethrough_segments, dict):
                                for segment_key, is_struck in strikethrough_segments.items():
                                    if not is_struck or not segment_key: continue
                                    is_context_specific_segment = False
                                    data = None
                                    if isinstance(positional_strikethrough, dict) and segment_key in positional_strikethrough:
                                        data = positional_strikethrough[segment_key]
                                        if isinstance(data, dict):
                                            if data.get("is_context_specific") or \
                                               data.get("context_before", "").strip() or \
                                               data.get("context_after", "").strip():
                                                is_context_specific_segment = True
                                        else: data = None  # Ignore non-dict positional data
                                    if is_context_specific_segment and data: context_segments_to_process[segment_key] = data
                                    else:
                                        if segment_key not in context_segments_to_process: non_context_segments_to_process[segment_key] = True

                            # 2. Process CONTEXT-SPECIFIC segments
                            if context_segments_to_process:
                                # --- Define find_with_context Helper Locally ---
                                def find_with_context(base_word, text, context_data):
                                    context_before = context_data.get("context_before", "")
                                    context_after = context_data.get("context_after", "")
                                    context_before = re.sub(r'<[^>]+>', '', context_before)
                                    context_after = re.sub(r'<[^>]+>', '', context_after)

                                    req_prefix_10 = context_before[-10:] if len(context_before) >= 10 else context_before
                                    req_suffix_10 = context_after[:10] if len(context_after) >= 10 else context_after
                                    req_prefix_6 = context_before[-6:] if len(context_before) >= 6 else context_before
                                    req_suffix_6 = context_after[:6] if len(context_after) >= 6 else context_after

                                    def find_with_specific_context(req_prefix, req_suffix):
                                        pos = 0
                                        while True:
                                            # Make sure base_word is not empty before find
                                            if not base_word: return None
                                            try: pos = text.find(base_word, pos)
                                            except Exception: return None
                                            if pos == -1: break
                                            has_full_prefix = pos >= len(req_prefix) if req_prefix else True
                                            has_full_suffix = (pos + len(base_word) + len(req_suffix) <= len(text)) if req_suffix else True
                                            if req_prefix and req_suffix and has_full_prefix and has_full_suffix:
                                                actual_prefix = text[pos - len(req_prefix):pos]
                                                actual_suffix = text[pos + len(base_word):pos + len(base_word) + len(req_suffix)]
                                                if actual_prefix == req_prefix and actual_suffix == req_suffix: return pos, pos + len(base_word)
                                                else: pos += 1; continue
                                            prefix_ok, suffix_ok = True, True
                                            if req_prefix:
                                                if has_full_prefix: prefix_ok = (text[pos - len(req_prefix):pos] == req_prefix)
                                                else: prefix_ok = req_prefix.endswith(text[max(0, pos - len(req_prefix)):pos])
                                            # Check base_word and its first char before accessing index
                                            elif pos > 0 and text[pos-1].isalnum() and base_word and base_word[0].isalnum(): prefix_ok = False
                                            if req_suffix:
                                                if has_full_suffix: suffix_ok = (text[pos + len(base_word):pos + len(base_word) + len(req_suffix)] == req_suffix)
                                                else: suffix_ok = req_suffix.startswith(text[pos + len(base_word):min(len(text), pos + len(base_word) + len(req_suffix))])
                                            # Check base_word and its last char before accessing index
                                            elif (pos + len(base_word)) < len(text) and text[pos + len(base_word)].isalnum() and base_word and base_word[-1].isalnum(): suffix_ok = False
                                            if prefix_ok and suffix_ok: return pos, pos + len(base_word)
                                            pos += 1
                                        return None

                                    # --- Find logic using helper ---
                                    match = None
                                    has_sufficient_10_prefix = len(context_before) >= 10; has_sufficient_10_suffix = len(context_after) >= 10
                                    has_sufficient_6_prefix = len(context_before) >= 6; has_sufficient_6_suffix = len(context_after) >= 6

                                    if has_sufficient_10_prefix and has_sufficient_10_suffix:
                                        match = find_with_specific_context(req_prefix_10, req_suffix_10)
                                    if not match and has_sufficient_6_prefix and has_sufficient_6_suffix:
                                        match = find_with_specific_context(req_prefix_6, req_suffix_6)
                                    if not match and req_prefix_10: # Changed from elif to if
                                        match = find_with_specific_context(req_prefix_10, "")
                                    if not match and req_suffix_10: # Changed from elif to if
                                        match = find_with_specific_context("", req_suffix_10)

                                    # Fallback to simple find if context fails and base_word exists
                                    if not match and base_word:
                                        simple_pos = text.find(base_word)
                                        if simple_pos != -1:
                                            match = (simple_pos, simple_pos + len(base_word))
                                    return match
                                # --- End of find_with_context Helper ---

                                # Loop through context segments
                                for segment_key, data in context_segments_to_process.items():
                                    processed_keys_context.add(segment_key)
                                    # Determine base word
                                    base_word = data.get('base_word', segment_key)
                                    if not base_word or base_word == segment_key:
                                        match_key = re.match(r'^(.+)_(\d+)$', segment_key)
                                        if match_key: base_word = match_key.group(1)
                                    # Find the specific match using context
                                    match_coords = find_with_context(base_word, storyboard_text_original, data) # Pass base_word here
                                    if match_coords:
                                        start, end = match_coords
                                        # Add coordinates, basic overlap check
                                        is_overlapping = False
                                        for r_start, r_end in strike_segments_to_apply:
                                             if max(start, r_start) < min(end, r_end): is_overlapping = True; break
                                        if not is_overlapping:
                                            strike_segments_to_apply.append((start, end))
#                                             print(f"DEBUG (Preview): Added context strike segment '{base_word}' range [{start}:{end}] for key '{segment_key}'")
                                        else:
                                            pass  # Skipped overlapping context strike segment
#                                              print(f"DEBUG (Preview): Skipped overlapping context strike segment '{base_word}' range [{start}:{end}]")

                            # 3. Process NON-CONTEXT segments
                            non_context_keys_final = [k for k in non_context_segments_to_process if k not in processed_keys_context]
                            if non_context_keys_final:
                                for segment_key in non_context_keys_final:
                                    if not segment_key: continue
                                    # Find all occurrences of the EXACT segment_key
                                    pos = 0
                                    while True:
                                        try: pos = storyboard_text_original.find(segment_key, pos)
                                        except Exception: break
                                        if pos == -1: break
                                        start = pos
                                        end = pos + len(segment_key)  # Use length of exact key
                                        # Add coordinates, basic overlap check
                                        is_overlapping = False
                                        for r_start, r_end in strike_segments_to_apply:
                                            if max(start, r_start) < min(end, r_end): is_overlapping = True; break
                                        if not is_overlapping:
                                            strike_segments_to_apply.append((start, end))
#                                             print(f"DEBUG (Preview): Added non-context strike segment '{segment_key}' range [{start}:{end}]")
                                        else:
                                            pass  # Skipped overlapping non-context strike segment
#                                             print(f"DEBUG (Preview): Skipped overlapping non-context strike segment '{segment_key}' range [{start}:{end}]")
                                        pos += 1  # Move to next position

                            # --- NEW IMPROVED SECTION ---
                            # 4. Add the current selection as a special segment if highlighting is enabled
                            selection_segments = []
                            if show_highlighting and current_selection and current_selection.strip():
                                # Get the annotation ID and actual highlight text
                                anno_id = affected_annotation.get('id')
    
#                                 print(f"DEBUG (Preview): Selection text: '{current_selection}'")
#                                 print(f"DEBUG (Preview): Stored highlight text: '{_outer_self.current_highlight_text}'")
    
                                # IMPORTANT CHANGE: First look for the user's actual selection in the storyboard text
                                # This prioritizes what the user actually selected over the stored annotation text
                                if current_selection:
                                    pos = storyboard_text_original.find(current_selection)
                                    if pos != -1:
                                        selection_segments.append((pos, pos + len(current_selection), "selection"))
#                                         print(f"DEBUG (Preview): Using user's actual selection at position {pos}-{pos+len(current_selection)}")
                                    else:
                                        # We couldn't find the exact selection, so try to find the longest matching substring
                                        best_match = ""
                                        best_pos = -1
            
                                        for i in range(len(current_selection)):
                                            for j in range(i + 1, len(current_selection) + 1):
                                                substring = current_selection[i:j]
                                                if len(substring) > 10:  # Only consider substantial substrings
                                                    pos = storyboard_text_original.find(substring)
                                                    if pos != -1 and len(substring) > len(best_match):
                                                        best_match = substring
                                                        best_pos = pos
            
                                        if best_pos != -1 and len(best_match) > 20:  # Found a good match
                                            selection_segments.append((best_pos, best_pos + len(best_match), "selection"))
#                                             print(f"DEBUG (Preview): Using best match from selection '{best_match}' at position {best_pos}-{best_pos+len(best_match)}")
                
                                # Only if we couldn't find the user's selection, fall back to the stored annotation text
                                if not selection_segments and _outer_self.current_highlight_text:
                                    actual_highlight_text = _outer_self.current_highlight_text
        
                                    # Try to find the MOST specific match for the annotation text
                                    # This helps avoid highlighting the entire annotation when user only wants part of it
                                    if len(actual_highlight_text) > 100:  # For long annotations, try to narrow down
                                        # Looking for good matches to the start of the user's selection
                                        # This helps when the user is selecting only part of a highlight
                                        selection_start = current_selection[:min(50, len(current_selection))]
            
                                        # Find where the selection might start in the annotation text
                                        overlap_pos = -1
                                        for i in range(len(selection_start), 10, -1):  # Try progressively shorter matches
                                            test_str = selection_start[:i]
                                            if test_str in actual_highlight_text:
                                                overlap_pos = actual_highlight_text.find(test_str)
                                                break
                    
                                        if overlap_pos != -1:
                                            # We found where the selection might start within the annotation text
                                            # Now estimate how much of the annotation the user might want
                                            # Start with the portion from overlap_pos to the end
                                            partial_highlight = actual_highlight_text[overlap_pos:]
                
                                            # If the partial highlight is still too long, try to cut it at a sentence boundary
                                            if len(partial_highlight) > len(current_selection) * 1.5:
                                                # Look for sentence endings (period followed by space)
                                                sentence_end = -1
                                                for i in range(min(len(partial_highlight), len(current_selection) * 2)):
                                                    if i+2 < len(partial_highlight) and partial_highlight[i] == '.' and partial_highlight[i+1] == ' ':
                                                        sentence_end = i+2  # Include the period and space
                                                        # If we're past the approximate selection length, this is good enough
                                                        if i > len(current_selection) * 0.75:
                                                            break
                                
                                                if sentence_end != -1:
                                                    partial_highlight = partial_highlight[:sentence_end]
                        
                                            # Now look for this partial highlight in the storyboard text
                                            pos = storyboard_text_original.find(partial_highlight)
                                            if pos != -1:
                                                selection_segments.append((pos, pos + len(partial_highlight), "selection"))
#                                                 print(f"DEBUG (Preview): Using partial annotation match at position {pos}-{pos+len(partial_highlight)}")
                    
                                    # If we still haven't found a good match, try the full annotation text
                                    if not selection_segments:
                                        pos = storyboard_text_original.find(actual_highlight_text)
                                        if pos != -1:
                                            selection_segments.append((pos, pos + len(actual_highlight_text), "selection"))
#                                             print(f"DEBUG (Preview): Using stored annotation text at position {pos}-{pos+len(actual_highlight_text)}")
                
                                # Last resort fallback - just use a simple string replacement
                                if not selection_segments and current_selection:
#                                     print(f"DEBUG (Preview): No good matches found, will use simple string replacement")
                                    # We'll handle this case in the fallback section later
                                    pass

                            # --- FIXED SEGMENT HANDLING ---
                            # 5. Process segments with priority for RED highlights
                            result_parts = []
                            current_pos = 0

                            # First identify any overlaps between highlight and strikethrough
                            overlapping_regions = []
                            if show_highlighting:
                                for sel_start, sel_end, _ in selection_segments:
                                    for strike_start, strike_end in strike_segments_to_apply:
                                        # Check if there's an overlap
                                        if max(sel_start, strike_start) < min(sel_end, strike_end):
                                            # There's an overlap - record the overlapping region
                                            overlap_start = max(sel_start, strike_start)
                                            overlap_end = min(sel_end, strike_end)
                                            overlapping_regions.append((overlap_start, overlap_end))
#                                             print(f"DEBUG (Preview): Found overlap between highlight and strikethrough at {overlap_start}-{overlap_end}")

                            # Build segments with proper priority
                            all_segments = []

                            # First add highlight segments - THEY TAKE PRIORITY
                            if show_highlighting:
                                for start, end, seg_type in selection_segments:
                                    all_segments.append((start, end, "selection"))

                            # Then add strikethrough segments, but SKIP portions that overlap with highlights
                            adjusted_strike_segments = []
                            for start, end in strike_segments_to_apply:
                                # Check if this segment overlaps with any selection
                                has_overlap = False
                                for sel_start, sel_end, _ in selection_segments:
                                    if max(start, sel_start) < min(end, sel_end):
                                        has_overlap = True
                                        break
                
                                if not has_overlap:
                                    # No overlap - add the whole segment
                                    adjusted_strike_segments.append((start, end, "strike"))
                                    continue
                
                                # Handle overlapping case by splitting into non-overlapping parts
                                current_pos = start
                                # Sort overlapping regions by start position
                                sorted_overlaps = sorted([r for r in overlapping_regions 
                                                         if max(r[0], start) < min(r[1], end)])
                
                                for overlap_start, overlap_end in sorted_overlaps:
                                    # Add portion before overlap (if any)
                                    if current_pos < overlap_start:
                                        adjusted_strike_segments.append((current_pos, overlap_start, "strike"))
#                                         print(f"DEBUG (Preview): Adding non-overlapping strike segment {current_pos}-{overlap_start}")
                    
                                    # Skip the overlapping portion (will be highlighted)
                                    current_pos = overlap_end
                
                                # Add any remaining portion after all overlaps
                                if current_pos < end:
                                    adjusted_strike_segments.append((current_pos, end, "strike"))
#                                     print(f"DEBUG (Preview): Adding trailing strike segment {current_pos}-{end}")

                            # Add the adjusted strike segments
                            all_segments.extend(adjusted_strike_segments)

                            # Sort all segments by position
                            all_segments.sort(key=lambda x: (x[0], -x[1]))  # Sort start asc, end desc

#                             print(f"DEBUG (Preview): Segments with proper highlight priority: {all_segments}")
                            # --- END FIXED SEGMENT HANDLING ---

                            # Apply the segments to build our output text
                            if all_segments:
                                last_processed_end = 0
                                for i, segment in enumerate(all_segments):
                                    start, end, seg_type = segment

                                    # Adjust start based on last processed end to handle overlaps
                                    start = max(start, last_processed_end)
                                    # Ensure end is valid and segment has positive length
                                    end = max(start, min(end, len(storyboard_text_original)))
                                    if start >= end: continue # Skip if this segment is fully covered or has no length

                                    # Add text before this segment (if any new space)
                                    if start > last_processed_end:
                                        result_parts.append(storyboard_text_original[last_processed_end:start])

                                    # Add the segment with appropriate styling
                                    segment_content = storyboard_text_original[start:end]
                                    if seg_type == "selection":
                                        # RED highlight
                                        clean_content = re.sub(r'<\/?s.*?>', '', segment_content, flags=re.IGNORECASE).strip()
                                        if clean_content:
                                            result_parts.append(f"<span style=\"background-color:#FF0000; color:white; font-weight:bold;\">{clean_content}</span>")
                                    elif seg_type == "strike":
                                        # Pink strikethrough
                                        clean_content = re.sub(r'<\/?s.*?>', '', segment_content, flags=re.IGNORECASE).strip()
                                        if clean_content:
                                            result_parts.append(f"<s style=\"color:#FF9999;\">{clean_content}</s>")

                                    # Update the position pointer
                                    last_processed_end = end

                                # Add any remaining text after the last segment
                                if last_processed_end < len(storyboard_text_original):
                                    result_parts.append(storyboard_text_original[last_processed_end:])

                                # Join all parts to create the formatted text
                                preview_text = "".join(result_parts)

                            # Fallback: If no segments were processed but we have a selection and highlighting is enabled
                            elif show_highlighting and current_selection and current_selection.strip():
                                try:
                                    # Simple approach: directly substitute the selection with highlighted version
                                    preview_text = storyboard_text_original.replace(
                                        current_selection,
                                        f"<span style=\"background-color:#FF0000; color:white; font-weight:bold;\">{current_selection}</span>"
                                    )
#                                     print(f"DEBUG (Preview): Applied direct red highlighting to '{current_selection[:50]}...' (Fallback)")
                                except Exception as e:
                                    pass  # Error applying direct highlighting
#                                     print(f"DEBUG (Preview): Error applying direct highlighting: {e}")
                            else:
                                 # No segments and no fallback condition met
                                 preview_text = storyboard_text_original

                            # Basic cleanup for potentially problematic nested tags
                            preview_text_cleaned_final = re.sub(r'<span[^>]*>\s*</span>', '', preview_text)
                            preview_text_cleaned_final = re.sub(r'<s[^>]*>\s*</s>', '', preview_text_cleaned_final)

                            # Update the text edit widget
#                             print("DEBUG: Setting HTML in text_edit widget")
                            text_edit.setHtml(preview_text_cleaned_final)
#                             print("DEBUG: HTML set successfully")

                    except Exception as e:
                        print(f"ERROR in update_preview_with_highlight: {e}")
                        # Provide a simple fallback content
                        text_edit.setHtml("<p>Error loading preview</p>")

                # --- Options Checkboxes with connected events ---
                try:

                    # Custom checkbox class if XMarkCheckBox is defined elsewhere
                    class XMarkCheckBox(QCheckBox):
                        def __init__(self, text="", parent=None):
                            super().__init__(text, parent)

                    options_layout = QHBoxLayout()
                    options_layout.setSpacing(20)

                    option1_layout = QVBoxLayout()
                    option1_layout.setSpacing(5)
                    option1 = XMarkCheckBox("Match content with removal")
                    option1.setChecked(True)  # Default to checked
                    option1_layout.addWidget(option1)
                    option1_desc = QLabel("Will modify and/or split the entry to match the removal results. Will preserve headers and strikethroughs.")
                    option1_desc.setWordWrap(True)
                    option1_desc.setStyleSheet("color: #666; font-style: italic;")
                    option1_layout.addWidget(option1_desc)

                    option2_layout = QVBoxLayout()
                    option2_layout.setSpacing(5)
                    # Determine the option2 description based on annotation details:
                    if (order_val is None or not str(order_val).strip()) and isinstance(storyboard_dict, dict) and storyboard_dict.get('text', '').strip():
                        option2_desc_text = "Script Editor text will not be affected by removal."
                    else:
                        option2_desc_text = "The original Script Editor entry remains untouched."

                    option2 = XMarkCheckBox("Keep the entry as is")
                    option2.setChecked(False)
                    option2_layout.addWidget(option2)
                    option2_desc = QLabel(option2_desc_text)
                    option2_desc.setWordWrap(True)
                    option2_desc.setStyleSheet("color: #666; font-style: italic;")
                    option2_layout.addWidget(option2_desc)

                    options_layout.addLayout(option1_layout)
                    options_layout.addLayout(option2_layout)
                    layout.addLayout(options_layout)

                    # Connect option toggling to update preview
                    def option1_toggled(checked):
                        print(f"DEBUG: option1_toggled to {checked}")
                        if checked:
                            option2.setChecked(False)
                            # Show highlighting when "Match content" is selected
                            update_preview_with_highlight(True)
                        elif not option2.isChecked():
                            option1.setChecked(True)

                    def option2_toggled(checked):
                        print(f"DEBUG: option2_toggled to {checked}")
                        if checked:
                            option1.setChecked(False)
                            # Hide highlighting when "Keep as is" is selected
                            update_preview_with_highlight(False)
                        elif not option1.isChecked():
                            option2.setChecked(True)

                    option1.toggled.connect(option1_toggled)
                    option2.toggled.connect(option2_toggled)

                    # --- Buttons and Dialog Execution ---
                    button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
                    button_box.accepted.connect(dialog.accept)
                    button_box.rejected.connect(dialog.reject)
                    layout.addWidget(button_box)
                
                    print("DEBUG: All dialog components created, trying to initialize preview")
                
                    # Initialize preview with highlighting (since option1 is checked by default)
                    try:
                        update_preview_with_highlight(True)
#                         print("DEBUG: Preview initialized successfully")
                    except Exception as e:
                        print(f"ERROR initializing preview: {e}")

                    # Execute the dialog
#                     print("DEBUG: About to show and execute dialog")
                
                    # Make sure the dialog is on top and visible
                    dialog.setWindowFlags(dialog.windowFlags() | Qt.WindowType.WindowStaysOnTopHint)
                    dialog.show()
                    dialog.raise_()
                    dialog.activateWindow()
                
                    result = dialog.exec()
                    print(f"DEBUG: Dialog execution returned: {result}")
                
                    if result == QDialog.DialogCode.Accepted:
                        update_storyboard = option1.isChecked()
                        # 'text' should be accessible from the scope where show_storyboard_conflict_dialog is defined
                        _outer_self.remove_highlight(text, False, update_storyboard)
                    else:
                        print("DEBUG: User cancelled removal")
                    
                except Exception as e:
                    print(f"ERROR in checkbox or dialog execution setup: {e}")
                    # Fallback to normal removal
                    _outer_self.remove_highlight(text, False, False)

            # Set up JavaScript execution with properly scoped callback
            self.page().runJavaScript(js_code, process_conflict_results)

        # Start by checking for auto-selection needs
        self.page().runJavaScript(js_code, check_auto_selection)

    def remove_highlight(self, text, dry_run=False, update_storyboard=False):
        """
        Remove highlight from selected text while preserving text position, line breaks, and handling multiple annotations
    
        Args:
            text: The text to remove highlight from
            dry_run: If True, only analyzes without modifying DOM
            update_storyboard: If True, updates storyboard text to match highlight changes
        """
        # Initialize should_update_order_list at the function scope level
        self.should_update_order_list = False

        # Add a timestamp tracking attribute if it doesn't exist
        if not hasattr(self, '_last_order_update_time'):
            self._last_order_update_time = 0
        # Add these helper functions
        def extract_header_from_text(text):
            """Extract header HTML from the beginning of text if present."""
            if not text:
                print("DEBUG: Empty text provided to extract_header_from_text")
                return None, text
    
            # Print first 150 chars for debugging
#             print(f"DEBUG: EXTRACTING HEADER FROM: {repr(text[:150])}")
    
            # Improved patterns that match your StoryboardHeaderDialog output exactly
            header_patterns = [
                # Match header with style attribute - prioritize exact pattern from StoryboardHeaderDialog
                r'^(\s*<div>\s*<b\s+style=[\'"]background-color:\s*[^\'";]+;?[\'"]>\s*.*?\s*</b>\s*</div>)(\s*\n?)',
                # Match header with style attribute - more general version
                r'^(\s*<div>\s*<b\s+style=[\'"][^\'"]*background-color:[^\'"]*[\'"]>\s*.*?\s*</b>\s*</div>)(\s*\n?)',
                # Simple div+b headers without style
                r'^(\s*<div>\s*<b>\s*.*?\s*</b>\s*</div>)(\s*\n?)',
            ]
    
            for i, pattern in enumerate(header_patterns):
                try:
                    match = re.match(pattern, text, re.DOTALL)
                    if match:
                        header = match.group(1)
                        separator = match.group(2) or "\n"
                        remaining_text = text[len(header) + len(separator):]
                        print(f"DEBUG: Extracted header using pattern {i+1}: {repr(header)}")
                        return header, remaining_text
                    else:
                        pass  # Pattern did not match
#                         print(f"DEBUG: Pattern {i+1} did not match")
                except Exception as e:
                    print(f"DEBUG: Error in header pattern {i+1}: {e}")
    
#             print("DEBUG: No header pattern matched")
            return None, text
    
        def apply_header_to_text(text, header):
            """Apply header to text content, ensuring header is at the beginning."""
            if not header:
                return text
            if not text:
                return header
            existing_header, clean_text = extract_header_from_text(text)
            if existing_header:
                print(f"DEBUG: Removed existing header: {existing_header}")
                text = clean_text
            result = f"{header}\n{text}"
            print(f"DEBUG: Applied header to text")
            return result

        js_code = r'''
            (function() {
                var scrollPos = window.pageYOffset;
                var dry_run = %s;  // Will be replaced with actual value

                // Helper function to check if content is empty (excluding whitespace and newlines)
                function isContentEmpty(content) {
                    if (typeof content === 'string') {
                        return !content.trim();
                    }
    
                    // For structured content (array of content parts)
                    if (Array.isArray(content)) {
                        return content.every(part => {
                            switch(part.type) {
                                case 'text':
                                    return !part.content.trim();
                                case 'break':
                                case 'spacing':
                                    return true; // Consider breaks and spacing as empty
                                case 'content':
                                    return isContentEmpty(part.content);
                                default:
                                    return true;
                            }
                        });
                    }
    
                    return true;
                }

                // Helper functions defined once at the top level
                function isInPreContext(node) {
                    let current = node;
                    while (current) {
                        if (current.nodeType === Node.ELEMENT_NODE) {
                            const style = window.getComputedStyle(current);
                            if (style.whiteSpace.startsWith('pre')) {
                                return true;
                            }
                        }
                        current = current.parentNode;
                    }
                    return false;
                }

                function hasSignificantWhitespace(node) {
                    // Check for non-breaking spaces and special whitespace characters
                    return /[\u00A0\u2000-\u200B\u202F\u205F\u3000\uFEFF]/.test(node.textContent);
                }

                function generateUUID() {
                    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                        var r = Math.random() * 16 | 0,
                            v = c == 'x' ? r : (r & 0x3 | 0x8);
                        return v.toString(16);
                    });
                }

                function getXPath(node) {
                    if (!node || !node.parentNode) {
                        return '';
                    }
        
                    if (node.nodeType === Node.TEXT_NODE) {
                        const parent = node.parentNode;
                        const children = parent.childNodes;
                        let index = 0;
                        let textIndex = 0;
        
                        for (let i = 0; i < children.length; i++) {
                            if (children[i] === node) {
                                textIndex = index + 1;
                                break;
                            }
                            if (children[i].nodeType === Node.TEXT_NODE) {
                                index++;
                            }
                        }
        
                        if (textIndex > 0) {
                            return getXPath(parent) + '/text()[' + textIndex + ']';
                        }
                    }
        
                    if (node.id) {
                        return '//*[@id="' + node.id + '"]';
                    }
        
                    let count = 1;
                    let sibling = node.previousSibling;
        
                    while (sibling) {
                        if (sibling.nodeType === Node.ELEMENT_NODE && 
                            sibling.nodeName === node.nodeName) {
                            count++;
                        }
                        sibling = sibling.previousSibling;
                    }
        
                    return getXPath(node.parentNode) + '/' + 
                           node.nodeName.toLowerCase() + '[' + count + ']';
                }

                function getNearestBlockAncestor(node) {
                    if (!node) {
                        return null;
                    }

                    let current = node;
                    while (current && current.nodeType === Node.TEXT_NODE) {
                        current = current.parentNode;
                    }
                    while (current && !/^(P|DIV|ARTICLE|SECTION|H[1-6])$/i.test(current.nodeName)) {
                        current = current.parentNode;
                    }
    
                    return current || node.parentNode;
                }

                function getTextContext(node, offset, length) {
                    const blockContainer = getNearestBlockAncestor(node);
                    if (!blockContainer) {
                        return { before: '', text: '', after: '' };
                    }

                    const fullText = blockContainer.textContent;

                    let accumulatedOffset = 0;
                    let targetNode = node;
                    const walker = document.createTreeWalker(blockContainer, NodeFilter.SHOW_TEXT);
    
                    while (walker.nextNode() && walker.currentNode !== node) {
                        accumulatedOffset += walker.currentNode.textContent.length;
                    }

                    const absoluteOffset = accumulatedOffset + offset;
                    const contextSize = 100;

                    const beforeText = fullText.substring(Math.max(0, absoluteOffset - contextSize), absoluteOffset);
                    const text = fullText.substring(absoluteOffset, absoluteOffset + length);
                    const afterText = fullText.substring(
                        absoluteOffset + length, 
                        Math.min(fullText.length, absoluteOffset + length + contextSize)
                    );

                    return {
                        before: beforeText,
                        text: text,
                        after: afterText
                    };
                }

                function preserveLineBreaks(node) {
                    // If the node is a text node, simply return its content
                    if (node.nodeType === Node.TEXT_NODE) {
                        return node.textContent;
                    }

                    // Initialize content array to preserve structure
                    var contentParts = [];
                    var currentNode = node.firstChild;

                    while (currentNode) {
                        if (currentNode.nodeType === Node.TEXT_NODE) {
                            contentParts.push({
                                type: 'text',
                                content: currentNode.textContent
                            });
                        } else if (currentNode.nodeName === 'BR') {
                            contentParts.push({
                                type: 'break',
                                content: '\\n'
                            });
                        } else if (currentNode.nodeType === Node.ELEMENT_NODE) {
                            // Preserve other elements' spacing
                            var style = window.getComputedStyle(currentNode);
                            if (style.display === 'block' || style.marginTop || style.marginBottom) {
                                contentParts.push({
                                    type: 'spacing',
                                    display: style.display,
                                    marginTop: style.marginTop,
                                    marginBottom: style.marginBottom
                                });
                            }
                            // Recursively process child content
                            contentParts.push({
                                type: 'content',
                                content: preserveLineBreaks(currentNode)
                            });
                        }
                        currentNode = currentNode.nextSibling;
                    }

                    return contentParts;
                }

                function createStructuredContent(contentParts) {
                    var container = document.createElement('div');

                    if (typeof contentParts === 'string') {
                        container.appendChild(document.createTextNode(contentParts));
                        return container;
                    }

                    contentParts.forEach((part, index) => {
                        switch(part.type) {
                            case 'text':
                                if (part.content.trim()) {
                                    container.appendChild(document.createTextNode(part.content));
                                }
                                break;
        
                            case 'break':
                                container.appendChild(document.createElement('br'));
                                break;
        
                            case 'spacing':
                                if (part.display === 'block' || part.marginTop || part.marginBottom) {
                                    const spacer = document.createElement('div');
                                    if (part.marginTop) spacer.style.marginTop = part.marginTop;
                                    if (part.marginBottom) spacer.style.marginBottom = part.marginBottom;
                                    container.appendChild(spacer);
                                }
                                break;
        
                            case 'content':
                                const childContent = createStructuredContent(part.content);
                                while (childContent.firstChild) {
                                    container.appendChild(childContent.firstChild);
                                }
                                break;
                        }
                    });

                    return container;
                }

                function cleanupTextNodes(node) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        // Skip cleanup if in pre-formatted context
                        if (isInPreContext(node)) return;

                        const hasSpecialSpace = hasSignificantWhitespace(node);

                        // Remove empty text nodes unless they have special space characters
                        if (!node.textContent.trim() && !hasSpecialSpace && 
                            (!node.previousSibling || node.previousSibling.nodeName !== 'BR') && 
                            (!node.nextSibling || node.nextSibling.nodeName !== 'BR')) {
                            node.parentNode.removeChild(node);
                        } else {
                            // Merge adjacent text nodes unless special spacing is present
                            if (node.previousSibling && 
                                node.previousSibling.nodeType === Node.TEXT_NODE &&
                                !hasSpecialSpace &&
                                (!node.previousSibling.previousSibling || 
                                 node.previousSibling.previousSibling.nodeName !== 'BR') &&
                                (!node.nextSibling || 
                                 node.nextSibling.nodeName !== 'BR')) {
                                node.previousSibling.textContent += node.textContent;
                                node.parentNode.removeChild(node);
                            }
                        }
                    } else if (node.hasChildNodes()) {
                        // Process child nodes in reverse to avoid issues with node removal
                        Array.from(node.childNodes).reverse().forEach(cleanupTextNodes);
                    }

                    // Normalize to merge remaining adjacent text nodes
                    node.normalize();
                }


                // Capture initial selection info before any modifications
                var selection = window.getSelection();
                var initialSelectionInfo = null;
                if (selection && selection.rangeCount > 0) {
                    var range = selection.getRangeAt(0);
                    initialSelectionInfo = {
                        text: range.toString(),
                        startContainerPath: getXPath(range.startContainer),
                        startOffset: range.startOffset,
                        endContainerPath: getXPath(range.endContainer),
                        endOffset: range.endOffset,
                        context: getTextContext(
                            range.startContainer,
                            range.startOffset,
                            range.toString().length
                        ),
                        location: {
                            containerPath: getXPath(getNearestBlockAncestor(range.startContainer)),
                            offset: range.startOffset,
                            length: range.toString().length,
                            blockContext: true
                        }
                    };
                }

                // Begin processing
                if (!selection || selection.rangeCount === 0) {
                    console.log("DEBUG: No valid selection found");
                    return { removedSpans: [], updatedSpans: [], scrollPos: scrollPos };
                }

                var range = selection.getRangeAt(0);
                var selectedText = range.toString();
                console.log("DEBUG: Selected text:", selectedText);

                var results = {
                    removedSpans: [],
                    updatedSpans: [],
                    scrollPos: scrollPos,
                    selectionInfo: initialSelectionInfo,
                    debugInfo: null
                };

                // Find all intersecting spans
                var intersectingSpans = [];
                var spans = document.querySelectorAll('span[data-annotation-id]');
                spans.forEach(function(span) {
                    if (range.intersectsNode(span)) {
                        console.log("DEBUG: Found intersecting span:", span.textContent);
                        intersectingSpans.push(span);
                    }
                });

                // ========== EXTRACT STORYBOARD INFO FOR DRY RUN ==========
                // If this is a dry run, collect storyboard data from spans
                if (dry_run) {
                    var storyboardEntries = [];
                    var hasPartialStoryboardRemoval = false;
                
                    // 1. Identify distinct annotation IDs among intersecting spans
                    var annotationIds = new Set();
                    intersectingSpans.forEach(function(s) {
                        var id = s.getAttribute('data-annotation-id');
                        annotationIds.add(id);
                    });
                
                    // Check if selection completely contains all spans
                    var completelyContains = intersectingSpans.every(function(span) {
                        var spanContent = preserveLineBreaks(span.firstChild);
                        var isContained = range.toString().includes(spanContent);
                        return isContained;
                    });
                
                    // Check for storyboard data
                    intersectingSpans.forEach(function(span) {
                        // Check if this span has storyboard data (look for order)
                        var order = span.getAttribute('data-order');
                        var storyboardAttr = span.getAttribute('data-storyboard');
                        var storyboard = null;
                    
                        try {
                            if (storyboardAttr) {
                                storyboard = JSON.parse(storyboardAttr);
                            }
                        } catch(e) {
                            console.log("Error parsing storyboard data:", e);
                        }
                    
                        var hasStoryboardEntry = order !== null || (storyboard && storyboard.order !== undefined);
                    
                        // If it has storyboard data and isn't completely contained, it's a partial removal
                        if (hasStoryboardEntry && !completelyContains) {
                            hasPartialStoryboardRemoval = true;
                        
                            // Collect info for the dialog
                            storyboardEntries.push({
                                id: span.getAttribute('data-annotation-id'),
                                text: span.textContent,
                                order: order || (storyboard ? storyboard.order : null),
                                storyboardText: storyboard ? storyboard.text : null,
                                strikethroughSegments: storyboard ? storyboard.strikethrough_segments : null,
                                positionalStrikethrough: storyboard ? storyboard.positional_strikethrough : null  // Add this line
                            });
                        }
                    });
                
                    return {
                        dry_run: true,
                        hasPartialStoryboardRemoval: hasPartialStoryboardRemoval,
                        storyboardEntries: storyboardEntries,
                        completelyContains: completelyContains,
                        selectionInfo: initialSelectionInfo,
                        intersectingSpanCount: intersectingSpans.length,
                        scrollPos: scrollPos
                    };
                }

                // ========== NEW LOGIC FOR BLOCKING MULTIPLE PARTIAL HIGHLIGHTS ==========
                // 1. Identify distinct annotation IDs among intersecting spans
                var annotationIds = new Set();
                intersectingSpans.forEach(function(s) {
                    var id = s.getAttribute('data-annotation-id');
                    annotationIds.add(id);
                });
        
                // 2. If more than one annotation ID is intersected, we must verify
                //    whether the selection fully contains each or not.
                //    If it partially contains multiple highlights, we'll block it.
                if (annotationIds.size > 1) {
                    var partiallyEncompassed = false;

                    intersectingSpans.forEach(function(span) {
                        var spanRange = document.createRange();
                        spanRange.selectNodeContents(span);

                        // Check if the user's range fully contains this highlight
                        var fullyContained = (
                            range.compareBoundaryPoints(Range.START_TO_START, spanRange) <= 0 &&
                            range.compareBoundaryPoints(Range.END_TO_END, spanRange) >= 0
                        );

                        // If any span is not fully contained, mark as partially encompassed
                        if (!fullyContained) {
                            partiallyEncompassed = true;
                        }
                    });

                    // If we have multiple distinct highlights and ANY of them is partial, block the operation
                    if (partiallyEncompassed) {
                        console.log("DEBUG: Blocking removal - multiple highlights with at least one partial selection");
                        return {
                            error: true,
                            message: "Cannot remove multiple highlights when any are partially selected. Please adjust your selection to either fully include or exclude each highlight. \n \n You may have to select a little before and a little after to fully encompass the selection.",
                            scrollPos: scrollPos,
                            selectionInfo: initialSelectionInfo
                        };
                    }
                }
                // =======================================================================


                // Check if selection completely contains all spans
                var completelyContains = intersectingSpans.every(function(span) {
                    var spanContent = preserveLineBreaks(span.firstChild);
                    var isContained = range.toString().includes(spanContent);
                    console.log("DEBUG: Checking containment for span:", {
                        spanContent: spanContent,
                        contained: isContained
                    });
                    return isContained;
                });

                if (completelyContains) {
                    console.log("DEBUG: Processing complete removal");
                    // Remove all spans completely while preserving line breaks
                    intersectingSpans.forEach(function(span) {
                        // Find the speech-content container for this span
                        var speechContentContainer = null;
                        var currentNode = span;
                        while (currentNode && currentNode !== document.body) {
                            if (currentNode.classList && currentNode.classList.contains('speech-content')) {
                                speechContentContainer = currentNode;
                                break;
                            }
                            currentNode = currentNode.parentNode;
                        }
                        
                        // Get context information for overlap detection
                        var textContext = '';
                        var textPosition = -1;
                        try {
                            var parentText = speechContentContainer ? speechContentContainer.textContent : span.parentNode.textContent;
                            textContext = parentText.substring(Math.max(0, parentText.indexOf(span.textContent) - 50), 
                                                              Math.min(parentText.length, parentText.indexOf(span.textContent) + span.textContent.length + 50));
                            textPosition = parentText.indexOf(span.textContent);
                        } catch(e) {
                            console.log("Could not capture text context:", e);
                        }
                        
                        var spanInfo = {
                            node: span,
                            originalId: span.getAttribute('data-annotation-id'),
                            scene: span.getAttribute('data-scene'),
                            text: preserveLineBreaks(span.firstChild),
                            notes: span.getAttribute('data-notes') || '',
                            notes_html: span.getAttribute('data-notes-html') || '',
                            style: span.getAttribute('style') || '',
                            used: span.getAttribute('data-used') || 'false',
                            favorite: span.getAttribute('data-favorite') || 'false',
                            completeRemoval: true,
                            speechContentId: speechContentContainer ? (speechContentContainer.id || 'no-id') : 'no-container',
                            textContext: textContext,
                            textPosition: textPosition
                        };

                        // Add storyboard and order info for complete removals
                        var orderAttr = span.getAttribute('data-order');
                        if (orderAttr !== null) {
                            spanInfo.order = orderAttr;
                        }

                        var storyboardAttr = span.getAttribute('data-storyboard');
                        if (storyboardAttr) {
                            try {
                                spanInfo.storyboard = JSON.parse(storyboardAttr);
                            } catch(e) {
                                console.log("Error parsing storyboard:", e);
                            }
                        }

                        console.log("DEBUG: Removing span completely:", spanInfo);

                        // Replace span with its structured content
                        var content = preserveLineBreaks(span.firstChild);
                        var container = createStructuredContent(content);
                        while (container.firstChild) {
                            span.parentNode.insertBefore(container.firstChild, span);
                        }
                        span.parentNode.removeChild(span);
                        results.removedSpans.push(spanInfo);
                    });
                } else {
                    console.log("DEBUG: Processing partial removals");
                    // Handle partial intersections
                    intersectingSpans.forEach(function(span) {
                        try {
                            var spanRange = document.createRange();
                            spanRange.selectNodeContents(span);
        
                            // Find the speech-content container for this span
                            var speechContentContainer = null;
                            var currentNode = span;
                            while (currentNode && currentNode !== document.body) {
                                if (currentNode.classList && currentNode.classList.contains('speech-content')) {
                                    speechContentContainer = currentNode;
                                    break;
                                }
                                currentNode = currentNode.parentNode;
                            }
                            
                            // Get context information for overlap detection
                            var textContext = '';
                            var textPosition = -1;
                            try {
                                var parentText = speechContentContainer ? speechContentContainer.textContent : span.parentNode.textContent;
                                textContext = parentText.substring(Math.max(0, parentText.indexOf(span.textContent) - 50), 
                                                                  Math.min(parentText.length, parentText.indexOf(span.textContent) + span.textContent.length + 50));
                                textPosition = parentText.indexOf(span.textContent);
                            } catch(e) {
                                console.log("Could not capture text context:", e);
                            }
                            
                            var spanInfo = {
                                node: span,
                                originalId: span.getAttribute('data-annotation-id'),
                                scene: span.getAttribute('data-scene'),
                                text: preserveLineBreaks(span.firstChild),
                                notes_html: span.getAttribute('data-notes-html') || '',
                                notes: span.getAttribute('data-notes') || '',
                                style: span.getAttribute('style') || '',
                                used: span.getAttribute('data-used') || 'false',
                                favorite: span.getAttribute('data-favorite') || 'false',
                                speechContentId: speechContentContainer ? (speechContentContainer.id || 'no-id') : 'no-container',
                                textContext: textContext,
                                textPosition: textPosition
                            };

                            // Add storyboard and order info for partial removals
                            var orderAttr = span.getAttribute('data-order');
                            if (orderAttr !== null) {
                                spanInfo.order = orderAttr;
                            }

                            var storyboardAttr = span.getAttribute('data-storyboard');
                            if (storyboardAttr) {
                                try {
                                    spanInfo.storyboard = JSON.parse(storyboardAttr);
                                } catch(e) {
                                    console.log("Error parsing storyboard:", e);
                                }
                            }

                            var parent = span.parentNode;
                            var spanContent = preserveLineBreaks(span.firstChild);
            
                            // Calculate selection points relative to the span content
                            var startOffset, endOffset;
            
                            if (range.startContainer === span.firstChild) {
                                startOffset = range.startOffset;
                            } else if (span.contains(range.startContainer)) {
                                var walker = document.createTreeWalker(span, NodeFilter.SHOW_TEXT);
                                var accOffset = 0;
                                while (walker.nextNode() && walker.currentNode !== range.startContainer) {
                                    accOffset += walker.currentNode.textContent.length;
                                }
                                startOffset = accOffset + range.startOffset;
                            } else {
                                startOffset = 0;
                            }
            
                            if (range.endContainer === span.firstChild) {
                                endOffset = range.endOffset;
                            } else if (span.contains(range.endContainer)) {
                                var walker = document.createTreeWalker(span, NodeFilter.SHOW_TEXT);
                                var accOffset = 0;
                                while (walker.nextNode() && walker.currentNode !== range.endContainer) {
                                    accOffset += walker.currentNode.textContent.length;
                                }
                                endOffset = accOffset + range.endOffset;
                            } else {
                                endOffset = spanContent.length;
                            }

                            startOffset = Math.max(0, Math.min(startOffset, spanContent.length));
                            endOffset = Math.max(0, Math.min(endOffset, spanContent.length));

                            console.log("DEBUG: Calculated offsets for span:", {
                                spanContent: spanContent,
                                startOffset: startOffset,
                                endOffset: endOffset
                            });

                            // In the main logic where spans are created
                            if (startOffset < endOffset) {
                                if (startOffset > 0) {
                                    var leftText = spanContent.substring(0, startOffset);
                                    // Create structured content container regardless of emptiness
                                    var leftContainer = createStructuredContent(leftText);
    
                                    if (!isContentEmpty(leftText)) {
                                        // If content is not empty, wrap it in an annotated span
                                        console.log("DEBUG: Creating left span with annotation:", leftText);
                                        var leftSpan = span.cloneNode(false);
                                        while (leftContainer.firstChild) {
                                            leftSpan.appendChild(leftContainer.firstChild);
                                        }
                                        leftSpan.setAttribute('data-annotation-id', spanInfo.originalId);
                                        parent.insertBefore(leftSpan, span);
                                        // Attach dblclick + tooltip listeners to the new left span
                                        try {
                                            if (typeof selectAnnotationSpan === 'function') {
                                                leftSpan.addEventListener('dblclick', selectAnnotationSpan);
                                            }
                                            if (typeof showTooltipDirect === 'function') {
                                                leftSpan.addEventListener('mouseenter', showTooltipDirect);
                                            }
                                            if (typeof hideTooltipDirect === 'function') {
                                                leftSpan.addEventListener('mouseleave', hideTooltipDirect);
                                            }
                                            leftSpan.setAttribute('data-tooltip-listeners-attached', 'true');
                                            console.log("Attached event listeners to left span:", leftSpan.getAttribute('data-annotation-id'));
                                        } catch (e) {
                                            console.log("WARN: Could not attach listeners to left span:", e);
                                        }

                                        results.updatedSpans.push({
                                            text: leftText,
                                            annotationId: spanInfo.originalId,
                                            scene: spanInfo.scene,
                                            order: spanInfo.order,
                                            storyboard: spanInfo.storyboard,
                                            isOriginal: true
                                        });
                                    } else {
                                        // If content is empty (only whitespace/newlines), insert it without annotation
                                        console.log("DEBUG: Inserting whitespace content without annotation");
                                        while (leftContainer.firstChild) {
                                            parent.insertBefore(leftContainer.firstChild, span);
                                        }
                                        results.removedSpans.push(spanInfo);
                                    }
                                }

                                var selectedContent = spanContent.substring(startOffset, endOffset);
                                console.log("DEBUG: Removing selected content:", selectedContent);
                                var selectedContainer = createStructuredContent(selectedContent);
                                while (selectedContainer.firstChild) {
                                    parent.insertBefore(selectedContainer.firstChild, span);
                                }

                                if (endOffset < spanContent.length) {
                                    var rightText = spanContent.substring(endOffset);
                                    // Create structured content container regardless of emptiness
                                    var rightContainer = createStructuredContent(rightText);
    
                                    if (!isContentEmpty(rightText)) {
                                        // If content is not empty, wrap it in an annotated span
                                        console.log("DEBUG: Creating right span with annotation:", rightText);
                                        var rightSpan = span.cloneNode(false);
                                        while (rightContainer.firstChild) {
                                            rightSpan.appendChild(rightContainer.firstChild);
                                        }
                                        // Check if this is middle text removal (left span already created) or beginning removal
                                        var hasLeftSpan = results.updatedSpans.some(function(span) {
                                            return span.annotationId === spanInfo.originalId;
                                        });
                                        
                                        var rightId, isOriginal;
                                        if (hasLeftSpan) {
                                            // Middle text removal: generate NEW UUID for right span
                                            rightId = generateUUID();
                                            isOriginal = false;
                                            console.log("DEBUG: Middle removal - generating new UUID for right span:", rightId);
                                        } else {
                                            // Beginning text removal: keep original ID for right span
                                            rightId = spanInfo.originalId;
                                            isOriginal = true;
                                            console.log("DEBUG: Beginning removal - keeping original ID for right span:", rightId);
                                        }
                                        
                                        rightSpan.setAttribute('data-annotation-id', rightId);
                                        parent.insertBefore(rightSpan, span);
                                        // Attach dblclick + tooltip listeners to the new right span
                                        try {
                                            if (typeof selectAnnotationSpan === 'function') {
                                                rightSpan.addEventListener('dblclick', selectAnnotationSpan);
                                            }
                                            if (typeof showTooltipDirect === 'function') {
                                                rightSpan.addEventListener('mouseenter', showTooltipDirect);
                                            }
                                            if (typeof hideTooltipDirect === 'function') {
                                                rightSpan.addEventListener('mouseleave', hideTooltipDirect);
                                            }
                                            rightSpan.setAttribute('data-tooltip-listeners-attached', 'true');
                                            console.log("Attached event listeners to right span:", rightSpan.getAttribute('data-annotation-id'));
                                        } catch (e) {
                                            console.log("WARN: Could not attach listeners to right span:", e);
                                        }

                                        results.updatedSpans.push({
                                            text: rightText,
                                            annotationId: rightId,
                                            scene: spanInfo.scene,
                                            order: spanInfo.order,
                                            storyboard: spanInfo.storyboard,
                                            isOriginal: isOriginal
                                        });
                                    } else {
                                        // If content is empty (only whitespace/newlines), insert it without annotation
                                        console.log("DEBUG: Inserting whitespace content without annotation");
                                        while (rightContainer.firstChild) {
                                            parent.insertBefore(rightContainer.firstChild, span);
                                        }
                                    }
                                }

                                parent.removeChild(span);
                                results.removedSpans.push(spanInfo);
                            }
                        } catch(e) {
                            console.error("DEBUG: Error processing span:", e);
                        }
                    });
                }

                // Store the commonAncestorContainer before clearing selection
                var commonAncestor = range.commonAncestorContainer;
    
                // Clear selection before cleanup
                if (selection && selection.removeAllRanges) {
                    selection.removeAllRanges();
                }
    
                try {
                    // Perform cleanup on the stored ancestor
                    cleanupTextNodes(commonAncestor);

                    console.log("Returning results:", results);
                    return results;
                } catch (error) {
                    console.error("Error in assign_to_scene:", error);
                    return {
                        removedSpans: [],
                        updatedSpans: [],
                        scrollPos: window.pageYOffset,
                        selectionInfo: initialSelectionInfo, // Preserve even on error
                        debugInfo: {
                            type: "error",
                            message: error.toString()
                        }
                    };
                }
            })();
        ''' % ('true' if dry_run else 'false')



        def handle_removed_spans(result):
            """Handle the result of the highlight removal operation."""
            # Make update_storyboard accessible within this function
            nonlocal update_storyboard

            # Debug flag for specific annotation tracking
            DEBUG_ANNOTATION_ID = "b95d4a48-2d65-4858-879d-8f864f12e8c3" # Keep original debug ID

            # Log available headers from class-level variable for debugging
            print(f"DEBUG: Available headers at start of handle_removed_spans: {getattr(self, 'original_headers', {})}")

            # Keep original nested helper functions exactly as they were
            def apply_header_to_text(text, header):
                """Apply header to text content, ensuring header is at the beginning."""
                if not header:
                    return text
                if not text:
                    return header
                # Check if text already has a header
                existing_header, clean_text = self.extract_header_from_text(text) # Uses class method
                if existing_header:
                    print(f"DEBUG: Removed existing header: {repr(existing_header)}")
                    text = clean_text
                result = f"{header}\n{text}"
                print(f"DEBUG: Applied header to text: {repr(result[:50])}...")
                return result

            def modified_is_beginning_of_text(part_text, original_text):
                """
                Enhanced version to check if part_text appears at the beginning of original_text.
                More robust than simple startswith, handles whitespace better.
                """
                if not part_text or not original_text:
                    return False
                clean_part = part_text.strip()
                clean_original = original_text.strip()
                simple_begins_with = clean_original.startswith(clean_part)
                part_len = len(clean_part)
                original_prefix = clean_original[:part_len]
                similarity = sum(a == b for a, b in zip(clean_part, original_prefix)) / max(1, part_len)
                robust_check = similarity > 0.9
                result = simple_begins_with or robust_check
                print(f"DEBUG: Checking if part is at beginning - Simple check: {simple_begins_with}, Robust check: {robust_check}, Final result: {result}")
                print(f"DEBUG: First 50 chars - Part: '{clean_part[:50]}', Original: '{clean_original[:50]}'")
                return result

            # Keep original initial checks exactly
            if not result:
                print("DEBUG: No result from JavaScript execution")
                return

            if dry_run and result.get('dry_run'):
                if result.get('hasPartialStoryboardRemoval'):
                    print("DEBUG: Detected partial removal affecting storyboard entries")
                    storyboard_entries = result.get('storyboardEntries', [])
                    if storyboard_entries:
                        affected_entry = storyboard_entries[0]
                        affected_id = affected_entry.get('id')
                        affected_annotation = None
                        for anno in self.annotations:
                            if anno.get('id') == affected_id:
                                affected_annotation = anno
                                break
                        if affected_annotation:
                            print("DEBUG: Found annotation with real storyboard, showing dialog")
                            # Assume show_storyboard_conflict_dialog exists and is called here if needed
                            return # Return as per original logic
                        else:
                            self.remove_highlight(text, dry_run=False, update_storyboard=False)
                            return
                    else:
                        self.remove_highlight(text, dry_run=False, update_storyboard=False)
                        return
                else:
                    self.remove_highlight(text, dry_run=False, update_storyboard=False)
                    return

            if result.get('error'):
                print(f"ERROR: {result.get('message')}")
                error_msg = QMessageBox(self)
                error_msg.setIcon(QMessageBox.Icon.Warning)
                error_msg.setWindowTitle("Highlight Removal Error")
                formatted_message = "<p style='font-weight: bold; font-size: 12pt;'>Cannot remove multiple highlights when any are partially selected</p>"
                formatted_message += "<p>Please adjust your selection to either fully include or exclude each highlight.<br>"
                formatted_message += "You may have to select a little before and a little after to fully encompass the selection.</p>"
                error_msg.setText(formatted_message)
                error_msg.setTextFormat(Qt.TextFormat.RichText)
                detailed_text = """
        1. Adjust your selection to fully include all highlights you want to remove.
        2. Select just one highlight at a time.
        3. Press "Auto Fix" to automatically expand your selection.
                """
                error_msg.setDetailedText(detailed_text)
                auto_fix_button = error_msg.addButton("Auto Fix", QMessageBox.ButtonRole.YesRole)
                error_msg.setDefaultButton(auto_fix_button)
                cancel_button = error_msg.addButton(QMessageBox.StandardButton.Cancel)
                auto_fix_button.setStyleSheet("QPushButton { font-weight: bold; }")
                error_msg.exec()
                if error_msg.clickedButton() == auto_fix_button:
                     # Assume self.auto_select_all_highlights exists
                     self.auto_select_all_highlights(result.get('selectionInfo'))
                return

            # Keep original initializations exactly
            original_strike_backup = {}
            original_positional_backup = {}
            original_texts = {}
            headers_found_count = 0

            # Keep original backup logic exactly
            if 'removedSpans' in result:
                for span_info in result['removedSpans']:
                    annotation_id = span_info.get('originalId') or span_info.get('annotationId')
                    if not annotation_id: continue
                    if annotation_id == DEBUG_ANNOTATION_ID:
                         # Keep debug logic
                         print(f"\n===== DEBUG FOR ANNOTATION {DEBUG_ANNOTATION_ID} =====")
                         storyboard = span_info.get('storyboard', {})
                         print(f"Has storyboard: {bool(storyboard)}")
                         print(f"strikethrough_segments: {storyboard.get('strikethrough_segments', {})}")
                         print(f"positional_strikethrough: {storyboard.get('positional_strikethrough', {})}")
                         print(f"===== END INITIAL DEBUG FOR {DEBUG_ANNOTATION_ID} =====\n")

                    original_texts[annotation_id] = span_info.get('text', '')
                    if isinstance(span_info.get('storyboard'), dict):
                        storyboard = span_info['storyboard']
                        if 'strikethrough_segments' in storyboard:
                            original_strike_backup[annotation_id] = copy.deepcopy(storyboard['strikethrough_segments'])
                            print(f"DEBUG: Backed up strikethrough segments for annotation {annotation_id}")
                            if annotation_id == DEBUG_ANNOTATION_ID: print(f"Backed up strikethrough_segments: {original_strike_backup[annotation_id]}")
                        if 'positional_strikethrough' in storyboard:
                            original_positional_backup[annotation_id] = copy.deepcopy(storyboard['positional_strikethrough'])
                            print(f"DEBUG: Backed up positional strikethrough data for annotation {annotation_id}")
                            if annotation_id == DEBUG_ANNOTATION_ID: print(f"Backed up positional_strikethrough: {original_positional_backup[annotation_id]}")

                    if isinstance(span_info.get('storyboard'), dict) and 'text' in span_info['storyboard']:
                        storyboard_text = span_info['storyboard']['text'].strip()
#                         print(f"DEBUG: Checking for header in storyboard text: {repr(storyboard_text[:100])}")
                        if re.match(r'^\s*<[^>]+>', storyboard_text): print("DEBUG: HTML tags detected at beginning of storyboard text - potential header")
                        header, text_without_header = self.extract_header_from_text(storyboard_text) # Uses class method
                        if header:
                            headers_found_count += 1
                            # Assume self.original_headers is class level dict
                            self.original_headers[annotation_id] = header
                            print(f"DEBUG: Backed up header for annotation {annotation_id}: {repr(header)}")
                            original_texts[annotation_id + "_no_header"] = text_without_header
                        else:
                            print(f"DEBUG: No header found in storyboard text for annotation {annotation_id}")
                            # Keep fallback logic exactly
                            for anno_fallback in self.annotations:
                                if anno_fallback.get('id') == annotation_id and isinstance(anno_fallback.get('storyboard'), dict):
                                    alt_text = anno_fallback['storyboard'].get('text', '')
                                    if alt_text and alt_text != storyboard_text:
                                        print(f"DEBUG: Trying alternative source for header - annotation storyboard text")
                                        header, alt_text_without_header = self.extract_header_from_text(alt_text)
                                        if header:
                                            headers_found_count += 1
                                            self.original_headers[annotation_id] = header
                                            print(f"DEBUG: Backed up header from alternative source: {repr(header)}")
                                            original_texts[annotation_id + "_no_header"] = alt_text_without_header
                                            break

            print(f"DEBUG: Found and backed up {headers_found_count} headers")

            # === UNDO CAPTURE: Save a snapshot for Ctrl+Z ===
            try:
                removed_spans_snapshot = copy.deepcopy(result.get('removedSpans', []))
                updated_spans_snapshot = copy.deepcopy(result.get('updatedSpans', []))
                selection_info_snapshot = copy.deepcopy(result.get('selectionInfo'))
                # Capture full annotations that are about to be removed
                affected_ids = []
                for s in removed_spans_snapshot:
                    aid = s.get('originalId') or s.get('annotationId')
                    if aid and aid not in affected_ids:
                        affected_ids.append(aid)
                annotations_snapshot = [copy.deepcopy(a) for a in self.annotations if a.get('id') in affected_ids]
                self._undo_stack.append({
                    'ts': time.time(),
                    'type': 'remove',
                    'payload': {
                        'removedSpans': removed_spans_snapshot,
                        'updatedSpans': updated_spans_snapshot,
                        'selectionInfo': selection_info_snapshot,
                        'annotations': annotations_snapshot
                    }
                })
                # Keep stack size reasonable
                if len(self._undo_stack) > 20:
                    self._undo_stack = self._undo_stack[-20:]
                
                # Clear redo stack when new action is performed
                self._redo_stack = []
                print(f"[UNDO] Captured removal undo snapshot: {len(removed_spans_snapshot)} spans, {len(annotations_snapshot)} annotations")
            except Exception as _e:
                print(f"[UNDO] Failed to capture undo snapshot: {_e}")

            # Keep original initializations exactly
            processed_ids = set()
            main_window = self.window()
            changes_made = False
            headers_applied_count = 0
            
            # Track annotation IDs for selection after storyboard update
            relevant_annotation_ids = []

            # =================== START OF MODIFIED SECTION ===================
            if 'removedSpans' in result:
                for span_info in result['removedSpans']:
                    annotation_id = span_info.get('originalId') or span_info.get('annotationId')
                    if not annotation_id:
                        continue

                    # Check if span_info itself indicates order (used for flagging list update)
                    span_has_order = span_info.get('order') is not None or \
                                     (isinstance(span_info.get('storyboard'), dict) and span_info['storyboard'].get('order') is not None)
                    if span_has_order:
                         # Set flag based on span info *before* finding annotation
                         self.should_update_order_list = True
                         print(f"DEBUG: Found span with order value {span_info.get('order') or span_info.get('storyboard', {}).get('order')}, will update order list (from span_info)")

                    # Process each annotation found in the list that matches the ID
                    # Using list() copy is important for safe removal during iteration
                    for anno_index, anno in enumerate(list(self.annotations)):
                        if anno.get('id') == annotation_id:

                            # Check if the *annotation object* has storyboard data.
                            # **FIXED**: Use same robust logic as Python fallback conflict detection
                            anno_has_storyboard_data = False
                            
                            # First check order attribute directly - make sure it's not None or empty
                            if 'order' in anno and anno['order'] is not None and str(anno['order']).strip():
                                anno_has_storyboard_data = True
                            
                            # Then check storyboard dictionary with stricter validation
                            storyboard_dict = anno.get('storyboard')
                            if isinstance(storyboard_dict, dict) and storyboard_dict:  # Make sure dict exists and is not empty
                                if ('order' in storyboard_dict and storyboard_dict['order'] is not None and 
                                    str(storyboard_dict['order']).strip()) or \
                                   ('text' in storyboard_dict and storyboard_dict['text'] and 
                                    storyboard_dict['text'].strip()):
                                    anno_has_storyboard_data = True
                            
                            # **DEBUG STORYBOARD**: Log storyboard state after multiple operations
#                             print(f"DEBUG STORYBOARD: Annotation {annotation_id} has storyboard data: {anno_has_storyboard_data}")
#                             print(f"DEBUG STORYBOARD: order = {anno.get('order')}")
#                             print(f"DEBUG STORYBOARD: storyboard type = {type(anno.get('storyboard'))}")
#                             print(f"DEBUG STORYBOARD: storyboard content = {anno.get('storyboard')}")
                            if isinstance(anno.get('storyboard'), dict):
                                pass  # Storyboard is a dict
#                                 print(f"DEBUG STORYBOARD: storyboard keys = {list(anno['storyboard'].keys())}")
#                                 print(f"DEBUG STORYBOARD: storyboard text = {repr(anno['storyboard'].get('text', 'NO TEXT')[:50])}...")

                            # Set the update flag if the *annotation object* has order info
                            if anno_has_storyboard_data:
                                self.should_update_order_list = True
                                print(f"DEBUG: Found annotation with storyboard data {anno.get('order') or anno.get('storyboard', {}).get('order')}, will update order list (from anno)")

                            # --- CORE FIX: The following block is NO LONGER conditional on anno_has_order ---
                            print(f"DEBUG: Processing annotation {annotation_id} (Storyboard data: {anno_has_storyboard_data})")
                            
                            # For simple updates (not splits), add the annotation ID for selection
                            if anno_has_storyboard_data and annotation_id not in relevant_annotation_ids:
                                relevant_annotation_ids.append(annotation_id)
                                print(f"DEBUG: Added updated annotation ID for selection: {annotation_id}")

                            # Get original text for logging/comparison (keep this logic)
                            original_anno_text = anno.get('text', '')
                            original_storyboard_text = ""
                            if isinstance(anno.get('storyboard'), dict) and 'text' in anno['storyboard']:
                                original_storyboard_text = anno['storyboard']['text']
                            print(f"DEBUG: Original annotation text: {repr(original_anno_text[:50])}...")
                            print(f"DEBUG: Original storyboard text: {repr(original_storyboard_text[:50])}...")
                            saved_original_text = original_texts.get(annotation_id, "") or original_anno_text
                            print(f"DEBUG: Saved original text for beginning comparison: {repr(saved_original_text[:50])}...")


                            if span_info.get('completeRemoval'):
                                print(f"DEBUG: Complete removal of annotation {annotation_id}")
                                if annotation_id == DEBUG_ANNOTATION_ID:
                                    print(f"\n===== DEBUG FOR ANNOTATION {DEBUG_ANNOTATION_ID} - COMPLETE REMOVAL =====")
                                    print(f"Complete removal - annotation will be removed")
                                    print(f"===== END COMPLETE REMOVAL DEBUG FOR {DEBUG_ANNOTATION_ID} =====\n")
                                try:
                                    # Remove the current annotation object `anno` from the main list
                                    self.annotations.remove(anno) # Directly remove the object found in the loop
                                    
                                    # Immediately remove from theme view - do this before emit
                                    main_window = self.window()
                                    if main_window and main_window.theme_view:
                                        scene = anno.get('scene', '')
                                        print(f"[DEBUG] Removing annotation {annotation_id} from theme view scene {scene}")
                                        
                                        # Find the tab for this scene and remove the item
                                        for i in range(main_window.scene_tabs.count()):
                                            if main_window.scene_tabs.tabText(i) == scene:
                                                list_widget = main_window.scene_tabs.widget(i)
                                                if isinstance(list_widget, AnnotationListWidget):
                                                    # Find and remove the item with this annotation ID
                                                    for j in range(list_widget.count()):
                                                        item = list_widget.item(j)
                                                        if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                                                            list_widget.takeItem(j)
                                                            print(f"[DEBUG] Successfully removed annotation {annotation_id} from theme view")
                                                            break
                                                    
                                                    # If tab is now empty, remove it
                                                    if list_widget.count() == 0:
                                                        main_window.scene_tabs.removeTab(i)
                                                        print(f"[DEBUG] Removed empty tab for scene {scene}")
                                                        # If that was the last tab, show the empty overlay immediately
                                                        try:
                                                            if main_window.scene_tabs.count() == 0 and hasattr(main_window, 'script_search') and main_window.script_search:
                                                                main_window.script_search._update_placeholder_overlay(0)
                                                        except Exception as _e:
                                                            print(f"[DEBUG] Failed to show empty overlay after last tab removal: {_e}")
                                                break
                                    
                                    self.annotation_deleted.emit(json.dumps({ # Keep emit logic
                                        'text': anno.get('text', ''), # Use data from 'anno' object
                                        'scene': anno.get('scene', ''),
                                        'id': annotation_id,
                                        'notes': anno.get('notes', ''),
                                        'notes_html': anno.get('notes_html', ''),
                                        'used': anno.get('used', False),
                                        'favorite': anno.get('favorite', False),
                                        'tags': anno.get('tags', []),
                                        'secondary_scenes': anno.get('secondary_scenes', []),
                                        'speech_title': anno.get('speech_title', '')
                                    }))
                                    changes_made = True # Mark that a change occurred
                                except ValueError:
                                    print(f"WARN: Annotation {annotation_id} already removed from list?")

                            else: # Partial removal / split case
                                print(f"DEBUG: Handling split case for annotation {annotation_id}")
                                updated_spans = result.get('updatedSpans', [])
                                original_text = original_texts.get(annotation_id, anno.get('text', ''))
                                
                                # NEW LOGIC: Handle middle removal with different annotation IDs
                                # Left span: isOriginal=true, annotationId=original_id
                                # Right span: isOriginal=false, annotationId=new_uuid
                                spans_with_original_id = [s for s in updated_spans if s.get('isOriginal') and s.get('annotationId') == annotation_id]
                                spans_with_new_id = [s for s in updated_spans if not s.get('isOriginal')]
                                
                                left_span = None
                                right_span = None
                                
                                print(f"DEBUG: Found {len(spans_with_original_id)} spans with original ID, {len(spans_with_new_id)} spans with new ID")
                                
                                # Collect annotation IDs for selection after storyboard update
                                for span in spans_with_original_id:
                                    span_id = span.get('annotationId')
                                    if span_id and span_id not in relevant_annotation_ids:
                                        relevant_annotation_ids.append(span_id)
                                        print(f"DEBUG: Added left span annotation ID for selection: {span_id}")
                                
                                for span in spans_with_new_id:
                                    span_id = span.get('annotationId')
                                    if span_id and span_id not in relevant_annotation_ids:
                                        relevant_annotation_ids.append(span_id)
                                        print(f"DEBUG: Added right span annotation ID for selection: {span_id}")
                                
                                # Check for middle removal: one span with original ID + one span with new ID
                                if len(spans_with_original_id) == 1 and len(spans_with_new_id) == 1:
                                    print("DEBUG: Middle removal detected - left span with original ID, right span with new ID")
                                    left_span = spans_with_original_id[0]
                                    right_span = spans_with_new_id[0]
                                elif len(spans_with_original_id) == 1 and len(spans_with_new_id) == 0:
                                    # Single remaining span - determine if it's left or right based on content
                                    span = spans_with_original_id[0]
                                    span_text = span.get('text', '').strip()
                                    if original_text.strip().startswith(span_text):
                                        right_span = span  # Beginning removal - remaining text is right part
                                        print("DEBUG: Beginning removal detected")
                                    elif original_text.strip().endswith(span_text):
                                        left_span = span   # End removal - remaining text is left part  
                                        print("DEBUG: End removal detected")
                                elif len(spans_with_original_id) == 2:
                                    # Legacy case: both spans have same original ID
                                    print("DEBUG: Legacy middle removal detected - both spans have original ID")
                                    span1, span2 = spans_with_original_id
                                    text1, text2 = span1.get('text', '').strip(), span2.get('text', '').strip()
                                    if original_text.strip().startswith(text1):
                                        left_span, right_span = span1, span2
                                    else:
                                        left_span, right_span = span2, span1

                                header_to_apply = self.original_headers.get(annotation_id) # Get potential header
                                if header_to_apply: print(f"DEBUG: Header is available for annotation {annotation_id}: {repr(header_to_apply[:50])}...")
                                else: print(f"DEBUG: No header available for annotation {annotation_id}")

                                has_left = left_span and left_span.get('text', '').strip() # Keep strip() check
                                has_right = right_span and right_span.get('text', '').strip() # Keep strip() check

                                if annotation_id == DEBUG_ANNOTATION_ID: # Keep debug logic
                                    print(f"\n===== DEBUG FOR ANNOTATION {DEBUG_ANNOTATION_ID} - BEFORE TEXT REMOVAL =====")
                                    print(f"Text removal scenario: has_left={has_left}, has_right={has_right}")
                                    if has_left: print(f"Left span text: {repr(left_span.get('text', '')[:50])}...")
                                    if has_right: print(f"Right span text: {repr(right_span.get('text', '')[:50])}...")
                                    print(f"===== END PRE-REMOVAL DEBUG FOR {DEBUG_ANNOTATION_ID} =====\n")

                                # --- Sub-cases for split (Keep all this logic exactly) ---

                                # ===== BEGINNING TEXT REMOVAL (EXACTLY like END removal) =====
                                if not has_left and has_right:
                                    print(f"DEBUG: Beginning text removal case - updating original with right part (SAME as end removal)")
                                    if annotation_id == DEBUG_ANNOTATION_ID:
                                        print(f"\n===== DEBUG FOR ANNOTATION {DEBUG_ANNOTATION_ID} - BEGINNING TEXT REMOVAL =====")
                                        if isinstance(anno.get('storyboard'), dict): print(f"Current storyboard before update: {anno['storyboard']}")
                                        print(f"===== END BEGINNING-REMOVAL DEBUG BEFORE UPDATE FOR {DEBUG_ANNOTATION_ID} =====\n")

                                    # Update the existing `anno` object directly (EXACTLY like end removal)
                                    anno['text'] = right_span['text']

                                    # *** DEBUG: Check storyboard before and after ***
#                                     print(f"DEBUG STORYBOARD BEGINNING: Before update - annotation text: {repr(anno.get('text', '')[:50])}")
#                                     print(f"DEBUG STORYBOARD BEGINNING: Before update - storyboard text: {repr(anno.get('storyboard', {}).get('text', '')[:50])}")
#                                     print(f"DEBUG STORYBOARD BEGINNING: update_storyboard flag: {update_storyboard}")
#                                     print(f"DEBUG STORYBOARD BEGINNING: anno_has_storyboard_data: {anno_has_storyboard_data}")

                                    # *** Conditional Storyboard Content Update (EXACTLY like end removal) ***
                                    if update_storyboard and anno_has_storyboard_data and isinstance(anno.get('storyboard'), dict):
                                        original_storyboard_order = anno['storyboard'].get('order')
                                        updated_text = right_span['text'].replace('\n', '<br>')
                                        if header_to_apply:
                                            updated_text = apply_header_to_text(updated_text, header_to_apply)
                                            headers_applied_count += 1
                                        anno['storyboard']['text'] = updated_text # Update storyboard text in place
                                        if original_storyboard_order is not None: anno['storyboard']['order'] = original_storyboard_order
                                        # Keep strikethrough merge logic
                                        if annotation_id in original_strike_backup:
                                            current_segments = anno['storyboard'].get('strikethrough_segments', {})
                                            merged_segments = {**original_strike_backup[annotation_id], **current_segments}
                                            anno['storyboard']['strikethrough_segments'] = merged_segments
                                        if annotation_id in original_positional_backup:
                                            current_positional = anno['storyboard'].get('positional_strikethrough', {})
                                            merged_positional = {**original_positional_backup[annotation_id], **current_positional}
                                            anno['storyboard']['positional_strikethrough'] = merged_positional
                                        
#                                         print(f"DEBUG STORYBOARD BEGINNING: Updated storyboard text to: {repr(updated_text[:50])}")
                                    else:
                                        pass  # Storyboard NOT updated - conflict should be detected next time
#                                         print(f"DEBUG STORYBOARD BEGINNING: Storyboard NOT updated - conflict should be detected next time")

#                                     print(f"DEBUG STORYBOARD BEGINNING: After update - annotation text: {repr(anno.get('text', '')[:50])}")
#                                     print(f"DEBUG STORYBOARD BEGINNING: After update - storyboard text: {repr(anno.get('storyboard', {}).get('text', '')[:50])}")

                                    if annotation_id == DEBUG_ANNOTATION_ID:
                                        print(f"\n===== DEBUG FOR ANNOTATION {DEBUG_ANNOTATION_ID} - AFTER BEGINNING TEXT REMOVAL =====")
                                        if isinstance(anno.get('storyboard'), dict): print(f"Updated storyboard: {anno['storyboard']}")
                                        print(f"===== END BEGINNING-REMOVAL DEBUG AFTER UPDATE FOR {DEBUG_ANNOTATION_ID} =====\n")

                                    # Emit update signal (EXACTLY like end removal)
                                    self.annotation_updated.emit(json.dumps(anno))

                                    # Targeted Theme View refresh to reflect updated text without full rebuild
                                    try:
                                        main_window = self.window()
                                        if main_window and hasattr(main_window, 'refresh_annotation_in_theme_view'):
                                            main_window.refresh_annotation_in_theme_view(annotation_id)
                                            print(f"DEBUG: Targeted refresh applied for annotation {annotation_id} (beginning removal)")
                                    except Exception as _e:
                                        print(f"DEBUG: Targeted refresh failed (beginning removal): {_e}")
                                    changes_made = True

                                # ===== END TEXT REMOVAL =====
                                elif has_left and not has_right:
                                    print(f"DEBUG: End text removal case - updating original with left part")
                                    if annotation_id == DEBUG_ANNOTATION_ID: # Keep debug logic
                                        print(f"\n===== DEBUG FOR ANNOTATION {DEBUG_ANNOTATION_ID} - END TEXT REMOVAL =====")
                                        if isinstance(anno.get('storyboard'), dict): print(f"Current storyboard before update: {anno['storyboard']}")
                                        print(f"===== END END-REMOVAL DEBUG BEFORE UPDATE FOR {DEBUG_ANNOTATION_ID} =====\n")

                                    # Update the existing `anno` object directly
                                    anno['text'] = left_span['text']

                                    # *** DEBUG: Check storyboard before and after ***
                                    print(f"DEBUG STORYBOARD END: Before update - annotation text: {repr(anno.get('text', '')[:50])}")
                                    print(f"DEBUG STORYBOARD END: Before update - storyboard text: {repr(anno.get('storyboard', {}).get('text', '')[:50])}")
                                    print(f"DEBUG STORYBOARD END: update_storyboard flag: {update_storyboard}")
                                    print(f"DEBUG STORYBOARD END: anno_has_storyboard_data: {anno_has_storyboard_data}")

                                    # *** Conditional Storyboard Content Update ***
                                    if update_storyboard and anno_has_storyboard_data and isinstance(anno.get('storyboard'), dict):
                                        original_storyboard_order = anno['storyboard'].get('order')
                                        updated_text = left_span['text'].replace('\n', '<br>')
                                        if header_to_apply:
                                            updated_text = apply_header_to_text(updated_text, header_to_apply)
                                            headers_applied_count += 1
                                        anno['storyboard']['text'] = updated_text # Update storyboard text in place
                                        if original_storyboard_order is not None: anno['storyboard']['order'] = original_storyboard_order
                                        # Keep strikethrough merge logic
                                        if annotation_id in original_strike_backup:
                                            current_segments = anno['storyboard'].get('strikethrough_segments', {})
                                            merged_segments = {**original_strike_backup[annotation_id], **current_segments}
                                            anno['storyboard']['strikethrough_segments'] = merged_segments
                                        if annotation_id in original_positional_backup:
                                            current_positional = anno['storyboard'].get('positional_strikethrough', {})
                                            merged_positional = {**original_positional_backup[annotation_id], **current_positional}
                                            anno['storyboard']['positional_strikethrough'] = merged_positional
                                        
                                        print(f"DEBUG STORYBOARD END: Updated storyboard text to: {repr(updated_text[:50])}")
                                    else:
                                        print(f"DEBUG STORYBOARD END: Storyboard NOT updated - conflict should be detected next time")

                                    print(f"DEBUG STORYBOARD END: After update - annotation text: {repr(anno.get('text', '')[:50])}")
                                    print(f"DEBUG STORYBOARD END: After update - storyboard text: {repr(anno.get('storyboard', {}).get('text', '')[:50])}")

                                    if annotation_id == DEBUG_ANNOTATION_ID: # Keep debug logic
                                        print(f"\n===== DEBUG FOR ANNOTATION {DEBUG_ANNOTATION_ID} - AFTER END TEXT REMOVAL =====")
                                        if isinstance(anno.get('storyboard'), dict): print(f"Updated storyboard with merged data: {anno['storyboard']}")
                                        print(f"===== END END-REMOVAL DEBUG AFTER UPDATE FOR {DEBUG_ANNOTATION_ID} =====\n")

                                    self.annotation_updated.emit(json.dumps(anno))

                                    # Targeted Theme View refresh to reflect updated text without full rebuild
                                    try:
                                        main_window = self.window()
                                        if main_window and hasattr(main_window, 'refresh_annotation_in_theme_view'):
                                            main_window.refresh_annotation_in_theme_view(annotation_id)
                                            print(f"DEBUG: Targeted refresh applied for annotation {annotation_id} (end removal)")
                                    except Exception as _e:
                                        print(f"DEBUG: Targeted refresh failed (end removal): {_e}")
                                    changes_made = True

                                # ===== MIDDLE TEXT REMOVAL =====
                                elif has_left and has_right:
                                    print(f"DEBUG: Middle text removal case - splitting annotation")
                                    if annotation_id == DEBUG_ANNOTATION_ID: # Keep debug logic
                                        print(f"\n===== DEBUG FOR ANNOTATION {DEBUG_ANNOTATION_ID} - MIDDLE TEXT REMOVAL =====")
                                        if isinstance(anno.get('storyboard'), dict): print(f"Current storyboard before split: {anno['storyboard']}")
                                        print(f"===== END MIDDLE-REMOVAL DEBUG BEFORE SPLIT FOR {DEBUG_ANNOTATION_ID} =====\n")

                                    original_storyboard_backup = None
                                    if isinstance(anno.get('storyboard'), dict): # Backup original storyboard content if exists
                                        original_storyboard_backup = copy.deepcopy(anno['storyboard'])

                                    # Update original annotation object `anno` with left part
                                    print(f"DEBUG MIDDLE: Before update - anno['text']: {repr(anno['text'][:100])}...")
                                    print(f"DEBUG MIDDLE: left_span['text']: {repr(left_span['text'][:100])}...")
                                    anno['text'] = left_span['text']
                                    print(f"DEBUG MIDDLE: After update - anno['text']: {repr(anno['text'][:100])}...")

                                    # *** Conditional Storyboard Content Update for Left Part ***
                                    if update_storyboard and anno_has_storyboard_data and isinstance(anno.get('storyboard'), dict):
                                        original_order = anno['storyboard'].get('order') # Get order before modifying text
                                        updated_text = left_span['text'].replace('\n', '<br>')
                                        if header_to_apply:
                                            updated_text = apply_header_to_text(updated_text, header_to_apply)
                                            headers_applied_count += 1
                                        anno['storyboard']['text'] = updated_text # Update text in place
                                        if original_order is not None: anno['storyboard']['order'] = original_order
                                        # Keep strikethrough merge logic for left part
                                        if annotation_id in original_strike_backup:
                                            current_segments = anno['storyboard'].get('strikethrough_segments', {})
                                            merged_segments = {**original_strike_backup[annotation_id], **current_segments}
                                            anno['storyboard']['strikethrough_segments'] = merged_segments
                                        if annotation_id in original_positional_backup:
                                            current_positional = anno['storyboard'].get('positional_strikethrough', {})
                                            merged_positional = {**original_positional_backup[annotation_id], **current_positional}
                                            anno['storyboard']['positional_strikethrough'] = merged_positional

                                    if annotation_id == DEBUG_ANNOTATION_ID: # Keep debug logic
                                        print(f"\n===== DEBUG FOR ANNOTATION {DEBUG_ANNOTATION_ID} - AFTER MIDDLE TEXT REMOVAL (LEFT PART) =====")
                                        if isinstance(anno.get('storyboard'), dict): print(f"Updated LEFT part storyboard with merged data: {anno['storyboard']}")
                                        print(f"===== END MIDDLE-REMOVAL DEBUG (LEFT PART) FOR {DEBUG_ANNOTATION_ID} =====\n")

                                    self.annotation_updated.emit(json.dumps(anno)) # Emit update for left part

                                    # Create new annotation data for right part
                                    new_anno = anno.copy() # Copy the updated left part (or original?) - let's copy original for safety of attributes
                                    new_anno = self.annotations[anno_index].copy() # Re-copy from list to be safe
                                    # Use the UUID that JavaScript generated for the right span
                                    new_anno['id'] = right_span['annotationId']
                                    new_anno['text'] = right_span['text']

                                    # *** Conditional Storyboard Content Update for Right Part ***
                                    if update_storyboard and anno_has_storyboard_data and original_storyboard_backup is not None:
                                         # Base the new storyboard on the original backup
                                         new_anno['storyboard'] = copy.deepcopy(original_storyboard_backup)
                                         new_anno['storyboard']['text'] = right_span['text'].replace('\n', '<br>') # Set right text
                                         # Do NOT apply header to right part
                                         # Keep strikethrough merge logic for right part using original backup
                                         if annotation_id in original_strike_backup:
                                             current_segments = new_anno['storyboard'].get('strikethrough_segments', {}) # Segments from backup
                                             merged_segments = {**original_strike_backup[annotation_id], **current_segments}
                                             new_anno['storyboard']['strikethrough_segments'] = merged_segments
                                         if annotation_id in original_positional_backup:
                                             current_positional = new_anno['storyboard'].get('positional_strikethrough', {}) # Positional from backup
                                             merged_positional = {**original_positional_backup[annotation_id], **current_positional}
                                             new_anno['storyboard']['positional_strikethrough'] = merged_positional
                                    # If original didn't have storyboard, ensure new one doesn't
                                    elif not anno_has_storyboard_data and 'storyboard' in new_anno:
                                        del new_anno['storyboard']
                                    # If not updating storyboard, but original had one, copy original content?
                                    elif anno_has_storyboard_data and not update_storyboard and original_storyboard_backup is not None:
                                        new_anno['storyboard'] = copy.deepcopy(original_storyboard_backup)
                                        new_anno['storyboard']['text'] = right_span['text'].replace('\n', '<br>') # Still set text


                                    if annotation_id == DEBUG_ANNOTATION_ID: # Keep debug logic
                                        print(f"\n===== DEBUG FOR ANNOTATION {DEBUG_ANNOTATION_ID} - AFTER MIDDLE TEXT REMOVAL (RIGHT PART) =====")
                                        if isinstance(new_anno.get('storyboard'), dict): print(f"New RIGHT part storyboard with merged data: {new_anno['storyboard']}")
                                        print(f"===== END MIDDLE-REMOVAL DEBUG (RIGHT PART) FOR {DEBUG_ANNOTATION_ID} =====\n")

                                    # Insert the new annotation right after the updated original one
                                    self.annotations.insert(anno_index + 1, new_anno)
                                    
                                    # Emit for storyboard updates but theme view handled by targeted updates
                                    print(f"DEBUG: Emitting annotation_added for storyboard sync: {new_anno['id']}")
                                    print(f"🔥🔥🔥🔥🔥 ANNOTATION EMIT TRACEBACK FOR {new_anno.get('id')} 🔥🔥🔥🔥🔥")
                                    import traceback
                                    traceback.print_stack()
                                    print(f"🔥🔥🔥🔥🔥 END EMIT TRACEBACK 🔥🔥🔥🔥🔥")
                                    self.annotation_added.emit(json.dumps(new_anno))
                                        
                    changes_made = True


                if annotation_id == DEBUG_ANNOTATION_ID: # Keep debug logic
                    print(f"\n===== FINAL DEBUG FOR ANNOTATION {DEBUG_ANNOTATION_ID} =====")
                    scenario = "Unknown scenario" # Determine scenario based on has_left/has_right
                    if not has_left and has_right: scenario = "Beginning text removal"
                    elif has_left and not has_right: scenario = "End text removal"
                    elif has_left and has_right: scenario = "Middle text removal"
                    print(f"Final processing complete. Text removal scenario was: {scenario}")
                    print(f"===== END FINAL DEBUG FOR {DEBUG_ANNOTATION_ID} =====\n")

                # --- End of UNCONDITIONAL processing block ---
            # =================== END OF MODIFIED SECTION ===================

            # Keep post-processing logic exactly as it was
            # print(f"DEBUG: Header preservation statistics:") # Keep comments if desired
            # print(f"DEBUG: Headers found: {headers_found_count}")
            # print(f"DEBUG: Headers preserved: {headers_applied_count}")

            if changes_made and main_window and hasattr(main_window, 'mark_changes_pending'):
                main_window.mark_changes_pending()

            if main_window and hasattr(main_window, 'theme_view'):
                if main_window.theme_view and main_window.theme_view.isVisible():
#                     print("DEBUG: Scheduling theme view update")
                    # Skip full theme view rebuild since targeted removal already handled it
                    # QTimer.singleShot(150, lambda: main_window.update_theme_view())
                    QTimer.singleShot(150, lambda: self.page().runJavaScript("window.isEditMode",
                                                                           lambda is_edit_mode: self.set_edit_mode(is_edit_mode) if hasattr(self,'set_edit_mode') else None))
                    QTimer.singleShot(150, lambda: self.enable_hotkeys(True) if hasattr(self,'enable_hotkeys') else None)

            if hasattr(self, 'scenes_updated'): # Check if signal exists
                 self.scenes_updated.emit()

            if 'scrollPos' in result:
                scroll_pos = result['scrollPos']
                print(f"DEBUG: Restoring scroll position to {scroll_pos}")
                restore_js = f"window.scrollTo(0, {scroll_pos})"
                QTimer.singleShot(100, lambda: self.page().runJavaScript(restore_js))

            # FIXED: Remove redundant check that triggers populate_order_list for non-storyboard removals
            # Only update order list if the removed annotation(s) actually had storyboard/order data
            # The presence of other annotations with order data doesn't require rebuilding the list

            # Keep original order list update logic exactly
            if hasattr(self, 'main_window') and self.main_window and self.should_update_order_list:
                current_time = int(time.time() * 1000)
                # Ensure _last_order_update_time attribute exists
                if not hasattr(self, '_last_order_update_time'): self._last_order_update_time = 0

                if current_time - self._last_order_update_time > 100:
                    self._last_order_update_time = current_time
                    dialog_exists = hasattr(self.main_window, 'storyboard_dialog') and self.main_window.storyboard_dialog
                    storyboard_dialog = getattr(self.main_window, 'storyboard_dialog', None) # Get instance safely

                    # Check if update method exists before calling
                    update_method_exists = storyboard_dialog and hasattr(storyboard_dialog, 'populate_order_list_and_improve_strikethroughs')

                    if not dialog_exists and hasattr(self.main_window, 'ensure_storyboard_dialog_hidden'):
                        # Keep original logic for creating/resetting dialog
                        print("DEBUG: Creating new storyboard dialog")
                        self.main_window.ensure_storyboard_dialog_hidden()
                        storyboard_dialog = getattr(self.main_window, 'storyboard_dialog', None) # Get new instance
                        update_method_exists = storyboard_dialog and hasattr(storyboard_dialog, 'populate_order_list_and_improve_strikethroughs')
                        reset_method_exists = storyboard_dialog and hasattr(storyboard_dialog, 'reset_state')

                        if storyboard_dialog and update_method_exists and reset_method_exists:
                             print(f"DEBUG: Scheduling update with reset_state for new dialog at timestamp {current_time}")
                             def update_with_reset(dialog=storyboard_dialog): # Capture dialog instance
                                 print("DEBUG: Resetting state for new storyboard dialog before updating")
                                 # Set pending selection IDs if we have any relevant annotations
                                 if relevant_annotation_ids:
                                     dialog._pending_selection_ids = relevant_annotation_ids.copy()
                                     print(f"DEBUG: Set pending selection IDs for new dialog: {relevant_annotation_ids}")
                                 dialog.reset_state()
                                 dialog.populate_order_list_and_improve_strikethroughs()
                             QTimer.singleShot(200, update_with_reset) # Keep original delay
                        else:
                             print("WARN: New storyboard dialog or its methods (reset/update) not found after creation.")

                    elif dialog_exists and update_method_exists:
                         # Keep original logic for updating existing dialog + add selection handling
                         print(f"DEBUG: Scheduling normal update for existing dialog at timestamp {current_time}")
                         # Capture dialog instance and selection IDs in lambda
                         def update_existing_dialog(dialog=storyboard_dialog, selection_ids=relevant_annotation_ids.copy() if relevant_annotation_ids else []):
                             if selection_ids:
                                 dialog._pending_selection_ids = selection_ids
                                 print(f"DEBUG: Set pending selection IDs for existing dialog: {selection_ids}")
                             dialog.populate_order_list_and_improve_strikethroughs()
                         QTimer.singleShot(100, update_existing_dialog) # Keep original delay
                    elif dialog_exists and not update_method_exists:
                         print("WARN: Storyboard dialog exists but populate_order_list_and_improve_strikethroughs method is missing.")

                else:
                    print(f"DEBUG: Skipping duplicate update, last update was {current_time - getattr(self, '_last_order_update_time', current_time)}ms ago") # Use getattr safely

            # Reset flag after processing is complete
            self.should_update_order_list = False
            # Clear temporary header/strikethrough storage (assuming these are meant to be temporary)
            if hasattr(self, 'original_headers'): self.original_headers = {}
            if hasattr(self, 'original_strikethrough_contexts'): self.original_strikethrough_contexts = {}


        # --- Original JS call remains outside the Python handler ---
        # This part should be where the JS execution is *initiated*,
        # and handle_removed_spans is the *callback* function.
        # Example structure (assuming js_code is defined elsewhere):
        # print("DEBUG: Executing remove_highlight JavaScript")
        # self.page().runJavaScript(js_code, handle_removed_spans)


        print("DEBUG: Executing remove_highlight JavaScript")
        self.page().runJavaScript(js_code, handle_removed_spans)

    def is_beginning_of_text(self, part_text, original_text):
        """Check if a text part appears at the beginning of the original text."""
        if not part_text or not original_text:
            return False
        clean_part = part_text.strip()
        clean_original = original_text.strip()
        begins_with = clean_original.startswith(clean_part)
        print(f"DEBUG: Checking if '{clean_part}' is at beginning of '{clean_original}': {begins_with}")
        return begins_with

    def extract_header_from_text(self, text):
        """Extract header HTML from the beginning of text if present."""
        if not text:
            print("DEBUG: Empty text provided to extract_header_from_text")
            return None, text
    
        # Print first 150 chars for debugging
#         print(f"DEBUG: EXTRACTING HEADER FROM: {repr(text[:150])}")
    
        # Improved patterns that match your StoryboardHeaderDialog output exactly
        header_patterns = [
            # Match header with style attribute - prioritize exact pattern from StoryboardHeaderDialog
            r'^(\s*<div>\s*<b\s+style=[\'"]background-color:\s*[^\'";]+;?[\'"]>\s*.*?\s*</b>\s*</div>)(\s*\n?)',
            # Match header with style attribute - more general version
            r'^(\s*<div>\s*<b\s+style=[\'"][^\'"]*background-color:[^\'"]*[\'"]>\s*.*?\s*</b>\s*</div>)(\s*\n?)',
            # Simple div+b headers without style
            r'^(\s*<div>\s*<b>\s*.*?\s*</b>\s*</div>)(\s*\n?)',
        ]
    
        for i, pattern in enumerate(header_patterns):
            try:
                match = re.match(pattern, text, re.DOTALL)
                if match:
                    header = match.group(1)
                    separator = match.group(2) or "\n"
                    remaining_text = text[len(header) + len(separator):]
                    print(f"DEBUG: Extracted header using pattern {i+1}: {repr(header)}")
                    return header, remaining_text
                else:
                    pass  # Pattern did not match
#                     print(f"DEBUG: Pattern {i+1} did not match")
            except Exception as e:
                print(f"DEBUG: Error in header pattern {i+1}: {e}")
    
#         print("DEBUG: No header pattern matched")
        return None, text

    def auto_select_all_highlights(self, selection_info=None):
        """
        Automatically adjust the current selection to include all intersecting highlighted spans completely.
    
        Args:
            selection_info: Optional dict containing the original selection range information
        """
        js_code = '''
            (function() {
                // Get current selection
                var selection = window.getSelection();
                if (!selection || selection.rangeCount === 0) {
                    console.log("DEBUG: No valid selection found");
                    return false;
                }
            
                var range = selection.getRangeAt(0);
                var commonAncestor = range.commonAncestorContainer;
            
                // Find all intersecting spans
                var spans = document.querySelectorAll('span[data-annotation-id]');
                var intersectingSpans = [];
                spans.forEach(function(span) {
                    if (range.intersectsNode(span)) {
                        console.log("DEBUG: Found intersecting span:", span.textContent);
                        intersectingSpans.push(span);
                    }
                });
            
                if (intersectingSpans.length === 0) {
                    console.log("DEBUG: No intersecting spans found");
                    return false;
                }
            
                // Create a new range encompassing all spans
                var newRange = document.createRange();
            
                // Find leftmost span (earliest in document)
                var leftmost = intersectingSpans[0];
                for (var i = 1; i < intersectingSpans.length; i++) {
                    if (leftmost.compareDocumentPosition(intersectingSpans[i]) & Node.DOCUMENT_POSITION_PRECEDING) {
                        leftmost = intersectingSpans[i];
                    }
                }
            
                // Find rightmost span (latest in document)
                var rightmost = intersectingSpans[0];
                for (var i = 1; i < intersectingSpans.length; i++) {
                    if (rightmost.compareDocumentPosition(intersectingSpans[i]) & Node.DOCUMENT_POSITION_FOLLOWING) {
                        rightmost = intersectingSpans[i];
                    }
                }
            
                // Get surrounding text to ensure we capture the full context
                // Find a reasonable amount of text before the leftmost span
                var leftContext = "";
                var currentNode = leftmost.previousSibling;
                var contextChars = 20; // Number of characters of context to include
            
                while (currentNode && leftContext.length < contextChars) {
                    if (currentNode.nodeType === Node.TEXT_NODE) {
                        var text = currentNode.textContent;
                        if (text.length > contextChars - leftContext.length) {
                            // Only take what we need from the end of this text node
                            leftContext = text.substring(text.length - (contextChars - leftContext.length)) + leftContext;
                            break;
                        } else {
                            leftContext = text + leftContext;
                        }
                    }
                    currentNode = currentNode.previousSibling;
                }
            
                // Find a reasonable amount of text after the rightmost span
                var rightContext = "";
                currentNode = rightmost.nextSibling;
            
                while (currentNode && rightContext.length < contextChars) {
                    if (currentNode.nodeType === Node.TEXT_NODE) {
                        var text = currentNode.textContent;
                        if (text.length > contextChars - rightContext.length) {
                            // Only take what we need from the beginning of this text node
                            rightContext += text.substring(0, contextChars - rightContext.length);
                            break;
                        } else {
                            rightContext += text;
                        }
                    }
                    currentNode = currentNode.nextSibling;
                }
            
                // Set range to encompass all spans plus context
                // If we have text nodes before or after, include them in the selection
                var startNode = leftmost;
                var startOffset = 0;
                if (leftmost.previousSibling && leftmost.previousSibling.nodeType === Node.TEXT_NODE) {
                    startNode = leftmost.previousSibling;
                    startOffset = Math.max(0, startNode.textContent.length - Math.min(leftContext.length, startNode.textContent.length));
                }
            
                var endNode = rightmost;
                var endOffset = rightmost.textContent.length;
                if (rightmost.nextSibling && rightmost.nextSibling.nodeType === Node.TEXT_NODE) {
                    endNode = rightmost.nextSibling;
                    endOffset = Math.min(endNode.textContent.length, rightContext.length);
                }
            
                // Create and set the new range
                try {
                    if (startNode.nodeType === Node.ELEMENT_NODE) {
                        newRange.setStartBefore(startNode);
                    } else {
                        newRange.setStart(startNode, startOffset);
                    }
                
                    if (endNode.nodeType === Node.ELEMENT_NODE) {
                        newRange.setEndAfter(endNode);
                    } else {
                        newRange.setEnd(endNode, endOffset);
                    }
                
                    // Provide debug information
                    console.log("DEBUG: Auto-selection range created:", {
                        startNode: startNode.nodeName + (startNode.nodeType === Node.TEXT_NODE ? " (text)" : ""),
                        startOffset: startOffset,
                        endNode: endNode.nodeName + (endNode.nodeType === Node.TEXT_NODE ? " (text)" : ""),
                        endOffset: endOffset,
                        leftContext: leftContext,
                        rightContext: rightContext,
                        selectedText: newRange.toString()
                    });
                
                    // Apply the new selection
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                
                    return {
                        success: true,
                        leftmost: leftmost.textContent,
                        rightmost: rightmost.textContent,
                        selectedText: newRange.toString(),
                        spanCount: intersectingSpans.length
                    };
                } catch (e) {
                    console.error("DEBUG: Error setting auto-selection range:", e);
                    return {
                        success: false,
                        error: e.toString()
                    };
                }
            })();
        '''
    
        def handle_auto_select_result(result):
            if result and isinstance(result, dict) and result.get('success'):
                print(f"DEBUG: Auto-selection successfully applied")
                print(f"DEBUG: Selected {result.get('spanCount', 0)} spans")
                print(f"DEBUG: Selection now includes from '{result.get('leftmost', '')}' to '{result.get('rightmost', '')}'")
                print(f"DEBUG: Full selected text: '{result.get('selectedText', '')}'")
            
                # Show a brief notification to the user
                QTimer.singleShot(0, lambda: self.main_window.status_bar.showMessage(
                    f"Auto-selected {result.get('spanCount', 0)} highlights", 3000))
            
                # Now we can trigger the removal with the new selection
                QTimer.singleShot(100, lambda: self.remove_highlight(""))
            else:
                error_msg = "Unknown error" if not isinstance(result, dict) else result.get('error', 'Unknown error')
                print(f"DEBUG: Auto-selection failed: {error_msg}")
            
                QMessageBox.warning(
                    self,
                    "Auto-Selection Failed",
                    f"Could not automatically adjust the selection. Please try selecting the highlights manually.\n\nError details: {error_msg}"
                )
    
        self.page().runJavaScript(js_code, handle_auto_select_result)

    def handle_highlight_removal(self, success, annotation, item, main_window, deletion_info):
        """Handle the result of highlight removal with proper script view refresh"""
        if success:
            # Store current state before making changes
            current_tab_index = None
            scroll_positions = {}
            selected_items = {}
    
            if main_window.theme_view and main_window.theme_view.isVisible():
                current_tab_index = main_window.scene_tabs.currentIndex()
                # Store scroll position and selected items for each tab
                for i in range(main_window.scene_tabs.count()):
                    list_widget = main_window.scene_tabs.widget(i)
                    if isinstance(list_widget, AnnotationListWidget):
                        scroll_positions[i] = list_widget.verticalScrollBar().value()
                        selected_items[i] = []
                        for j in range(list_widget.count()):
                            current_item = list_widget.item(j)
                            if current_item.isSelected():
                                item_widget = list_widget.itemWidget(current_item)
                                if item_widget:
                                    label = item_widget.findChild(QLabel)
                                    notes_edit = item_widget.findChild(QLineEdit)
                                    annotation_id = current_item.data(Qt.ItemDataRole.UserRole)
                                    if label:
                                        selected_items[i].append({
                                            'text': label.text(),
                                            'notes': notes_edit.text() if notes_edit else '',
                                            'id': annotation_id
                                        })
    
            # Store web view scroll position
            js_code = "window.pageYOffset"
    
            def restore_state_and_update(scroll_pos):
                # Find the annotation by ID in the annotations list
                annotation_id = deletion_info.get('id')
                if annotation_id:
                    # Remove annotation from data structure
                    for anno in list(main_window.web_view.annotations):
                        if anno.get('id') == annotation_id:
                            main_window.web_view.annotations.remove(anno)
                            break
        
                # Remove item from list widget if it exists
                if item is not None and hasattr(self, 'selectedItems'):
                    if item in self.selectedItems():
                        self.takeItem(self.row(item))
        
                # Emit deletion signal with complete annotation info
                main_window.web_view.annotation_deleted.emit(json.dumps(deletion_info))
                main_window.web_view.scenes_updated.emit()
        
                # Use targeted annotation removal instead of full rebuild
                if main_window.theme_view and main_window.theme_view.isVisible():
                    # Find and remove the specific annotation item from the theme view
                    scene = deletion_info['scene']
                    annotation_id = deletion_info.get('id')
                    
                    print(f"[DEBUG] Removing annotation {annotation_id} from scene {scene}")
                    
                    # Find the tab for this scene
                    for i in range(main_window.scene_tabs.count()):
                        if main_window.scene_tabs.tabText(i) == scene:
                            list_widget = main_window.scene_tabs.widget(i)
                            if isinstance(list_widget, AnnotationListWidget):
                                # Find and remove the item with this annotation ID
                                for j in range(list_widget.count()):
                                    item = list_widget.item(j)
                                    if item:
                                        item_id = item.data(Qt.ItemDataRole.UserRole)
                                        if item_id == annotation_id:
                                            list_widget.takeItem(j)
                                            print(f"[DEBUG] Successfully removed annotation {annotation_id} from theme view")
                                            break
                                
                                # If tab is now empty, remove it
                                if list_widget.count() == 0:
                                    main_window.scene_tabs.removeTab(i)
                                    print(f"[DEBUG] Removed empty tab for scene {scene}")
                            break
            
                    # Restore state
                    # First restore selections by annotation ID
                    for i, items in selected_items.items():
                        if i < main_window.scene_tabs.count():
                            list_widget = main_window.scene_tabs.widget(i)
                            if isinstance(list_widget, AnnotationListWidget):
                                for j in range(list_widget.count()):
                                    current_item = list_widget.item(j)
                                    item_id = current_item.data(Qt.ItemDataRole.UserRole)
                                    for selected_info in items:
                                        if item_id == selected_info['id']:
                                            current_item.setSelected(True)
                                            break
            
                    # Then restore scroll positions
                    for i, pos in scroll_positions.items():
                        if i < main_window.scene_tabs.count():
                            list_widget = main_window.scene_tabs.widget(i)
                            if isinstance(list_widget, AnnotationListWidget):
                                list_widget.verticalScrollBar().setValue(pos)
            
                    # Finally set the current tab
                    if main_window.scene_tabs.count() > 0 and current_tab_index >= 0:
                        main_window.scene_tabs.setCurrentIndex(
                            min(current_tab_index, main_window.scene_tabs.count() - 1)
                        )
        
                # Update status message
                main_window.status_bar.showMessage("Annotation removed successfully", 5000)
        
                # # Update the web view content and restore its scroll position
                # def update_with_scroll(html):
                #     main_window.update_preview_content(html)
                #     restore_js = f"window.scrollTo(0, {scroll_pos})"
                #     QTimer.singleShot(100, lambda: main_window.web_view.page().runJavaScript(restore_js))
        
                # main_window.web_view.page().toHtml(update_with_scroll)
    
            main_window.web_view.page().runJavaScript(js_code, restore_state_and_update)
        else:
            main_window.status_bar.showMessage("Failed to remove highlight", 5000)

class ScriptoriaMain(QMainWindow):
    def __init__(self):
        # ... (existing __init__ code) ...
        print("\n=== INITIALIZATION START ===")
        super().__init__()

        # Initialize save state tracking
        self._save_in_progress = False

        self.initial_theme_state = {}
        # Add resize timer
        self._resize_timer = QTimer()
        self._resize_timer.setSingleShot(True)
        self._resize_timer.setInterval(100)  # Wait 150ms after resize stops
        self._resize_timer.timeout.connect(self._handle_resize_complete)
        self._last_resize_width = None
        self.install_event_filter()
        self._formatting_in_progress = False # Add this flag
        # Configure Gemini model once during initialization
        #self.gemini_model = self._configure_gemini()

        # Initialize shared model cache for AI dialogs
        self._cached_model = None
        self._cached_api_key = None
        self._cached_model_name = None
        
        # Initialize AI dialog reference for reuse
        self._ai_query_dialog = None

        # Initialize prompt content (load default or from file)
        self.current_prompt_content = self._load_default_prompt() # Assuming you have this method


        print("1. Setting up initial flags and properties...")
        self.current_session_file = None
        self.original_styles = {}
        self.updated_styles = {}
        self.tags = []  # Initialize empty tags list
        self.theme_view = None
        self.welcome_dialog_shown = False
        self.theme_view_visible = False
        self.changes_pending = False
        self.storyboard_changes_pending = False
        self.previous_html = None
        self.storyboard_content = None
        self.storyboard_recreating = False

        self._conversion_load_in_progress = False
        self._pending_html_content = None
        self._temp_html_path = None
        self._pending_bookmark_injection = False

        print("2. Setting up application icon...")
        if os.name == 'nt':
            import ctypes
            myappid = 'mycompany.transcriptmanager.welcome.1'
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
        self.setWindowFlags(self.windowFlags() | Qt.WindowType.WindowStaysOnTopHint)
        self.setup_application_icon()

        print("3. Initializing UI...")
        self.init_ui()

        print("\n7. Setting up timer for smooth transition...")
        QTimer.singleShot(250, self.smooth_remove_stays_on_top)

        self.add_chronological_sort_button_to_search()

        # Add the EPUB import button
        self.add_import_tools_button_to_scriptoria()

        # Initialize StoryboardDialog early to avoid delay on first text highlight
        print("8. Pre-creating StoryboardDialog to avoid first-use delay...")
        self.ensure_storyboard_dialog_hidden()

        print("=== INITIALIZATION END ===\n")

    def refresh_annotation_in_theme_view(self, annotation_id):
        """
        Refresh a single annotation in the theme view instead of regenerating the entire list.
    
        Args:
            annotation_id: The ID of the annotation that was updated
        """
        print(f"DEBUG: Refreshing annotation {annotation_id} in theme view")
    
        if not annotation_id:
            print("DEBUG: No annotation ID provided, cannot refresh")
            return
            
        # Refresh the annotation in all theme view tabs (regardless of visibility)
        if hasattr(self, 'scene_tabs') and self.scene_tabs:
            for i in range(self.scene_tabs.count()):
                list_widget = self.scene_tabs.widget(i)
                if hasattr(list_widget, 'refresh_annotation_display'):
                    list_widget.refresh_annotation_display(annotation_id)
            print(f"DEBUG: Refreshed annotation {annotation_id} in all theme view tabs")
        else:
            print("DEBUG: No scene tabs available for refresh")
            return
    
        # Find the annotation in the data structure
        annotation = None
        for anno in self.web_view.annotations:
            if anno.get('id') == annotation_id:
                annotation = anno
                break
    
        if not annotation:
            print(f"DEBUG: Could not find annotation with ID {annotation_id}")
            return
    
        scene_name = annotation.get('scene')
        if not scene_name:
            print(f"DEBUG: No scene name in annotation {annotation_id}, cannot refresh")
            return
    
        # Find the tab index for this scene
        tab_index = -1
        for i in range(self.scene_tabs.count()):
            if self.scene_tabs.tabText(i) == scene_name:
                tab_index = i
                break
    
        if tab_index == -1:
            print(f"DEBUG: Could not find tab for scene '{scene_name}'")
            return
    
        # Get the list widget for this scene
        list_widget = self.scene_tabs.widget(tab_index)
        if not isinstance(list_widget, AnnotationListWidget):
            print(f"DEBUG: Widget at tab {tab_index} is not an AnnotationListWidget")
            return
    
        # Find the item with this annotation ID
        found_item = None
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                found_item = item
                break
    
        if not found_item:
            print(f"DEBUG: Could not find item for annotation ID {annotation_id}")
            return
    
        # Get the widget for this item
        item_widget = list_widget.itemWidget(found_item)
        if not item_widget:
            print(f"DEBUG: No widget for item with annotation ID {annotation_id}")
            return
    
        # Update the widget components
        try:
            # **UPDATE ANNOTATION TEXT**: Make sure label reflects current annotation text
            label = item_widget.findChild(QLabel)
            if label and annotation.get('text'):
                current_label_text = label.text()
                annotation_text = annotation.get('text', '')
                
                # Update label if text has changed
                if current_label_text != annotation_text:
                    print(f"DEBUG: Updating label text from '{current_label_text[:50]}...' to '{annotation_text[:50]}...'")
                    label.setText(annotation_text)
                    
                    # **CLEAR CACHE**: Invalidate cached data since text changed
                    list_widget.clearItemCache(annotation_id)
            
            # Update notes field
            notes_edit = item_widget.findChild(QLineEdit)
            if notes_edit:
                notes_edit.setText(annotation.get('notes', ''))
                print(f"DEBUG: Updated notes field to: '{annotation.get('notes', '')}'")
        
            # Update notes_html property
            item_widget.setProperty('notes_html', annotation.get('notes_html', ''))
            item_widget.setProperty('notes', annotation.get('notes', ''))
        
            # Update notes button icon
            edit_notes_btn = item_widget.findChild(QPushButton, "editNotesButton")
            if edit_notes_btn:
                # Check if notes are empty (similar to the add_item_with_checkbox method)
                def is_notes_empty(notes_html_str):
                    if not notes_html_str:
                        return True
                    doc = QTextDocument()
                    doc.setHtml(notes_html_str)
                    return doc.toPlainText().strip() == ""
                
                notes_html = annotation.get('notes_html', '')
                if notes_html and not is_notes_empty(notes_html):
                    edit_notes_btn.setIcon(list_widget._cached_icons['notes']['active'])
                    print(f"DEBUG: Set notes icon to active (notes exist)")
                else:
                    edit_notes_btn.setIcon(list_widget._cached_icons['notes']['normal'])
                    print(f"DEBUG: Set notes icon to normal (notes empty)")
            
            # **MISSING PIECE**: Update tags widget with current tag data
            annotation_tags = annotation.get('tags', [])
            print(f"DEBUG: Updating tags display with current tags: {annotation_tags}")
            
            # Find and update the tags widget - it's a QLabel in the top-right
            for child in item_widget.findChildren(QLabel):
                child_text = child.text()
                # Tags widget has specific styling and content pattern
                if (hasattr(child, 'cursor') and child.cursor().shape() == Qt.CursorShape.PointingHandCursor and
                    (child_text.startswith('#') or child_text == "add tags" or ', #' in child_text)):
                    # This is the tags widget - update it
                    if annotation_tags:
                        tags_text = ", ".join([f"#{tag}" for tag in annotation_tags])
                        child.setText(tags_text)
                        child.setProperty('original_tags_text', tags_text)  # CRITICAL: Update cached property
                        child.setToolTip(f"Tags: {tags_text}")
                        print(f"DEBUG: Updated tags widget to: {tags_text}")
                    else:
                        child.setText("add tags")
                        child.setProperty('original_tags_text', "add tags")  # CRITICAL: Update cached property
                        child.setToolTip("Click to add tags")
                        print(f"DEBUG: Updated tags widget to 'add tags' (no tags)")
                    break
            else:
                print(f"DEBUG: Could not find tags widget to update")

            # **SECONDARY SCENES UPDATE**: Update secondary_scenes data and display
            annotation_secondary_scenes = annotation.get('secondary_scenes', [])
            print(f"DEBUG: Updating secondary_scenes with current data: {annotation_secondary_scenes}")
            
            # Update cached secondary_scenes property on the widget
            item_widget.setProperty('secondary_scenes', annotation_secondary_scenes)
            
            # **REBUILD SECONDARY SCENES CHIPS**: Remove existing secondary row and rebuild
            try:
                # First, remove any existing secondary scenes row
                for child in item_widget.findChildren(QWidget):
                    if child.property('is_secondary_row'):
                        print(f"DEBUG: Removing existing secondary scenes row for {annotation_id}")
                        child.setParent(None)  # This removes the widget from the layout
                        child.deleteLater()
                        break
                
                # Now rebuild the secondary scenes row with current data
                print(f"DEBUG: Rebuilding secondary scenes row for {annotation_id}")
                if hasattr(list_widget, '_build_secondary_row_for_item'):
                    built = list_widget._build_secondary_row_for_item(item_widget, annotation_id, force_recalc=True)
                    if built:
                        print(f"DEBUG: Successfully rebuilt secondary scenes row for {annotation_id}")
                    else:
                        print(f"DEBUG: Failed to rebuild secondary scenes row for {annotation_id}")
                else:
                    print(f"DEBUG: _build_secondary_row_for_item method not available on list_widget")
                    
            except Exception as sec_e:
                print(f"DEBUG: Error rebuilding secondary scenes row: {sec_e}")
                import traceback
                print(f"DEBUG: Traceback: {traceback.format_exc()}")
            
            # Update any cached data that might be used for filtering or display
            if annotation_secondary_scenes:
                print(f"DEBUG: Annotation {annotation_id} has {len(annotation_secondary_scenes)} secondary scenes: {annotation_secondary_scenes}")
                if hasattr(item_widget, 'cached_secondary_scenes'):
                    item_widget.cached_secondary_scenes = annotation_secondary_scenes
                    print(f"DEBUG: Updated cached_secondary_scenes property")
            else:
                print(f"DEBUG: Annotation {annotation_id} has no secondary scenes")
                if hasattr(item_widget, 'cached_secondary_scenes'):
                    item_widget.cached_secondary_scenes = []
        
            # Refresh item size to accommodate potential changes
            # Force full calculation since this is a data update
            list_widget.updateItemSize(found_item, item_widget, force_full_calculation=True)
            print(f"DEBUG: Successfully refreshed annotation {annotation_id} in theme view")
        
        except Exception as e:
            print(f"DEBUG: Error updating annotation widget: {str(e)}")
            import traceback
            print(f"DEBUG: Traceback: {traceback.format_exc()}")


    def handle_navigate_to_annotation(self, annotation_id, scene_name):
        """Handles request to navigate to a specific annotation in the theme view."""
        print(f"Python Handling: Navigate to Annotation ID: {annotation_id}, Scene: {scene_name}")
    
        # 1. Find the correct scene from the data structure (ignore the scene_name parameter)
        correct_scene = None
    
        # Access annotations directly from web_view
        if hasattr(self, 'web_view') and hasattr(self.web_view, 'annotations'):
            for anno in self.web_view.annotations:
                if anno.get('id') == annotation_id:
                    correct_scene = anno.get('scene')
                    print(f"Found annotation in web_view.annotations with scene: '{correct_scene}'")
                    break
    
        if not correct_scene:
            print(f"Warning: Couldn't find annotation {annotation_id} in web_view.annotations")
            correct_scene = scene_name  # Fall back to provided scene name
    
        # 2. Ensure theme view is visible
        print(f"Navigating to scene: '{correct_scene}'")
        theme_view_needs_creation = False
        
        if hasattr(self, 'view_annotations_button') and not self.view_annotations_button.isChecked():
            self.view_annotations_button.setChecked(True)
            self.toggle_theme_view()  # Ensure theme view is toggled open
            theme_view_needs_creation = True
        else:
            self._ensure_theme_view_visible()
        
        # Check if theme view is updating/being created or if scene tabs don't exist yet
        needs_waiting = (theme_view_needs_creation or 
                        (hasattr(self, '_updating_theme_view') and self._updating_theme_view) or
                        not hasattr(self, 'scene_tabs') or 
                        self.scene_tabs.count() == 0)
        
        if needs_waiting:
            print("Theme view is being created/updated or not ready, using smart waiting...")
            self._wait_for_theme_view_and_navigate(annotation_id, correct_scene)
            return
    
        # 3. Proceed with immediate navigation if theme view is ready
        self._navigate_to_annotation_in_theme_view(annotation_id, correct_scene)

    def _find_annotation_scene_in_data(self, annotation_id):
        """Finds the annotation with the given ID in the data structure and returns its scene."""
        # Try to find the annotation in the annotations data
        if hasattr(self, 'annotations'):
            print("Looking for annotation in self.annotations")
            for annotation in self.annotations:
                if isinstance(annotation, dict) and 'id' in annotation:
                    if self._annotation_id_matches(annotation['id'], annotation_id):
                        return annotation.get('scene')
    
        # Try alternate data structures if available
        data_attributes = ['annotations_data', 'data', 'annotation_data', 'theme_data']
        for attr in data_attributes:
            if hasattr(self, attr):
                data = getattr(self, attr)
                print(f"Looking for annotation in self.{attr}")
            
                if isinstance(data, list):
                    for item in data:
                        if isinstance(item, dict) and 'id' in item:
                            if self._annotation_id_matches(item['id'], annotation_id):
                                return item.get('scene')
    
        # If we still haven't found it, search in any attribute that might contain annotations
        for attr_name in dir(self):
            if attr_name.startswith('_') or attr_name in ['parent', 'children']:
                continue  # Skip private attributes and common non-data attributes
            
            try:
                attr = getattr(self, attr_name)
                if isinstance(attr, list) and len(attr) > 0 and isinstance(attr[0], dict):
                    for item in attr:
                        if 'id' in item and 'scene' in item:
                            if self._annotation_id_matches(item['id'], annotation_id):
                                print(f"Found annotation in self.{attr_name}")
                                return item.get('scene')
            except:
                pass  # Ignore any errors accessing attributes
    
        print("Could not find annotation in any data structure")
        return None

    def _annotation_id_matches(self, stored_id, search_id):
        """Compares annotation IDs, handling potential truncation or format differences."""
        # Convert both to strings and strip any whitespace
        stored_id_str = str(stored_id).strip()
        search_id_str = str(search_id).strip()
    
        # Check for exact match first
        if stored_id_str == search_id_str:
            return True
    
        # Check if one is a substring of the other (for truncated IDs)
        if search_id_str in stored_id_str or stored_id_str in search_id_str:
            return True
    
        # Check if they match when hyphens are removed (for format differences)
        stored_id_nohyphens = stored_id_str.replace('-', '')
        search_id_nohyphens = search_id_str.replace('-', '')
    
        if stored_id_nohyphens == search_id_nohyphens:
            return True
    
        if search_id_nohyphens in stored_id_nohyphens or stored_id_nohyphens in search_id_nohyphens:
            return True
    
        return False

    def _ensure_theme_view_visible(self):
        """Helper method to make sure the theme view is visible"""
        # Show the theme view and its container
        self.theme_view.show()
        self.right_panel_container.show()
    
        # Update theme view to populate annotations if this is the first time showing it
        if not getattr(self, '_theme_view_was_shown', False):
            self._theme_view_was_shown = True
            self.update_theme_view()
        
            # Update styles after content is populated
            if hasattr(self, 'scene_tabs') and hasattr(self, 'web_view'):
                self.scene_tabs.update_scene_styles(self.web_view.scene_styles)
    
        # Adjust layout based on visibility of other panels
        self._update_panel_layout()
    
        # Give Qt a chance to process the layout changes
        QApplication.processEvents()

    def _wait_for_theme_view_and_navigate(self, annotation_id, scene_name):
        """Wait for theme view update to complete, then navigate to annotation"""
        print(f"Waiting for theme view to complete before navigating to {annotation_id}")
        
        timer_active = [True]  # Use list to allow modification in nested functions
        timer = [None]  # Use list to store timer reference for access in nested functions
        
        def check_theme_view_ready():
            # Check if theme view update is complete
            updating = getattr(self, '_updating_theme_view', False)
            
            print(f"Theme view update check: _updating_theme_view={updating}")
            
            # Theme view is ready when update flag is False AND UI elements exist
            if not updating:
                # Additional checks for UI readiness
                if not hasattr(self, 'scene_tabs'):
                    print("scene_tabs not available yet")
                    return False
                    
                if self.scene_tabs.count() == 0:
                    print("scene_tabs has no tabs yet")
                    return False
                    
                # Check if the target scene tab exists
                scene_tab_found = False
                for i in range(self.scene_tabs.count()):
                    tab_text = self.scene_tabs.tabText(i)
                    if tab_text == scene_name or tab_text.lower() == scene_name.lower():
                        scene_tab_found = True
                        # Check if the tab widget is properly initialized
                        tab_widget = self.scene_tabs.widget(i)
                        if tab_widget is None:
                            print(f"Tab widget for '{tab_text}' not initialized yet")
                            return False
                            
                        # Check if it's an AnnotationListWidget and has content
                        if hasattr(tab_widget, 'count'):
                            item_count = tab_widget.count()
                            print(f"Tab widget for '{tab_text}' has {item_count} items")
                            # Don't require items - empty scenes are valid
                        
                        print(f"Target scene tab '{tab_text}' found and initialized")
                        break
                
                if not scene_tab_found:
                    print(f"Target scene tab '{scene_name}' not found yet")
                    return False
                
                print("Theme view detected as ready with all UI elements, executing navigation...")
                # Give UI a moment to fully render before navigation
                if timer_active[0] and timer[0]:
                    timer_active[0] = False
                    timer[0].stop()
                    timer[0].deleteLater()
                # Small delay to ensure UI is fully rendered
                QTimer.singleShot(200, lambda: self._navigate_to_annotation_in_theme_view(annotation_id, scene_name))
                return True
            return False
        
        # Check immediately first
        if check_theme_view_ready():
            return
            
        # If not ready, set up a timer to check periodically
        print("Theme view still updating, setting up smart waiting...")
        timer[0] = QTimer()
        timer[0].timeout.connect(check_theme_view_ready)
        timer[0].start(100)  # Check every 100ms
        
        # Safety timeout after 10 seconds
        def timeout_fallback():
            if timer_active[0] and timer[0]:
                timer_active[0] = False
                timer[0].stop()
                timer[0].deleteLater()
                print("Theme view navigation timeout reached, falling back to immediate navigation")
                self._navigate_to_annotation_in_theme_view(annotation_id, scene_name)
        
        QTimer.singleShot(10000, timeout_fallback)


    def _navigate_to_annotation_in_theme_view(self, annotation_id, scene_name):
        """Navigate to annotation in theme view (extracted from original logic)"""
        print(f"Executing theme view navigation to annotation {annotation_id} in scene '{scene_name}'")
        
        # Find the exact tab matching the scene name
        tab_index = -1
        for i in range(self.scene_tabs.count()):
            tab_text = self.scene_tabs.tabText(i)
            print(f"Tab {i}: '{tab_text}'")
            if tab_text == scene_name:
                tab_index = i
                print(f"Found exact match for tab '{scene_name}' at index {i}")
                break
    
        # If no exact match, try case-insensitive matches
        if tab_index == -1:
            print(f"No exact tab match for '{scene_name}', trying case-insensitive match")
            for i in range(self.scene_tabs.count()):
                tab_text = self.scene_tabs.tabText(i)
                if tab_text.lower() == scene_name.lower():
                    tab_index = i
                    print(f"Found case-insensitive match: tab '{tab_text}' at index {i}")
                    break
    
        # Switch to the tab and use existing function to find and select item
        if tab_index != -1:
            if self.scene_tabs.currentIndex() != tab_index:
                print(f"Switching to tab index {tab_index}: '{self.scene_tabs.tabText(tab_index)}'")
                self.scene_tabs.setCurrentIndex(tab_index)
            else:
                print(f"Already on correct tab index {tab_index}: '{self.scene_tabs.tabText(tab_index)}'")
        
            # Allow UI to update before trying to find and select the item
            QCoreApplication.processEvents()
        
            # Use the existing _find_and_select_annotation_item method
            QTimer.singleShot(100, lambda: self._find_and_select_annotation_item(
                tab_index, 
                annotation_id, 
                self.scene_tabs.tabText(tab_index)
            ))
        else:
            print(f"Error: Could not find a tab matching scene '{scene_name}'")
            QMessageBox.warning(self, "Navigation Failed", 
                               f"Could not find a tab matching scene '{scene_name}' for the selected annotation.\n\n Do you have filters set in the Theme Panel?")

    def _update_panel_layout(self):
        """Update layout stretch factors based on panel visibility"""
        if not hasattr(self, 'right_panel_container'):
            return
        
        bookmark_visible = hasattr(self, 'bookmark_panel') and self.bookmark_panel.isVisible()
        color_key_visible = hasattr(self, 'color_key_panel') and self.color_key_panel.isVisible()
    
        # Theme view is always visible here
        if bookmark_visible and color_key_visible:
            self.right_panel_container.layout().setStretchFactor(self.theme_view, 4)
            self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 4)
            self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 2)
        elif bookmark_visible:
            self.right_panel_container.layout().setStretchFactor(self.theme_view, 6)
            self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 4)
            if hasattr(self, 'color_key_panel'):
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 0)
        elif color_key_visible:
            self.right_panel_container.layout().setStretchFactor(self.theme_view, 6)
            if hasattr(self, 'bookmark_panel'):
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 0)
            self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 4)
        else:
            self.right_panel_container.layout().setStretchFactor(self.theme_view, 10)
            if hasattr(self, 'bookmark_panel'):
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 0)
            if hasattr(self, 'color_key_panel'):
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 0)

    def _find_and_select_annotation_item(self, tab_index, annotation_id, scene_name):
        """Helper function to find, scroll to, and select the item."""
        widget = self.scene_tabs.widget(tab_index)
        if isinstance(widget, AnnotationListWidget):
            list_widget = widget
            found_item = None
            for i in range(list_widget.count()):
                item = list_widget.item(i)
                item_anno_id = item.data(Qt.ItemDataRole.UserRole)
                if item_anno_id == annotation_id:
                    found_item = item
                    print(f"Found item for annotation ID {annotation_id} at row {i}") # Debug
                    break

            if found_item:
                # Ensure item is visible and selected
                list_widget.scrollToItem(found_item, QAbstractItemView.ScrollHint.PositionAtCenter)
                # Ensure selection is visually updated
                self.clear_all_tab_selections() # Clear previous selections across ALL tabs first
                list_widget.setCurrentItem(found_item) # Makes it the active item visually
                found_item.setSelected(True) # Explicitly set selected state
                print(f"Scrolled to and selected item for annotation ID {annotation_id}") # Debug
            else:
                print(f"Warning: Item with annotation ID '{annotation_id}' not found in list widget for scene '{scene_name}'.")
                # Optional: Add user feedback if item not found after switching tab
                # QMessageBox.warning(self, "Navigation Warning", f"Selected annotation not found in scene '{scene_name}'. \n\n Do you have filters set in the Theme Panel?")
        else:
            print(f"Warning: Widget at tab index {tab_index} is not an AnnotationListWidget.")

    def handle_storyboard_navigation(self, annotation_id):
        """Handles request to navigate to a specific annotation in the storyboard."""
        print(f"DEBUG: handle_storyboard_navigation called with annotation_id: {annotation_id}")
        print(f"Python Handling: Navigate to Annotation ID: {annotation_id} in storyboard")
        
        # CHECK IF ANNOTATION EXISTS IN STORYBOARD FIRST
        annotation_exists_in_storyboard = False
        if hasattr(self, 'web_view') and hasattr(self.web_view, 'annotations'):
            for annotation in self.web_view.annotations:
                if annotation.get('id') == annotation_id:
                    has_order = 'order' in annotation and annotation.get('order') is not None
                    annotation_exists_in_storyboard = has_order
                    print(f"DEBUG: Found annotation {annotation_id} - in storyboard: {has_order} (order: {annotation.get('order', 'None')})")
                    break
        
        if not annotation_exists_in_storyboard:
            print(f"DEBUG: Annotation {annotation_id} not found in storyboard - BLOCKING navigation")
            QMessageBox.information(self, "Navigation Blocked", 
                                  f"Annotation not found in Script Editor")
            return
        
        print(f"DEBUG: Annotation {annotation_id} exists in storyboard - proceeding with navigation")
        
        try:
            storyboard_was_created = False
            
            # Check if storyboard dialog exists and is available
            if not hasattr(self, 'storyboard_dialog') or not self.storyboard_dialog:
                print("Storyboard dialog not found, creating new one...")
                storyboard_was_created = True
                # Use the existing toggle method to create and show storyboard
                self.toggle_storyboard_panel()
                
            # Ensure storyboard dialog is visible
            if hasattr(self, 'storyboard_dialog') and self.storyboard_dialog:
                # Check if it's in collapsed (floating widget) mode
                if self.storyboard_dialog.is_collapsed():
                    print("[DEBUG] Storyboard is in floating widget mode, expanding for navigation")
                    self.storyboard_dialog.expand_from_widget()
                # Show the dialog if it's hidden or minimized
                elif self.storyboard_dialog.isMinimized():
                    self.storyboard_dialog.showNormal()
                elif not self.storyboard_dialog.isVisible():
                    self.storyboard_dialog.show()
                
                # Bring it to front (only if not collapsed, since expand_from_widget handles this)
                if not self.storyboard_dialog.is_collapsed():
                    self.storyboard_dialog.raise_()
                    self.storyboard_dialog.activateWindow()
                
                # Smart waiting: check if we need to wait for population to complete
                if storyboard_was_created:
                    print("Storyboard was just created, waiting for population to complete...")
                    self._wait_for_population_and_navigate(annotation_id)
                else:
                    print("Using immediate navigation for existing storyboard")
                    # Immediate navigation for existing storyboard
                    if hasattr(self.storyboard_dialog, 'navigate_to_annotation'):
                        self.storyboard_dialog.navigate_to_annotation(annotation_id)
                    elif hasattr(self.storyboard_dialog, 'order_list'):
                        # Fallback: use order_list directly to find and scroll to annotation
                        self._navigate_to_annotation_in_storyboard(annotation_id)
                    else:
                        print("Storyboard dialog doesn't have navigate_to_annotation method or order_list")
                    
        except Exception as e:
            print(f"Error navigating to storyboard annotation: {e}")
            QMessageBox.warning(self, "Navigation Error", 
                              f"Could not navigate to annotation in storyboard: {str(e)}")

    def _wait_for_population_and_navigate(self, annotation_id):
        """Wait for storyboard population to complete, then navigate to annotation"""
        if not hasattr(self, 'storyboard_dialog') or not self.storyboard_dialog:
            print("No storyboard dialog available for smart navigation")
            return
            
        timer_active = [True]  # Use list to allow modification in nested functions
        
        def check_population_complete():
            # Check if population flags indicate completion
            population_in_progress = getattr(self.storyboard_dialog, '_population_in_progress', False)
            in_population = getattr(self.storyboard_dialog, '_in_population', False)
            
            print(f"Population check: _population_in_progress={population_in_progress}, _in_population={in_population}")
            
            # Population is complete when both flags are False
            if not population_in_progress and not in_population:
                print("Population detected as complete, executing navigation...")
                self._navigate_to_annotation_in_storyboard(annotation_id)
                if timer_active[0]:
                    timer_active[0] = False
                    timer.stop()
                    timer.deleteLater()
                return True
            return False
        
        # Check immediately first
        if check_population_complete():
            return
            
        # If not ready, set up a timer to check periodically
        print("Population still in progress, setting up smart waiting...")
        timer = QTimer()
        timer.timeout.connect(check_population_complete)
        timer.start(100)  # Check every 100ms instead of blind 2000ms delay
        
        # Safety timeout after 10 seconds
        def timeout_fallback():
            if timer_active[0]:
                timer_active[0] = False
                timer.stop()
                timer.deleteLater()
                print("Smart navigation timeout reached, falling back to immediate navigation")
                self._navigate_to_annotation_in_storyboard(annotation_id)
        
        QTimer.singleShot(10000, timeout_fallback)

    def _navigate_to_annotation_in_storyboard(self, annotation_id, retry_count=0, max_retries=3):
        """Navigate to a specific annotation in the storyboard order list with retry mechanism"""
        try:
            if not hasattr(self, 'storyboard_dialog') or not self.storyboard_dialog:
                print(f"No storyboard dialog available for navigation to {annotation_id}")
                return
                
            print(f"DEBUG: Checking storyboard_dialog attributes...")
            print(f"DEBUG: storyboard_dialog type: {type(self.storyboard_dialog)}")
            print(f"DEBUG: storyboard_dialog has order_list: {hasattr(self.storyboard_dialog, 'order_list')}")
            
            if hasattr(self.storyboard_dialog, 'order_list'):
                order_list = self.storyboard_dialog.order_list
                print(f"DEBUG: order_list value: {order_list}")
                print(f"DEBUG: order_list type: {type(order_list)}")
            else:
                order_list = None
                
            if not order_list:
                print(f"No order_list available in storyboard dialog for navigation to {annotation_id}")
                return
            
            print(f"Searching for annotation {annotation_id} in storyboard order list (attempt {retry_count + 1}/{max_retries + 1})...")
            print(f"Order list currently has {order_list.count()} items")
            
            # Find the item with matching annotation ID
            target_item = None
            for i in range(order_list.count()):
                item = order_list.item(i)
                if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                    target_item = item
                    print(f"Found annotation {annotation_id} at index {i} in storyboard")
                    break
            
            if target_item:
                # Clear current selection
                order_list.clearSelection()
                
                # Select and scroll to the target item
                order_list.setCurrentItem(target_item)
                target_item.setSelected(True)
                
                # Scroll to make the item visible (center it in view)
                order_list.scrollToItem(target_item, QAbstractItemView.ScrollHint.PositionAtCenter)
                
                print(f"Successfully navigated to annotation {annotation_id} in storyboard")
                
                # Optional: Also trigger the scroll_to_annotation method if it exists
                if hasattr(order_list, 'scroll_to_annotation'):
                    try:
                        order_list.scroll_to_annotation(target_item)
                        print(f"Also triggered scroll_to_annotation for {annotation_id}")
                    except Exception as e:
                        print(f"Error calling scroll_to_annotation: {e}")
            else:
                # If not found and we have retries left, try again
                if retry_count < max_retries:
                    print(f"Annotation {annotation_id} not found, retrying in 1 second... (attempt {retry_count + 1}/{max_retries + 1})")
                    QTimer.singleShot(1000, lambda: self._navigate_to_annotation_in_storyboard(annotation_id, retry_count + 1, max_retries))
                else:
                    print(f"DEBUG: Annotation {annotation_id} not found in storyboard order list after {max_retries + 1} attempts")
                    print(f"DEBUG: Showing popup for annotation not found")
                    QMessageBox.information(self, "Navigation Info", 
                                          f"Annotation not found in the current storyboard order after waiting for population to complete.")
                
        except Exception as e:
            print(f"Error navigating to annotation {annotation_id} in storyboard: {e}")
            import traceback
            traceback.print_exc()

    def add_import_tools_button_to_scriptoria(self):
        """
        Add a combined Import Tools button to the Create Transcript tab.
        This function should be called from ScriptoriaMain.__init__
        """
        # Import required modules
        import sys
        import os
        import importlib.util

        # CRITICAL: For PyInstaller bundled app, we need to prioritize the directory
        # next to the executable, NOT the temp extraction directory
        if getattr(sys, 'frozen', False):
            # When running as bundled executable, prioritize the directory next to the .exe
            base_path = os.path.dirname(sys.executable)
        else:
            # When running as a script
            base_path = os.path.dirname(os.path.abspath(__file__))

        # Define the Data directory path and module paths for imports
        data_dir = os.path.join(base_path, 'Data')
        pdf_module_path = os.path.join(data_dir, 'pdf_import_module.pyw')
        epub_module_path = os.path.join(data_dir, 'epub-import-module.pyw')  # Note the hyphen, not underscore

        # Print path info (for debugging)
        print(f"Base path: {base_path}")
        print(f"Data dir: {data_dir}")
        print(f"PDF Module path: {pdf_module_path}")
        print(f"PDF Module exists: {os.path.exists(pdf_module_path)}")
        print(f"EPUB Module path: {epub_module_path}")
        print(f"EPUB Module exists: {os.path.exists(epub_module_path)}")

        # IMPORTANT: Add Data directory to system path BEFORE trying to import
        if data_dir not in sys.path:
            sys.path.insert(0, data_dir)  # Add at beginning to prioritize

        # Also add the base path to ensure all standard libraries can be found
        if base_path not in sys.path:
            sys.path.insert(0, base_path)

        # Print current system path for debugging
        print(f"Current sys.path: {sys.path}")

        # Try to import the PDF module
        try:
            if os.path.exists(pdf_module_path):
                # Use direct path import
                print(f"Attempting to load PDF module from: {pdf_module_path}")
                spec = importlib.util.spec_from_file_location("pdf_import_module", pdf_module_path)
                pdf_import_module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(pdf_import_module)
        
                # Check if the module has the required class
                if hasattr(pdf_import_module, 'PDFImportDialog'):
                    self.PDFImportDialog = pdf_import_module.PDFImportDialog
                    print("Successfully loaded PDFImportDialog class")
                else:
                    raise AttributeError("Module does not contain PDFImportDialog class")
            else:
                print(f"PDF Import module not found at {pdf_module_path}")
                self.PDFImportDialog = None
        except Exception as e:
            print(f"Error loading PDFImportDialog: {str(e)}")
            self.PDFImportDialog = None
            
        # Try to import the EPUB module
        try:
            if os.path.exists(epub_module_path):
                # Use direct path import
                print(f"Attempting to load EPUB module from: {epub_module_path}")
                spec = importlib.util.spec_from_file_location("epub_import_module", epub_module_path)
                epub_import_module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(epub_import_module)
        
                # Check if the module has the required class
                if hasattr(epub_import_module, 'EPubImportDialog'):
                    self.EPubImportDialog = epub_import_module.EPubImportDialog
                    print("Successfully loaded EPubImportDialog class")
                else:
                    raise AttributeError("Module does not contain EPubImportDialog class")
            else:
                raise ImportError(f"Module file not found at {epub_module_path}")
        except ImportError as e:
            print(f"Error importing EPUB module: {e}")
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.warning(
                self, 
                "EPUB Import Not Available",
                f"The EPUB Import Module was not found at {epub_module_path}\n\n"
                "Please ensure the file 'epub-import-module.pyw' exists in the Data folder."
            )
            self.EPubImportDialog = None
        except Exception as e:
            print(f"Error loading EPubImportDialog: {str(e)}")
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.warning(
                self, 
                "EPUB Import Error",
                f"Error loading the EPUB Import Module: {str(e)}\n\n"
                "Please check that all required libraries are installed."
            )
            self.EPubImportDialog = None

        # Find the input tab's toolbar section where the other buttons are
        if hasattr(self, 'input_widget'):
            # Look for the auto_wrap_button as reference for placement
            if hasattr(self, 'auto_wrap_button'):
                # Create the Import Tools button
                from PyQt6.QtWidgets import QPushButton
                from PyQt6.QtCore import Qt
                # Get button style from an existing button
                transcriber_button_style = self.auto_wrap_button.styleSheet()
    
                self.import_tools_button = QPushButton("File Import Tools")
                self.import_tools_button.setStyleSheet(transcriber_button_style)
                self.import_tools_button.setCursor(Qt.CursorShape.PointingHandCursor)
    
                # Find the parent layout where the transcriber buttons reside
                parent_layout = None
                if self.auto_wrap_button and self.auto_wrap_button.parent():
                    parent_layout = self.auto_wrap_button.parent().layout()
    
                if parent_layout:
                    # Add the Import Tools button to the layout next to the captions transcriber button
                    index = parent_layout.indexOf(self.auto_wrap_button)
                    parent_layout.insertWidget(index, self.import_tools_button)
    
                    # Connect the button signal to show the import format selection dialog
                    self.import_tools_button.clicked.connect(self.show_import_format_selection)

    def show_import_format_selection(self):
        """
        Show a dialog for selecting the import format (PDF or EPUB).
        """
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QPushButton, QLabel
        from PyQt6.QtCore import Qt

        # Create dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Select Import Format")
        dialog.setFixedSize(300, 150)
        
        # Create layout
        layout = QVBoxLayout()
        
        # Add instruction label
        label = QLabel("Select the format you want to import:")
        layout.addWidget(label)
        
        # Style buttons
        button_style = """
            QPushButton {
                background-color: #F5F5F5;
                color: #333333;
                border: 1px solid #CCCCCC;
                padding: 8px 10px;
                border-radius: 5px;
                font-size: 11px;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #E0E0E0;
            }
            QPushButton:pressed {
                background-color: #D6D6D6;
            }
        """
        
        # COMMENTED OUT: PDF import button - PDF importer is broken, may re-enable when fixed
        # pdf_button = QPushButton("PDF Document")
        # pdf_button.setStyleSheet(button_style)
        # pdf_button.setCursor(Qt.CursorShape.PointingHandCursor)
        # if self.PDFImportDialog is None:
        #     pdf_button.setEnabled(False)
        #     pdf_button.setToolTip("PDF Import module not available")
        # pdf_button.clicked.connect(lambda: self.handle_import_selection(dialog, "pdf"))
        # layout.addWidget(pdf_button)
        
        # Add EPUB import button
        epub_button = QPushButton("EPUB Document")
        epub_button.setStyleSheet(button_style)
        epub_button.setCursor(Qt.CursorShape.PointingHandCursor)
        if self.EPubImportDialog is None:
            epub_button.setEnabled(False)
            epub_button.setToolTip("EPUB Import module not available")
        epub_button.clicked.connect(lambda: self.handle_import_selection(dialog, "epub"))
        layout.addWidget(epub_button)
        
        # # Add cancel button
        # cancel_button = QPushButton("Cancel")
        # cancel_button.setStyleSheet(button_style)
        # cancel_button.setCursor(Qt.CursorShape.PointingHandCursor)
        # cancel_button.clicked.connect(dialog.reject)
        # layout.addWidget(cancel_button)
        
        # Set dialog layout
        dialog.setLayout(layout)
        
        # Show dialog
        dialog.exec()

    def handle_import_selection(self, dialog, format_type):
        """
        Handle the import format selection and show the appropriate dialog.
        
        Args:
            dialog: The format selection dialog to close
            format_type: The selected format type ("pdf" or "epub")
        """
        # Close the selection dialog
        dialog.accept()
        
        # Show the appropriate import dialog
        if format_type == "pdf":
            self.show_pdf_import_dialog()
        elif format_type == "epub":
            self.show_epub_import_dialog()

    def show_pdf_import_dialog(self):
        """
        Show the PDF Import Dialog when the PDF Import button is clicked.
        """
        try:
            # Create and show the dialog
            dialog = self.PDFImportDialog(self)
            # Configure it as non-modal
            dialog.setModal(False)
            dialog.show()
        except Exception as e:
            from PyQt6.QtWidgets import QMessageBox
            print(f"Error showing PDF Import Dialog: {str(e)}")
            QMessageBox.critical(
                self,
                "PDF Import Error",
                f"Failed to open PDF Import Dialog: {str(e)}"
            )

    def show_epub_import_dialog(self):
        """
        Show the EPUB Import Dialog when the button is clicked.
        """
        try:
            # Create the dialog
            dialog = self.EPubImportDialog(self)
        
            # Configure it as non-modal
            dialog.setModal(False)
        
            # Show the dialog using show() instead of exec()
            dialog.show()
        except Exception as e:
            from PyQt6.QtWidgets import QMessageBox
            print(f"Error showing EPUB Import Dialog: {str(e)}")
            QMessageBox.critical(
                self,
                "EPUB Import Error",
                f"Failed to open EPUB Import Dialog: {str(e)}"
            )


    def ensure_storyboard_dialog_hidden(self):
        """Create or retrieve the storyboard dialog without ever showing it."""
        if not hasattr(self, 'storyboard_dialog') or not self.storyboard_dialog:
            # Create the dialog
            self.storyboard_dialog = StoryboardDialog(self)
            self.storyboard_dialog.closed.connect(self.on_storyboard_dialog_closed)
        
            # Hide it before populating to minimize visual effects
            self.storyboard_dialog.hide()
        
            # Critical: populate the order list to ensure proper initialization
            #self.storyboard_dialog.populate_order_list()
        
            # Clean up any overlay that might have been created during population
            if hasattr(self.storyboard_dialog, '_cleanup_existing_overlay'):
                self.storyboard_dialog._cleanup_existing_overlay(process_events=False)
        else:
            # If it exists but is showing, hide it
            self.storyboard_dialog.hide()


    def add_chronological_sort_button_to_search(self):
        """Add chronological sort button to the search toolbar if it doesn't exist."""
        if hasattr(self, 'script_search') and not hasattr(self.script_search, 'sort_btn'):
            self.script_search.add_sort_chronologically_button()

    def on_checkbox_toggled(self, is_checked: bool):
        """Called whenever the user toggles the .speech-checkbox in HTML."""
        print(f"Checkbox toggled -> is_checked={is_checked}")
        self.changes_pending = True
        if not self.windowTitle().startswith('*'):
            self.setWindowTitle('*' + self.windowTitle())

    def handle_bookmark_toggle(self, is_bookmarked: bool):
        """Handle bookmark toggle changes."""
        print(f"Bookmark toggled: {is_bookmarked}")
        self.changes_pending = True
        if not self.windowTitle().startswith('*'):
            self.setWindowTitle('*' + self.windowTitle())

    def mark_changes_pending(self):
        """
        Called to mark a change as pending
        """
        self.changes_pending = True

        # Add asterisk to the window title if not already present
        if not self.windowTitle().startswith('*'):
            self.setWindowTitle('*' + self.windowTitle())

    def show_tag_dialog(self):
        """Show the tag list dialog"""
        dialog = TagListDialog(self, self.tags)
        dialog.tagsChanged.connect(self.update_tags)
        dialog.show()
        dialog.raise_()
        dialog.activateWindow()

    def update_tags(self):
        """Update tags from dialog"""
        dialog = self.sender()
        if dialog:
            self.tags = dialog.get_tags()
            # Update sticky header tag filter with new tags
            if hasattr(self, 'web_view'):
                self.web_view.populate_dom_sticky_header_tags(self.tags)

    def moveEvent(self, event):
        if hasattr(self, 'storyboard_dialog') and self.storyboard_dialog:
            if not getattr(self.storyboard_dialog, 'is_manually_hidden', False):
                # Only raise if not in collapsed mode
                if not self.storyboard_dialog.is_collapsed():
                    self.storyboard_dialog.raise_()
                elif hasattr(self.storyboard_dialog, 'collapsible_widget') and self.storyboard_dialog.collapsible_widget:
                    # If collapsed, raise the floating widget instead
                    self.storyboard_dialog.collapsible_widget.raise_()
        super().moveEvent(event)  

    def smooth_remove_stays_on_top(self):
        """Smoothly remove WindowStaysOnTopHint flag"""
        flags = self.windowFlags() & ~Qt.WindowType.WindowStaysOnTopHint
        self.setWindowFlags(flags)
        self.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
        self.show()

    def setup_application_icon(self):
        """Set up the application icon."""
        print("Application icon setup complete.")
    
    def debug_tag_filtering(self, message):
        """Debug method for tag filtering"""
        print(f"[TAG FILTER DEBUG] {message}")
        return True

    def add_storyboard_button(self, bottom_layout):
        """Add storyboard button with toggle functionality"""
        self.storyboard_button = QPushButton()
    
        # Create normal and hover icons
        self.storyboard_normal_icon = QIcon("Img/Storyboard-Button.png")
        self.storyboard_hover_icon = QIcon("Img/Storyboard-Button-Hover.png")
    
        # Set initial icon
        self.storyboard_button.setIcon(self.storyboard_normal_icon)
        self.storyboard_button.setIconSize(QSize(130, 80))
        self.storyboard_button.setFixedSize(125, 55)
        self.storyboard_button.setCheckable(True)
    
        # Create event filter for hover effects
        class StoryboardButtonFilter(QObject):
            def __init__(self, button, normal_icon, hover_icon):
                super().__init__()
                self.button = button
                self.normal_icon = normal_icon
                self.hover_icon = hover_icon
        
            def eventFilter(self, obj, event):
                if obj == self.button:
                    if event.type() == QEvent.Type.Enter:
                        if not self.button.isChecked():  # Only change icon if not checked
                            self.button.setIcon(self.hover_icon)
                    elif event.type() == QEvent.Type.Leave:
                        if not self.button.isChecked():  # Only change icon if not checked
                            self.button.setIcon(self.normal_icon)
                return super().eventFilter(obj, event)
    
        # Install event filter
        self.storyboard_filter = StoryboardButtonFilter(
            self.storyboard_button, 
            self.storyboard_normal_icon, 
            self.storyboard_hover_icon
        )
        self.storyboard_button.installEventFilter(self.storyboard_filter)
    
        # Connect toggle handler
        def handle_toggle(checked):
            if checked:
                self.storyboard_button.setIcon(self.storyboard_hover_icon)
            else:
                self.storyboard_button.setIcon(self.storyboard_normal_icon)
    
        self.storyboard_button.toggled.connect(handle_toggle)
        self.storyboard_button.setStyleSheet("""
            QPushButton { 
                border: none; 
                background: transparent;
            }
        """)
        self.storyboard_button.setCursor(Qt.CursorShape.PointingHandCursor)  # Set pointing hand cursor
        self.storyboard_button.clicked.connect(self.toggle_storyboard_panel)
        bottom_layout.addWidget(self.storyboard_button)

        # Initialize storyboard dialog tracking
        self.storyboard_dialog = None

    def toggle_tag_dialog(self):
        """Toggle the tag list dialog with single instance logic"""
        if self.tag_dialog is None or not self.tag_dialog.isVisible():
            # Create or show dialog
            self.show_tag_dialog()
            self.tag_button.setChecked(True)
        else:
            # Dialog is open, close it
            self.tag_dialog.close()
            self.tag_button.setChecked(False)

    def on_tag_dialog_closed(self):
        """Handle tag dialog being closed"""
        self.tag_button.setChecked(False)
        
    def show_tag_dialog(self):
        """Show the tag dialog (modified to work with toggle logic)"""
        if self.tag_dialog is not None and self.tag_dialog.isVisible():
            # Dialog already open, just bring to front
            self.tag_dialog.raise_()
            self.tag_dialog.activateWindow()
            return
            
        # Get existing tags
        tags = self.tags if hasattr(self, 'tags') else []
        
        # Create new dialog
        self.tag_dialog = TagListDialog(self, tags)
        self.tag_dialog.tagsChanged.connect(self.update_tags)
        
        # Connect close signal to uncheck button
        self.tag_dialog.finished.connect(self.on_tag_dialog_closed)
        
        # Make it non-modal
        self.tag_dialog.setModal(False)
        self.tag_dialog.show()
        self.tag_dialog.raise_()
        self.tag_dialog.activateWindow()

    def add_storyboard_button_to_layout(self, layout):
        """Add storyboard button to specified layout"""
        if not hasattr(self, 'storyboard_button'):
            self.storyboard_button = QPushButton()
        
            # Create normal and hover icons
            self.storyboard_normal_icon = QIcon("Img/Storyboard-Button.png")
            self.storyboard_hover_icon = QIcon("Img/Storyboard-Button-Hover.png")
        
            # Set initial icon
            self.storyboard_button.setIcon(self.storyboard_normal_icon)
            self.storyboard_button.setIconSize(QSize(125, 55))  # Match other buttons
            self.storyboard_button.setFixedSize(125, 55)
            self.storyboard_button.setCheckable(True)
        
            # Create event filter for hover effects
            class StoryboardButtonFilter(QObject):
                def __init__(self, button, normal_icon, hover_icon):
                    super().__init__()
                    self.button = button
                    self.normal_icon = normal_icon
                    self.hover_icon = hover_icon
        
                def eventFilter(self, obj, event):
                    if obj == self.button:
                        if event.type() == QEvent.Type.Enter:
                            if not self.button.isChecked():
                                self.button.setIcon(self.hover_icon)
                        elif event.type() == QEvent.Type.Leave:
                            if not self.button.isChecked():
                                self.button.setIcon(self.normal_icon)
                    return super().eventFilter(obj, event)
        
            # Install event filter
            self.storyboard_filter = StoryboardButtonFilter(
                self.storyboard_button, 
                self.storyboard_normal_icon, 
                self.storyboard_hover_icon
            )
            self.storyboard_button.installEventFilter(self.storyboard_filter)
        
            # Connect toggle handler
            def handle_toggle(checked):
                if checked:
                    self.storyboard_button.setIcon(self.storyboard_hover_icon)
                else:
                    self.storyboard_button.setIcon(self.storyboard_normal_icon)
        
            self.storyboard_button.toggled.connect(handle_toggle)
            self.storyboard_button.setStyleSheet("QPushButton { border: none; background: transparent; }")
            self.storyboard_button.setCursor(Qt.CursorShape.PointingHandCursor)
            self.storyboard_button.clicked.connect(self.toggle_storyboard_panel)
            
            # Initialize storyboard dialog tracking
            self.storyboard_dialog = None
        
        layout.addWidget(self.storyboard_button)

    def toggle_storyboard_panel(self):
        """Toggle the storyboard panel visibility with proper state tracking."""
        if not hasattr(self, 'storyboard_dialog') or self.storyboard_dialog is None:
            print("[DEBUG] Creating new storyboard dialog")
            # Use delay_population parameter to prevent immediate population
            self.storyboard_dialog = StoryboardDialog(self, delay_population=True)
            self.storyboard_dialog.closed.connect(self.on_storyboard_dialog_closed)
            
            # Clean up any existing overlay before showing
            if hasattr(self.storyboard_dialog, '_cleanup_existing_overlay'):
                self.storyboard_dialog._cleanup_existing_overlay(process_events=False)
            self.storyboard_dialog.show()
            self.storyboard_dialog.raise_()
            self.storyboard_dialog.activateWindow()
            self.storyboard_button.setChecked(True)
        
            # Initialize both tracking flags
            self.storyboard_dialog.is_manually_hidden = False
            self.storyboard_dialog.is_manually_minimized = False
        
            # Schedule population after dialog is fully visible and laid out
    
        elif self.storyboard_dialog.isVisible() or self.storyboard_dialog.is_collapsed():
            print("[DEBUG] Hiding storyboard dialog")
            # Track that we manually hid it and reset minimize flag
            self.storyboard_dialog.is_manually_hidden = True
            self.storyboard_dialog.is_manually_minimized = False
            
            # Use the new hide_completely method to handle both states
            self.storyboard_dialog.hide_completely()
            
            self.storyboard_button.setChecked(False)
        else:
            print("[DEBUG] Showing storyboard dialog")
            # Reset both flags when manually showing
            self.storyboard_dialog.is_manually_hidden = False
            self.storyboard_dialog.is_manually_minimized = False
        
            # Reset any in-progress flags before repopulating
            if hasattr(self.storyboard_dialog, '_population_in_progress'):
                self.storyboard_dialog._population_in_progress = False
            if hasattr(self.storyboard_dialog, '_in_critical_ui_update'):
                self.storyboard_dialog._in_critical_ui_update = False
            if hasattr(self.storyboard_dialog.order_list, '_in_population'):
                self.storyboard_dialog.order_list._in_population = False
        
            # Then show the dialog
            
            self.storyboard_dialog.showNormal()
            self.storyboard_dialog.raise_()
            self.storyboard_dialog.activateWindow()
            self.storyboard_button.setChecked(True)
            self.storyboard_dialog.improve_strikethroughs_and_apply_changes()

    def on_storyboard_dialog_closed(self):
        """Handle storyboard dialog being closed"""
        self.storyboard_button.setChecked(False)
        self.storyboard_dialog = None  # Clear the reference when closed

    def setup_application_icon(self):
        """Set up the application icon safely"""
        icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Img', 'video_transcript_manager.ico')
        try:
            self.setWindowIcon(QIcon(icon_path))
            if os.name == 'nt':  # Windows
                import ctypes
                ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID('mycompany.transcriptmanager.app.1')
        except Exception as e:
            print(f"Could not load icon from {icon_path}: {str(e)}")

    def show_welcome_dialog(self):
        """Show the welcome dialog when everything is properly initialized"""
        # Load recent sessions
        recent_sessions = self.load_recent_sessions()

        # Check if a welcome dialog already exists and close it if it does
        if hasattr(self, 'welcome_dialog') and self.welcome_dialog:
            self.welcome_dialog.close()
            self.welcome_dialog.deleteLater()
            self.welcome_dialog = None

        # Create the welcome dialog (only once)
        self.welcome_dialog = WelcomeDialog(self, recent_sessions)

        # Show and activate the dialog
        self.welcome_dialog.show()
        self.welcome_dialog.raise_()
        self.welcome_dialog.activateWindow()

        # Handle dialog results
        result = self.welcome_dialog.exec()
        if result == QDialog.DialogCode.Accepted and self.welcome_dialog is not None:
            session_info = self.welcome_dialog.get_session_info()
            if session_info['type'] == 'new':
                # Handle new session using existing new_session logic
                self.current_session_file = session_info['data']['location']
                self.setWindowTitle(f'Scriptoria - {session_info["data"]["name"]}')
                self.clear_all()

                # Only save the session if a valid save location is provided
                if self.current_session_file:
                    self.save_session()

                # Switch to Process Captions tab
                for i in range(self.tabs.count()):
                    if self.tabs.tabText(i) == 'Process Captions':
                        self.tabs.setCurrentIndex(i)
                        break
            elif session_info['type'] == 'load':
                # Directly load the session file without confirmation dialogs or LoadRecentSessionDialog
                file_path = session_info['data']
                self.load_session(file_path=file_path, skip_confirmation=True, skip_recent_dialog=True)
    
        # Clean up the welcome dialog reference after it's closed
        self.welcome_dialog = None

    def _adjust_layout_for_dpi(self, layout, scale_factor):
        """Adjust layout spacing based on DPI scale factor"""
        # Only adjust if significant scaling is needed
        if abs(scale_factor - 1.0) > 0.1:
            base_spacing = 8  # Your base spacing value
            scaled_spacing = int(base_spacing * scale_factor)
            layout.setSpacing(scaled_spacing)
        
            # If it's a QVBoxLayout or QHBoxLayout
            if hasattr(layout, 'setContentsMargins'):
                base_margin = 10  # Your base margin
                scaled_margin = int(base_margin * scale_factor)
                layout.setContentsMargins(scaled_margin, scaled_margin, scaled_margin, scaled_margin)

    def setup_application_icon(self):
        """Set up the application icon safely with DPI awareness"""
        icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Img', 'video_transcript_manager.ico')
        try:
            # Get the device pixel ratio for the current screen
            pixel_ratio = self.devicePixelRatioF()
        
            # Load an appropriately sized icon based on the pixel ratio
            app_icon = QIcon(icon_path)
        
            # You can provide multiple sizes for different scaling factors
            if pixel_ratio > 1.5:
                # Optionally add a higher-resolution version if available
                hires_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Img', 'video_transcript_manager_hires.ico')
                if os.path.exists(hires_path):
                    app_icon = QIcon(hires_path)
        
            self.setWindowIcon(app_icon)
        
            if os.name == 'nt':  # Windows
                import ctypes
                ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID('mycompany.transcriptmanager.app.1')
        except Exception as e:
            print(f"Could not load icon from {icon_path}: {str(e)}")


    def handle_welcome_dialog_rejection(self):
        """Handle the welcome dialog being closed (rejected) without a selection."""
        if self.welcome_dialog:
            self.welcome_dialog.deleteLater()
            self.welcome_dialog = None

    def handle_welcome_dialog_close(self):
        self.welcome_dialog_shown = True
        self.welcome_dialog = None

    def check_dpi_changes(self):
        """Check and adjust for DPI changes in a more PyQt6-compatible way"""
        # Get current screen
        screen = self.screen()
        if not screen:
            return
        
        # Get current DPI
        current_dpi = screen.physicalDotsPerInch()
    
        # Store initial DPI if not already stored
        if not hasattr(self, '_initial_dpi'):
            self._initial_dpi = current_dpi
            self._initial_logical_dpi = screen.logicalDotsPerInch()
            print(f"[DEBUG] Initial DPI: Physical={self._initial_dpi}, Logical={self._initial_logical_dpi}")
            return
        
        # Check if DPI has changed
        if abs(current_dpi - self._initial_dpi) > 1.0:  # Allow small fluctuations
            scale_factor = current_dpi / 96.0  # Standard 96 DPI as reference
            print(f"[DEBUG] DPI changed: {self._initial_dpi} -> {current_dpi}, Scale factor: {scale_factor}")
        
            # Update stored DPI
            self._initial_dpi = current_dpi
        
            # Adjust UI elements
            self._adjust_ui_for_dpi_change(scale_factor)

    def _force_desired_size(self):
        """Ensure the window is the correct size after all UI components are created,
        but only if not maximized or minimized."""
        if self.isMaximized() or self.isMinimized():
            return  # Don't enforce size on maximized or minimized windows
        
        current_width = self.width()
        current_height = self.height()
    
        if hasattr(self, '_desired_width') and hasattr(self, '_desired_height'):
            desired_width = self._desired_width
            desired_height = self._desired_height
        
            print(f"[DEBUG] Final size check: current={current_width}x{current_height}, desired={desired_width}x{desired_height}")
        
            if abs(current_width - desired_width) > 5 or abs(current_height - desired_height) > 5:
                print(f"[DEBUG] Forcing final resize to {desired_width}x{desired_height}")
                self.programmatic_resize(desired_width, desired_height)
            
                # Also lock the size to prevent future unwanted resizes when unmaximizing
                self._desired_restore_size = QSize(desired_width, desired_height)

    def _check_size_enforcement(self):
        """Double-check that our size enforcement worked"""
        if not self.isMaximized() and not self.isMinimized() and hasattr(self, '_desired_width') and hasattr(self, '_desired_height'):
            current_width = self.width()
            current_height = self.height()
            desired_width = self._desired_width
            desired_height = self._desired_height
        
            # Only enforce if substantially different
            if abs(current_width - desired_width) > 5 or abs(current_height - desired_height) > 5:
                print(f"[DEBUG] Size enforcement check: current={current_width}x{current_height}, desired={desired_width}x{desired_height}")
                print(f"[DEBUG] Re-enforcing desired size")
                self.programmatic_resize(desired_width, desired_height)

    # helper ────────────────────────────────────────────────────────────────
    def _move_window_to_screen(self, tgt_screen: QScreen):
        """ShowNormal, move to target screen’s centre, then maximise next tick."""
        avail   = tgt_screen.availableGeometry()
        centre  = avail.center()
        self.showNormal()                                   # step 1
        self.windowHandle().setScreen(tgt_screen)           # step 2
        self.move(centre.x() - self.width() // 2,
                  centre.y() - self.height() // 2)

        # maximise after the move has landed
        QTimer.singleShot(0, self.showMaximized)            # step 3


    # ───────────────────── helpers ──────────────────────
    def _get_screen_by_name(self, name: str):
        """Return QScreen whose .name() matches, or None."""
        for s in QGuiApplication.screens():
            if s.name() == name:
                return s
        return None

    def _fit_geometry_to_screen(self, rect: QRect, screen: QScreen) -> QRect:
        """Clamp rect to the screen’s availableGeometry()."""
        avail = screen.availableGeometry()

        # Size clamp
        w = min(rect.width(),  avail.width())
        h = min(rect.height(), avail.height())

        # Position clamp (keep top‑left on‑screen, leave a 6‑px margin for safety)
        x = max(avail.x() + 6, min(rect.x(), avail.right()  - w))
        y = max(avail.y() + 6, min(rect.y(), avail.bottom() - h))

        return QRect(x, y, w, h)

    # ───────────────────── changeEvent ──────────────────────
    def changeEvent(self, event):
        if event.type() == QEvent.Type.WindowStateChange:
            old_state = event.oldState()
            new_state = self.windowState()

            # let resizeEvent know we’re in a transient state
            self._in_state_change = True
            QTimer.singleShot(500, lambda: setattr(self, '_in_state_change', False))

            # ─────────── 1.  MINIMISE  ───────────
            if (new_state & Qt.WindowState.WindowMinimized) and not (old_state & Qt.WindowState.WindowMinimized):

                # remember *how* we were showing
                self._last_geometry          = self.frameGeometry()
                screen                       = self.windowHandle().screen() or QApplication.primaryScreen()
                self._last_screen_name       = screen.name()
                self._was_max_before_minimise = bool(old_state & Qt.WindowState.WindowMaximized)

                # storyboard handling - DISABLED: Don't auto-minimize storyboard with main window
                # if getattr(self, 'storyboard_dialog', None):
                #     manual_hide = getattr(self.storyboard_dialog, 'is_manually_hidden', False)
                #     manual_min  = getattr(self.storyboard_dialog, 'is_manually_minimized', False)
                #     self._storyboard_was_visible = self.storyboard_dialog.isVisible() and not manual_hide and not manual_min
                #     if self._storyboard_was_visible:
                #         self.storyboard_dialog.showMinimized()

                # welcome dialog
                if getattr(self, 'welcome_dialog', None) and self.welcome_dialog.isVisible():
                    self.welcome_dialog.showMinimized()

            # ─────────── 2.  RESTORE FROM MINIMISE  ───────────
            elif (old_state & Qt.WindowState.WindowMinimized) and not (new_state & Qt.WindowState.WindowMinimized):

                def _deferred_restore():

                    # --- 2‑a   MAIN WINDOW ---
                    # inside the deferred‑restore() lambda — replace the old maximised path
                    if getattr(self, '_was_max_before_minimise', False):
                        tgt_screen = self._get_screen_by_name(
                                         getattr(self, '_last_screen_name', '')
                                     ) or self.windowHandle().screen() or QApplication.primaryScreen()
                        self._move_window_to_screen(tgt_screen)

                    elif hasattr(self, '_last_geometry'):
                        # (normal‑size restore path stays the same) …

                        tgt_screen = self._get_screen_by_name(getattr(self, '_last_screen_name', '')) \
                                     or self.windowHandle().screen() \
                                     or QApplication.primaryScreen()
                        fitted = self._fit_geometry_to_screen(self._last_geometry, tgt_screen)
                        self.showNormal()
                        self.setGeometry(fitted)

                    # tidy up temp attributes
                    for attr in ('_last_geometry', '_last_screen_name', '_was_max_before_minimise'):
                        if hasattr(self, attr):
                            delattr(self, attr)

                    # --- 2‑b   STORYBOARD --- Auto-restore if storyboard is minimized
                    if getattr(self, 'storyboard_dialog', None) and self.storyboard_dialog.isMinimized():
                        QTimer.singleShot(50, lambda: self.storyboard_dialog.showNormal())

                    # --- 2‑c   WELCOME DIALOG ---
                    if getattr(self, 'welcome_dialog', None) and self.welcome_dialog.isVisible():
                        self.welcome_dialog.showNormal()
                        self.welcome_dialog.raise_()
                        self.welcome_dialog.activateWindow()

                # defer until Qt finishes its own un‑minimise
                QTimer.singleShot(0, _deferred_restore)

            # ─────────── 3.  MAXIMISE  ───────────
            elif (new_state & Qt.WindowState.WindowMaximized) and not (old_state & Qt.WindowState.WindowMaximized):
                self._pre_maximized_size     = self.size()
                self._pre_maximized_geometry = self.geometry()

            # ─────────── 4.  RESTORE FROM MAXIMISE  ───────────
            elif (old_state & Qt.WindowState.WindowMaximized) and not (new_state & Qt.WindowState.WindowMaximized):
                pass  # keep any extra logic you already had here

        # always bubble up
        super().changeEvent(event)


    def programmatic_resize(self, width, height):
        """Perform a resize programmatically without triggering UI adjustments"""
        try:
            print(f"[DEBUG] Performing programmatic resize to {width}x{height}")
            self._programmatic_resize_in_progress = True
        
            # Store these dimensions as our stored "desired" dimensions
            # This ensures these dimensions are preserved for future restorations
            self._desired_width = width
            self._desired_height = height
            self._desired_restore_size = QSize(width, height)
        
            # Block processing events during resize to prevent race conditions
            QGuiApplication.processEvents()
        
            # Actually perform the resize
            self.resize(width, height)
        
            # Force an immediate update
            self.update()
        
        finally:
            # Use a short delay to reset the flag
            QTimer.singleShot(300, self._reset_programmatic_resize_flag)

    def _reset_programmatic_resize_flag(self):
        """Reset the programmatic resize flag after a short delay"""
        self._programmatic_resize_in_progress = False
        print("[DEBUG] Programmatic resize flag reset")

    def _apply_restore_size(self):
        """Apply the calculated restore size and then clear it"""
        if hasattr(self, '_calculated_restore_size'):
            scaled_width = self._calculated_restore_size.width()
            scaled_height = self._calculated_restore_size.height()
        
            # If Qt has already resized to something close to our desired size, don't resize again
            if abs(self.width() - scaled_width) > 50 or abs(self.height() - scaled_height) > 50:
                print(f"[DEBUG] Applying calculated restore size: {scaled_width}x{scaled_height}")
                self.programmatic_resize(scaled_width, scaled_height)
            else:
                print(f"[DEBUG] Current size {self.width()}x{self.height()} is close enough to calculated size, skipping resize")
        
            # Clean up
            delattr(self, '_calculated_restore_size')

    def install_event_filter(self):
        """Install an event filter to track resize events"""
        self.installEventFilter(self)
        print("[DEBUG] Installed event filter for resize tracking")

    def eventFilter(self, obj, event):
        """Filter events to track resize operations"""
        import traceback
    
        if obj is self and event.type() == QEvent.Type.Resize:
            width = self.width()
            height = self.height()
        
            # Check for suspicious resize
            if (hasattr(self, '_desired_restore_size') and
                not getattr(self, '_programmatic_resize_in_progress', False) and
                abs(width - 1400) < 5 and abs(height - 1000) < 5):
            
                print(f"[DEBUG] EVENT FILTER CAUGHT RESIZE TO {width}x{height}")
                stack_trace = traceback.format_stack()
                for line in stack_trace:
                    print(f"[STACK] {line.strip()}")
    
        # Always return False to allow event processing to continue
        return False

    def resizeEvent(self, event):
        """Handle window resize events"""
        super().resizeEvent(event)
    
        # Get current window dimensions
        current_width = self.width()
        current_height = self.height()
    
        # Debug information
        old_width = getattr(self, '_last_resize_width', None)
        old_height = getattr(self, '_last_resize_height', None)
        if old_width != current_width or old_height != current_height:
            print(f"[DEBUG] Window resized: {old_width}x{old_height} -> {current_width}x{current_height}")
    
        # Store current dimensions
        self._last_resize_width = current_width
        self._last_resize_height = current_height
        
        # Update progress overlay position if visible
        self._resize_progress_overlay()
    
        # Check if this is a programmatic resize we should ignore
        is_programmatic_resize = getattr(self, '_programmatic_resize_in_progress', False)
        is_in_state_change = getattr(self, '_in_state_change', False)
    
        # # Only enforce dimensions if not maximized or minimized
        # # and only for significant deviations from desired size
        # if (hasattr(self, '_desired_width') and hasattr(self, '_desired_height') and 
        #         not is_programmatic_resize and not is_in_state_change and
        #         not self.isMaximized() and not self.isMinimized()):
        #     desired_width = self._desired_width
        #     desired_height = self._desired_height
        
        #     # Only enforce if substantially different (allow small adjustments)
        #     if abs(current_width - desired_width) > 50 or abs(current_height - desired_height) > 50:
        #         # Only log this - don't actually enforce during arbitrary resize events
        #         # as this could interfere with normal window management
        #         print(f"[DEBUG] Detected size change to {current_width}x{current_height} " 
        #               f"from desired {desired_width}x{desired_height}")
    
        # Store normal size if it's a user resize (not during transitions and not programmatic)
        if not self.isMaximized() and not self.isMinimized() and not is_in_state_change and not is_programmatic_resize:
            self._pre_maximized_size = self.size()
            self._pre_maximized_geometry = self.geometry()
            print(f"[DEBUG] Updated stored normal size: {current_width}x{current_height}")
    
        # Normal resize handling for UI adjustments
        if not is_programmatic_resize:
            # Cache viewport dimensions
            if not hasattr(self, '_last_resize_dims'):
                self._last_resize_dims = {}
        
            # Theme view adjustments
            if hasattr(self, 'theme_view') and self.theme_view and self.view_annotations_button.isChecked():
                self.theme_view.show()
                self.right_panel_container.show()
        
                # Adjust splitter sizes immediately
                total_width = self.preview_splitter.width()
                left_width = int(total_width * 0.7)
                self.preview_splitter.setSizes([left_width, total_width - left_width])
        
                # Restart resize timer instead of updating immediately
                self._resize_timer.start()
        
            # Color key panel adjustments
            if hasattr(self, 'color_key_panel') and self.color_key_panel and self.color_key_button.isChecked():
                self.color_key_panel.show()
                self.right_panel_container.show()
        
            # Mode container adjustments
            def update_mode_container():
                if hasattr(self, 'mode_container'):
                    bottom_container = self.mode_container.parent()
                    if bottom_container:
                        self.mode_container.setVisible(True)
                        self.mode_container.raise_()
                        bottom_container.layout().update()
                
            QTimer.singleShot(0, update_mode_container)
            
            # Update sticky header positioning on resize
            if hasattr(self, 'web_view') and hasattr(self.web_view, 'sticky_header') and self.web_view.sticky_header_enabled:
                if self.web_view.sticky_header.isVisible():
                    print("[DEBUG] Triggering sticky header recalculation from MainWindow resize")
                    QTimer.singleShot(50, self.web_view.recalculate_header_position)
        else:
            print(f"[DEBUG] Ignoring UI adjustments for programmatic resize")

    def _restore_storyboard_dialog(self):
        """Helper method to restore the storyboard dialog after a delay"""
        if hasattr(self, 'storyboard_dialog') and self.storyboard_dialog:
            # Final check to ensure it's still not manually hidden or minimized
            is_manually_hidden = getattr(self.storyboard_dialog, 'is_manually_hidden', False)
            is_manually_minimized = getattr(self.storyboard_dialog, 'is_manually_minimized', False)
        
            if not is_manually_hidden and not is_manually_minimized:
                print("[DEBUG] Actually restoring storyboard dialog now")
                self.storyboard_dialog.showNormal()
                self.storyboard_dialog.raise_()
                self.storyboard_dialog.activateWindow()
            else:
                print("[DEBUG] Not restoring storyboard - manually hidden or minimized")

    def _adjust_ui_for_dpi_change(self, scale_factor):
        """Adjust UI elements after a DPI change"""
        try:
            print(f"[DEBUG] Adjusting UI for DPI change, scale factor: {scale_factor}")
        
            # Adjust button sizes that have fixed dimensions
            # We divide by scale_factor to make logical pixels smaller at higher DPI
            if hasattr(self, 'storyboard_button'):
                new_icon_size = QSize(int(130 / scale_factor), int(80 / scale_factor))
                new_button_size = QSize(int(125 / scale_factor), int(55 / scale_factor))
                self.storyboard_button.setIconSize(new_icon_size)
                self.storyboard_button.setFixedSize(new_button_size.width(), new_button_size.height())
            
            # Adjust view annotations button
            if hasattr(self, 'view_annotations_button'):
                new_icon_size = QSize(int(125 / scale_factor), int(55 / scale_factor))
                self.view_annotations_button.setIconSize(new_icon_size)
                self.view_annotations_button.setFixedSize(new_icon_size.width(), new_icon_size.height())
        
            # Adjust bookmark button
            if hasattr(self, 'bookmark_button'):
                new_icon_size = QSize(int(125 / scale_factor), int(55 / scale_factor))
                self.bookmark_button.setIconSize(new_icon_size)
                self.bookmark_button.setFixedSize(new_icon_size.width(), new_icon_size.height())
        
            # Adjust color key button
            if hasattr(self, 'color_key_button'):
                new_icon_size = QSize(int(125 / scale_factor), int(55 / scale_factor))
                self.color_key_button.setIconSize(new_icon_size)
                self.color_key_button.setFixedSize(new_icon_size.width(), new_icon_size.height())
        
            # Adjust tag button
            if hasattr(self, 'tag_button'):
                new_icon_size = QSize(int(35 / scale_factor), int(35 / scale_factor))
                new_button_size = QSize(int(40 / scale_factor), int(40 / scale_factor))
                self.tag_button.setIconSize(new_icon_size)
                self.tag_button.setFixedSize(new_button_size.width(), new_button_size.height())
        
            # Force an update of annotation item sizes in the theme view
            QTimer.singleShot(300, self.update_tab_item_sizes)
        except Exception as e:
            print(f"[DEBUG] Error adjusting UI for DPI: {e}")


    def init_ui(self):
        windows_scaling = None

        if os.name == 'nt':
            try:
                import ctypes
                user32 = ctypes.windll.user32
                windows_scaling = user32.GetDpiForSystem() / 96.0
                print(f"Detected Windows scaling directly: {windows_scaling:.2f} ({int(windows_scaling * 100)}%)")
            except Exception as e:
                print("Failed to detect Windows scaling directly, will use DPI-based fallback")

        screen = QApplication.primaryScreen()
        physical_dpi = screen.physicalDotsPerInch()
        logical_dpi = screen.logicalDotsPerInch()

        if windows_scaling is None:
            if logical_dpi == 96.0 and physical_dpi > 120:
                if 120 <= physical_dpi < 144:
                    windows_scaling = 1.25
                elif 144 <= physical_dpi < 192:
                    windows_scaling = 1.5
                elif physical_dpi >= 192:
                    windows_scaling = 2.0
                else:
                    windows_scaling = 1.0
                print(f"Qt didn't detect Windows scaling - using fixed scaling: {windows_scaling:.2f} ({int(windows_scaling * 100)}%)")
            else:
                windows_scaling = logical_dpi / 96.0

        # Fallback to computing physical resolution if nativeGeometry() is not available
        logical_geometry = screen.geometry()
        dpr = screen.devicePixelRatio()
        screen_width = int(logical_geometry.width() * dpr)
        screen_height = int(logical_geometry.height() * dpr)

        print(f"Screen Resolution (computed physical): {screen_width}x{screen_height}")
        print(f"Physical DPI: {physical_dpi}, Logical DPI: {logical_dpi}")
        print(f"OS Scaling Factor: {windows_scaling} (Windows Display Scale: {int(windows_scaling * 100)}%)")

        # Define base dimensions based on physical resolution
        if screen_height > 1600:
            base_width = 1600
            base_height = 1200
            print(f"Setting high resolution base dimensions (1600x1200) for {screen_width}x{screen_height}")
        elif screen_height > 1200 and screen_height <= 1600:
            base_width = 1400
            base_height = 1000
            print(f"Setting mid resolution base dimensions (1400x1000) for {screen_width}x{screen_height}")
        elif screen_height <= 1080:
            base_width = 1200
            base_height = 800
            print(f"Setting standard resolution base dimensions (1200x800) for {screen_width}x{screen_height}")
        else:
            base_width = 1000
            base_height = 700
            print(f"Setting minimum base dimensions (1000x700) for {screen_width}x{screen_height}")

        scale_factor = windows_scaling
        print(f"Using scale factor: {scale_factor} (based on OS scaling)")

        # Calculate how much to reduce the scaling effect based on the scale factor
        # For 125% scaling (1.25), we'll apply a smaller reduction to maintain around 96% of original dimensions
        if scale_factor <= 1.0:
            # No scaling needed
            adjusted_scale_factor = 1.0
        elif scale_factor <= 1.25:
            # For 125% scaling, apply only 15% of the scaling effect
            # This gives us ~96% of original size (exactly what you wanted for 1400x1000 → 1350x900)
            scaling_reduction = 0.15
            adjusted_scale_factor = 1.0 + ((scale_factor - 1.0) * scaling_reduction)
        elif scale_factor <= 1.5:
            # For 150% scaling, apply 20% of the scaling effect
            scaling_reduction = 0.20
            adjusted_scale_factor = 1.0 + ((scale_factor - 1.0) * scaling_reduction)
        elif scale_factor <= 1.75:
            # For 175% scaling, apply 25% of the scaling effect
            scaling_reduction = 0.25
            adjusted_scale_factor = 1.0 + ((scale_factor - 1.0) * scaling_reduction)
        else:
            # For 200%+ scaling, apply 30% of the scaling effect
            scaling_reduction = 0.30
            adjusted_scale_factor = 1.0 + ((scale_factor - 1.0) * scaling_reduction)

        print(f"Adjusted scale factor: {adjusted_scale_factor:.3f} (gentler scaling)")

        # Apply the adjusted scaling to maintain proportions regardless of resolution
        scaled_width = int(base_width / adjusted_scale_factor)
        scaled_height = int(base_height / adjusted_scale_factor)

        print(f"Base dimensions: {base_width}x{base_height}")
        print(f"Scaled dimensions: {scaled_width}x{scaled_height}")

        self._desired_width = scaled_width
        self._desired_height = scaled_height

        # Center the window on screen instead of using fixed (100, 100) position
        screen_geometry = screen.availableGeometry()
        center_x = screen_geometry.x() + (screen_geometry.width() - scaled_width) // 2
        center_y = screen_geometry.y() + (screen_geometry.height() - scaled_height) // 2
        self.setGeometry(center_x, center_y, scaled_width, scaled_height)
        # Create a status bar
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)


        # Create a status bar
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        self.status_bar.setStyleSheet("""
            QStatusBar {
                border-top: 1px solid #e0e0e0;
                background: #ffffff;
                padding: 2px;
                color: #666666;
            }
        """)

        # Build your menu
        self.create_menu()
        # -- STEP 4: Create (and style) your tab widget, then add to main layout --
        self.tabs = QTabWidget()
        self.tabs.setStyleSheet("""
            QTabWidget::pane {
                border: none;
                background: #ffffff;
            }
            QTabBar::tab {
                padding: 8px 16px;
                margin: 0;
                border: none;
                background: #f5f5f5;
                color: #666666;
            }
            QTabBar::tab:selected {
                background: #ffffff;
                color: #2196F3;
                border-bottom: 2px solid #2196F3;
            }
            QTabBar::tab:hover:!selected {
                background: #eeeeee;
            }
        """)

        # 2) Create a container widget and set a layout
        logo_container = QWidget()
        layout = QHBoxLayout(logo_container)

        # 2) Set margins around the logo
        layout.setContentsMargins(10, 0, 10, 44)
        layout.setSpacing(0)
    
        # Create and configure logo
        logo_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'Img', 'delisimedia-header.png')
        logo_label = QLabel(self)  # Add parent
        logo_pixmap = QPixmap(logo_path)
        if not logo_pixmap.isNull():
            scaled_pixmap = logo_pixmap.scaled(200, 20, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
            logo_label.setPixmap(scaled_pixmap)
            #logo_label.setContentsMargins(0, 0, 15, 20)  # Small top margin to align with menu
        else:
            print(f"Could not load logo from {logo_path}")
   
        # 4) Add the label inside that layout
        layout.addWidget(logo_label)
        logo_container.setMinimumSize(200, 60)

        # 5) Set this container as the corner widget
        self.tabs.setCornerWidget(logo_container, Qt.Corner.TopRightCorner)
        self.detect_headers = self.detect_headers  # Ensure the method is bound early
        
        # Now create your tabs as before
        self.create_cleaner_tab()
        self.create_input_tab()

        # Define button_style here so it's accessible in this method ONLY ONCE
        button_style = """
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 5px;
                font-weight: 500;
                font-size: 13px;
                min-width: 55px;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
            QPushButton:disabled {
                background-color: #BDBDBD;
            }
        """

        # Create Backend Tab
        self.backend_widget = QWidget()
        backend_layout = QVBoxLayout()

        # Create warning banner at the top
        warning_container = QWidget()
        warning_container.setStyleSheet("""
            QWidget {
                background-color: #FFF3CD;
                border: 1px solid #FFEEBA;
                border-radius: 4px;
            }
        """)
        warning_layout = QHBoxLayout(warning_container)
        warning_layout.setContentsMargins(10, 8, 10, 8)

        warning_icon = QLabel("⚠️")
        warning_icon.setStyleSheet("font-size: 16px; margin-right: 5px;")

        warning_text = QLabel("Beta Feature: The Backend tab is not fully featured, buggy, and only used as a debug tool. Please backup your project before making changes.")
        warning_text.setStyleSheet("""
            color: #856404;
            font-size: 12px;
            font-weight: 500;
        """)
        warning_text.setWordWrap(True)

        warning_layout.addWidget(warning_icon)
        warning_layout.addWidget(warning_text, stretch=1)

        backend_layout.addWidget(warning_container)
        backend_layout.addSpacing(8)  # Add some space after the warning

        # Create search bar for backend tab
        search_container = QWidget()
        search_container.setStyleSheet("""
            QWidget {
                background-color: #f5f5f5;
                border-bottom: 1px solid #e0e0e0;
            }
        """)
        search_layout = QHBoxLayout(search_container)
        search_layout.setContentsMargins(10, 5, 10, 5)
        search_layout.setSpacing(5)

        # Search input field
        self.backend_search_input = QLineEdit()
        self.backend_search_input.setPlaceholderText("Search in HTML...")
        self.backend_search_input.setMaximumWidth(300)
        self.backend_search_input.setStyleSheet("""
            QLineEdit {
                padding: 5px 10px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: white;
                font-size: 13px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
        """)

        # Navigation buttons for search
        self.backend_prev_button = QPushButton("▲")
        self.backend_next_button = QPushButton("▼")
        self.backend_close_search_button = QPushButton("✕")

        # Counter label to show current match
        self.backend_match_counter = QLabel("")
        self.backend_match_counter.setStyleSheet("""
            QLabel {
                color: #666666;
                font-size: 12px;
                padding: 0 10px;
                min-width: 80px;
            }
        """)

        # Style for all buttons
        for button in [self.backend_prev_button, self.backend_next_button, self.backend_close_search_button]:
            button.setFixedSize(28, 28)
            button.setStyleSheet("""
                QPushButton {
                    background-color: #ffffff;
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    font-size: 12px;
                    padding: 0px;
                }
                QPushButton:hover {
                    background-color: #f5f5f5;
                }
                QPushButton:pressed {
                    background-color: #e0e0e0;
                }
                QPushButton:disabled {
                    background-color: #f5f5f5;
                    color: #aaaaaa;
                }
            """)
            button.setCursor(Qt.CursorShape.PointingHandCursor)

        # Add widgets to search layout
        search_layout.addWidget(self.backend_search_input)
        search_layout.addWidget(self.backend_prev_button)
        search_layout.addWidget(self.backend_next_button)
        search_layout.addWidget(self.backend_match_counter)
        search_layout.addWidget(self.backend_close_search_button)
        search_layout.addStretch()

        # Connect search signals
        self.backend_search_input.textChanged.connect(self.handle_backend_search)
        self.backend_prev_button.clicked.connect(lambda: self.find_backend_text(self.backend_search_input.text(), False))
        self.backend_next_button.clicked.connect(lambda: self.find_backend_text(self.backend_search_input.text(), True))
        self.backend_close_search_button.clicked.connect(self.close_backend_search)
        self.backend_search_input.returnPressed.connect(lambda: self.find_backend_text(self.backend_search_input.text(), True))

        # Initialize search state variables
        self.backend_search_matches = []
        self.backend_current_match = -1

        # Add search container to backend layout
        backend_layout.addWidget(search_container)

        # Buttons Layout (Refresh and Update)
        buttons_layout = QHBoxLayout()
        buttons_layout.setSpacing(10) # Add some spacing between buttons
        buttons_layout.addStretch(1)  # Push buttons to the right

        # Refresh Button (Manual Refresh) - NOW ON THE LEFT
        self.refresh_backend_button = QPushButton("Refresh")
        self.refresh_backend_button.setStyleSheet(button_style)
        self.refresh_backend_button.clicked.connect(self.manual_refresh_backend_tab) # New manual refresh function
        buttons_layout.addWidget(self.refresh_backend_button)

        # Update Button - NOW ON THE RIGHT
        self.update_backend_button = QPushButton("Update")
        self.update_backend_button.setStyleSheet(button_style)
        self.update_backend_button.clicked.connect(self.update_dom_from_backend)
        buttons_layout.addWidget(self.update_backend_button)

        backend_layout.addLayout(buttons_layout) # Add buttons layout to backend layout

        self.backend_text_edit = QTextEdit()
        self.backend_text_edit.setFont(QFont("Courier New", 10))  # Monospace font for code
        self.backend_text_edit.setAcceptRichText(False)  # Disable rich text for code editing
        backend_layout.addWidget(self.backend_text_edit)

        self.backend_widget.setLayout(backend_layout)

        #Removed the backend tab.
        #self.tabs.addTab(self.backend_widget, "Backend")

        # Add search keyboard shortcuts
        backend_search_shortcut = QShortcut(QKeySequence("Ctrl+F"), self.backend_text_edit)
        backend_search_shortcut.activated.connect(self.focus_backend_search)

        backend_next_shortcut = QShortcut(QKeySequence("F3"), self.backend_text_edit)
        backend_next_shortcut.activated.connect(lambda: self.find_backend_text(self.backend_search_input.text(), True))

        backend_prev_shortcut = QShortcut(QKeySequence("Shift+F3"), self.backend_text_edit)
        backend_prev_shortcut.activated.connect(lambda: self.find_backend_text(self.backend_search_input.text(), False))

        backend_escape_shortcut = QShortcut(QKeySequence("Esc"), self.backend_text_edit)
        backend_escape_shortcut.activated.connect(self.close_backend_search)

        # Connect tab changed signal to refresh backend tab
        self.tabs.currentChanged.connect(self.refresh_backend_tab)

        self.create_output_tab()
        self.create_preview_tab()

        # Make the QTabWidget the central widget
        self.setCentralWidget(self.tabs)
        # Update the default_html variable to match the actual empty content placeholder
        self.default_html = """
        <!DOCTYPE html>
        <html>
        <head>
            <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
            <script>
                document.addEventListener("DOMContentLoaded", function() {
                    if (typeof QWebChannel !== "undefined") {
                        new QWebChannel(qt.webChannelTransport, function(channel) {
                            window.jsHandler = channel.objects.jsHandler;
                            window.webChannelInitialized = true;
                        });
                    }
                });
            </script>
        </head>
        <body contenteditable="false"></body>
        </html>
        """.strip()

        # Set the default HTML in output_text
        self.output_text = QTextEdit()
        self.output_text.setPlainText(self.default_html)

        # Connect annotation signals
        self.web_view.annotation_added.connect(self.handle_annotation_added)
        self.web_view.reassignment_completed.connect(self.handle_reassignment_completed)

        # Add this to your init_ui method after setting geometry
        min_width = 1100 # Adjust this value as needed
        min_height = 700  # Adjust this value as needed
        self.setMinimumSize(min_width, min_height)
        print(f"Final program dimensions: {self.width()}x{self.height()}")

        # Add this line to enforce the desired size after UI setup
        QTimer.singleShot(0, lambda: self._force_desired_size())

    def focus_backend_search(self):
        """Focus the backend search input and select text if present"""
        self.backend_search_input.setFocus()
        self.backend_search_input.selectAll()

    def handle_backend_search(self):
        """Handle backend search text changes"""
        search_text = self.backend_search_input.text()
    
        # Enable or disable buttons based on search text
        has_text = bool(search_text)
        self.backend_prev_button.setEnabled(has_text)
        self.backend_next_button.setEnabled(has_text)
        self.backend_close_search_button.setEnabled(has_text)
    
        if search_text:
            self.find_all_backend_matches(search_text)
            self.find_backend_text(search_text, True)  # Search forward on text change
        else:
            # Clear selection and matches when search is empty
            cursor = self.backend_text_edit.textCursor()
            cursor.clearSelection()
            self.backend_text_edit.setTextCursor(cursor)
            self.backend_match_counter.setText("")
            self.backend_search_matches = []
            self.backend_current_match = -1

    def find_all_backend_matches(self, search_text):
        """Find all occurrences of search text in backend editor"""
        self.backend_search_matches = []
        self.backend_current_match = -1
    
        if not search_text:
            return
    
        # Get document content
        document = self.backend_text_edit.document()
        text_content = document.toPlainText()
    
        # Find all occurrences
        start_pos = 0
        while True:
            pos = text_content.find(search_text, start_pos)
            if pos == -1:
                break
            self.backend_search_matches.append(pos)
            start_pos = pos + len(search_text)
    
        # Update match counter
        self.update_backend_match_counter()

    def find_backend_text(self, search_text, forward=True):
        """Find and highlight next/previous occurrence of search text in backend editor"""
        if not search_text or not self.backend_search_matches:
            return
    
        # Determine the next match index
        if forward:
            self.backend_current_match = (self.backend_current_match + 1) % len(self.backend_search_matches)
        else:
            self.backend_current_match = (self.backend_current_match - 1) % len(self.backend_search_matches)
    
        # Get the position of the match
        match_pos = self.backend_search_matches[self.backend_current_match]
    
        # Create a cursor and select the match
        cursor = self.backend_text_edit.textCursor()
        cursor.setPosition(match_pos)
        cursor.setPosition(match_pos + len(search_text), QTextCursor.MoveMode.KeepAnchor)
    
        # Set the cursor to highlight the match
        self.backend_text_edit.setTextCursor(cursor)
        self.backend_text_edit.ensureCursorVisible()
    
        # Update match counter
        self.update_backend_match_counter()

    def update_backend_match_counter(self):
        """Update the match counter label"""
        if not self.backend_search_matches:
            self.backend_match_counter.setText("")
            return
    
        total = len(self.backend_search_matches)
        current = self.backend_current_match + 1 if self.backend_current_match >= 0 else 0
        self.backend_match_counter.setText(f"{current} of {total}")

    def close_backend_search(self):
        """Close the search functionality in backend editor"""
        self.backend_search_input.clear()
        cursor = self.backend_text_edit.textCursor()
        cursor.clearSelection()
        self.backend_text_edit.setTextCursor(cursor)
        self.backend_match_counter.setText("")
        self.backend_search_matches = []
        self.backend_current_match = -1
        self.backend_prev_button.setEnabled(False)
        self.backend_next_button.setEnabled(False)
        self.backend_close_search_button.setEnabled(False)
        self.backend_text_edit.setFocus()

    def refresh_backend_tab(self, index):
        if self.tabs.widget(index) == self.backend_widget:
            # Automatically refresh if text is empty
            if not self.backend_text_edit.toPlainText().strip():
                self.update_backend_text()

    def on_scene_tab_changed(self, index):
        """Handle scene tab switching to refresh annotation list widget sizing"""
        if index >= 0 and index < self.scene_tabs.count():
            current_widget = self.scene_tabs.widget(index)
            if isinstance(current_widget, AnnotationListWidget):
                print(f"DEBUG: Tab switched to index {index}, refreshing annotation list sizing")
                
                # Force visual refresh of all annotation items in the newly visible tab
                for i in range(current_widget.count()):
                    item = current_widget.item(i)
                    widget = current_widget.itemWidget(item)
                    
                    if widget:
                        # Force full recalculation and visual update
                        current_widget.updateItemSize(item, widget, force_full_calculation=True)
                
                # Process any pending visual updates
                current_widget.processVisibleItemUpdates()
                
                # Force geometry update
                current_widget.updateGeometry()
                current_widget.update()

    def manual_refresh_backend_tab(self):
        """Manually refresh the Backend tab content."""
        self.update_backend_text()

    def update_backend_text(self):
        """Fetch and display raw HTML in the Backend tab without beautification."""
        def set_backend_html(html_content):
            # Directly set the raw HTML content as plain text
            self.backend_text_edit.setPlainText(html_content)

        self.web_view.page().toHtml(set_backend_html)

    def update_dom_from_backend(self):
        """Update the DOM in QWebEngineView with the HTML from Backend tab, with confirmation."""
        reply = QMessageBox.question(
            self,
            "Confirmation",
            "Are you sure you want to update the DOM?\n\n"
            "Changes will be saved immediately and cannot be undone.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No  # Default to No
        )

        if reply == QMessageBox.StandardButton.Yes:
            html_code = self.backend_text_edit.toPlainText()
            self.web_view.setHtml(html_code)
            self.status_bar.showMessage("DOM updated from Backend tab.", 3000)
            self.manual_refresh_backend_tab() # Manual refresh after update


    def create_cleaner_tab(self):
        self.cleaner_widget = QWidget()
        layout = QVBoxLayout()
        layout.setSpacing(1)
        layout.setContentsMargins(8, 8, 8, 8)

        # Add information label at the top
        info_label = QLabel("The Process Captions tab is intended to process .srt or .txt video captions into paragraph form. If you are not working with video captions, proceed to the Create Transcript tab.")
        info_label.setStyleSheet("""
            QLabel {
                background-color: #f0f7ff;
                border: 1px solid #d0e3f7;
                border-radius: 4px;
                color: #2e5075;
                font-size: 12px;
                padding: 6px 10px;
                margin-bottom: 0px;
            }
        """)
        info_label.setWordWrap(True)
        info_label.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Fixed)
        layout.addWidget(info_label)

        # Top container with open button
        top_container = QWidget()
        top_layout = QHBoxLayout()
        top_layout.setSpacing(2)
        top_layout.setContentsMargins(0, 0, 0, 0)

        # Top container with open button
        top_container = QWidget()
        top_layout = QHBoxLayout()
        top_layout.setSpacing(4)
        top_layout.setContentsMargins(0, 0, 0, 0)

        button_style = """
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 6px 10px;
                border-radius: 4px;
                font-weight: 500;
                font-size: 11px;
                min-width: 100px;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
            QPushButton:disabled {
                background-color: #BDBDBD;
            }
        """

        top_container.setLayout(top_layout)
        top_container.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Fixed)
        layout.addWidget(top_container)

        # Create horizontal layout for input, arrow, and output
        content_layout = QHBoxLayout()
        content_layout.setSpacing(0)

        # Input container
        input_container = QWidget()
        input_layout = QVBoxLayout(input_container)
        input_layout.setSpacing(4)
        input_layout.setContentsMargins(45, 35, 5, 85) # <-- Adjusted margins

        # Create header layout with label and clear button
        input_header = QHBoxLayout()
        input_label = QLabel("Original Video Captions Text")
        input_label.setStyleSheet("color: #666666; font-size: 13px; font-weight: bold; margin-left: 5px;")
        
        # Add Clear button
        clear_input_btn = QPushButton("Clear")
        clear_input_btn.setToolTip("Clear all original video captions text")
        clear_input_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #dc3545;
                border-radius: 12px;
                background-color: #f8f9fa;
                color: #dc3545;
                font-size: 11px;
                font-weight: bold;
                padding: 3px 10px;
                margin-left: 8px;
                max-width: 50px;
            }
            QPushButton:hover {
                background-color: #dc3545;
                color: white;
            }
            QPushButton:pressed {
                background-color: #c82333;
            }
        """)
        clear_input_btn.clicked.connect(self.clear_input_text)
        
        input_header.addWidget(input_label)
        input_header.addStretch()
        input_header.addWidget(clear_input_btn)
        self.cleaner_input_text = QTextEdit()
        self.cleaner_input_text.setStyleSheet("""
            QTextEdit {
                border: 2px dashed #ADADAD;
                border-radius: 8px;
                padding: 40px;
                background-color: #FDFDFD;
                font-family: 'Segoe UI', sans-serif;
                font-size: 16px;
                color: #333333;
                font-weight: bold;
            }
        """)
        
        # Override cursor behavior completely - target the viewport
        self.cleaner_input_text.setCursor(Qt.CursorShape.ArrowCursor)
        self.cleaner_input_text.viewport().setCursor(Qt.CursorShape.ArrowCursor)
        
        def force_arrow_cursor(event):
            self.cleaner_input_text.setCursor(Qt.CursorShape.ArrowCursor)
            self.cleaner_input_text.viewport().setCursor(Qt.CursorShape.ArrowCursor)
            return QTextEdit.mouseMoveEvent(self.cleaner_input_text, event)
        
        def force_arrow_enter(event):
            self.cleaner_input_text.setCursor(Qt.CursorShape.ArrowCursor)
            self.cleaner_input_text.viewport().setCursor(Qt.CursorShape.ArrowCursor)
            return QTextEdit.enterEvent(self.cleaner_input_text, event)
        
        self.cleaner_input_text.mouseMoveEvent = force_arrow_cursor
        self.cleaner_input_text.enterEvent = force_arrow_enter
        
        # Create a centered placeholder overlay
        self.placeholder_label = QLabel("Drag and drop .txt or .srt files here", self.cleaner_input_text)
        self.placeholder_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.placeholder_label.setStyleSheet("""
            QLabel {
                color: #999999;
                font-size: 16px;
                font-weight: bold;
                background: transparent;
                border: none;
            }
        """)
        self.placeholder_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        
        # Position the label to cover the entire text edit
        def update_placeholder_position():
            if hasattr(self, 'placeholder_label') and hasattr(self, 'cleaner_input_text'):
                self.placeholder_label.setGeometry(self.cleaner_input_text.rect())
                
        # Connect to resize and show events
        def custom_resize_event(event):
            QTextEdit.resizeEvent(self.cleaner_input_text, event)
            update_placeholder_position()
        
        self.cleaner_input_text.resizeEvent = custom_resize_event
        
        # Hide placeholder when text is entered and update content flag
        def check_placeholder_visibility():
            if hasattr(self, 'placeholder_label'):
                has_text = bool(self.cleaner_input_text.toPlainText().strip())
                self.placeholder_label.setVisible(not has_text)
                # Update the content flag whenever text changes
                self.cleaner_input_has_real_content = has_text
                
        self.cleaner_input_text.textChanged.connect(check_placeholder_visibility)
        
        # Initial positioning
        QTimer.singleShot(10, update_placeholder_position)
        
        # Flag to track if we have real content vs placeholder
        self.cleaner_input_has_real_content = False

        # Add drag and drop support for multiple text files
        self.cleaner_input_text.setAcceptDrops(True)
        

        def dragEnterEvent(event):
            if event.mimeData().hasUrls():
                # Check if all URLs are text files
                all_text_files = True
                for url in event.mimeData().urls():
                    file_path = url.toLocalFile()
                    if not (file_path.endswith('.txt') or file_path.endswith('.srt') or 
                            file_path.endswith('.vtt') or file_path.endswith('.caption')):
                        all_text_files = False
                        break
                
                if all_text_files:
                    # Add drag enter hover state - just border highlight
                    self.cleaner_input_text.setStyleSheet("""
                        QTextEdit {
                            border: 3px solid #2196F3;
                            border-radius: 8px;
                            padding: 40px;
                            background-color: #F5F9FF;
                            font-family: 'Segoe UI', sans-serif;
                            font-size: 16px;
                            color: #666666;
                            font-weight: bold;
                        }
                    """)
                    event.acceptProposedAction()
                else:
                    # Invalid file type hover state - red border
                    self.cleaner_input_text.setStyleSheet("""
                        QTextEdit {
                            border: 3px solid #f44336;
                            border-radius: 8px;
                            padding: 40px;
                            background-color: #FFF5F5;
                            font-family: 'Segoe UI', sans-serif;
                            font-size: 16px;
                            color: #666666;
                            font-weight: bold;
                        }
                    """)
                    event.ignore()
            else:
                event.ignore()
                
        def dragLeaveEvent(event):
            # Restore normal appearance when drag leaves
            self.cleaner_input_text.setStyleSheet("""
                QTextEdit {
                    border: 2px dashed #ADADAD;
                    border-radius: 8px;
                    padding: 40px;
                    background-color: #FAFBFC;
                    font-family: 'Segoe UI', sans-serif;
                    font-size: 16px;
                    color: #666666;
                    font-weight: bold;
                }
            """)
            
        def dragMoveEvent(event):
            # Also need to accept drag move events for drop to work
            if event.mimeData().hasUrls():
                # Check if all URLs are text files
                all_text_files = True
                for url in event.mimeData().urls():
                    file_path = url.toLocalFile()
                    if not (file_path.endswith('.txt') or file_path.endswith('.srt') or 
                            file_path.endswith('.vtt') or file_path.endswith('.caption')):
                        all_text_files = False
                        break
                
                if all_text_files:
                    event.acceptProposedAction()
                else:
                    event.ignore()
            else:
                event.ignore()

        def dropEvent(event):
            if event.mimeData().hasUrls():
                # First, restore normal appearance after drop
                self.cleaner_input_text.setStyleSheet("""
                    QTextEdit {
                        border: 2px dashed #ADADAD;
                        border-radius: 8px;
                        padding: 40px;
                        background-color: #FAFBFC;
                        font-family: 'Segoe UI', sans-serif;
                        font-size: 16px;
                        text-align: center;
                        color: #666666;
                        font-weight: bold;
                    }
                """)
                
                # Check if there's existing text using our flag
                has_existing_text = getattr(self, 'cleaner_input_has_real_content', False)
                
                append_mode = False
                if has_existing_text:
                    # Create custom message box with specific button labels
                    reply_box = QMessageBox(self)
                    reply_box.setWindowTitle('Existing Text Found')
                    reply_box.setText('There is already text in the input area.\n\nHow would you like to handle the new files?')
                    reply_box.setInformativeText('Choose how to handle the dropped files:')
                    
                    overwrite_btn = reply_box.addButton('Overwrite', QMessageBox.ButtonRole.YesRole)
                    add_btn = reply_box.addButton('Add Below', QMessageBox.ButtonRole.NoRole) 
                    cancel_btn = reply_box.addButton('Cancel', QMessageBox.ButtonRole.RejectRole)
                    
                    # Ensure buttons are properly sized
                    reply_box.setDefaultButton(cancel_btn)
                    
                    reply_box.exec()
                    
                    clicked_button = reply_box.clickedButton()
                    if clicked_button == cancel_btn:
                        return  # User canceled
                    elif clicked_button == add_btn:
                        append_mode = True
                    # If overwrite_btn, append_mode stays False
                
                urls = event.mimeData().urls()
                combined_content = []
                loaded_files = []
                errors = []
                
                for url in urls:
                    file_path = url.toLocalFile()
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            content = file.read().strip()
                            if content:  # Only add non-empty files
                                # Create highlighted header for QTextEdit
                                filename = os.path.splitext(os.path.basename(file_path))[0]  # Remove extension
                                header = f"[[{filename}]]"
                                combined_content.append(header)
                                combined_content.append(content)
                                combined_content.append("")  # Add blank line between files
                                loaded_files.append(os.path.basename(file_path))
                    except Exception as e:
                        errors.append(f"{os.path.basename(file_path)}: {str(e)}")
                
                if combined_content:
                    # Join all content and set it in the text field
                    final_content = "\n".join(combined_content).strip()
                    
                    scroll_to_new_content = False
                    if append_mode and has_existing_text:
                        # Add below existing text
                        existing_content = self.cleaner_input_text.toPlainText()
                        final_content = existing_content + '\n\n' + final_content
                        scroll_to_new_content = True
                    
                    self.cleaner_input_text.setPlainText(final_content)
                    
                    # Auto-scroll to newly added content if in append mode
                    if scroll_to_new_content:
                        # Find the position where new content starts (after existing + \n\n)
                        existing_length = len(existing_content)
                        new_content_start = existing_length + 2  # +2 for \n\n
                        
                        # Move cursor to the start of new content
                        cursor = self.cleaner_input_text.textCursor()
                        cursor.setPosition(new_content_start)
                        self.cleaner_input_text.setTextCursor(cursor)
                        self.cleaner_input_text.ensureCursorVisible()
                    
                    # Mark that we now have real content
                    self.cleaner_input_has_real_content = True
                    
                    # Don't apply formatting to input area - keep it plain
                    
                    # Show success message
                    if len(loaded_files) == 1:
                        action = "Added" if append_mode else "Loaded"
                        self.status_bar.showMessage(f'{action} file: {loaded_files[0]}', 5000)
                    else:
                        action = "Added" if append_mode else "Loaded"
                        self.status_bar.showMessage(f'{action} {len(loaded_files)} files: {", ".join(loaded_files)}', 5000)
                
                # Show any errors
                if errors:
                    error_msg = "Errors occurred while loading some files:\n" + "\n".join(errors)
                    QMessageBox.warning(self, 'Loading Errors', error_msg)

        self.cleaner_input_text.dragEnterEvent = dragEnterEvent
        self.cleaner_input_text.dragMoveEvent = dragMoveEvent
        self.cleaner_input_text.dragLeaveEvent = dragLeaveEvent
        self.cleaner_input_text.dropEvent = dropEvent

        input_layout.addLayout(input_header)
        input_layout.addWidget(self.cleaner_input_text)

        # Center container for arrow button
        center_container = QWidget()
        center_container.setFixedWidth(85)
        center_layout = QVBoxLayout(center_container)
        center_layout.setContentsMargins(0, 0, 0, 0)
        center_layout.setSpacing(6)
        center_layout.addStretch()

        # Add label
        arrow_label = QLabel("Process")
        arrow_label.setStyleSheet("""
            QLabel {
                color: black;
                font-size: 12px;
                margin-left:18px;
            }
        """)
        center_layout.addWidget(arrow_label)

        self.clean_button = QPushButton("➜")
        self.clean_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #203740;
                border: none;
                font-size: 50px;
                padding: 0;
                min-width: 50px;
                min-height: 50px;
                max-width: 50px;
                max-height: 50px;
            }
            QPushButton:hover {
                color: #2C4952;
            }
            QPushButton:pressed {
                color: #1A5E5C;
            }
            QPushButton:disabled {
                 color: #BDBDBD;
            }
        """)
        self.clean_button.setCursor(Qt.CursorShape.PointingHandCursor)  # Change cursor to pointing h
        center_layout.addWidget(self.clean_button, alignment=Qt.AlignmentFlag.AlignCenter)
        center_layout.addStretch()

        # Output container section - modify this part
        output_container = QWidget()
        output_layout = QVBoxLayout(output_container)
        output_layout.setSpacing(4)
        output_layout.setContentsMargins(5, 35, 50, 0) # <-- Adjusted margins

        # Create a horizontal layout for the label and counter
        output_header = QHBoxLayout()

        output_label = QLabel("Cleaned Text Without Timecodes")
        output_label.setStyleSheet("color: #666666; font-size: 13px; font-weight: bold; margin-left: 5px;")
        output_header.addWidget(output_label)

        # Add word counter label
        self.word_counter = QLabel("Words: 0")
        self.word_counter.setStyleSheet("""
            color: #666666;
            font-size: 13px;
            font-weight: 500;
            padding-right: 5px;
            margin-right: 5px;
        """)
        output_header.addStretch()  # This pushes the counter to the right
        output_header.addWidget(self.word_counter)

        output_layout.addLayout(output_header)

        # Add discrete search bar
        search_container = QHBoxLayout()
        search_container.setContentsMargins(5, 8, 5, 8)
        
        # Search input field
        self.cleaner_search_input = QLineEdit()
        self.cleaner_search_input.setPlaceholderText("🔍 Search in cleaned text...")
        self.cleaner_search_input.setStyleSheet("""
            QLineEdit {
                border: 1px solid #d0d0d0;
                border-radius: 15px;
                padding: 6px 12px;
                background-color: #f8f9fa;
                font-size: 12px;
                color: #555;
                max-width: 300px;
            }
            QLineEdit:focus {
                border: 1px solid #2196F3;
                background-color: white;
            }
            QLineEdit:hover {
                border: 1px solid #bbb;
            }
        """)
        # Initialize search variables
        self.search_matches = []
        self.current_match_index = -1
        self.search_debounce_timer = QTimer()
        self.search_debounce_timer.setSingleShot(True)
        self.search_debounce_timer.timeout.connect(self.perform_search)
        
        self.cleaner_search_input.textChanged.connect(self.debounced_search)
        
        # Search navigation buttons
        search_prev_btn = QPushButton("↑")
        search_prev_btn.setToolTip("Previous match")
        search_prev_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #d0d0d0;
                border-radius: 12px;
                background-color: #f8f9fa;
                color: #555;
                font-size: 11px;
                font-weight: bold;
                width: 24px;
                height: 24px;
                margin-left: 5px;
            }
            QPushButton:hover {
                background-color: #e9ecef;
                border: 1px solid #bbb;
            }
            QPushButton:pressed {
                background-color: #dee2e6;
            }
        """)
        search_prev_btn.clicked.connect(self.search_previous_cleaner)
        
        search_next_btn = QPushButton("↓")
        search_next_btn.setToolTip("Next match")
        search_next_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #d0d0d0;
                border-radius: 12px;
                background-color: #f8f9fa;
                color: #555;
                font-size: 11px;
                font-weight: bold;
                width: 24px;
                height: 24px;
                margin-left: 2px;
            }
            QPushButton:hover {
                background-color: #e9ecef;
                border: 1px solid #bbb;
            }
            QPushButton:pressed {
                background-color: #dee2e6;
            }
        """)
        search_next_btn.clicked.connect(self.search_next_cleaner)
        
        # Match counter
        self.search_counter = QLabel("")
        self.search_counter.setStyleSheet("""
            color: #777;
            font-size: 11px;
            margin-left: 8px;
        """)
        
        search_container.addWidget(self.cleaner_search_input)
        search_container.addWidget(search_prev_btn)
        search_container.addWidget(search_next_btn)
        search_container.addWidget(self.search_counter)
        search_container.addStretch()
        
        # Add Reset button
        reset_btn = QPushButton("Reset")
        reset_btn.setToolTip("Clear all cleaned text (Warning: Affects Premiere Pro sync)")
        reset_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #dc3545;
                border-radius: 12px;
                background-color: #f8f9fa;
                color: #dc3545;
                font-size: 11px;
                font-weight: bold;
                padding: 4px 12px;
                margin-left: 8px;
            }
            QPushButton:hover {
                background-color: #dc3545;
                color: white;
            }
            QPushButton:pressed {
                background-color: #c82333;
            }
        """)
        reset_btn.clicked.connect(self.reset_cleaned_text)
        search_container.addWidget(reset_btn)
        
        # Add block navigation buttons
        nav_separator = QLabel("|")
        nav_separator.setStyleSheet("color: #ccc; margin: 0 8px; font-weight: bold;")
        search_container.addWidget(nav_separator)
        
        prev_block_btn = QPushButton("◀ Block")
        prev_block_btn.setToolTip("Previous text block (file segment)")
        prev_block_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #6c757d;
                border-radius: 12px;
                background-color: #f8f9fa;
                color: #6c757d;
                font-size: 11px;
                font-weight: bold;
                padding: 4px 8px;
                margin-right: 2px;
            }
            QPushButton:hover {
                background-color: #6c757d;
                color: white;
            }
            QPushButton:pressed {
                background-color: #5a6268;
            }
            QPushButton:disabled {
                color: #ccc;
                border-color: #e9ecef;
                background-color: #f8f9fa;
            }
        """)
        prev_block_btn.clicked.connect(self.navigate_to_previous_block)
        search_container.addWidget(prev_block_btn)
        
        next_block_btn = QPushButton("Block ▶")
        next_block_btn.setToolTip("Next text block (file segment)")
        next_block_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #6c757d;
                border-radius: 12px;
                background-color: #f8f9fa;
                color: #6c757d;
                font-size: 11px;
                font-weight: bold;
                padding: 4px 8px;
                margin-left: 2px;
            }
            QPushButton:hover {
                background-color: #6c757d;
                color: white;
            }
            QPushButton:pressed {
                background-color: #5a6268;
            }
            QPushButton:disabled {
                color: #ccc;
                border-color: #e9ecef;
                background-color: #f8f9fa;
            }
        """)
        next_block_btn.clicked.connect(self.navigate_to_next_block)
        search_container.addWidget(next_block_btn)
        
        # Block counter
        self.block_counter = QLabel("")
        self.block_counter.setStyleSheet("""
            color: #777;
            font-size: 11px;
            margin-left: 8px;
            font-weight: bold;
        """)
        search_container.addWidget(self.block_counter)
        
        # Store references to navigation buttons for enabling/disabling
        self.prev_block_btn = prev_block_btn
        self.next_block_btn = next_block_btn
        
        output_layout.addLayout(search_container)

        self.cleaner_output_text = QTextEdit()
        self.cleaner_output_text.setStyleSheet("""
            QTextEdit {
                border: 1px solid #ADADAD;
                border-radius: 4px;
                margin-bottom: 11px;
                padding: 8px;
                background-color: #FDFDFD;
                font-family: 'Segoe UI', sans-serif;
                font-size: 13px;
                selection-background-color: #2196F3;
                selection-color: white;
            }
        """)
        self.cleaner_output_text.setPlaceholderText("Text with Removed Timecodes will Appear Here")
        self.cleaner_output_text.setReadOnly(True)
        
        # Override cursor behavior completely - target the viewport
        self.cleaner_output_text.setCursor(Qt.CursorShape.ArrowCursor)
        self.cleaner_output_text.viewport().setCursor(Qt.CursorShape.ArrowCursor)
        
        def force_arrow_cursor_output(event):
            self.cleaner_output_text.setCursor(Qt.CursorShape.ArrowCursor)
            self.cleaner_output_text.viewport().setCursor(Qt.CursorShape.ArrowCursor)
            return QTextEdit.mouseMoveEvent(self.cleaner_output_text, event)
        
        def force_arrow_enter_output(event):
            self.cleaner_output_text.setCursor(Qt.CursorShape.ArrowCursor)
            self.cleaner_output_text.viewport().setCursor(Qt.CursorShape.ArrowCursor)
            return QTextEdit.enterEvent(self.cleaner_output_text, event)
        
        self.cleaner_output_text.mouseMoveEvent = force_arrow_cursor_output
        self.cleaner_output_text.enterEvent = force_arrow_enter_output

        # Connect text changed signal to update counter and block navigation
        self.cleaner_output_text.textChanged.connect(self.update_word_count)
        self.cleaner_output_text.textChanged.connect(lambda: QTimer.singleShot(50, self.update_block_navigation))

        output_layout.addWidget(self.cleaner_output_text)

        # --- Bottom row container - MOVED BUTTON HERE ---
        bottom_row = QHBoxLayout()
        bottom_row.setContentsMargins(0, 10, 10, 20)
        bottom_row.setSpacing(2) # Add spacing between buttons

        # Percentage section (centered)
        percentage_container = QWidget()
        percentage_layout = QHBoxLayout(percentage_container)
        percentage_layout.setContentsMargins(0, 0, 0, 0)
        percentage_layout.addStretch()

        # Add label
        percentage_label = QLabel("Select Text by Portions:")
        percentage_label.setStyleSheet("""
            QLabel {
                color: #666666;
                font-size: 11px;
                margin-right:6px;
            }
        """)
        percentage_layout.addWidget(percentage_label)

        # Style for percentage buttons
        percentage_button_style = """
            QPushButton {
                background-color: #f0f0f0;
                color: #203740;
                border: 1px solid #dadada;
                border-radius: 3px;
                padding: 3px;
                font-size: 11px;
                min-width: 35px;
                max-width: 35px;
            }
            QPushButton:hover {
                background-color: #e3e3e3;
            }
            QPushButton:pressed {
                background-color: #d6d6d6;
            }
            QPushButton:disabled {
                color: #BDBDBD;
                background-color: #f5f5f5;
            }
        """

        # Style for section labels
        section_label_style = """
            QLabel {
                color: #666666;
                font-size: 11px;
                font-weight: bold;
            }
        """

        # Halves section
        halves_section = QWidget()
        halves_layout = QVBoxLayout(halves_section)
        halves_layout.setSpacing(2)
        halves_layout.setContentsMargins(0, 0, 0, 0)

        halves_label = QLabel("Halves")
        halves_label.setStyleSheet(section_label_style)
        halves_layout.addWidget(halves_label, alignment=Qt.AlignmentFlag.AlignCenter)

        halves_buttons = QWidget()
        halves_buttons_layout = QHBoxLayout(halves_buttons)
        halves_buttons_layout.setSpacing(2)
        halves_buttons_layout.setContentsMargins(0, 0, 0, 0)

        self.first_half_button = QPushButton("1st")
        self.second_half_button = QPushButton("2nd")

        for button in [self.first_half_button, self.second_half_button]:
            button.setStyleSheet(percentage_button_style)
            button.setEnabled(False)
            halves_buttons_layout.addWidget(button)

        halves_layout.addWidget(halves_buttons)
        percentage_layout.addWidget(halves_section)

        # Add separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.VLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        separator.setStyleSheet("QFrame { color: #cccccc; }")
        separator.setFixedWidth(1)
        percentage_layout.addWidget(separator)

        # Quarters section
        quarters_section = QWidget()
        quarters_layout = QVBoxLayout(quarters_section)
        quarters_layout.setSpacing(2)
        quarters_layout.setContentsMargins(0, 0, 0, 0)

        quarters_label = QLabel("Quarters")
        quarters_label.setStyleSheet(section_label_style)
        quarters_layout.addWidget(quarters_label, alignment=Qt.AlignmentFlag.AlignCenter)

        quarters_buttons = QWidget()
        quarters_buttons_layout = QHBoxLayout(quarters_buttons)
        quarters_buttons_layout.setSpacing(2)
        quarters_buttons_layout.setContentsMargins(0, 0, 0, 0)

        self.first_quarter_button = QPushButton("1st")
        self.second_quarter_button = QPushButton("2nd")
        self.third_quarter_button = QPushButton("3rd")
        self.fourth_quarter_button = QPushButton("4th")

        quarter_buttons = [
            self.first_quarter_button, self.second_quarter_button,
            self.third_quarter_button, self.fourth_quarter_button
        ]

        for button in quarter_buttons:
            button.setStyleSheet(percentage_button_style)
            button.setEnabled(False)
            quarters_buttons_layout.addWidget(button)

        quarters_layout.addWidget(quarters_buttons)
        percentage_layout.addWidget(quarters_section)
        percentage_layout.addStretch() # Keep stretch after percentage section

        # Create the image-only caption reorganizer button
        self.captions_reorganizer_button = QPushButton()
        self.captions_reorganizer_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.captions_reorganizer_button.clicked.connect(self.show_transcriber_options)
        self.captions_reorganizer_button.setFixedSize(50, 50)

        # Define the button's event filter class for hover detection
        class ButtonHoverFilter(QObject):
            def __init__(self, parent=None, normal_icon=None, hover_icon=None):
                super().__init__(parent)
                self.normal_icon = normal_icon
                self.hover_icon = hover_icon
                self.parent_button = parent

            def eventFilter(self, obj, event):
                if event.type() == QEvent.Type.Enter:
                    # Mouse entered - show hover icon
                    if self.hover_icon:
                        self.parent_button.setIcon(QIcon(self.hover_icon))
                    return True
                elif event.type() == QEvent.Type.Leave:
                    # Mouse left - show normal icon
                    if self.normal_icon:
                        self.parent_button.setIcon(QIcon(self.normal_icon))
                    return True
                return False

        # Load the normal state image
        try:
            normal_icon = QPixmap("Img/captions-transcriber.png")
            hover_icon = QPixmap("Img/captions-transcriber-hover.png")
    
            if not normal_icon.isNull() and not hover_icon.isNull():
                # Set the initial normal icon
                self.captions_reorganizer_button.setIcon(QIcon(normal_icon))
                self.captions_reorganizer_button.setIconSize(QSize(50, 50))
        
                # Create and install the event filter
                hover_filter = ButtonHoverFilter(self.captions_reorganizer_button, normal_icon, hover_icon)
                self.captions_reorganizer_button.installEventFilter(hover_filter)
        
                # Store the filter as an attribute to prevent garbage collection
                self.captions_reorganizer_button.hover_filter = hover_filter
            else:
                print("Failed to load one or both caption reorganizer images")
        except Exception as e:
            print(f"Error loading caption reorganizer images: {str(e)}")

        # Create a custom event filter for the button
        class InstantTooltipFilter(QObject):
            def eventFilter(self, obj, event):
                # In PyQt6, use QEvent.Type.ToolTip instead of QEvent.ToolTip
                if event.type() == QEvent.Type.ToolTip:
                    from PyQt6.QtWidgets import QToolTip
                    QToolTip.showText(event.globalPos(), obj.toolTip())
                    return True
                return False

        # Set the basic tooltip
        self.captions_reorganizer_button.setToolTip("Caption Reorganizer")
        self.captions_reorganizer_button.setToolTipDuration(1)  # Set to minimum value (1 ms)

        # Install the event filter on the button
        instant_tooltip_filter = InstantTooltipFilter(self.captions_reorganizer_button)
        self.captions_reorganizer_button.installEventFilter(instant_tooltip_filter)

        # Apply styling for the tooltip appearance
        self.captions_reorganizer_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QToolTip {
                background-color: #F0F0F0;
                color: #333333;
                border: 1px solid #CCCCCC;
                border-radius: 2px;
                padding: 2px;
                opacity: 255;
                font-size: 11px;
            }
        """)

        # --- Add percentage section and caption reorganizer to bottom row ---
        bottom_row.addWidget(percentage_container) # Percentage section
        bottom_row.addStretch(1) # Add stretch here to push caption reorganizer to the right
        bottom_row.addWidget(self.captions_reorganizer_button) # Caption Reorganizer button

        # Add bottom row to output layout
        output_layout.addLayout(bottom_row)

        # Add all containers to content layout
        content_layout.addWidget(input_container, stretch=2)
        content_layout.addWidget(center_container)
        content_layout.addWidget(output_container, stretch=3)

        # Add content layout to main layout
        layout.addLayout(content_layout)

        # Connect signals
        self.clean_button.clicked.connect(self.clean_transcript)
        #self.clean_save_button.clicked.connect(self.save_cleaned_transcript)

        # Connect percentage buttons
        self.first_quarter_button.clicked.connect(lambda: self.select_quarter(0))
        self.second_quarter_button.clicked.connect(lambda: self.select_quarter(1))
        self.third_quarter_button.clicked.connect(lambda: self.select_quarter(2))
        self.fourth_quarter_button.clicked.connect(lambda: self.select_quarter(3))
        self.first_half_button.clicked.connect(lambda: self.select_half(0))
        self.second_half_button.clicked.connect(lambda: self.select_half(1))

        self.cleaner_widget.setLayout(layout)
        self.tabs.addTab(self.cleaner_widget, 'Process Captions') # Original tab name was 'Cleaner'

        # Rename the tab to 'Process Captions'
        cleaner_tab_index = -1
        for i in range(self.tabs.count()):
            if self.tabs.widget(i) == self.cleaner_widget:
                cleaner_tab_index = i
                break
        if cleaner_tab_index != -1:
            self.tabs.setTabText(cleaner_tab_index, 'Process Captions')

    def update_word_count(self):
        text = self.cleaner_output_text.toPlainText().strip()
        if text:
            words = len([word for word in text.split() if word])
        else:
            words = 0

        # Base style with different colors based on word count
        if words >= 4000:
            style = """
                color: #d32f2f;  /* Red */                
                font-size: 13px;
                font-weight: 500;
                padding-right:5px;
                margin:right: 10px;
            """
            self.word_counter.setStyleSheet(style)
            self.word_counter.setText(f"Words: {words:,}")
            self.word_counter.setToolTipDuration(10000)  # Show for 10 seconds
            self.word_counter.setStyleSheet(style + """
                QToolTip {
                    max-width: 300px;               
                    padding: 8px;
                    font-size: 11px;
                    line-height: 1.3;
                }
            """)
            self.word_counter.setToolTip(
                "Length exceeds 4,000 words.\n"
                "Consider the quarter selection buttons\n"
                "to process text in smaller segments."
            )
        elif words >= 2000:
            style = """
                color: #f57c00;  /* Orange */
                font-size: 13px;
                font-weight: 500;
                padding-right:5px;
                margin-right: 10px;
            """
            self.word_counter.setStyleSheet(style + """
                QToolTip {
                    max-width: 300px;
                    padding: 8px;
                    font-size: 11px;
                    line-height: 1.3;
                }
            """)
            self.word_counter.setText(f"Words: {words:,}")
            self.word_counter.setToolTipDuration(10000)  # Show for 10 seconds
            self.word_counter.setToolTip(
                "Length exceeds 2,000 words.\n"
                "Consder the half selection buttons\n"
                "to process text in smaller segments."
            )
        else:
            style = """
                color: #666666;
                font-size: 13px;
                font-weight: 500;
                padding-right:5px;
                margin-right: 10px;
            """
            self.word_counter.setStyleSheet(style)
            self.word_counter.setText(f"Words: {words:,}")
            self.word_counter.setToolTip("")

    def format_file_headers(self):
        """Apply bold and highlighted formatting to file headers in QTextEdit"""
        document = self.cleaner_input_text.document()
        cursor = QTextCursor(document)
        
        # Find and format all headers that match the pattern "[[filename]]"
        text = document.toPlainText()
        lines = text.split('\n')
        
        cursor.setPosition(0)
        for line_num, line in enumerate(lines):
            if line.strip().startswith('[[') and line.strip().endswith(']]'):
                # Find this line in the document
                cursor = QTextCursor(document)
                cursor.setPosition(0)
                
                # Move to the correct line
                for i in range(line_num):
                    cursor.movePosition(QTextCursor.MoveOperation.Down)
                
                # Select the entire line
                cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)
                cursor.movePosition(QTextCursor.MoveOperation.EndOfLine, QTextCursor.MoveMode.KeepAnchor)
                
                # Apply formatting: bold + background color
                format = QTextCharFormat()
                format.setFontWeight(QFont.Weight.Bold)
                format.setBackground(QColor("#e3f2fd"))  # Light blue background
                format.setForeground(QColor("#1976d2"))  # Dark blue text
                cursor.mergeCharFormat(format)

    def format_text_with_headers(self, text):
        """Format text with HTML styling for file headers"""
        try:
            # Escape HTML characters in the text first
            import html
            escaped_text = html.escape(text)
            
            # Replace [[filename]] patterns with formatted HTML
            pattern = r'\[\[([^\]]+)\]\]'
            formatted_text = re.sub(
                pattern,
                r'<span style="font-weight: bold; background-color: #e3f2fd; color: #1976d2;">[[\1]]</span>',
                escaped_text
            )
            
            # Convert newlines to HTML breaks and wrap in a div
            formatted_text = formatted_text.replace('\n', '<br>')
            return f'<div style="white-space: pre-wrap;">{formatted_text}</div>'
            
        except Exception as e:
            print(f"Error formatting text with headers: {e}")
            # Return plain text if formatting fails
            return text.replace('\n', '<br>')

    def debounced_search(self, text):
        """Debounce search input to avoid excessive processing"""
        # Stop the current timer if it's running
        self.search_debounce_timer.stop()
        
        # Store the search text for the timer
        self.pending_search_text = text
        
        # If search is empty, clear immediately (no debounce needed)
        if not text.strip():
            self.clear_search_highlighting()
            return
        
        # Start debounce timer (300ms delay)
        self.search_debounce_timer.start(300)
    
    def perform_search(self):
        """Perform the actual search after debounce delay"""
        text = self.pending_search_text.strip()
        if not text:
            self.clear_search_highlighting()
            return
        
        # Clear previous highlighting efficiently
        self.clear_search_highlighting()
        
        # Find all matches using more efficient method
        document = self.cleaner_output_text.document()
        self.search_matches = []
        self.current_match_index = -1
        
        # Use QTextDocument.find for better performance
        cursor = QTextCursor(document)
        text_lower = text.lower()
        document_text = document.toPlainText().lower()
        
        # Find matches using string search (faster than QTextCursor.find for many matches)
        start_pos = 0
        while True:
            pos = document_text.find(text_lower, start_pos)
            if pos == -1:
                break
            self.search_matches.append(pos)
            start_pos = pos + 1
        
        if self.search_matches:
            # Apply highlighting in batches for better performance
            self.apply_search_highlighting(text)
            self.current_match_index = 0
            self.scroll_to_current_match()
            self.update_search_counter()
        else:
            self.search_counter.setText("No matches")
    
    def clear_search_highlighting(self):
        """Efficiently clear all search highlighting"""
        # Save cursor position
        cursor = self.cleaner_output_text.textCursor()
        saved_position = cursor.position()
        
        # Clear all formatting efficiently
        cursor.select(QTextCursor.SelectionType.Document)
        format = QTextCharFormat()
        format.setBackground(QColor("transparent"))
        cursor.mergeCharFormat(format)
        
        # Restore cursor position
        cursor.setPosition(saved_position)
        self.cleaner_output_text.setTextCursor(cursor)
        
        # Clear state
        self.search_matches = []
        self.current_match_index = -1
        self.search_counter.setText("")
    
    def apply_search_highlighting(self, search_text):
        """Apply highlighting to all matches efficiently"""
        document = self.cleaner_output_text.document()
        
        # Create formats once
        all_matches_format = QTextCharFormat()
        all_matches_format.setBackground(QColor("#ffeb3b"))  # Yellow
        
        # Apply highlighting to all matches in one operation
        cursor = self.cleaner_output_text.textCursor()
        for match_pos in self.search_matches:
            cursor.setPosition(match_pos)
            cursor.setPosition(match_pos + len(search_text), QTextCursor.MoveMode.KeepAnchor)
            cursor.mergeCharFormat(all_matches_format)
    
    def highlight_current_match(self):
        """Highlight only the current match with orange (more efficient)"""
        if not self.search_matches or self.current_match_index < 0:
            return
        
        search_text = self.cleaner_search_input.text()
        
        # Re-apply yellow to all matches first (only if needed)
        self.apply_search_highlighting(search_text)
        
        # Highlight current match in orange
        current_pos = self.search_matches[self.current_match_index]
        cursor = self.cleaner_output_text.textCursor()
        cursor.setPosition(current_pos)
        cursor.setPosition(current_pos + len(search_text), QTextCursor.MoveMode.KeepAnchor)
        
        current_format = QTextCharFormat()
        current_format.setBackground(QColor("#ff9800"))  # Orange
        cursor.mergeCharFormat(current_format)
        
        self.scroll_to_current_match()
        self.update_search_counter()
    
    def scroll_to_current_match(self):
        """Scroll to the current match"""
        if not self.search_matches or self.current_match_index < 0:
            return
        
        current_pos = self.search_matches[self.current_match_index]
        cursor = self.cleaner_output_text.textCursor()
        cursor.setPosition(current_pos)
        self.cleaner_output_text.setTextCursor(cursor)
        self.cleaner_output_text.ensureCursorVisible()
    
    def update_search_counter(self):
        """Update the search counter display"""
        if self.search_matches:
            if self.current_match_index >= 0:
                self.search_counter.setText(f"{self.current_match_index + 1} of {len(self.search_matches)}")
            else:
                self.search_counter.setText(f"{len(self.search_matches)} matches")
        else:
            self.search_counter.setText("No matches")
    
    def search_next_cleaner(self):
        """Go to next search match (optimized)"""
        if not self.search_matches:
            return
        
        self.current_match_index = (self.current_match_index + 1) % len(self.search_matches)
        self.highlight_current_match()
    
    def search_previous_cleaner(self):
        """Go to previous search match (optimized)"""
        if not self.search_matches:
            return
        
        self.current_match_index = (self.current_match_index - 1) % len(self.search_matches)
        self.highlight_current_match()

    def select_half(self, half_index):
        """Handle selection of first or second half of text"""
        # Ensure we have current block quarters calculated
        if hasattr(self, 'text_blocks') and self.text_blocks and hasattr(self, 'current_block_index') and self.current_block_index >= 0:
            self.calculate_quarters()  # Recalculate for current block
            
        if not hasattr(self, 'quarter_positions') or not self.quarter_positions:
            return

        if half_index == 0:  # First half
            start = self.quarter_positions[0][0]  # Start of first quarter
            end = self.quarter_positions[1][1]    # End of second quarter
        else:  # Second half
            start = self.quarter_positions[2][0]  # Start of third quarter
            end = self.quarter_positions[3][1]    # End of fourth quarter

        cursor = self.cleaner_output_text.textCursor()
        cursor.setPosition(start)
        cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)
        self.cleaner_output_text.setTextCursor(cursor)
        self.cleaner_output_text.ensureCursorVisible()

    def clean_transcript(self):
        input_text = self.cleaner_input_text.toPlainText()
        if not input_text.strip():
            QMessageBox.warning(self, 'Input Error', 'Please provide transcript text to clean.')
            return
            
        # Remove BOM (Byte Order Mark) that often appears in SRT files
        if input_text.startswith('\ufeff'):
            input_text = input_text[1:]

        lines = input_text.split('\n')
        cleaned_lines = []

        # Pattern for standard timecodes (e.g., 00:12:34:56 - 00:12:40:12)
        timecode_pattern = r'^\d{2}[;:]\d{2}[;:]\d{2}[;:]\d{2}\s*-\s*\d{2}[;:]\d{2}[;:]\d{2}[;:]\d{2}'
        
        # Pattern for SRT timecodes (e.g., 00:00:03,878 --> 00:00:05,422)
        srt_timecode_pattern = r'^\d{2}:\d{2}:\d{2},\d{3}\s*-->\s*\d{2}:\d{2}:\d{2},\d{3}'
        
        # Pattern for SRT sequence numbers (just a number on its own line, with possible whitespace)
        srt_sequence_pattern = r'^\s*\d+\s*$'

        for line in lines:
            # Remove all whitespace and control characters for processing
            clean_line = line.strip()
            if not clean_line:
                continue

            # Skip SRT sequence numbers (1, 2, 3, etc.) - even with invisible characters
            if re.match(srt_sequence_pattern, clean_line):
                continue
                
            # Handle standard timecodes
            if re.match(timecode_pattern, clean_line):
                text_parts = re.split(timecode_pattern, clean_line, maxsplit=1)
                if len(text_parts) > 1 and text_parts[1].strip():
                    cleaned_lines.append(text_parts[1].strip())
            # Handle SRT timecodes 
            elif re.match(srt_timecode_pattern, clean_line):
                # Skip SRT timecode lines entirely
                continue
            else:
                # This is actual text content - keep it
                if clean_line:
                    cleaned_lines.append(clean_line)

        cleaned_text = '\n'.join(cleaned_lines)
        
        # Validate the operation before processing
        if not self.validate_process_operation(cleaned_text):
            return
            
        # Check if we need to append to existing text
        current_text = self.cleaner_output_text.toPlainText().strip()
        if current_text:
            # Append new text below existing text
            combined_text = current_text + '\n\n' + cleaned_text
            formatted_text = self.format_text_with_headers(combined_text)
        else:
            # Format file headers before setting text
            formatted_text = self.format_text_with_headers(cleaned_text)
            
        self.cleaner_output_text.setHtml(formatted_text)
        
        # Update block navigation after processing
        QTimer.singleShot(100, self.update_block_navigation)
        
        self.status_bar.showMessage('Transcript cleaned successfully!', 5000)

        # Enable all quarter and half buttons
        for button in [
            self.first_quarter_button, self.second_quarter_button,
            self.third_quarter_button, self.fourth_quarter_button,
            self.first_half_button, self.second_half_button
        ]:
            button.setEnabled(True)

        self.calculate_quarters(cleaned_text)
        
        # Show success dialog and offer to open Captions Reorganizer
        self.show_cleaning_success_dialog()

    def calculate_quarters(self, full_text=None):
        self.quarter_positions = []

        # Get text from current block if no text provided
        if full_text is None:
            if hasattr(self, 'text_blocks') and self.text_blocks and hasattr(self, 'current_block_index') and self.current_block_index >= 0:
                current_block = self.text_blocks[self.current_block_index]
                # Extract just the content part (without header)
                full_text_content = self.cleaner_output_text.toPlainText()
                block_text = full_text_content[current_block['content_start']:current_block['content_end']].strip()
                block_offset = current_block['content_start']
            else:
                # Fallback to entire text if no current block
                block_text = self.cleaner_output_text.toPlainText().strip()
                block_offset = 0
        else:
            # Use provided text (legacy behavior for initial processing)
            block_text = full_text
            block_offset = 0

        if not block_text.strip():
            self.quarter_positions = [(0,0),(0,0),(0,0),(0,0)]
            return

        length = len(block_text)
        quarter_len = length / 4.0
        boundaries = []
        start_idx = 0

        for i in range(1,5):
            if i == 4:
                boundaries.append((start_idx + block_offset, length + block_offset))
                break

            approximate_pos = int(i * quarter_len)
            boundary = self.find_sentence_boundary(block_text, approximate_pos, start_idx, length)
            if boundary is None:
                boundary = length
            boundaries.append((start_idx + block_offset, boundary + block_offset))
            start_idx = boundary

        self.quarter_positions = boundaries

    def find_sentence_boundary(self, text, approximate_pos, start_idx, end_idx):
        search_limit = min(approximate_pos + 200, end_idx)
        chunk = text[approximate_pos:search_limit]

        period_pos = chunk.find('.')
        if period_pos != -1:
            return approximate_pos + period_pos + 1
        else:
            space_pos = chunk.find(' ')
            if space_pos != -1:
                return approximate_pos + space_pos
            return approximate_pos if approximate_pos < end_idx else end_idx

    def select_quarter(self, quarter_index):
        # Ensure we have current block quarters calculated
        if hasattr(self, 'text_blocks') and self.text_blocks and hasattr(self, 'current_block_index') and self.current_block_index >= 0:
            self.calculate_quarters()  # Recalculate for current block
        
        if not hasattr(self, 'quarter_positions') or not self.quarter_positions:
            return

        if quarter_index < 0 or quarter_index > 3:
            return

        start, end = self.quarter_positions[quarter_index]
        cursor = self.cleaner_output_text.textCursor()
        cursor.setPosition(start)
        cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)
        self.cleaner_output_text.setTextCursor(cursor)
        self.cleaner_output_text.ensureCursorVisible()


    def open_transcript(self):
        file_name, _ = QFileDialog.getOpenFileName(
            self, "Open Text File", "", "Text Files (*.txt);;All Files (*)"
        )
        if file_name:
            try:
                with open(file_name, 'r', encoding='utf-8') as file:
                    content = file.read()
                    self.cleaner_input_text.setPlainText(content)
                self.status_bar.showMessage(f'Loaded text file: {file_name}', 5000)
            except Exception as e:
                QMessageBox.critical(self, 'Error', f'Could not open file: {str(e)}')

    def save_cleaned_transcript(self):
        cleaned_text = self.cleaner_output_text.toPlainText()
        if not cleaned_text.strip():
            QMessageBox.warning(self, 'Output Error', 'No cleaned text to save.')
            return

        file_name, _ = QFileDialog.getSaveFileName(
            self, "Export Text", "", "Text Files (*.txt);;All Files (*)"
        )
        if file_name:
            try:
                with open(file_name, 'w', encoding='utf-8') as file:
                    file.write(cleaned_text)
                self.status_bar.showMessage(f'Saved cleaned text to: {file_name}', 5000)
            except Exception as e:
                QMessageBox.critical(self, 'Error', f'Could not save file: {str(e)}')

    def reset_cleaned_text(self):
        """Reset/clear the cleaned text with warning about Premiere Pro sync"""
        if not self.cleaner_output_text.toPlainText().strip():
            # No text to clear
            return
            
        reply = QMessageBox.warning(
            self,
            'Reset Cleaned Text',
            'If you delete this text, Scriptoria will no longer be able to sync the following text with Adobe Premiere Pro when dragging and dropping annotations into Premiere.\n\nDo you want to continue?',
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            self.cleaner_output_text.clear()
            # Disable quarter and half buttons since there's no text
            for button in [
                getattr(self, 'first_quarter_button', None), 
                getattr(self, 'second_quarter_button', None),
                getattr(self, 'third_quarter_button', None), 
                getattr(self, 'fourth_quarter_button', None),
                getattr(self, 'first_half_button', None), 
                getattr(self, 'second_half_button', None)
            ]:
                if button:
                    button.setEnabled(False)
            # Update block navigation since text is cleared
            self.update_block_navigation()
            self.status_bar.showMessage('Cleaned text cleared', 3000)

    def clear_input_text(self):
        """Clear the original video captions input text"""
        reply = QMessageBox.question(
            self,
            'Clear Input Text',
            'Are you sure you want to clear all original video captions text?',
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # Clear the text content
            self.cleaner_input_text.clear()
            # Reset the flag
            self.cleaner_input_has_real_content = False
            self.status_bar.showMessage('Input text cleared', 3000)

    def validate_process_operation(self, new_text):
        """Validate processing operation - check for existing text and duplicates"""
        current_text = self.cleaner_output_text.toPlainText().strip()
        new_text = new_text.strip()
        
        if not new_text:
            return False
            
        # Check if the new text already exists entirely in current text
        if current_text and new_text in current_text:
            QMessageBox.information(
                self,
                'Duplicate Text Detected',
                'The cleaned text already exists in the cleaned text section. Processing blocked to prevent duplication.',
                QMessageBox.StandardButton.Ok
            )
            return False
            
        # If there's existing text, warn about appending
        if current_text:
            reply = QMessageBox.question(
                self,
                'Existing Text Found',
                'Cleaned captions will be added below the existing text.\n\nDo you want to continue?',
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            return reply == QMessageBox.StandardButton.Yes
            
        return True

    def find_text_blocks(self):
        """Find all text blocks marked with [[filename]] patterns"""
        text = self.cleaner_output_text.toPlainText()
        if not text.strip():
            return []
            
        # Pattern to match [[filename]] headers
        pattern = r'\[\[([^\]]+)\]\]'
        blocks = []
        
        # Find all matches and their positions
        matches = list(re.finditer(pattern, text))
        if not matches:
            return []
            
        for i, match in enumerate(matches):
            start_pos = match.start()
            
            # Find the end of this block (start of next block or end of text)
            if i + 1 < len(matches):
                end_pos = matches[i + 1].start() - 1  # Just before next block
            else:
                end_pos = len(text)  # End of text
                
            # Find the end of the current line to start selecting content after the header
            header_end = text.find('\n', start_pos)
            if header_end == -1:
                header_end = start_pos + len(match.group(0))
            else:
                header_end += 1  # Include the newline
                
            blocks.append({
                'filename': match.group(1),
                'header_start': start_pos,
                'header_end': header_end,
                'content_start': header_end,
                'content_end': end_pos,
                'full_start': start_pos,
                'full_end': end_pos
            })
            
        return blocks

    def update_block_navigation(self):
        """Update block navigation buttons and counter"""
        if not hasattr(self, 'prev_block_btn') or not hasattr(self, 'next_block_btn'):
            return
            
        self.text_blocks = self.find_text_blocks()
        
        if not self.text_blocks:
            # No blocks found - disable navigation
            self.prev_block_btn.setEnabled(False)
            self.next_block_btn.setEnabled(False)
            self.block_counter.setText("")
            self.current_block_index = -1
            return
            
        # Initialize current block index if not set
        if not hasattr(self, 'current_block_index'):
            self.current_block_index = 0
            
        # Ensure index is within bounds
        if self.current_block_index >= len(self.text_blocks):
            self.current_block_index = 0
        elif self.current_block_index < 0:
            self.current_block_index = len(self.text_blocks) - 1
            
        # Update button states - enable if there's at least one block
        self.prev_block_btn.setEnabled(len(self.text_blocks) >= 1)
        self.next_block_btn.setEnabled(len(self.text_blocks) >= 1)
        
        # Update counter
        if self.text_blocks:
            total_blocks = len(self.text_blocks)
            current_num = self.current_block_index + 1 if self.current_block_index >= 0 else 1
            current_filename = self.text_blocks[self.current_block_index]['filename'] if self.current_block_index >= 0 else ""
            self.block_counter.setText(f"Block {current_num}/{total_blocks}: {current_filename}")

    def navigate_to_previous_block(self):
        """Navigate to the previous text block"""
        if not hasattr(self, 'text_blocks') or not self.text_blocks:
            self.update_block_navigation()
            if not self.text_blocks:
                return
                
        self.current_block_index = (self.current_block_index - 1) % len(self.text_blocks)
        self.select_current_block()
        self.update_block_navigation()

    def navigate_to_next_block(self):
        """Navigate to the next text block"""
        if not hasattr(self, 'text_blocks') or not self.text_blocks:
            self.update_block_navigation()
            if not self.text_blocks:
                return
                
        self.current_block_index = (self.current_block_index + 1) % len(self.text_blocks)
        self.select_current_block()
        self.update_block_navigation()

    def select_current_block(self):
        """Select the entire current text block"""
        if not hasattr(self, 'text_blocks') or not self.text_blocks or self.current_block_index < 0:
            return
            
        if self.current_block_index >= len(self.text_blocks):
            self.current_block_index = 0
            
        block = self.text_blocks[self.current_block_index]
        
        # Select the entire block (header + content)
        cursor = self.cleaner_output_text.textCursor()
        cursor.setPosition(block['full_start'])
        cursor.setPosition(block['full_end'], QTextCursor.MoveMode.KeepAnchor)
        
        self.cleaner_output_text.setTextCursor(cursor)
        self.cleaner_output_text.ensureCursorVisible()
        
        # Recalculate quarters for the current block
        self.calculate_quarters()

    def create_menu(self):
        menubar = self.menuBar()
    
        # Create a container widget for the entire menubar
        menubar_container = QWidget(self)  # Add parent
        menubar_layout = QHBoxLayout(menubar_container)
        menubar_layout.setContentsMargins(0, 0, 10, 0)
        menubar_layout.setSpacing(0)
    
        # Create File menu
        file_menu = menubar.addMenu('&File')  # Add mnemonic
    
        # Session management actions
        new_session_action = QAction('&New Session', self)  # Add parent and mnemonic
        new_session_action.setShortcut('Ctrl+N')
        new_session_action.triggered.connect(self.new_session)
        file_menu.addAction(new_session_action)
    
        load_session_action = QAction('&Load Session', self)  # Add parent and mnemonic
        load_session_action.setShortcut('Ctrl+O')
        load_session_action.triggered.connect(self.load_session)
        file_menu.addAction(load_session_action)
    
        save_session_action = QAction('&Save', self)  # Add parent and mnemonic
        save_session_action.setShortcut('Ctrl+S')
        save_session_action.triggered.connect(self.save_session)
        file_menu.addAction(save_session_action)
    
        save_session_as_action = QAction('Save &As...', self)  # Add parent and mnemonic
        save_session_as_action.setShortcut('Ctrl+Shift+S')
        save_session_as_action.triggered.connect(lambda: self.save_session(save_as=True))
        file_menu.addAction(save_session_as_action)
    
        file_menu.addSeparator()
    
        # Existing menu items
        #open_action = QAction('Open Text &File', self)  # Add parent and mnemonic
        #open_action.triggered.connect(self.open_file)
        #file_menu.addAction(open_action)
    
        save_action = QAction('Save Trancript as &HTML', self)  # Add parent and mnemonic
        save_action.triggered.connect(self.save_output)
        file_menu.addAction(save_action)

        # Add separator and Manage Gemini API Keys option
        file_menu.addSeparator()
        manage_gemini_action = QAction('Manage &Gemini API Keys', self)
        manage_gemini_action.triggered.connect(self.manage_gemini_keys)
        file_menu.addAction(manage_gemini_action)
        
        # Add Settings option
        settings_action = QAction('&Settings...', self)
        settings_action.triggered.connect(self.show_settings_dialog)
        file_menu.addAction(settings_action)

        # file_menu.addSeparator()

        # exit_action = QAction('E&xit', self)  # Add parent and mnemonic
        # exit_action.triggered.connect(self.close)
        # file_menu.addAction(exit_action)
    
        # Set menubar stylesheet to accommodate logo
        menubar.setStyleSheet("""
            QMenuBar {
                background: transparent;
                spacing: 0px;
                padding: 0px;
            }
            QMenuBar::item {
                padding: 4px 8px;
                background: transparent;
            }
            QMenuBar::item:selected {
                background: #e0e0e0;
            }
            QMenuBar::item:pressed {
                background: #d0d0d0;
            }
            QMenu {
                background-color: white;
                border: 1px solid #d0d0d0;
            }
            QMenu::item {
                padding: 6px 20px;
            }
            QMenu::item:selected {
                background-color: #e0e0e0;
            }
        """)
    
        # Add the custom widget to the menubar
        menubar.setCornerWidget(menubar_container, Qt.Corner.TopRightCorner)


    def check_unsaved_changes(self):
        if self.has_unsaved_changes():  # You'll need to implement this method
            reply = QMessageBox.question(
                self,
                'Unsaved Changes',
                'Do you want to save your changes before closing this session?',
                QMessageBox.StandardButton.Save | 
                QMessageBox.StandardButton.Discard | 
                QMessageBox.StandardButton.Cancel
            )
            
            if reply == QMessageBox.StandardButton.Save:
                return self.save_session()
            elif reply == QMessageBox.StandardButton.Cancel:
                return False
                
        return True
        
    def has_unsaved_changes(self):
        """
        Returns True if there are unsaved changes, based solely on the changes_pending flag.
        """
        try:
            # Simply check if changes_pending is True
            # If changes_pending hasn't been set anywhere, getattr will default to False
            return getattr(self, 'changes_pending', False)
        
        except Exception as e:
            print(f"Error in has_unsaved_changes: {e}")
            import traceback
            traceback.print_exc()
            # Return True to be safe
            return True


    # def get_current_state(self):
    #     """Get the current state of all content with optimized performance."""
    #     try:
    #         # Helper to detect text changes
    #         def get_text_if_changed(widget, cached_hash):
    #             current_text = widget.toPlainText()
    #             current_hash = hash(current_text)
    #             if current_hash != cached_hash:
    #                 self._cached_hashes[widget] = current_hash
    #                 return current_text
    #             return None

    #         # Init caches if needed
    #         if not hasattr(self, '_cached_hashes'):
    #             self._cached_hashes = {}
    #             self._cached_state = {}

    #         # 1) Detect text changes including HTML content
    #         text_changes = {}
    #         for field, widget in [
    #             ('cleaner_input', self.cleaner_input_text),
    #             ('cleaner_output', self.cleaner_output_text),
    #             ('input', self.input_text)
    #             #('preview_html', self.output_text)  # Track HTML content changes
    #         ]:
    #             if new_text := get_text_if_changed(widget, self._cached_hashes.get(widget, None)):
    #                 text_changes[field] = new_text

    #         # 2) Detect bookmark changes
    #         bookmarks_changed = False
    #         bookmarks_data = []
    #         if hasattr(self, 'bookmark_panel') and self.bookmark_panel:
    #             bookmarks_data = self.bookmark_panel.get_bookmarks_data()
    #             bookmarks_hash = hash(str(bookmarks_data))
    #             if bookmarks_hash != self._cached_hashes.get('bookmarks'):
    #                 bookmarks_changed = True

    #         # 3) Script Editor changes?
    #         storyboard_has_changes = (
    #             hasattr(self, 'storyboard_dialog') and
    #             self.storyboard_dialog and
    #             self.storyboard_dialog.changes_pending
    #         )

    #         # 4) Early return if NOTHING changed
    #         if (
    #             not text_changes
    #             and self._cached_state.get('annotation_count') == len(self.web_view.annotations)
    #             and not bookmarks_changed
    #             and not storyboard_has_changes
    #         ):
    #             return self._cached_state.copy()

    #         # 5) Build the new state
    #         current_state = self._cached_state.copy()

    #         # Update text fields
    #         current_state.update(text_changes)

    #         # Update annotations if needed
    #         if (
    #             self._cached_state.get('annotation_count') != len(self.web_view.annotations)
    #             or storyboard_has_changes
    #         ):
    #             processed_annotations = []
    #             for ann in self.web_view.annotations:
    #                 if ann.get('deleted', False):
    #                     continue
    #                 processed_ann = {
    #                     'id': ann.get('id'),
    #                     'text': ann.get('text'),
    #                     'order': ann.get('order'),
    #                     'used': ann.get('used', False),
    #                     'favorite': ann.get('favorite', False),
    #                     'divider': ann.get('divider', False),
    #                     'color': ann.get('color')
    #                 }
    #                 if 'storyboard' in ann:
    #                     processed_ann['storyboard'] = ann['storyboard']
    #                 processed_annotations.append(processed_ann)

    #             current_state['annotations'] = processed_annotations
    #             current_state['annotation_count'] = len(self.web_view.annotations)

    #         # Update scene styles if changed
    #         scene_styles_hash = hash(str(self.web_view.scene_styles))
    #         if scene_styles_hash != self._cached_hashes.get('scene_styles'):
    #             current_state['scene_styles'] = self.web_view.scene_styles.copy()
    #             self._cached_hashes['scene_styles'] = scene_styles_hash

    #         # Update bookmarks if changed
    #         if bookmarks_changed:
    #             current_state['bookmarks'] = bookmarks_data
    #             self._cached_hashes['bookmarks'] = bookmarks_hash

    #         # If storyboard changed, store its state
    #         if storyboard_has_changes:
    #             current_state['storyboard_state'] = {
    #                 'changes_pending': True,
    #                 'ordered_annotations': (
    #                     self.storyboard_dialog.get_ordered_annotations()
    #                     if hasattr(self.storyboard_dialog, 'get_ordered_annotations')
    #                     else []
    #                 ),
    #                 'pending_deletions': getattr(self.storyboard_dialog, '_pending_deletions', set())
    #             }

    #         # Update the cached state
    #         self._cached_state = current_state.copy()
    #         return current_state

    #     except Exception as e:
    #         print(f"Error getting current state: {e}")
    #         import traceback
    #         traceback.print_exc()

    #         # Try to return a basic fallback
    #         basic_state = {}
    #         try:
    #             basic_state['cleaner_input'] = self.cleaner_input_text.toPlainText()
    #             basic_state['cleaner_output'] = self.cleaner_output_text.toPlainText()
    #             basic_state['input'] = self.input_text.toPlainText()
    #             basic_state['preview_html'] = self.output_text.toPlainText()  # Include HTML in fallback
    #             if hasattr(self.web_view, 'annotations'):
    #                 basic_state['annotations'] = self.web_view.annotations
    #             if hasattr(self.web_view, 'scene_styles'):
    #                 basic_state['scene_styles'] = self.web_view.scene_styles
    #             if hasattr(self, 'bookmark_panel') and self.bookmark_panel:
    #                 basic_state['bookmarks'] = self.bookmark_panel.get_bookmarks_data()
    #         except Exception as inner_e:
    #             print(f"Error getting basic state: {inner_e}")
    #             traceback.print_exc()

    #         return basic_state


        
        
    def clear_all(self):
        # Clear Cleaner tab
        self.cleaner_input_text.clear()
        self.cleaner_output_text.clear()
        
        # Clear Input tab
        self.input_text.clear()
        
        # Clear Output tab
        self.output_text.clear()
        
        # Clear Preview tab
        self.web_view.setHtml('')
        self.web_view.annotations = []
        self.web_view.scene_styles = {}
        
        # Clear sticky header cache when session is cleared
        if hasattr(self.web_view, 'sticky_header') and self.web_view.sticky_header:
            self.web_view.sticky_header.invalidate_cache() 
        
    def ensure_backup_directory(self, session_file):
        """Create backup directory if it doesn't exist"""
        #print("\n=== ENSURING BACKUP DIRECTORY ===")
        try:
            session_dir = os.path.dirname(session_file)
            #print(f"Session directory: {session_dir}")
        
            backup_dir = os.path.join(session_dir, "Transcript Session Backups")
            #print(f"Backup directory path: {backup_dir}")
        
            if not os.path.exists(backup_dir):
                #print("Creating backup directory...")
                os.makedirs(backup_dir)
                #print("Backup directory created successfully")
            else:
                print("Backup directory already exists")
            
            #print(f"Final backup directory path: {backup_dir}")
            return backup_dir
        
        except Exception as e:
            print(f"ERROR creating backup directory: {e}")
            print("Falling back to session directory")
            return session_dir

    def create_shadow_effect(self):
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(20)
        shadow.setXOffset(0)
        shadow.setYOffset(2)
        shadow.setColor(QColor(0, 0, 0, 50))  # Semi-transparent black
        self.setGraphicsEffect(shadow)

    def showEvent(self, event):
        super().showEvent(event)
        # Create fade-in animation
        self.animation = QPropertyAnimation(self, b"windowOpacity")
        self.animation.setDuration(150)
        self.animation.setStartValue(0.0)
        self.animation.setEndValue(1.0)
        self.animation.start()

    def hideEvent(self, event):
        """Handle hide events with proper fade animation"""
        # Store the event since we'll need it later
        self._hide_event = event
    
        # Create fade-out animation
        self.animation = QPropertyAnimation(self, b"windowOpacity")
        self.animation.setDuration(150)
        self.animation.setStartValue(1.0)
        self.animation.setEndValue(0.0)
    
        # Connect to our finish handler
        self.animation.finished.connect(self._finish_hide_event)
        self.animation.start()
    
        # Call parent class hideEvent with the original event
        super().hideEvent(event)

    def _finish_hide_event(self):
        """Cleanup after hide animation finishes"""
        # Clean up our stored event
        self._hide_event = None

    def create_session_backup(self, session_file):
        """Create backups of the session file being opened
        Maintains 6 backup files: backup6 (oldest) through backup1 (newest)
        """
        print("\n=== BACKUP CREATION START ===")
        # print(f"Creating backup for: {session_file}")
    
        try:
            # Get or create backup directory
            backup_dir = self.ensure_backup_directory(session_file)
            # print(f"Backup directory: {backup_dir}")
        
            # Remove .session extension for base name
            session_name = os.path.basename(session_file)
            if session_name.endswith('.session'):
                session_name = session_name[:-8]  # Remove .session
            # print(f"Base session name: {session_name}")
        
            # Define backups from oldest to newest with correct naming
            backups = [
                os.path.join(backup_dir, f"{session_name}_backup6.session"),
                os.path.join(backup_dir, f"{session_name}_backup5.session"), 
                os.path.join(backup_dir, f"{session_name}_backup4.session"),
                os.path.join(backup_dir, f"{session_name}_backup3.session"),
                os.path.join(backup_dir, f"{session_name}_backup2.session"),
                os.path.join(backup_dir, f"{session_name}_backup1.session")
            ]
        
            # print("\nBackup paths:")
            for i, path in enumerate(backups):
                # print(f"backup{6-i}: {path}")
                pass

            # Rotate backups: shift older files up (6 -> 5 -> 4 etc)
            # print("\nStarting backup rotation...")
            for i in range(len(backups)-1):
                old_file = backups[i+1]  # Current backup file
                new_file = backups[i]    # Next backup slot
            
                # print(f"\nChecking rotation: {os.path.basename(old_file)} -> {os.path.basename(new_file)}")
            
                if os.path.exists(old_file):
                    # print(f"Found existing backup at: {old_file}")
                
                    # Remove target file if it exists
                    if os.path.exists(new_file):
                        # print(f"Removing existing file at target location: {new_file}")
                        os.remove(new_file)
                    
                    # Move current backup to next slot    
                    # print(f"Moving {os.path.basename(old_file)} to {os.path.basename(new_file)}")
                    os.rename(old_file, new_file)
                    # print("Move successful")
                else:
                    # print(f"No existing backup at: {old_file}")
                    pass
                
            # Create newest backup (backup1) from current file
            newest_backup = backups[-1]  # backup1 is last in list
            if os.path.exists(session_file):
                # print(f"\nCreating newest backup (backup1) from: {session_file}")
                # print(f"Target location: {newest_backup}")
                shutil.copy2(session_file, newest_backup)
                # print("Newest backup created successfully")
            
                # Verify backup creation
                if os.path.exists(newest_backup):
                    # print(f"Verified: Backup file exists at {newest_backup}")
                    src_size = os.path.getsize(session_file)
                    backup_size = os.path.getsize(newest_backup)
                    # print(f"Source file size: {src_size} bytes")
                    # print(f"Backup file size: {backup_size} bytes")
                    if src_size == backup_size:
                        # print("File sizes match")
                        pass
                    else:
                        # print("WARNING: File sizes do not match")
                        pass
                else:
                    # print("WARNING: Backup file was not created")
                    pass
                
            else:
                # print(f"\nWARNING: Source file does not exist: {session_file}")
                pass
            
            # Final verification
            # print("\nFinal backup status:")
            for backup in backups:
                exists = os.path.exists(backup)
                size = os.path.getsize(backup) if exists else 0
                # print(f"{os.path.basename(backup)}: {'Exists' if exists else 'Missing'} ({size} bytes)")
            
        except Exception as e:
            # print("\nERROR during backup creation:")
            # print(f"Exception: {str(e)}")
            import traceback
            # print("Traceback:")
            # print(traceback.format_exc())
            # Continue with load operation even if backup fails
        
        print("\n=== BACKUP CREATION COMPLETE ===")

    def beautify_html(html_content):
        """
        Beautify HTML content with proper indentation and line breaks.
        """
        soup = BeautifulSoup(html_content, 'html.parser')
    
        # prettify() adds too many line breaks, so we'll use a custom formatter
        def format_tag(tag, level=0):
            indent = '    ' * level  # 4 spaces per level
            result = []
        
            # Special handling for script and style tags to preserve content formatting
            if tag.name in ['script', 'style']:
                content = tag.string if tag.string else ''
                if content:
                    # Indent the content lines
                    content_lines = content.strip().split('\n')
                    indented_content = '\n'.join(indent + '    ' + line for line in content_lines)
                    result.append(f'{indent}<{tag.name}{format_attributes(tag.attrs)}>\n{indented_content}\n{indent}</{tag.name}>')
                else:
                    result.append(f'{indent}<{tag.name}{format_attributes(tag.attrs)}></{tag.name}>')
                return '\n'.join(result)
        
            # Handle doctype
            if isinstance(tag, BeautifulSoup) and tag.descendents and isinstance(list(tag.children)[0], Doctype):
                result.append('<!DOCTYPE html>')
            
            # Format opening tag with attributes
            if tag.name:
                result.append(f'{indent}<{tag.name}{format_attributes(tag.attrs)}>')
        
            # Handle contents
            for child in tag.children:
                if isinstance(child, NavigableString):
                    if child.strip():
                        result.append(indent + '    ' + child.strip())
                else:
                    result.append(format_tag(child, level + 1))
        
            # Add closing tag
            if tag.name:
                if len(result) > 1:  # If there were contents, put closing tag on new line
                    result.append(f'{indent}</{tag.name}>')
                else:  # If no contents, keep closing tag on same line
                    result[-1] = result[-1].rstrip('>') + f'></{tag.name}>'
        
            return '\n'.join(result)
    
        def format_attributes(attrs):
            if not attrs:
                return ''
            parts = []
            for key, value in sorted(attrs.items()):
                if isinstance(value, list):
                    value = ' '.join(value)
                if value is True:
                    parts.append(key)
                else:
                    parts.append(f'{key}="{value}"')
            return ' ' + ' '.join(parts) if parts else ''
    
        # Format the entire document
        formatted_html = format_tag(soup)
    
        # Clean up empty lines and normalize line endings
        formatted_html = '\n'.join(line for line in formatted_html.splitlines() if line.strip())
        return formatted_html


    def save_session(self, save_as=False):
        """Save the current session."""
        print("\n=== SAVE SESSION START ===")
        
        # Set save in progress flag
        self._save_in_progress = True

        # Use stored scroll position from closeEvent if available
        scroll_pos = getattr(self, 'final_scroll_position', None)
        if scroll_pos is not None:
            print(f"Using stored scroll position from close event: {scroll_pos}")
        else:
            print("No stored scroll position found")
        
        # Temporarily disable tooltips while saving
        tooltips_were_enabled = True
        if hasattr(self, 'web_view') and self.web_view:
            tooltips_were_enabled = self.web_view.tooltips_enabled
        
            # Clear any visible tooltips by running JavaScript
            clear_tooltips_js = """
                (function() {
                    var tooltip = document.querySelector('.notes-tooltip');
                    if (tooltip) {
                        tooltip.classList.remove('visible');
                    }
                    window.activeHighlight = null;
                    if (window.tooltipShowTimer) {
                        clearTimeout(window.tooltipShowTimer);
                        window.tooltipShowTimer = null;
                    }
                    if (window.tooltipHideTimer) {
                        clearTimeout(window.tooltipHideTimer);
                        window.tooltipHideTimer = null;
                    }
                    return true;
                })();
            """
            self.web_view.page().runJavaScript(clear_tooltips_js)
        
            # Disable tooltips during save
            print("Temporarily disabling tooltips during save")
            self.web_view.toggle_tooltips(False)
    
        # Store a reference to help with restoring tooltips later
        self._tooltips_restore_needed = tooltips_were_enabled
        
        """Save the current session, ensuring storyboard changes are only processed if the dialog exists."""
        print("=== SAVE SESSION START ===")
        print(f"Save As mode: {save_as}")
        print(f"Current session file: {self.current_session_file}")

        # Handle any pending storyboard changes if the dialog exists
        print("Checking for pending storyboard changes...")
        if hasattr(self, 'storyboard_dialog') and self.storyboard_dialog:
            try:
                if self.storyboard_dialog.changes_pending:
                    print("Applying pending storyboard changes.")
                    self.storyboard_dialog.apply_changes()
            except RuntimeError as e:
                print(f"[WARNING] StoryboardDialog has been deleted or is inaccessible: {e}")
            except Exception as e:
                print(f"[ERROR] Error applying storyboard changes: {e}")
                import traceback
                traceback.print_exc()
        else:
            print("StoryboardDialog does not exist or has been deleted. Skipping storyboard changes.")

        # Handle 'Save As' or missing session file
        if not self.current_session_file or save_as:
            print("Session file is missing or Save As is requested.")
            default_name = "New Session"  # Initial default

            if self.current_session_file:
                # Get the base filename from the existing path
                base_name = os.path.basename(self.current_session_file)
                # Remove the .session extension if present for a cleaner suggestion
                if base_name.lower().endswith('.session'):
                     default_name = base_name[:-len('.session')]
                else:
                     default_name = base_name
                print(f"Derived default_name from current_session_file: {default_name}")

            else:
                # Try getting name from window title if no current file
                title_name = self.windowTitle().replace("Scriptoria - ", "").strip()
                print(f"Derived title_name from windowTitle: {title_name}")
                # Use title_name if it's valid and different from the initial default
                # Also check against the asterisk version of the default
                if title_name and title_name not in ["New Session", "*New Session"]:
                    default_name = title_name
                    print(f"Using title_name as default_name: {default_name}")


            # --- Strip the leading asterisk HERE ---
            original_default = default_name # Keep for logging if needed
            default_name = default_name.lstrip('*')
            if original_default != default_name:
                print(f"Stripped leading asterisk. New default_name: {default_name}")

            # --- Add a fallback if stripping made it empty ---
            if not default_name:
                print("Default name became empty after stripping, using fallback.")
                default_name = "Untitled Session" # Or just "Session" or similar

            print(f"Final default_name to be suggested: {default_name}")

            try:
                # Suggest the cleaned default name + .session extension
                file_name, _ = QFileDialog.getSaveFileName(
                    self,
                    "Save Session",
                    f"{default_name}.session",
                    # It's usually good practice to keep All Files option
                    "Session Files (*.session);;All Files (*)"
                )
                if not file_name:
                    print("Save session canceled by user.")
                    # Restore tooltips if save is cancelled
                    if hasattr(self, '_tooltips_restore_needed') and self._tooltips_restore_needed:
                        if hasattr(self, 'web_view') and self.web_view:
                            print("Restoring tooltips after save cancellation")
                            self.web_view.toggle_tooltips(True)
                            delattr(self, '_tooltips_restore_needed')
                    return False # Indicate cancellation
            except Exception as e:
                print(f"QFileDialog.getSaveFileName failed: {e}")
                # Consider if fallback path is still needed or if returning False is better
                # file_name = os.path.join(os.path.expanduser("~"), f"{default_name}.session") # Ensure extension in fallback too
                # print(f"Using fallback path: {file_name}")
                return False # Indicate failure


            # Ensure the final chosen filename ends with .session
            # QFileDialog usually handles this if the filter is selected, but double-check
            if not file_name.lower().endswith('.session'):
                print("Appending .session extension to chosen filename.")
                file_name += '.session'

            self.current_session_file = file_name
            # Update window title with the *clean* base name (without path, potentially without *)
            clean_base_name = os.path.basename(file_name).lstrip('*')
            self.setWindowTitle(f'Scriptoria - {clean_base_name}') # Show the saved name
            print(f"Session file set to: {self.current_session_file}")

        # Show progress dialog
        progress = None
        try:
            progress = SaveProgressDialog(self)
            progress.show()
            QApplication.processEvents()
            print("Progress dialog initialized and displayed.")

            # Process script panel states
            progress.update_progress(15, "Processing panel states...")
            current_states = {}
            if self.theme_view and self.theme_view.isVisible():
                print("Processing script panel...")
                current_states['theme_view'] = {
                    'current_tab': self.scene_tabs.currentIndex(),
                    'scroll_positions': {},
                    'selected_items': {}
                }
                for i in range(self.scene_tabs.count()):
                    list_widget = self.scene_tabs.widget(i)
                    if isinstance(list_widget, AnnotationListWidget):
                        print(f"Processing tab {i} in script panel...")
                        current_states['theme_view']['scroll_positions'][i] = list_widget.verticalScrollBar().value()
                        current_states['theme_view']['selected_items'][i] = []
                        for j in range(list_widget.count()):
                            item = list_widget.item(j)
                            if item.isSelected():
                                item_widget = list_widget.itemWidget(item)
                                if item_widget:
                                    label = item_widget.findChild(QLabel)
                                    notes_edit = item_widget.findChild(QLineEdit)
                                    item_id = item.data(Qt.ItemDataRole.UserRole)
                                    print(f"Item {j}: ID={item_id}, Text={label.text() if label else 'N/A'}")
                                    current_states['theme_view']['selected_items'][i].append({
                                        'text': label.text() if label else '',
                                        'notes': notes_edit.text() if notes_edit else '',
                                        'id': item_id
                                    })

            # Process annotation states
            progress.update_progress(30, "Processing annotation states...")
            existing_states = {}

            for anno in self.web_view.annotations:
                anno_id = anno.get('id')
                if anno_id:
                    # Safely initialize or clean storyboard state
                    if 'storyboard' not in anno or anno['storyboard'] is None:
                        print(f"Script Editor data missing or None for annotation {anno_id}. Initializing with default values.")
                        anno['storyboard'] = {'order': 0}  # Default values
                    elif anno['storyboard'].get('text') in [None, ""]:
                        print(f"Script Editor text is empty for annotation {anno_id}. Removing storyboard data.")
                        del anno['storyboard']
    
                    # Proceed with saving the current state
                    storyboard_data = anno.get('storyboard', {})
                    existing_states[anno_id] = {
                        'storyboard': storyboard_data,
                        'used': anno.get('used', False),
                        'favorite': anno.get('favorite', False),
                        'notes': anno.get('notes', ''),
                        'notes_html': anno.get('notes_html', ''),
                        'strikethrough_segments': storyboard_data.get('strikethrough_segments', {}),
                        'positional_strikethrough': storyboard_data.get('positional_strikethrough', {})
                    }


            if progress and progress.was_cancelled():
                # Restore tooltips if save is cancelled
                if hasattr(self, '_tooltips_restore_needed') and self._tooltips_restore_needed:
                    if hasattr(self, 'web_view') and self.web_view:
                        print("Restoring tooltips after save cancellation (progress dialog)")
                        self.web_view.toggle_tooltips(True)
                        delattr(self, '_tooltips_restore_needed')
                return False

            # Process storyboard annotations
            progress.update_progress(45, "Processing storyboard states...")
            storyboard_states = {}

            # Initialize storyboard dialog if needed
            dialog_initialized_here = False
            if not hasattr(self, 'storyboard_dialog') or not self.storyboard_dialog:
                print("Initializing hidden storyboard dialog for state retrieval...")
                try:
                    # Create a temporary dialog with special handling
                    self.storyboard_dialog = StoryboardDialog(self, is_temp_for_save=True)
                    self.storyboard_dialog.hide()  # Ensure it's hidden immediately
    
                    # Important: Block signals to prevent event cascades
                    self.storyboard_dialog.blockSignals(True)
    
                    # Initialize order_list from annotations without triggering resize logic
                    if hasattr(self.storyboard_dialog, 'order_list') and self.storyboard_dialog.order_list:
                        # Temporarily populate order list without visual updates
                        self.storyboard_dialog.order_list.begin_batch_updates()
                        try:
                            # Filter and sort annotations
                            ordered = [a for a in self.web_view.annotations if not a.get('deleted', False) and a.get('order') is not None]
                            ordered.sort(key=lambda x: x['order'])
            
                            # Create all items without triggering resize code
                            for i, a in enumerate(ordered):
                                new_item = QListWidgetItem()
                                new_item.setData(Qt.ItemDataRole.UserRole, a['id'])
                                self.storyboard_dialog.order_list.addItem(new_item)
                        finally:
                            self.storyboard_dialog.order_list.end_batch_updates(0)
    
                    dialog_initialized_here = True
                except Exception as e:
                    print(f"Error creating temp storyboard dialog: {e}")
                    import traceback
                    traceback.print_exc()
                    # Continue without the dialog
                    self.storyboard_dialog = None

            # Process storyboard states only if we have a valid dialog with order_list
            if hasattr(self, 'storyboard_dialog') and self.storyboard_dialog and hasattr(self.storyboard_dialog, 'order_list'):
                print("Processing storyboard dialog states...")
                order_list = self.storyboard_dialog.order_list
                for i in range(order_list.count()):
                    if progress and progress.was_cancelled():
                        # Restore tooltips if save is cancelled
                        if hasattr(self, '_tooltips_restore_needed') and self._tooltips_restore_needed:
                            if hasattr(self, 'web_view') and self.web_view:
                                print("Restoring tooltips after save cancellation (storyboard processing)")
                                self.web_view.toggle_tooltips(True)
                                delattr(self, '_tooltips_restore_needed')
                        return False
    
                    item = order_list.item(i)
                    anno_id = item.data(Qt.ItemDataRole.UserRole)
                    widget = order_list.itemWidget(item)
    
                    # Get annotation directly from our data if widget isn't available
                    # (which is likely for temporary dialogs)
                    annotation = next((a for a in self.web_view.annotations if a and a.get('id') == anno_id), None)
    
                    if annotation is not None:
                        existing_state = existing_states.get(anno_id, {})
                        # Safely handle None storyboard
                        storyboard = annotation.get('storyboard') or {}
                        storyboard_text = storyboard.get('text', annotation.get('text', ''))
                
                        # Safely get strikethrough segments from existing state
                        strikethrough_segments = existing_state.get('strikethrough_segments', {})
                
                        # Safely get positional_strikethrough from existing state
                        positional_strikethrough = existing_state.get('positional_strikethrough', {})
        
                        resolved_text = storyboard_text
        
                        # Handle dividers specially
                        if annotation.get('divider', False):
                            color = annotation.get('color', 'yellow')
                            storyboard_states[anno_id] = {
                                'order': i,
                                'text': resolved_text,
                                'color': color,
                                'divider': True
                            }
                        else:
                            storyboard_states[anno_id] = {
                                'order': i,
                                'text': resolved_text,
                                'strikethrough_segments': strikethrough_segments,
                                'positional_strikethrough': positional_strikethrough
                            }

            # Clean up temporary dialog if we created one
            if dialog_initialized_here and hasattr(self, 'storyboard_dialog') and self.storyboard_dialog:
                print("Closing the temporary storyboard dialog...")
                try:
                    self.storyboard_dialog.blockSignals(True)  # Prevent any signals during close
                    self.storyboard_dialog.close()
                except Exception as e:
                    print(f"Error closing temporary dialog: {e}")
                finally:
                    self.storyboard_dialog = None

            # Compile ordered annotations with save handling of None storyboard
            progress.update_progress(60, "Compiling final annotations...")
            ordered_annotations = []
            used_annotation_ids = set()

            for anno in self.web_view.annotations:
                if progress and progress.was_cancelled():
                    # Restore tooltips if save is cancelled
                    if hasattr(self, '_tooltips_restore_needed') and self._tooltips_restore_needed:
                        if hasattr(self, 'web_view') and self.web_view:
                            print("Restoring tooltips after save cancellation (annotation compilation)")
                            self.web_view.toggle_tooltips(True)
                            delattr(self, '_tooltips_restore_needed')
                    return False

                anno_id = anno.get('id')
                if anno_id not in used_annotation_ids:
                    anno_copy = anno.copy()
                    existing_state = existing_states.get(anno_id, {})

                    # Always preserve notes_html
                    anno_copy['notes_html'] = anno.get('notes_html', '')
                    
                    # Always preserve tags
                    anno_copy['tags'] = anno.get('tags', [])
                    
                    # Always preserve speech_title
                    anno_copy['speech_title'] = anno.get('speech_title', '')
                    
                    # Always preserve secondary_scenes
                    anno_copy['secondary_scenes'] = anno.get('secondary_scenes', [])

                    # Proper handling of storyboard state
                    if anno_id in storyboard_states:
                        storyboard_state = storyboard_states[anno_id]
                        anno_copy['storyboard'] = storyboard_state
                
                        # Merge existing strikethrough segments if they exist
                        if existing_state.get('strikethrough_segments'):
                            if 'strikethrough_segments' not in storyboard_state:
                                storyboard_state['strikethrough_segments'] = {}
                            storyboard_state['strikethrough_segments'].update(
                                existing_state['strikethrough_segments']
                            )
                
                        # Merge existing positional strikethrough data if it exists
                        if existing_state.get('positional_strikethrough'):
                            if 'positional_strikethrough' not in storyboard_state:
                                storyboard_state['positional_strikethrough'] = {}
                            storyboard_state['positional_strikethrough'].update(
                                existing_state['positional_strikethrough']
                            )
                    
                    elif existing_state.get('storyboard'):
                        anno_copy['storyboard'] = existing_state['storyboard']

                    # Remove storyboard if text is empty or None
                    if 'storyboard' in anno_copy and (
                        anno_copy['storyboard'].get('text') is None or
                        anno_copy['storyboard'].get('text') == ""
                    ):
                        del anno_copy['storyboard']

                    ordered_annotations.append(anno_copy)
                    used_annotation_ids.add(anno_id)

            # Clean up notes in storyboard states, safely handling None
            for annotation in ordered_annotations:
                storyboard = annotation.get('storyboard')
                if storyboard is not None and 'notes' in storyboard:
                    storyboard.pop('notes', None)

            # Build session data
            progress.update_progress(75, "Building session data...")
            session_data = {
                'version': '1.0',
                'timestamp': datetime.datetime.now().isoformat(),
                'session_name': os.path.basename(self.current_session_file),
                'ui_state': current_states,
                'cleaner': {
                    'input': self.cleaner_input_text.toPlainText(),
                    'output': self.cleaner_output_text.toPlainText()
                },
                'input': {
                    'text': self.input_text.toPlainText()
                },
                # 'output': {
                #     'html': self.output_text.toPlainText()
                # },
                'preview': {
                    'scene_styles': self.web_view.scene_styles,
                    'ordered_scenes': list(self.web_view.scene_styles.keys()),
                    'annotations': ordered_annotations,
                    'scroll_position': 0  # Default value
                },
                'tags': self.tags,
                'bookmarks': [],  # Initialize bookmarks
                'session-headers': getattr(self.script_search, 'session_headers', []) if hasattr(self, 'script_search') else []
            }

            # Add bookmarks data with 'is_favorite'
            if hasattr(self, 'bookmark_panel'):
                bookmarks_data = self.bookmark_panel.get_bookmarks_data()
                for bookmark in bookmarks_data:
                    if 'is_favorite' not in bookmark:
                        bookmark['is_favorite'] = False  # Add 'is_favorite' if missing
                session_data['bookmarks'] = bookmarks_data

            def on_scroll_retrieved(scroll_pos):
                session_data['preview']['scroll_position'] = scroll_pos
                # Proceed with saving after getting the scroll position
                continue_saving(scroll_pos)

            self.web_view.page().runJavaScript("window.pageYOffset", on_scroll_retrieved)

            if progress and progress.was_cancelled():
                # Restore tooltips if save is cancelled
                if hasattr(self, '_tooltips_restore_needed') and self._tooltips_restore_needed:
                    if hasattr(self, 'web_view') and self.web_view:
                        print("Restoring tooltips after save cancellation (final stages)")
                        self.web_view.toggle_tooltips(True)
                        delattr(self, '_tooltips_restore_needed')
                return False

            def continue_saving(scroll_pos):
                # Update progress for final save
                progress.update_progress(90, "Writing session file...")

                def save_with_html(html):
                    try:
                        # Debug: Print the HTML content
                        #print("=== DEBUG: HTML Content to Save ===")
                        #print(html)  # This will print the entire HTML content to the console
                        #print("=== END OF DEBUG: HTML Content ===")

                        session_data['preview']['html'] = html
                        session_data['preview']['scroll_position'] = scroll_pos

                        # Inside the 'try' block, before calling 'json.dump', add:
                        if hasattr(self, 'bookmark_panel'):
                            progress.update_progress(70, "Saving bookmarks...")
                            # Ensure 'is_favorite' is included
                            bookmarks_data = self.bookmark_panel.get_bookmarks_data()
                            for bookmark in bookmarks_data:
                                if 'is_favorite' not in bookmark:
                                    bookmark['is_favorite'] = False
                            session_data['bookmarks'] = bookmarks_data
                        else:
                            session_data['bookmarks'] = []

                        # Save the current session using atomic write
                        import tempfile
                        import shutil
                        
                        # Write to temporary file first
                        temp_file = None
                        try:
                            with tempfile.NamedTemporaryFile(mode='w', encoding='utf-8', 
                                                           dir=os.path.dirname(self.current_session_file),
                                                           prefix='.session_temp_', suffix='.tmp', 
                                                           delete=False) as temp_file:
                                json.dump(session_data, temp_file, indent=4, ensure_ascii=False)
                                temp_file.flush()
                                os.fsync(temp_file.fileno())  # Force write to disk
                                temp_filename = temp_file.name
                            
                            # Atomic rename - either succeeds completely or fails completely
                            if os.name == 'nt':  # Windows
                                # On Windows, remove target first if it exists
                                if os.path.exists(self.current_session_file):
                                    os.remove(self.current_session_file)
                            shutil.move(temp_filename, self.current_session_file)
                            print("Session saved atomically")
                            
                        except Exception as e:
                            print(f"Error during atomic save: {e}")
                            # Cleanup temp file if it exists
                            if temp_file and hasattr(temp_file, 'name') and os.path.exists(temp_file.name):
                                try:
                                    os.remove(temp_file.name)
                                except:
                                    pass
                            raise  # Re-raise to trigger fallback or error handling

                        # Store current state BEFORE modifying window title
                        ##self.last_saved_state = self.get_current_state()

                        # Only remove asterisk if it exists
                        if self.windowTitle().startswith('*'):
                            self.setWindowTitle(self.windowTitle()[1:])

                        if progress:
                            progress.update_progress(100, "Session saved successfully!")
                        self.status_bar.showMessage(f'Session saved to {self.current_session_file}', 5000)
                        print("Session saved successfully.")

                        # Add the newly created session to the JSON file here
                        self.add_new_session_to_json(self.current_session_file)

                        if progress:
                            progress.update_progress(100, "Save completed successfully")
                            progress.accept()

                        # Restore tooltips after successful save
                        if hasattr(self, '_tooltips_restore_needed') and self._tooltips_restore_needed:
                            if hasattr(self, 'web_view') and self.web_view:
                                print("Restoring tooltips after successful save")
                                self.web_view.toggle_tooltips(True)
                                delattr(self, '_tooltips_restore_needed')

                        # Call completion callback if it exists
                        if hasattr(self, 'save_completion_callback') and self.save_completion_callback:
                            print("Executing save completion callback")
                            try:
                                callback = self.save_completion_callback
                                # Store in local variable before clearing to prevent race conditions
                                self.save_completion_callback = None
                                # Use a QTimer to ensure we return to the event loop
                                # This is CRITICAL for close events to work properly
                                QTimer.singleShot(100, callback)
                                print("Save completion callback scheduled")
                            except Exception as e:
                                print(f"Error scheduling callback: {e}")
                                import traceback
                                traceback.print_exc()
                                # Try to force application close if this was part of a close sequence
                                if hasattr(self, '_original_close_requested') and self._original_close_requested:
                                    print("Attempting emergency application close")
                                    QTimer.singleShot(200, QApplication.quit)
        
                        return True  # Indicate that save was successful
                    
                    except Exception as e:
                        print(f"Error saving session: {e}")
                        import traceback
                        traceback.print_exc()

                        # Restore tooltips even if save fails
                        if hasattr(self, '_tooltips_restore_needed') and self._tooltips_restore_needed:
                            if hasattr(self, 'web_view') and self.web_view:
                                print("Restoring tooltips after save failure")
                                self.web_view.toggle_tooltips(True)
                                delattr(self, '_tooltips_restore_needed')

                        if hasattr(self, 'save_completion_callback'):
                            self.save_completion_callback = None
    
                        # Try to force close if this was part of a close sequence
                        if hasattr(self, '_original_close_requested') and self._original_close_requested:
                            print("Save failed but close was requested - attempting to force close")
                            QTimer.singleShot(300, QApplication.quit)
    
                        # Show error message using a static method to avoid accessing deleted 'self'
                        QMessageBox.critical(
                            None,  # Use None for parent since self might be deleted
                            'Error Saving Session',
                            f'Failed to save session:\n{str(e)}'
                        )

                        if progress:
                            progress.reject()
    
                        return False

                print("Converting web view to HTML for final save...")
                
                def save_with_html_cleaned(html):
                    # Remove filter classes from HTML string
                    import re
                    
                    print("Cleaning filter classes from HTML before saving...")
                    
                    # List of classes that should be removed before saving
                    classes_to_remove = [
                        'favorites-hidden',
                        'used-hidden', 
                        'unused-hidden',
                        'tag-filtered-hidden',
                        'theme-hidden'
                    ]
                    
                    clean_html = html
                    for filter_class in classes_to_remove:
                        # Remove the class from class attributes
                        # Pattern matches: class="other-class filter-class more-classes"
                        pattern = r'class="([^"]*\s+)?' + re.escape(filter_class) + r'(\s+[^"]*)?'
                        
                        def clean_class_attr(match):
                            full_match = match.group(0)
                            before_class = match.group(1) or ''
                            after_class = match.group(2) or ''
                            
                            # Reconstruct class attribute without the filter class
                            remaining_classes = (before_class + after_class).strip()
                            if remaining_classes:
                                return f'class="{remaining_classes}"'
                            else:
                                return ''  # Remove empty class attribute
                        
                        clean_html = re.sub(pattern, clean_class_attr, clean_html)
                        
                        # Also handle cases where it's the only class: class="filter-class"
                        clean_html = re.sub(f'class="{re.escape(filter_class)}"', '', clean_html)
                        
                        # Handle cases with single quotes
                        clean_html = re.sub(f"class='{re.escape(filter_class)}'", '', clean_html)
                    
                    # Remove any empty class attributes that might remain
                    clean_html = re.sub(r'\s+class=""', '', clean_html)
                    clean_html = re.sub(r"\s+class=''", '', clean_html)
                    
                    print(f"Class cleaning completed. Removed: {', '.join(classes_to_remove)}")
                    
                    # Now save the cleaned HTML
                    save_with_html(clean_html)
                
                # Capture HTML and clean it
                self.web_view.page().toHtml(save_with_html_cleaned)
                print("=== SAVE SESSION END ===")
                # Update last_saved_state with the current state
                #self.last_saved_state = self.get_current_state()
                self.changes_pending = False

                # Remove asterisk from title if present
                if self.windowTitle().startswith('*'):
                    self.setWindowTitle(self.windowTitle()[1:])
                    
                # Clear save in progress flag
                self._save_in_progress = False
                
                # Handle deferred close if one was pending
                if hasattr(self, '_pending_close_event') and self._pending_close_event:
                    print("Save completed - processing deferred close event")
                    if hasattr(self, 'status_bar') and self.status_bar:
                        self.status_bar.clearMessage()
                    # Process the deferred close event
                    deferred_event = self._pending_close_event
                    self._pending_close_event = None
                    QTimer.singleShot(100, lambda: self.closeEvent(deferred_event))

        except Exception as e:
            print(f"Error during save session: {e}")
            if progress:
                progress.reject()

            # Restore tooltips on exception
            if hasattr(self, '_tooltips_restore_needed') and self._tooltips_restore_needed:
                if hasattr(self, 'web_view') and self.web_view:
                    print("Restoring tooltips after save exception")
                    self.web_view.toggle_tooltips(True)
                    delattr(self, '_tooltips_restore_needed')
                    
            # Clear save in progress flag on exception
            self._save_in_progress = False
            
            # Handle deferred close even on exception
            if hasattr(self, '_pending_close_event') and self._pending_close_event:
                print("Save failed - processing deferred close event anyway")
                if hasattr(self, 'status_bar') and self.status_bar:
                    self.status_bar.clearMessage()
                deferred_event = self._pending_close_event
                self._pending_close_event = None
                QTimer.singleShot(100, lambda: self.closeEvent(deferred_event))

            # Show error message using a static method
            QMessageBox.critical(
                None,  # Use None for parent since self might be deleted
                'Error Saving Session',
                f'An unexpected error occurred:\n{str(e)}'
            )
            return False

    def cleanup_and_close(self):
        """Perform any necessary cleanup before closing the application."""
        print("Performing cleanup before closing...")
        self.close()

    def new_session(self):
        # Initial confirmation for new session
        if self.current_session_file:  # Only show if there's an existing session
            # Save scroll position before confirmation dialog
            def handle_scroll(scroll_pos):
                try:
                    with open(self.current_session_file, 'r', encoding='utf-8') as f:
                        session_data = json.load(f)
            
                    if 'preview' not in session_data:
                        session_data['preview'] = {}
                    session_data['preview']['scroll_position'] = scroll_pos

                    with open(self.current_session_file, 'w', encoding='utf-8') as f:
                        json.dump(session_data, f, indent=4, ensure_ascii=False)
                    print(f"Scroll position saved before new session: {scroll_pos}")
                except Exception as e:
                    print(f"Error saving scroll position before new session: {e}")

            # Get current scroll position before showing confirmation dialog
            self.web_view.page().runJavaScript("window.pageYOffset", handle_scroll)

            confirm_dialog = QMessageBox(self)
            confirm_dialog.setWindowTitle("New Session")
            confirm_dialog.setText("Are you sure you want to start a new session?")
            confirm_dialog.setInformativeText("Starting a new session will close the current one.")
            confirm_dialog.setStandardButtons(
                QMessageBox.StandardButton.Yes | 
                QMessageBox.StandardButton.No
            )
            confirm_dialog.setDefaultButton(QMessageBox.StandardButton.No)
    
            if confirm_dialog.exec() != QMessageBox.StandardButton.Yes:
                return

        # Check for unsaved changes
        if self.has_unsaved_changes():
            confirm_dialog = QMessageBox(self)
            confirm_dialog.setWindowTitle("Unsaved Changes")
            confirm_dialog.setText("You have unsaved changes.")
            confirm_dialog.setInformativeText("Would you like to save your changes before starting a new session?")
            confirm_dialog.setStandardButtons(
                QMessageBox.StandardButton.Save | 
                QMessageBox.StandardButton.Discard | 
                QMessageBox.StandardButton.Cancel
            )
            confirm_dialog.setDefaultButton(QMessageBox.StandardButton.Save)

            reply = confirm_dialog.exec()

            if reply == QMessageBox.StandardButton.Save:
                if not self.save_session():
                    return  # Stop if saving fails
            elif reply == QMessageBox.StandardButton.Cancel:
                return  # Stop if canceled

        # Close welcome dialog if open
        if hasattr(self, 'welcome_dialog') and self.welcome_dialog:
            if self.welcome_dialog.isVisible():
                self.welcome_dialog.close()
            if self.welcome_dialog is not None:  # Ensure it's not None before calling deleteLater
                self.welcome_dialog.deleteLater()
            self.welcome_dialog = None

        # Clean up all panels before starting new session
        self.clean_panels_before_load()

        # Proceed with starting a new session
        self.current_session_file = None
        self.clear_all()

        # Show the new session dialog
        dialog = NewSessionDialog(self)
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return

        # Get session info from dialog
        session_info = dialog.get_session_info()
    
        # Update the current session file and UI
        self.current_session_file = session_info['location']
        self.setWindowTitle(f'Scriptoria - {session_info["name"]}')

        # Switch to Process Captions tab
        for i in range(self.tabs.count()):
            if self.tabs.tabText(i) == 'Process Captions':
                self.tabs.setCurrentIndex(i)
                break

        # Only save the session if a valid save location is provided
        if session_info['location']:
            self.save_session()  # save_session is called here in the parent class
            self.status_bar.showMessage('New session created', 5000)
        else:
            self.status_bar.showMessage('New session created without a save location', 5000)


    def add_new_session_to_json(self, session_path):
        """Add the newly created session to the JSON file."""
        try:
            # Use the shared get_data_folder method to determine the correct data folder
            data_folder = get_data_folder()
            file_path = os.path.join(data_folder, "recent_sessions.json")

            # Load existing sessions if the file exists, otherwise initialize an empty list
            if os.path.exists(file_path):
                with open(file_path, 'r', encoding='utf-8') as f:
                    recent_sessions = json.load(f)
            else:
                recent_sessions = []

            # Add the new session entry
            now = QDateTime.currentDateTime().toString("yyyy-MM-dd hh:mm:ss")
            new_session_entry = {
                "path": session_path,
                "last_accessed": now
            }

            # Insert the new session into the list
            recent_sessions.insert(0, new_session_entry)

            # Save back to the JSON file
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(recent_sessions, f, indent=4)

            print(f"New session added to recent_sessions.json: {session_path}")

        except Exception as e:
            print(f"Error adding new session to JSON: {e}")


    def load_recent_sessions(self):
        """Load recent sessions from a JSON file."""
        try:
            data_folder = get_data_folder()
            file_path = os.path.join(data_folder, "recent_sessions.json")
        
            if not os.path.exists(file_path):
                print("No recent sessions file found")
                return []

            with open(file_path, "r", encoding="utf-8") as f:
                recent_sessions = json.load(f)

            # Ensure unique sessions based on path
            unique_sessions = {}
            for session in recent_sessions:
                if isinstance(session, str):
                    path = session
                    unique_sessions[path] = {
                        "path": path,
                        "last_accessed": "Unknown"
                    }
                elif isinstance(session, dict) and "path" in session:
                    path = session["path"]
                    if path not in unique_sessions or session["last_accessed"] > unique_sessions[path]["last_accessed"]:
                        unique_sessions[path] = session

            return list(unique_sessions.values())
    
        except Exception as e:
            print(f"Error loading recent sessions: {e}")
            return []

    def save_recent_sessions(self):
        """Save the list of recent sessions to a JSON file."""
        try:
            data_folder = get_data_folder()
            file_path = os.path.join(data_folder, "recent_sessions.json")
        
            # Ensure unique sessions based on path
            unique_sessions = {}
            
            # Handle both dictionary and list formats for self.recent_sessions
            if isinstance(self.recent_sessions, dict):
                # Dictionary format: {basename: {path, last_accessed}}
                for basename, session_data in self.recent_sessions.items():
                    path = session_data["path"]
                    if path not in unique_sessions or session_data["last_accessed"] > unique_sessions[path]["last_accessed"]:
                        unique_sessions[path] = {
                            "path": path,
                            "last_accessed": session_data["last_accessed"]
                        }
            elif isinstance(self.recent_sessions, list):
                # List format: [{path, last_accessed}, ...]
                for session_data in self.recent_sessions:
                    if isinstance(session_data, dict) and "path" in session_data:
                        path = session_data["path"]
                        if path not in unique_sessions or session_data.get("last_accessed", "") > unique_sessions[path].get("last_accessed", ""):
                            unique_sessions[path] = {
                                "path": path,
                                "last_accessed": session_data.get("last_accessed", "Unknown")
                            }
                    elif isinstance(session_data, str):
                        # Handle legacy string format
                        path = session_data
                        unique_sessions[path] = {
                            "path": path,
                            "last_accessed": "Unknown"
                        }
            else:
                print(f"[WARNING] Unknown recent_sessions format: {type(self.recent_sessions)}")
        
            # Save sessions
            sessions_list = list(unique_sessions.values())
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(sessions_list, f, indent=4)
        
            print("Recent sessions saved successfully.")

        except Exception as e:
            print(f"Error saving recent sessions: {e}")

    def clean_panels_before_load(self):
        """Close and clean up all panels before loading a new session."""
        print("\n=== CLEANING PANELS BEFORE SESSION LOAD ===")

        # Handle Script Editor Panel
        if hasattr(self, 'storyboard_dialog') and self.storyboard_dialog:
            print("Cleaning up Script Editor panel...")
            try:
                # Handle any pending changes in storyboard
                if self.storyboard_dialog.changes_pending:
                    print("Applying pending storyboard changes before cleanup")
                    self.storyboard_dialog.apply_changes()

                # Close and clean up storyboard dialog
                self.storyboard_dialog.close()
                self.storyboard_dialog = None
                print("Script Editor panel cleaned up successfully")

                # Ensure the button is unchecked
                if hasattr(self, 'storyboard_button'):
                    self.storyboard_button.setChecked(False)
            except Exception as e:
                print(f"Error cleaning up storyboard panel: {e}")

        # Handle Script Panel (Theme View)
        if hasattr(self, 'theme_view') and self.theme_view:
            print("Cleaning up Script panel...")
            try:
                self.theme_view.hide()
                # Clear all tabs
                if hasattr(self, 'scene_tabs'):
                    self.scene_tabs.clear()
                print("Script panel cleaned up successfully")

                # Ensure the button is unchecked
                if hasattr(self, 'view_annotations_button'):
                    self.view_annotations_button.setChecked(False)
            except Exception as e:
                print(f"Error cleaning up script panel: {e}")

        # Handle Color Key Panel (Edit Themes)
        if hasattr(self, 'color_key_panel') and self.color_key_panel:
            print("Cleaning up Color Key panel...")
            try:
                self.color_key_panel.hide()
                # Clear form layout
                if hasattr(self, 'color_key_form'):
                    while self.color_key_form.rowCount() > 0:
                        self.color_key_form.removeRow(0)
                print("Color Key panel cleaned up successfully")

                # Ensure the button is unchecked
                if hasattr(self, 'color_key_button'):
                    self.color_key_button.setChecked(False)
            except Exception as e:
                print(f"Error cleaning up color key panel: {e}")

        # Handle Bookmark Panel
        if hasattr(self, 'bookmark_panel') and self.bookmark_panel:
            print("Cleaning up Bookmark panel...")
            try:
                self.bookmark_panel.hide()
                self.bookmark_panel.bookmark_list.clear()  # Clear the list widget
                self.bookmark_panel.bookmarks = []  # Clear the stored bookmarks
                print("Bookmark panel cleaned up successfully")

                # Ensure the button is unchecked
                if hasattr(self, 'bookmark_button'):
                    self.bookmark_button.setChecked(False)
            except Exception as e:
                print(f"Error cleaning up bookmark panel: {e}")

        # Hide the right panel container if it exists
        if hasattr(self, 'right_panel_container'):
            print("Hiding right panel container...")
            self.right_panel_container.hide()

        # Clear sticky header DOM elements only (preserve state structure for reinitialization)
        print("Cleaning up sticky header DOM...")
        try:
            cleanup_js = """
                console.log('[DEBUG] Cleaning up sticky header DOM for new session');
                
                // Remove existing DOM sticky header if present
                const existingHeader = document.getElementById('scriptoria-sticky-header');
                if (existingHeader) {
                    existingHeader.remove();
                    console.log('[DEBUG] Removed existing DOM sticky header');
                }
                
                // Remove sticky header restore button if present
                const restoreButton = document.getElementById('sticky-header-restore');
                if (restoreButton) {
                    restoreButton.remove();
                    console.log('[DEBUG] Removed sticky header restore button');
                }
                
                // Clear sticky header styles
                const stickyStyles = document.getElementById('scriptoria-sticky-header-styles');
                if (stickyStyles) {
                    stickyStyles.remove();
                }
                
                // Remove scroll listeners
                if (window.stickyHeaderScrollListener) {
                    document.removeEventListener('scroll', window.stickyHeaderScrollListener);
                    window.stickyHeaderScrollListener = null;
                }
                
                if (window.domStickyHeaderScrollListener) {
                    document.removeEventListener('scroll', window.domStickyHeaderScrollListener);
                    window.domStickyHeaderScrollListener = null;
                }
                
                // Reset state objects to clean defaults (don't nullify - preserve structure)
                window.stickyHeaderState = {
                    hiddenThemes: new Set(),
                    soloTheme: null,
                    themes: []
                };
                
                window.stickyHeaderTagState = {
                    tagStates: {},
                    isActive: false,
                    strictMode: true,
                    availableTags: []
                };
                
                window.stickyHeaderFilters = {
                    favorites: false,
                    used: 0
                };
                
                window.stickyHeaderDOM = null;
                
                console.log('[DEBUG] Sticky header DOM cleanup complete');
                return { success: true };
            """
            
            self.web_view.page().runJavaScript(cleanup_js)
            print("Sticky header DOM cleaned up successfully")
        except Exception as e:
            print(f"Error cleaning up sticky header: {e}")

        # Clear any stored panel states
        if hasattr(self, 'theme_view_state'):
            self.theme_view_state = None
        if hasattr(self, 'color_key_state'):
            self.color_key_state = None

        print("=== PANEL CLEANUP COMPLETE ===\n")

    # ✅ Preserve both the bookmark state and updated theme colors
    def update_bookmark_images(self):
        """Ensure bookmark images and theme colors persist after content updates."""
        print("[DEBUG] update_bookmark_images() called")
        
        def process_html(html):
            """Parse and modify the HTML to ensure correct bookmark states."""
            soup = BeautifulSoup(html, 'html.parser')
            
            # Get absolute paths for bookmark images
            app_dir = os.path.dirname(os.path.abspath(__file__))
            bookmark_path = os.path.join(app_dir, 'Img', 'bookmark.png')
            bookmark_filled_path = os.path.join(app_dir, 'Img', 'bookmark-filled.png')
            
            # Convert to file:// URLs
            bookmark_url = QUrl.fromLocalFile(bookmark_path).toString()
            bookmark_filled_url = QUrl.fromLocalFile(bookmark_filled_path).toString()
            
            # Ensure URLs are properly encoded for spaces
            if ' ' in bookmark_url:
                bookmark_url = bookmark_url.replace(' ', '%20')
            if ' ' in bookmark_filled_url:
                bookmark_filled_url = bookmark_filled_url.replace(' ', '%20')

            # ✅ Update the bookmark icons based on their bookmarked state
            for bookmark in soup.find_all('img', {'class': 'bookmark-icon'}):
                is_bookmarked = bookmark.get('data-bookmarked', 'false') == 'true'
                bookmark['src'] = bookmark_filled_url if is_bookmarked else bookmark_url
            
            # ✅ Fix the JavaScript variables permanently in the HTML
            import json
            import re
            
            print(f"[DEBUG] Looking for script tags to fix bookmark paths...")
            script_found = False
            
            for script in soup.find_all('script'):
                if script.string and 'window.bookmarkImagePath' in script.string:
                    script_found = True
                    print(f"[DEBUG] Found script with bookmark paths!")
                    
                    # Get the old script content
                    old_script = script.string
                    
                    # Log what we found
                    print(f"[DEBUG] Current bookmark path lines:")
                    for line in old_script.split('\n'):
                        if 'bookmarkImagePath' in line or 'bookmarkFilledImagePath' in line:
                            print(f"  > {line.strip()}")
                    
                    # Match any existing bookmark path assignment
                    pattern1 = r"window\.bookmarkImagePath\s*=\s*['\"].*?['\"]"
                    pattern2 = r"window\.bookmarkFilledImagePath\s*=\s*['\"].*?['\"]"
                    
                    matches1 = re.findall(pattern1, old_script)
                    matches2 = re.findall(pattern2, old_script)
                    
                    print(f"[DEBUG] Found patterns: bookmarkImagePath={matches1}, bookmarkFilledImagePath={matches2}")
                    
                    # Replace with new paths
                    new_script = re.sub(
                        pattern1,
                        f"window.bookmarkImagePath = {json.dumps(bookmark_url)}",
                        old_script
                    )
                    new_script = re.sub(
                        pattern2,
                        f"window.bookmarkFilledImagePath = {json.dumps(bookmark_filled_url)}",
                        new_script
                    )
                    
                    # Also handle cases where the variables might be empty or have semicolons
                    if "window.bookmarkImagePath = '';" in new_script:
                        new_script = new_script.replace("window.bookmarkImagePath = '';", f"window.bookmarkImagePath = {json.dumps(bookmark_url)};")
                    if "window.bookmarkImagePath = \"\";" in new_script:
                        new_script = new_script.replace("window.bookmarkImagePath = \"\";", f"window.bookmarkImagePath = {json.dumps(bookmark_url)};")
                    
                    if "window.bookmarkFilledImagePath = '';" in new_script:
                        new_script = new_script.replace("window.bookmarkFilledImagePath = '';", f"window.bookmarkFilledImagePath = {json.dumps(bookmark_filled_url)};")
                    if "window.bookmarkFilledImagePath = \"\";" in new_script:
                        new_script = new_script.replace("window.bookmarkFilledImagePath = \"\";", f"window.bookmarkFilledImagePath = {json.dumps(bookmark_filled_url)};")
                    
                    # Check if we actually made changes
                    if old_script != new_script:
                        script.string = new_script
                        print(f"[DEBUG] Successfully updated JavaScript bookmark paths!")
                        print(f"[DEBUG] New bookmark path lines:")
                        for line in new_script.split('\n'):
                            if 'bookmarkImagePath' in line or 'bookmarkFilledImagePath' in line:
                                print(f"  > {line.strip()}")
                        
                        # Mark that we need to save the session to make changes permanent
                        self._bookmark_paths_fixed = True
                        print(f"[DEBUG] Session needs to be saved to make bookmark path fix permanent")
                    else:
                        print(f"[DEBUG] No changes made to script - paths may already be correct")
                    
                    break
            
            if not script_found:
                print(f"[DEBUG] No script tag with bookmark paths found in HTML")

            # ✅ Apply the modified HTML back to the web view with the correct base URL
            base_path = os.path.dirname(os.path.abspath(__file__))
            
            # Instead of replacing the entire HTML, just inject JavaScript to update the paths in place
            if hasattr(self, '_bookmark_paths_fixed') and self._bookmark_paths_fixed:
                import json
                update_js = f'''
                (function() {{
                    console.log('[DEBUG] Permanently updating bookmark paths in live DOM');
                    window.bookmarkImagePath = {json.dumps(bookmark_url)};
                    window.bookmarkFilledImagePath = {json.dumps(bookmark_filled_url)};
                    
                    // Also update any existing script tags in the DOM
                    const scripts = document.getElementsByTagName('script');
                    for (let script of scripts) {{
                        if (script.innerHTML && script.innerHTML.includes('window.bookmarkImagePath')) {{
                            let newScript = script.innerHTML;
                            newScript = newScript.replace(
                                /window\\.bookmarkImagePath\\s*=\\s*['""][^'"]*['""];?/g, 
                                'window.bookmarkImagePath = {json.dumps(bookmark_url)};'
                            );
                            newScript = newScript.replace(
                                /window\\.bookmarkFilledImagePath\\s*=\\s*['""][^'"]*['""];?/g, 
                                'window.bookmarkFilledImagePath = {json.dumps(bookmark_filled_url)};'
                            );
                            script.innerHTML = newScript;
                            console.log('[DEBUG] Updated script tag in DOM');
                            break;
                        }}
                    }}
                    
                    console.log('[DEBUG] Bookmark paths permanently updated:', window.bookmarkImagePath, window.bookmarkFilledImagePath);
                }})();
                '''
                
                def handle_js_result(result):
                    print(f"[DEBUG] JavaScript bookmark path update result: {result}")
                    
                self.web_view.page().runJavaScript(update_js, handle_js_result)
            else:
                # Store the updated HTML for next save and reload
                self._current_html_content = str(soup)
                self.web_view.setHtml(self._current_html_content, baseUrl=QUrl.fromLocalFile(base_path + os.sep))

        # ✅ Capture the current HTML and apply updates using the nested function
        self.web_view.page().toHtml(process_html)

    def update_tag_count(self):
        """Update the tag button tooltip with current tag count"""
        if hasattr(self, 'tag_button'):
            tag_count = len(self.tags)
            self.tag_button.setToolTip(f"Manage Tags ({tag_count})")

    def update_tags(self):
        """Update tags from dialog"""
        dialog = self.sender()
        if dialog:
            self.tags = dialog.get_tags()
            self.update_tag_count()  # Update the count after tags change
            # Update sticky header tag filter with new tags
            if hasattr(self, 'web_view'):
                self.web_view.populate_dom_sticky_header_tags(self.tags)

    def fix_invisible_text(self):
        """
        Fix invisible text - anti-stuttering version
        Only runs once when triggered by user (F5 key) or after loading
        """
        try:
            if not hasattr(self, 'input_text') or not self.input_text:
                return
            
            # Get the text
            current_text = self.input_text.toPlainText()
            if not current_text:
                return
        
            # CRITICAL: Fix stuttering by disabling any ongoing operations
        
            # First, stop any running timers in the text edit
            if hasattr(self.input_text, 'keypress_timer') and self.input_text.keypress_timer.isActive():
                self.input_text.keypress_timer.stop()
            
            if hasattr(self.input_text, 'highlight_timer') and self.input_text.highlight_timer.isActive():
                self.input_text.highlight_timer.stop()
            
            # Disable input text updates
            self.input_text.setUpdatesEnabled(False)
            self.input_text.blockSignals(True)
        
            # Stop any ongoing highlighting
            if hasattr(self.input_text, 'header_highlighter'):
                highlighter = self.input_text.header_highlighter
            
                # First pause the highlighter
                if hasattr(highlighter, 'pause_highlighting'):
                    highlighter.pause_highlighting()
                
                # Stop any rehighlight timer
                if hasattr(highlighter, '_rehighlight_timer') and highlighter._rehighlight_timer.isActive():
                    highlighter._rehighlight_timer.stop()
                
                # Stop ongoing rehighlight
                if hasattr(highlighter, '_rehighlighting'):
                    highlighter._rehighlighting = False
        
            # Store cursor and scroll position
            cursor = self.input_text.textCursor()
            cursor_position = cursor.position()
            scroll_bar = self.input_text.verticalScrollBar()
            scroll_position = scroll_bar.value()
        
            # Apply black text formatting to ALL text in one operation
            cursor = QTextCursor(self.input_text.document())
            cursor.select(QTextCursor.SelectionType.Document)
        
            format = QTextCharFormat()
            format.setForeground(QColor(0, 0, 0))  # Black
            cursor.mergeCharFormat(format)
        
            # Restore cursor position
            cursor = self.input_text.textCursor()
            cursor.setPosition(cursor_position)
            self.input_text.setTextCursor(cursor)
        
            # Restore scroll position
            scroll_bar.setValue(scroll_position)
        
            # Mark visibility as checked to prevent more checks
            if hasattr(self.input_text, '_visibility_checked'):
                self.input_text._visibility_checked = True
            
            if hasattr(self.input_text, '_last_check_time'):
                self.input_text._last_check_time = time.time()
        
            # Re-enable signals and updates
            self.input_text.blockSignals(False)
            self.input_text.setUpdatesEnabled(True)
        
            # Do a single repaint
            self.input_text.repaint()
        
            # Resume the highlighter with a long delay to prevent immediate rehighlighting
            if hasattr(self.input_text, 'header_highlighter'):
                highlighter = self.input_text.header_highlighter
            
                # First set flags to prevent rapid rehighlighting
                if hasattr(highlighter, '_last_rehighlight_time'):
                    highlighter._last_rehighlight_time = time.time()
                
                # Resume with a long delay
                QTimer.singleShot(2000, lambda: highlighter.resume_highlighting())
            
            # Show confirmation
            self.status_bar.showMessage("Text visibility fix applied", 2000)
            
        except Exception as e:
            print(f"Error in fix_invisible_text: {e}")
        
            # Always re-enable signals and updates
            if hasattr(self, 'input_text'):
                self.input_text.blockSignals(False)
                self.input_text.setUpdatesEnabled(True)

    def perform_delayed_header_detection(self):
        """Run header detection with extreme anti-stuttering measures"""
        try:
            # Only run if not loading
            if self.is_loading_session:
                return
            
            # Only refresh if input_text exists and has content
            if hasattr(self, 'input_text') and self.input_text and self.input_text.toPlainText():
                # Make sure header highlighting is properly reset
                if hasattr(self.input_text, 'header_highlighter'):
                    highlighter = self.input_text.header_highlighter
                
                    # Make sure highlighting is enabled
                    highlighter._highlighting_paused = False
                
                    # Run the orphaned text check with extreme throttling
                    if hasattr(highlighter, 'check_for_orphaned_text'):
                        highlighter.check_for_orphaned_text()
                    
                # Refresh headers list with delay to prevent UI freezing
                if hasattr(self, 'refresh_headers_list'):
                    QTimer.singleShot(500, self.refresh_headers_list)
                
        except Exception as e:
            print(f"Error in perform_delayed_header_detection: {e}")

    def set_text_with_verification(self, text_edit, text, max_retries=5, widget_name=None):
        """
        Set text in a text edit widget with verification to ensure it's properly loaded and visible.
    
        Args:
            text_edit: The QTextEdit widget to set text in
            text: The text to set
            max_retries: Maximum number of retry attempts
            widget_name: Name of the widget for logging/dialog updates (optional)
    
        Returns:
            bool: True if text was set successfully, False otherwise
        """
        if not text:
            return True  # Nothing to set
    
        # Try to determine widget name if not provided
        if not widget_name and hasattr(text_edit, 'objectName'):
            widget_name = text_edit.objectName()
        if not widget_name:
            widget_name = "Text field"
    
        text_length = len(text)
        retry_count = 0
    
        # Update loading dialog if available
        if hasattr(self, '_loading_dialog') and self._loading_dialog:
            self._loading_dialog.update_status(f"Loading {widget_name}...")
            self._loading_dialog.update_detail(f"Setting {text_length} characters")
    
        # Check if this is the input text editor that needs header handling
        is_input_text = (text_edit == self.input_text) if hasattr(self, 'input_text') else False
    
        # If this is the input text, pause header highlighting during load
        if is_input_text and hasattr(text_edit, 'header_highlighter'):
            if hasattr(text_edit.header_highlighter, 'pause_highlighting'):
                text_edit.header_highlighter.pause_highlighting()
    
        # Reset any text formatting and ensure default colors
        def reset_text_formatting():
            """Reset any text formatting that might cause rendering issues"""
            try:
                # Set default character format
                cursor = text_edit.textCursor()
                cursor.movePosition(QTextCursor.MoveOperation.Start)
                cursor.movePosition(QTextCursor.MoveOperation.End, QTextCursor.MoveMode.KeepAnchor)
            
                # Create a character format with explicit color settings
                format = QTextCharFormat()
                format.setForeground(QColor("#000000"))  # Black text
                cursor.setCharFormat(format)
            
                # Repaint the widget to ensure visibility
                text_edit.repaint()
                QApplication.processEvents()
            
                print(f"Reset text formatting for {widget_name}")
            except Exception as e:
                print(f"Error resetting text format: {e}")
    
        # Function to check text and retry if needed
        def check_and_retry():
            nonlocal retry_count
        
            # Verify the text was set correctly
            actual_text = text_edit.toPlainText()
            if actual_text == text:
                # Update loading dialog on success if available
                if hasattr(self, '_loading_dialog') and self._loading_dialog:
                    self._loading_dialog.update_detail(f"Loaded {len(actual_text)}/{text_length} characters successfully")
            
                # Force reset of text formatting to ensure visibility
                reset_text_formatting()
            
                # If this is input text, resume highlighting and update headers
                if is_input_text:
                    QTimer.singleShot(100, lambda: handle_successful_input_text_load(text_edit))
                
                # Force a final repaint and processing of events to ensure visibility
                text_edit.repaint()
                QApplication.processEvents()
            
                return True
        
            # If we've reached max retries, log and return false
            if retry_count >= max_retries:
                print(f"Warning: Failed to set full text after {max_retries} attempts")
                if len(actual_text) < text_length:
                    print(f"Text truncated: {len(actual_text)}/{text_length} characters loaded")
                
                    # Update loading dialog with error if available
                    if hasattr(self, '_loading_dialog') and self._loading_dialog:
                        self._loading_dialog.update_status(f"Warning: {widget_name} incomplete")
                        self._loading_dialog.update_detail(
                            f"Only {len(actual_text)}/{text_length} characters loaded"
                        )
            
                # Force reset of text formatting even for partial text
                reset_text_formatting()
            
                # Even with partial text, try to update headers if this is input text
                if is_input_text:
                    QTimer.singleShot(100, lambda: handle_successful_input_text_load(text_edit))
                
                return False
        
            # Try again with exponential backoff delay
            retry_count += 1
            print(f"{widget_name} verification failed (attempt {retry_count}/{max_retries}). " 
                  f"Expected length: {text_length}, actual: {len(actual_text)}")
        
            # Update loading dialog if available
            if hasattr(self, '_loading_dialog') and self._loading_dialog:
                self._loading_dialog.update_status(f"Retrying {widget_name} load...")
                self._loading_dialog.update_detail(
                    f"Attempt {retry_count}/{max_retries}\n"
                    f"Loaded: {len(actual_text)}/{text_length} characters"
                )
        
            # Exponential backoff: 100ms, 200ms, 400ms, 800ms...
            delay = 100 * (2 ** (retry_count - 1))
        
            # Schedule the retry
            QTimer.singleShot(delay, lambda: retry_set_text())
            return False
    
        # Helper function to handle successful input text load
        def handle_successful_input_text_load(text_edit):
            if not hasattr(text_edit, 'header_highlighter'):
                return
            
            # Resume highlighting
            if hasattr(text_edit.header_highlighter, 'resume_highlighting'):
                text_edit.header_highlighter.resume_highlighting()
            
            # Run the orphaned text check
            if hasattr(text_edit.header_highlighter, 'check_for_orphaned_text'):
                text_edit.header_highlighter.check_for_orphaned_text()
            
            # Refresh the headers list if we have that method
            if hasattr(self, 'refresh_headers_list'):
                self.refresh_headers_list()
    
        # Function to set text and process events
        def retry_set_text():
            # Update loading dialog if available
            if hasattr(self, '_loading_dialog') and self._loading_dialog:
                self._loading_dialog.update_detail(f"Setting text (attempt {retry_count + 1})")
        
            # Clear existing content first to prevent any formatting issues
            text_edit.blockSignals(True)
            text_edit.clear()  # Clear first to prevent potential memory issues
        
            # Set plain text
            text_edit.setPlainText(text)
        
            # Force additional update calls
            text_edit.viewport().update()
            text_edit.document().documentLayout().documentSizeChanged.emit(text_edit.document().size())
        
            text_edit.blockSignals(False)
        
            # Process events to ensure the text is set and UI updates
            QApplication.processEvents()
        
            # Force a repaint to ensure visibility
            text_edit.repaint()
            QApplication.processEvents()
        
            # Check if text was set correctly
            result = check_and_retry()
        
            # Run a post-setting state refresh only if successful and not input text
            # (input text is handled separately above)
            if result and not is_input_text and hasattr(text_edit, 'header_highlighter') and text_edit.header_highlighter:
                # Update loading dialog if available
                if hasattr(self, '_loading_dialog') and self._loading_dialog:
                    self._loading_dialog.update_detail("Running highlighter...")
            
                QTimer.singleShot(500, lambda: text_edit.header_highlighter.check_for_orphaned_text())
        
            return result
    
        # Initial attempt
        text_edit.blockSignals(True)
        text_edit.clear()  # Clear first to prevent potential memory issues
    
        # Set plain text with no formatting
        text_edit.setPlainText(text)
    
        # Force update calls
        text_edit.viewport().update()
        text_edit.document().documentLayout().documentSizeChanged.emit(text_edit.document().size())
    
        text_edit.blockSignals(False)
    
        # Process events to ensure the text is set
        QApplication.processEvents()
    
        # Force a repaint to ensure visibility
        text_edit.repaint()
        QApplication.processEvents()
    
        # Check result of initial attempt
        return check_and_retry()
  
    def load_session(self, file_path=None, skip_confirmation=False, skip_recent_dialog=False, restore_scroll=None):
        """
        Load a session file, manage recent sessions, and create backups.
        """
        try:
            # Add loading state flags first
            self.is_loading_session = True
            self._scroll_restore_handled = False
            self._verified_content = False  # Reset verification flag
            self._theme_view_populated = False  # Reset theme view population flag
    
            # Load recent sessions only if not skipping the recent dialog
            if not skip_recent_dialog:
                self.recent_sessions = self.load_recent_sessions()

            # Confirm loading new session BEFORE showing loading dialog
            if not skip_confirmation and self.current_session_file:
                # First save the current scroll position
                def handle_scroll(scroll_pos):
                    try:
                        with open(self.current_session_file, 'r', encoding='utf-8') as f:
                            session_data = json.load(f)
    
                        if 'preview' not in session_data:
                            session_data['preview'] = {}
                        session_data['preview']['scroll_position'] = scroll_pos

                        with open(self.current_session_file, 'w', encoding='utf-8') as f:
                            json.dump(session_data, f, indent=4, ensure_ascii=False)
                        print(f"Scroll position saved before load confirmation: {scroll_pos}")
                    except Exception as e:
                        print(f"Error saving scroll position before load: {e}")

                # Get current scroll position before showing confirmation dialog
                self.web_view.page().runJavaScript("window.pageYOffset", handle_scroll)

                confirm_dialog = QMessageBox(self)
                confirm_dialog.setWindowTitle("Load New Session")
                confirm_dialog.setText("Are you sure you want to load a new session?")
                confirm_dialog.setInformativeText("Loading a new session will close the current one.")
                confirm_dialog.setStandardButtons(
                    QMessageBox.StandardButton.Yes | 
                    QMessageBox.StandardButton.No
                )
                confirm_dialog.setDefaultButton(QMessageBox.StandardButton.No)

                if confirm_dialog.exec() != QMessageBox.StandardButton.Yes:
                    self.is_loading_session = False
                    return

            # Check for unsaved changes BEFORE showing loading dialog
            if not skip_confirmation and self.has_unsaved_changes():
                reply = QMessageBox.question(
                    self,
                    'Unsaved Changes',
                    'Do you want to save your changes before loading a new session?',
                    QMessageBox.StandardButton.Save |
                    QMessageBox.StandardButton.Discard |
                    QMessageBox.StandardButton.Cancel
                )

                if reply == QMessageBox.StandardButton.Save:
                    if not self.save_session():
                        self.is_loading_session = False
                        return
                elif reply == QMessageBox.StandardButton.Cancel:
                    self.is_loading_session = False
                    return

            # Close welcome dialog if open
            if hasattr(self, 'welcome_dialog') and self.welcome_dialog:
                if self.welcome_dialog.isVisible():
                    self.welcome_dialog.close()
                if self.welcome_dialog is not None:
                    self.welcome_dialog.deleteLater()
                self.welcome_dialog = None

            # Handle file selection BEFORE showing loading dialog
            if not file_path and not skip_recent_dialog:
                recent_dialog = LoadRecentSessionDialog(recent_sessions=self.recent_sessions, parent=self)
                if recent_dialog.exec() == QDialog.DialogCode.Accepted:
                    file_path = recent_dialog.get_selected_file()
                else:
                    self.is_loading_session = False
                    return

            if not file_path:
                file_dialog = QFileDialog(self)
                file_dialog.setWindowTitle("Select Session File")
                file_dialog.setNameFilter("Session Files (*.session);;All Files (*)")
                file_dialog.setFileMode(QFileDialog.FileMode.ExistingFile)
                file_dialog.setViewMode(QFileDialog.ViewMode.Detail)

                if file_dialog.exec() == QDialog.DialogCode.Accepted:
                    selected_files = file_dialog.selectedFiles()
                    if selected_files:
                        file_path = selected_files[0]
                    else:
                        self.is_loading_session = False
                        return
                else:
                    self.is_loading_session = False
                    return

            # Check file exists BEFORE showing loading dialog
            if not os.path.exists(file_path):
                QMessageBox.critical(
                    self,
                    'File Not Found',
                    f"The session file does not exist:\n{file_path}"
                )
                self.is_loading_session = False
                return

            # NOW show the loading dialog - after all confirmations and file selection
            self._loading_dialog = LoadingDialog(self)
            # Set a timeout for the loading dialog to ensure it always closes
            if hasattr(self._loading_dialog, 'set_timeout'):
                self._loading_dialog.set_timeout(30000)  # 30 second timeout
        
            self._loading_dialog.show()

            # Add the selected session to recent sessions if not skipping
            if not skip_recent_dialog:
                if file_path not in self.recent_sessions:
                    self.recent_sessions.insert(0, file_path)
                    self.recent_sessions = self.recent_sessions[:5]  # Keep only the 5 most recent
                    self.save_recent_sessions()

            # Clean up all panels before loading
            self.clean_panels_before_load()

            # Create backups of the session being loaded
            self.create_session_backup(file_path)

            # Load and process the session file
            with open(file_path, 'r', encoding='utf-8') as f:
                session_data = json.load(f)

            # Store session data for potential retries
            self._current_session_data = session_data
        
            # Initialize the bookmark panel if it doesn't exist
            if not hasattr(self, 'bookmark_panel'):
                self.bookmark_panel = BookmarkPanel(self.web_view)
                self.bookmark_panel.scroll_to_position.connect(self.scroll_to_position)
                self.right_panel_container.layout().addWidget(self.bookmark_panel)
                self.bookmark_panel.hide()  # Hide initially

            # Load bookmarks data with a default value for 'is_favorite'
            if 'bookmarks' in session_data:
                bookmarks_data = session_data['bookmarks']
                for bookmark in bookmarks_data:
                    bookmark.setdefault('is_favorite', False)  # Add 'is_favorite' if missing
                self.bookmark_panel.load_bookmarks(bookmarks_data)

            self.current_session_file = file_path
            # Remove '.session' from window title
            stripped_name = file_path.rsplit('.session', 1)[0]
            self.setWindowTitle(f'Scriptoria - {os.path.basename(stripped_name)}')

            version = session_data.get('version', '1.0')
            if not self.is_compatible_version(version):
                QMessageBox.warning(
                    self,
                    'Version Warning',
                    f'Session file version ({version}) may not be fully compatible with current version.'
                )

            # Load basic tab data
            # Update loading dialog to show the current operation
            if hasattr(self, '_loading_dialog') and self._loading_dialog:
                self._loading_dialog.update_status("Loading text content...")
            
            cleaner_data = session_data.get('cleaner', {})
            self.cleaner_input_text.setPlainText(cleaner_data.get('input', ''))
            self.cleaner_output_text.setPlainText(cleaner_data.get('output', ''))
            
            # Don't apply formatting to input area during session load
            # self.format_file_headers()  # For input area - disabled
            # self.format_output_file_headers()  # For output area - temporarily disabled

            input_data = session_data.get('input', {})
            self.input_text.setPlainText(input_data.get('text', ''))

            output_data = session_data.get('output', {})
            self.output_text.setPlainText(output_data.get('html', ''))

            # Set current tab to preview widget first
            self.tabs.setCurrentWidget(self.preview_widget)

            # Load Preview tab data
            preview_data = session_data.get('preview', {})
            html_content = preview_data.get('html', '') # Get the large HTML string

            # Initialize tags from session data
            self.tags = session_data.get('tags', [])
            
            # Initialize session headers from session data
            if hasattr(self, 'script_search'):
                self.script_search.session_headers = session_data.get('session-headers', [])
                self.script_search.available_headers = set(self.script_search.session_headers)
                print(f"[DEBUG] Restored {len(self.script_search.session_headers)} session headers: {self.script_search.session_headers}")
    
            # Always ensure tag button is properly initialized
            if not hasattr(self, 'tag_button'):
                self.tag_button = QPushButton()
                tag_icon = QIcon("Img/tag.png")
                self.tag_button.setIcon(tag_icon)
                self.tag_button.setIconSize(QSize(35, 35))
                self.tag_button.setFixedSize(40, 40)
                self.tag_button.setToolTip("Manage Tags (0)")
                self.tag_button.setStyleSheet("""
                    QPushButton {
                        background-color: transparent;
                        border: none;
                        padding: 2px;
                    }
                    QPushButton:hover {
                        background-color: #f0f0f0;
                        border-radius: 5px;
                    }
                """)
                self.tag_button.clicked.connect(self.show_tag_dialog)

            # Update tag button tooltip to show count
            tag_count = len(self.tags)
            self.tag_button.setToolTip(f"Manage Tags ({tag_count})")

            # Load scene styles with order preservation
            if 'ordered_scenes' in preview_data:
                ordered_styles = {
                    scene: preview_data['scene_styles'][scene]
                    for scene in preview_data['ordered_scenes']
                    if scene in preview_data['scene_styles']
                }
                self.web_view.scene_styles = ordered_styles
            else:
                self.web_view.scene_styles = preview_data.get('scene_styles', {})

            # Process and load annotations
            annotations = preview_data.get('annotations', [])
            current_time = datetime.datetime.now().isoformat()
            self.web_view.annotations = [
                {
                    **anno,
                    'id': anno.get('id', str(uuid.uuid4())),
                    'timestamp': anno.get('timestamp', current_time),
                    'notes': anno.get('notes', ''),
                    'notes_html': anno.get('notes_html', ''),
                    'used': anno.get('used', False),
                }
                for anno in annotations
            ]

            # Update loading dialog for the next phase
            if hasattr(self, '_loading_dialog') and self._loading_dialog:
                self._loading_dialog.update_status("Loading preview content...")

            # === CHANGE START ===
            # Decide loading strategy based on content size (e.g., > 2MB)
            # Use a threshold appropriate for your typical "large" files
            LOAD_FROM_FILE_THRESHOLD = 2 * 1024 * 1024 # 2 MB

            if not html_content:
                print("No HTML content found in session, proceeding with empty.")
                # Ensure file_path is passed correctly here
                self._handle_html_load_finished(True, preview_data, restore_scroll, file_path)
                return # Exit if no HTML

            # --- Webview Reset ---
            # Add this reset before any loading attempt
            self._reset_web_view_state()
            # --- End Webview Reset ---

            # Disconnect any existing loadFinished connections
            try:
                self.web_view.loadFinished.disconnect()
            except TypeError:
                pass # No connections to disconnect

            # Connect new loadFinished handler
            # Pass file_path for base URL context later if needed
            self.web_view.loadFinished.connect(lambda success: self._handle_html_load_finished(
                success, preview_data, restore_scroll, file_path
            ))

            if len(html_content.encode('utf-8')) > LOAD_FROM_FILE_THRESHOLD:
                print(f"HTML content exceeds threshold ({LOAD_FROM_FILE_THRESHOLD} bytes), loading from temporary file.")
                try:
                    # Create a temporary file
                    import tempfile
                    # Use delete=False so we control deletion, get path via .name
                    with tempfile.NamedTemporaryFile(mode='w', suffix=".html", delete=False, encoding='utf-8') as temp_f:
                        temp_path = temp_f.name
                        print(f"Writing HTML to temporary file: {temp_path}")
                        temp_f.write(html_content)
                        self._temp_html_path = temp_path # Store path for later cleanup

                    # Load the URL of the temporary file
                    file_url = QUrl.fromLocalFile(temp_path)
                    print(f"Loading WebView from URL: {file_url.toString()}")
                    self.web_view.load(file_url)

                except Exception as e:
                    print(f"Error creating/writing temporary file, falling back to setHtml: {e}")
                    # Fallback to setHtml if file creation fails
                    self.web_view.setHtml(
                        html_content,
                        baseUrl=QUrl.fromLocalFile(os.path.dirname(file_path) + os.sep)
                    )
            else:
                # *** EXPERIMENTAL FIX: Force file-based loading for large HTML (>1MB) ***
                if len(html_content) > 1000000:  # If larger than 1MB
                    print(f"DEBUG: Large HTML content ({len(html_content)} chars) detected, using temporary file method instead of setHtml")
                    try:
                        # Create temporary file and load it instead
                        import tempfile
                        with tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False, encoding='utf-8') as temp_file:
                            temp_file.write(html_content)
                            temp_file_path = temp_file.name
                        
                        print(f"DEBUG: Created temporary file: {temp_file_path}")
                        file_url = QUrl.fromLocalFile(temp_file_path)
                        print(f"DEBUG: Loading from temporary file URL: {file_url.toString()}")
                        self.web_view.load(file_url)
                        
                        # Clean up temp file after a delay
                        def cleanup_temp_file():
                            try:
                                os.unlink(temp_file_path)
                                print(f"DEBUG: Cleaned up temporary file: {temp_file_path}")
                            except:
                                pass
                        QTimer.singleShot(30000, cleanup_temp_file)  # Clean up after 30 seconds
                        
                    except Exception as e:
                        print(f"Error creating temporary file for large HTML, falling back to setHtml: {e}")
                        # Fallback to setHtml
                        self.web_view.setHtml(
                            html_content,
                            baseUrl=QUrl.fromLocalFile(os.path.dirname(file_path) + os.sep)
                        )
                else:
                    # For smaller files, use setHtml directly
                    print("HTML content within threshold, loading using setHtml.")
                    
                    # *** DEBUG: Log HTML content info before loading ***
                    print(f"DEBUG: About to setHtml - Content length: {len(html_content)}")
                    print(f"DEBUG: HTML preview (first 200 chars): {html_content[:200]}")
                    print(f"DEBUG: Base URL: {QUrl.fromLocalFile(os.path.dirname(file_path) + os.sep).toString()}")
                    
                    self.web_view.setHtml(
                        html_content,
                        baseUrl=QUrl.fromLocalFile(os.path.dirname(file_path) + os.sep)
                    )
            # === CHANGE END ===

        except Exception as e:
            # Ensure loading dialog is closed on error
            if hasattr(self, '_loading_dialog') and self._loading_dialog:
                self._loading_dialog.close()
                self._loading_dialog = None
        
            self.is_loading_session = False
            QMessageBox.critical(
                self,
                'Error Loading Session',
                f'Failed to load session:\n{str(e)}'
            )

    # MODIFIED METHOD TO FIX PLACEHOLDER FALSE POSITIVE
    def _handle_html_load_finished(self, success, preview_data, restore_scroll, file_path, retry_count=0, max_retries=3):
        """Enhanced HTML loading handler with placeholder detection and better error recovery"""

        # Force-ensure loading dialog stays open during retries
        if hasattr(self, '_loading_dialog') and self._loading_dialog and not self._loading_dialog.isVisible():
            self._loading_dialog.show()

        # Save these values as instance variables to prevent garbage collection/scope issues
        self._current_success = success
        self._current_preview_data = preview_data
        self._current_restore_scroll = restore_scroll
        self._current_file_path = file_path
        self._current_retry_count = retry_count
        self._current_max_retries = max_retries

        # Add a timeout to ensure loading dialog always closes (only set on first call)
        if retry_count == 0:
             # Store original HTML for potential emergency reload
            if preview_data and 'html' in preview_data:
                self._current_html_content = preview_data['html']
            else:
                 self._current_html_content = "" # Ensure it exists
            # Set timeout timer
            if hasattr(self, '_loading_timeout_timer') and self._loading_timeout_timer.isActive():
                 self._loading_timeout_timer.stop() # Stop previous timer if exists
            self._loading_timeout_timer = QTimer()
            self._loading_timeout_timer.setSingleShot(True)
            self._loading_timeout_timer.timeout.connect(self.ensure_loading_dialog_closed)
            self._loading_timeout_timer.start(30000) # 30 second timeout

        # Check if HTML content is actually available regardless of loadFinished signal
        html_content = self._current_html_content if hasattr(self, '_current_html_content') else ""
        html_is_available = len(html_content) > 100000  # If we have substantial content, don't retry
        
        # Log the actual situation
        print(f"DEBUG: HTML loading check - success={success}, html_available={html_is_available}, html_length={len(html_content)}")
        
        # If initial loadFinished signal indicates failure, BUT check if content is actually available
        if not success and retry_count < max_retries and not html_is_available:
            if hasattr(self, '_loading_dialog') and self._loading_dialog:
                self._loading_dialog.update_status(f"Initial HTML load failed, retrying ({retry_count + 1}/{max_retries})...")

            delay = 800 * (2 ** retry_count)
            print(f"HTML load failed (attempt {retry_count + 1}/{max_retries}), retrying in {delay}ms...")

            # Re-set the HTML content before retrying the handler logic
            def retry_load():
                print(f"Retrying setHtml for attempt {self._current_retry_count + 1}")
                
                # *** DEBUG: Log retry info ***
                html_content = self._current_html_content if hasattr(self, '_current_html_content') else ""
                print(f"DEBUG: Retry attempt - HTML content available: {len(html_content) > 0}")
                print(f"DEBUG: Retry HTML length: {len(html_content)}")
                if len(html_content) > 0:
                    print(f"DEBUG: Retry HTML preview (first 200 chars): {html_content[:200]}")
                else:
                    print("DEBUG: WARNING - No HTML content available for retry!")
                
                 # Reconnect the handler before setting HTML again
                try:
                    self.web_view.loadFinished.disconnect()
                except TypeError: pass
                self.web_view.loadFinished.connect(lambda ok: self._handle_html_load_finished(
                    ok, # Use the actual success value from the retry
                    self._current_preview_data,
                    self._current_restore_scroll,
                    self._current_file_path,
                    self._current_retry_count + 1, # Increment retry count here
                    self._current_max_retries
                ))
                # Use stored original HTML for retry
                self.web_view.setHtml(
                    html_content,
                    baseUrl=QUrl.fromLocalFile(os.path.dirname(self._current_file_path) + os.sep)
                )

            QTimer.singleShot(delay, retry_load)
            QCoreApplication.processEvents()
            return

        # If HTML content is available despite loadFinished=False, proceed directly
        if not success and html_is_available:
            print(f"DEBUG: loadFinished reported false but HTML content is available ({len(html_content)} chars). Skipping retries and proceeding.")

        # If loadFinished reported success OR we exhausted initial retries OR HTML content is available, proceed to JS verification
        print(f"loadFinished reported success={success} on attempt {retry_count+1}. Proceeding to JS content check.")

        # Check if we already verified content to prevent duplicate processing in recursive calls
        if hasattr(self, '_verified_content') and self._verified_content:
            print("Content already verified, skipping duplicate JS check.")
            # Only close dialog if we're not loading a session AND not updating theme view
            if not getattr(self, 'is_loading_session', False) and not getattr(self, '_updating_theme_view_for_session', False):
                print("🔍 DEBUG: Content verified and not loading session - closing dialog")
                self.ensure_loading_dialog_closed()
            else:
                print("🔍 DEBUG: Content verified but session still loading or theme view updating - keeping dialog open")
            return

        # Update loading dialog status
        if hasattr(self, '_loading_dialog') and self._loading_dialog:
            self._loading_dialog.update_status(f"Verifying content (attempt {retry_count + 1}/{max_retries})...")

        # *** MODIFIED JAVASCRIPT ***
        # JavaScript function to check the content status, now includes placeholder detection
        js_code = """
        (function checkContent() {
            try {
                if (!document.body) return { hasContent: false, error: "No document body" };

                const bodyHtml = document.body.innerHTML;
                const elementCount = document.getElementsByTagName('*').length;
                const textContent = document.body.textContent.trim();
                const title = document.title || "No title";

                // *** PLACEHOLDER CHECK ADDED HERE ***
                // Check for specific elements/text unique to the placeholder
                const isPlaceholder = bodyHtml.includes('No Content Yet') && bodyHtml.includes('font-size: 4rem');
                if (isPlaceholder) {
                    return {
                        hasContent: false, // CRITICAL: Report false if placeholder found
                        error: "Placeholder content detected",
                        isPlaceholder: true, // Flag indicating placeholder
                        bodyPreview: bodyHtml.substring(0, 300),
                        contentLength: textContent.length,
                        elementCount: elementCount,
                        documentTitle: title
                    };
                }
                // *** END OF PLACEHOLDER CHECK ***

                // Original check (can be refined further if needed, e.g., checking for specific transcript elements)
                // Check for minimum content length and element count as a basic sanity check
                const hasSufficientContent = textContent.length > 200 && elementCount > 20; // Adjust thresholds as needed

                // *** ENHANCED DEBUG LOGGING ***
                console.log("=== CONTENT VALIDATION DEBUG ===");
                console.log("Text Content Length:", textContent.length);
                console.log("Element Count:", elementCount);
                console.log("Text Content Preview:", textContent.substring(0, 100));
                console.log("Body HTML Preview:", bodyHtml.substring(0, 200));
                console.log("Document Title:", title);
                console.log("Has Sufficient Content:", hasSufficientContent);
                console.log("Content Threshold Check: textContent.length > 200 =", textContent.length > 200);
                console.log("Element Threshold Check: elementCount > 20 =", elementCount > 20);
                console.log("=================================");

                return {
                    hasContent: hasSufficientContent,
                    isPlaceholder: false, // Not the placeholder
                    contentLength: textContent.length,
                    elementCount: elementCount,
                    bodyPreview: bodyHtml.substring(0, 300),
                    textPreview: textContent.substring(0, 300), // *** ADDED TEXT PREVIEW ***
                    documentTitle: title,
                    windowInnerHeight: window.innerHeight,
                    windowInnerWidth: window.innerWidth,
                    // Include image checks if still relevant
                    regularImageCount: document.querySelectorAll('img[src*="bookmark.png"]:not([src*="bookmark-filled"])').length,
                    filledImageCount: document.querySelectorAll('img[src*="bookmark-filled.png"]').length,
                    totalImageCount: document.querySelectorAll('img').length,
                    loadedImageCount: Array.from(document.querySelectorAll('img')).filter(img => img.complete && img.naturalWidth > 0).length,
                    // *** ENHANCED ERROR MESSAGE ***
                    error: hasSufficientContent ? null : `Content insufficient - Length: ${textContent.length} (need >200), Elements: ${elementCount} (need >20)`
                };
            } catch (e) {
                return { hasContent: false, error: e.toString(), isPlaceholder: false };
            }
        })();
        """

        # DIRECT HANDLER: No intermediate function to avoid garbage collection issues
        def direct_content_handler(result):
            try:
                # Debug: Print result for troubleshooting
                print(f"CONTENT CHECK RESULT: {result}")

                is_placeholder = False
                has_content = False # Default to false

                if isinstance(result, dict):
                    # *** UPDATED LOGIC TO CHECK isPlaceholder FLAG ***
                    is_placeholder = result.get('isPlaceholder', False)
                    if is_placeholder:
                        print("Placeholder content detected by JavaScript check.")
                        has_content = False # Explicitly treat placeholder as no *valid* content
                    else:
                        # If not placeholder, use the 'hasContent' value from JS check
                        has_content = result.get('hasContent', False)
                    # *** END OF UPDATED LOGIC ***

                    # Log detailed content status
                    print(f"Content check - Placeholder: {is_placeholder}, Has Valid Content: {has_content}, " +
                          f"JS Reported Length: {result.get('contentLength', 0)}, " +
                          f"JS Reported Elements: {result.get('elementCount', 0)}")
                    if 'bodyPreview' in result:
                         print(f"Body HTML preview: {result['bodyPreview']}")
                    if 'error' in result and result['error']:
                        print(f"Content check error reported by JS: {result['error']}")

                else:
                     # Handle cases where JS might return non-dict (e.g., null, undefined -> becomes None in Python)
                     print(f"Content check returned unexpected type or null: {result}. Assuming no content.")
                     has_content = False


                # Set content as verified ONLY if successful AND not placeholder
                # We only set this flag to True here if everything is ok to proceed.
                # It remains False if we need to retry or reload.
                
                # *** BYPASS FIX: If HTML content is substantial but DOM validation fails,
                # assume it's a WebView rendering issue and mark as verified ***
                html_content_size = len(getattr(self, '_current_html_content', ''))
                if html_content_size > 100000:  # If we have substantial HTML content (>100KB)
                    print(f"DEBUG: Large HTML content ({html_content_size} chars) detected but DOM validation failed")
                    print("DEBUG: Assuming WebView rendering issue - marking content as verified")
                    
                    # *** ADDITIONAL DEBUG: Check what's actually in the WebView ***
                    def check_webview_content(actual_html):
                        print(f"DEBUG: WebView actual HTML length: {len(actual_html) if actual_html else 0}")
                        if actual_html:
                            print(f"DEBUG: WebView HTML preview: {actual_html[:200]}")
                        else:
                            print("DEBUG: WebView returned no HTML content!")
                            print("DEBUG: Attempting to force reload with original content...")
                            # Try to reload the content directly
                            if hasattr(self, '_current_file_path') and self._current_file_path:
                                base_path = os.path.dirname(self._current_file_path)
                                self.web_view.setHtml(
                                    self._current_html_content,
                                    baseUrl=QUrl.fromLocalFile(base_path + os.sep)
                                )
                    
                    # Get actual HTML from WebView to debug
                    self.web_view.page().toHtml(check_webview_content)
                    
                    self._verified_content = True
                    has_content = True  # Override for subsequent logic
                else:
                    self._verified_content = has_content and not is_placeholder

                # If content isn't ready yet (either truly empty, insufficient, or placeholder detected)
                # AND we haven't maxed out retries
                if not self._verified_content and self._current_retry_count < self._current_max_retries:
                    delay = 800 * (2 ** self._current_retry_count) # Use current retry count for delay calculation
                    log_reason = "Placeholder detected" if is_placeholder else "Content not ready/sufficient"
                    print(f"{log_reason} (attempt {self._current_retry_count + 1}/{self._current_max_retries}), retrying in {delay}ms...")

                    # Define the retry function using current (incremented) retry count
                    # Store the retry function as instance variable to prevent garbage collection
                    self._content_retry_function = lambda: self._handle_html_load_finished(
                        True, # Assume loadFinished was ok, focus on content verification retry
                        self._current_preview_data,
                        self._current_restore_scroll,
                        self._current_file_path,
                        self._current_retry_count + 1, # Increment retry count for the *next* call
                        self._current_max_retries
                    )

                    QTimer.singleShot(delay, self._content_retry_function)
                    QCoreApplication.processEvents()
                    return # Exit handler, wait for retry

                # CRITICAL FALLBACK: If content still not ready after retries, try emergency reloading
                # This now correctly triggers if placeholder is still detected after retries
                if not self._verified_content and self._current_retry_count >= self._current_max_retries:
                    print(f"Content still not ready or is placeholder after max retries ({self._current_max_retries + 1}), attempting emergency reload")
                    
                    # *** DEBUG: Log why emergency reload was triggered ***
                    print(f"DEBUG: Emergency reload triggered because:")
                    print(f"  - _verified_content: {self._verified_content}")
                    print(f"  - _current_retry_count: {self._current_retry_count}")
                    print(f"  - _current_max_retries: {self._current_max_retries}")
                    print(f"  - has_content from last check: {has_content if 'has_content' in locals() else 'N/A'}")
                    print(f"  - is_placeholder from last check: {is_placeholder if 'is_placeholder' in locals() else 'N/A'}")
                    
                    if hasattr(self, '_current_html_content'):
                        print(f"DEBUG: Emergency reload HTML available, length: {len(self._current_html_content)}")
                        self._emergency_reload_session_html(self._current_preview_data, self._current_restore_scroll)
                        return # Exit handler, emergency reload will take over
                    else:
                         print("ERROR: Cannot perform emergency reload, no stored HTML content.")
                         print("DEBUG: Available attributes:", [attr for attr in dir(self) if attr.startswith('_current')])
                         # Proceed to UI update, but it will likely show placeholder/error
                         self._update_ui_after_load(self._current_preview_data, self._current_restore_scroll)
                         self.ensure_loading_dialog_closed() # Ensure dialog closes even in this error state
                         return


                # If we get here, content is verified (has_content is True and isPlaceholder is False)
                print("Content verified successfully.")
                # Proceed with UI updates
                self._update_ui_after_load(self._current_preview_data, self._current_restore_scroll)

            except Exception as e:
                print(f"ERROR in direct_content_handler: {e}")
                import traceback
                traceback.print_exc()
                # Ensure we proceed even with errors, but log it clearly
                print("Proceeding with UI update despite error in handler.")
                self._update_ui_after_load(self._current_preview_data, self._current_restore_scroll)
                self.ensure_loading_dialog_closed() # Ensure dialog closes

        # Run the content check
        if hasattr(self, 'web_view') and self.web_view and self.web_view.page():
            # *** INCREASED DELAY: Add more time for DOM to fully populate ***
            print("DEBUG: Scheduling content validation in 1000ms to allow DOM to fully render...")
            QTimer.singleShot(1000, lambda: self.web_view.page().runJavaScript(js_code, direct_content_handler))
        else:
            print("Web view not available, cannot verify content.")
            # If web view isn't available, proceed anyway but log warning
            self._update_ui_after_load(preview_data, restore_scroll)
            self.ensure_loading_dialog_closed()

    def _emergency_reload_session_html(self, preview_data, restore_scroll):
        """Emergency reload of HTML content when initial load verification fails"""
        try:
            print("EMERGENCY: Reloading HTML content after verification failure")
        
            if not hasattr(self, '_current_html_content') or not self._current_html_content:
                print("ERROR: No HTML content available for emergency reload")
                self._update_ui_after_load(preview_data, restore_scroll)
                return
            
            # Disconnect any existing loadFinished connections
            try:
                self.web_view.loadFinished.disconnect()
            except TypeError:
                pass
            
            # Connect to a simple handler for emergency reload
            def emergency_handler(success):
                print(f"Emergency reload completed: success={success}")
                try:
                    self.web_view.loadFinished.disconnect()
                except TypeError:
                    pass
                
                # Fix bookmark images immediately
                self.fix_bookmark_images()
                
                # Continue with UI updates immediately - no timer delay
                self._update_ui_after_load(preview_data, restore_scroll)
        
            # Connect the handler
            self.web_view.loadFinished.connect(emergency_handler)
        
            # First load empty content to reset WebView state
            self.web_view.setHtml("<html><body>Emergency reset...</body></html>")
        
            # Force process events
            QCoreApplication.processEvents()
        
            # Wait briefly then reload the real content
            QTimer.singleShot(800, lambda: self._execute_emergency_reload(preview_data))
        
        except Exception as e:
            print(f"Error during emergency reload: {e}")
            import traceback
            traceback.print_exc()
            self._update_ui_after_load(preview_data, restore_scroll)

    def _execute_emergency_reload(self, preview_data):
        """Execute the emergency reload with the saved HTML content"""
        try:
            # IMPORTANT: Get the baseUrl from the session file directory
            base_path = None
            if hasattr(self, '_current_file_path') and self._current_file_path:
                base_path = os.path.dirname(self._current_file_path)
            else:
                base_path = os.path.dirname(os.path.abspath(__file__))
        
            print(f"Emergency reload with baseUrl: {base_path}")
            
            # *** DEBUG: Log emergency reload info ***
            html_content = getattr(self, '_current_html_content', '')
            print(f"DEBUG: Emergency reload - HTML content available: {len(html_content) > 0}")
            print(f"DEBUG: Emergency reload HTML length: {len(html_content)}")
            if len(html_content) > 0:
                print(f"DEBUG: Emergency HTML preview (first 300 chars): {html_content[:300]}")
                print(f"DEBUG: Emergency HTML contains body tag: {'<body' in html_content}")
                print(f"DEBUG: Emergency HTML contains head tag: {'<head' in html_content}")
            else:
                print("DEBUG: CRITICAL - No HTML content available for emergency reload!")
                # Try to provide minimal fallback content
                html_content = "<html><head><title>Content Loading...</title></head><body><p>Loading content...</p></body></html>"
                print(f"DEBUG: Using fallback HTML content: {html_content}")
        
            # Set the HTML content again
            self.web_view.setHtml(
                html_content,
                baseUrl=QUrl.fromLocalFile(base_path + os.sep)
            )
        except Exception as e:
            print(f"Error during emergency reload execution: {e}")
            import traceback
            traceback.print_exc()

    def _update_ui_after_load(self, preview_data, restore_scroll):
        """Update UI elements after content is verified as loaded"""
        try:
            # Add debugging to track execution
            print(f"_update_ui_after_load called with restore_scroll={restore_scroll}")
        
            # Store scroll position for later with proper fallback
            scroll_pos = None
            if restore_scroll is not None:
                scroll_pos = restore_scroll
                print(f"Using explicit restore_scroll value: {scroll_pos}")
            elif preview_data and 'scroll_position' in preview_data:
                scroll_pos = preview_data.get('scroll_position')
                print(f"Using scroll position from preview_data: {scroll_pos}")
        
            print(f"Final scroll_pos: {scroll_pos}")
        
            # CRITICAL: Fix bookmark images BEFORE updating panels
            # This ensures images are fixed even if content check partially failed
            
            # First, permanently update the HTML with correct paths
            print("[DEBUG] Calling update_bookmark_images to permanently fix paths")
            self.update_bookmark_images()
            
            # Then apply the runtime fix as well
            self.fix_bookmark_images()
        
            # Add a verification check for bookmark images
            QTimer.singleShot(500, self.verify_bookmark_images)
        
            # Schedule heavy operations asynchronously to keep loading animation responsive
            self._pending_scroll_pos = scroll_pos
            self._pending_restore_scroll = restore_scroll
            
            # Reinitialize sticky header after session load (only if enabled in settings)
            if hasattr(self, 'web_view') and self.web_view:
                # Check QSettings for sticky header preference
                sticky_enabled = getattr(self.web_view, 'sticky_header_enabled', False)
                if sticky_enabled:
                    print("[DEBUG] Reinitializing sticky header after session load")
                    # Use a timer to ensure DOM is ready
                    QTimer.singleShot(100, self._reinitialize_sticky_header)
                else:
                    print("[DEBUG] Sticky header disabled in settings, skipping reinitialization")
                    # Ensure sticky header elements are completely removed when disabled
                    self._ensure_sticky_header_cleared()

            # Always update theme view when session loads (visible or not)
            if hasattr(self, 'theme_view') and self.theme_view:
                # Update loading dialog status
                if hasattr(self, '_loading_dialog') and self._loading_dialog:
                    self._loading_dialog.update_status("Loading Theme Panel...")
                    self._loading_dialog.update_detail("Processing annotations...")
                
                # Set flag to prevent dialog from being closed during theme view update
                self._updating_theme_view_for_session = True
                
                # Reset the loading session flag so theme view update can proceed
                self.is_loading_session = False
                
                # Use timer to allow loading animation to continue
                QTimer.singleShot(50, self._async_update_theme_view)
            else:
                # Use timer for scene tabs to keep animation responsive
                QTimer.singleShot(50, self._async_update_scene_tabs)

        except Exception as e:
            self.is_loading_session = False
            print(f"ERROR in _update_ui_after_load: {str(e)}")
            import traceback
            traceback.print_exc()

    def _async_update_theme_view(self):
        """Async theme view update to keep loading animation responsive"""
        try:
            # Check if we're still loading the session
            if getattr(self, 'is_loading_session', False):
                print("[DEBUG] Session still loading, deferring theme view update...")
                QTimer.singleShot(300, self._async_update_theme_view)
                return
                
            # Verify web_view.annotations is ready and properly populated
            if not hasattr(self.web_view, 'annotations') or self.web_view.annotations is None:
                print("[DEBUG] web_view.annotations not ready, deferring theme view update...")
                # Check if we've been waiting too long (avoid infinite loop)
                if not hasattr(self, '_theme_update_attempts'):
                    self._theme_update_attempts = 0
                self._theme_update_attempts += 1
                
                if self._theme_update_attempts > 20:  # 20 * 300ms = 6 seconds max wait
                    print("[WARNING] web_view.annotations never became available, skipping theme view update")
                    self._finish_loading_process()
                    return
                    
                QTimer.singleShot(300, self._async_update_theme_view)
                return
            
            print(f"[DEBUG] Starting theme view update with {len(self.web_view.annotations)} annotations")
            # Reset attempt counter on success
            self._theme_update_attempts = 0
            
            # Update loading dialog status before theme view update
            if hasattr(self, '_loading_dialog') and self._loading_dialog:
                print("🔍 DEBUG: Updating loading dialog status before theme view update")
                self._loading_dialog.update_status("Loading Theme Panel...")
                self._loading_dialog.update_detail("Processing annotations...")
                # Force the dialog to update its display immediately
                QApplication.processEvents()
                print("🔍 DEBUG: Loading dialog should be visible after processEvents")
            else:
                print("🔍 DEBUG: No loading dialog available before theme view update")
            
            # Ensure is_loading_session stays true during theme view update
            # This prevents other code from closing the loading dialog prematurely
            was_loading = getattr(self, 'is_loading_session', False)
            self.is_loading_session = True
            
            try:
                print("🔍 DEBUG: About to call update_theme_view()")
                # Update theme view - this is synchronous and blocks the UI thread
                self.update_theme_view()
                # Mark theme view as populated after session loading update
                self._theme_view_populated = True
                print("🔍 DEBUG: update_theme_view() completed")
            finally:
                # Restore the original loading state
                self.is_loading_session = was_loading
                # Clear the theme view updating flag
                self._updating_theme_view_for_session = False
                print("🔍 DEBUG: Restored loading state after theme view update")
            
            # Continue with storyboard update after theme view is completely finished
            self._async_update_storyboard()
        except Exception as e:
            print(f"ERROR in _async_update_theme_view: {e}")
            self._finish_loading_process()

    def _async_update_scene_tabs(self):
        """Async scene tabs update to keep loading animation responsive"""
        try:
            # Update loading dialog for scene tabs (if still available)
            if hasattr(self, '_loading_dialog') and self._loading_dialog and hasattr(self._loading_dialog, 'update_status'):
                self._loading_dialog.update_status("Building Scene Tabs...")
                if hasattr(self._loading_dialog, 'update_detail'):
                    self._loading_dialog.update_detail("Organizing annotations by scene...")
            
            # Clear and rebuild scene tabs
            self.scene_tabs.clear()

            # Group annotations by scene
            scene_annotations = {}
            for anno in self.web_view.annotations:
                if anno.get("divider", False):
                    continue  # Skip dividers

                scene = anno.get('scene')
                if not scene:
                    print(f"Skipping annotation without a scene: {anno}")
                    continue

                if scene not in scene_annotations:
                    scene_annotations[scene] = []
                scene_annotations[scene].append(anno)

            # Rebuild tabs
            for scene in self.web_view.scene_styles.keys():
                if scene in scene_annotations:
                    list_widget = AnnotationListWidget()
                    for anno in scene_annotations[scene]:
                        list_widget.add_item_with_checkbox(
                            anno['text'],
                            anno.get('id', ''),
                            is_used=bool(anno.get('used', False)),
                            notes=anno.get('notes', ''),
                            notes_html=anno.get('notes_html', ''),
                            is_favorite=bool(anno.get('favorite', False)),
                            tags=anno.get('tags', []),
                            speech_title=anno.get('speech_title', '')
                        )
                    self.scene_tabs.addTab(list_widget, scene)

            # Continue with storyboard update if needed
            QTimer.singleShot(50, self._async_update_storyboard)
        except Exception as e:
            print(f"ERROR in _async_update_scene_tabs: {e}")
            self._finish_loading_process()

    def _async_update_storyboard(self):
        """Async storyboard update to keep loading animation responsive"""
        try:
            # Update storyboard if visible
            if hasattr(self, 'storyboard_dialog') and self.storyboard_dialog and self.storyboard_dialog.isVisible():
                if hasattr(self, '_loading_dialog') and self._loading_dialog:
                    self._loading_dialog.update_status("Updating Storyboard...")
                    self._loading_dialog.update_detail("Refreshing storyboard contents...")
                    
                self._update_storyboard()

            # Finish the loading process
            QTimer.singleShot(50, self._finish_loading_process)
        except Exception as e:
            print(f"ERROR in _async_update_storyboard: {e}")
            self._finish_loading_process()

    def _reinitialize_sticky_header(self):
        """Reinitialize sticky header after session load"""
        try:
            # Double-check that sticky header is enabled before reinitializing
            if not getattr(self.web_view, 'sticky_header_enabled', False):
                print("[DEBUG] Sticky header disabled, aborting reinitialization")
                return
                
            print("[DEBUG] Reinitializing sticky header components after session load")
            
            # Inject the sticky header DOM structure
            self.web_view.inject_sticky_header_dom()
            
            # Inject permanent restore button CSS
            self.web_view.inject_restore_button_css()
            
            # Apply transparency update
            self.web_view.update_restore_button_transparency()
            
            # Populate with current scene styles if available
            if hasattr(self.web_view, 'scene_styles') and self.web_view.scene_styles:
                print(f"[DEBUG] Populating sticky header with {len(self.web_view.scene_styles)} themes")
                self.web_view.populate_dom_sticky_header_themes(self.web_view.scene_styles)
            
            # Populate with current tags if available
            if hasattr(self, 'tags') and self.tags:
                print(f"[DEBUG] Populating sticky header with {len(self.tags)} tags")
                self.web_view.populate_dom_sticky_header_tags(self.tags)
            
            # Ensure menu bindings exist after population (post-DOM stabilization)
            QTimer.singleShot(50, self.web_view.ensure_dom_sticky_header_bindings)

            print("[DEBUG] Sticky header reinitialization complete")
            
        except Exception as e:
            print(f"ERROR in _reinitialize_sticky_header: {e}")
            import traceback
            traceback.print_exc()

    def _ensure_sticky_header_cleared(self):
        """Ensure sticky header elements are completely removed when disabled during session loading"""
        try:
            print("[DEBUG] Ensuring sticky header is cleared when disabled")
            
            clear_sticky_header_js = """
            (function() {
                console.log('[DEBUG] Clearing sticky header elements (disabled in settings)');
                
                // Remove sticky header element
                const header = document.getElementById('scriptoria-sticky-header');
                if (header) {
                    header.remove();
                    console.log('[DEBUG] Removed sticky header element');
                }
                
                // Remove restore button element
                const restoreButton = document.getElementById('sticky-header-restore');
                if (restoreButton) {
                    restoreButton.remove();
                    console.log('[DEBUG] Removed sticky header restore button');
                }
                
                // Remove sticky header styles
                const stickyStyles = document.getElementById('scriptoria-sticky-header-styles');
                if (stickyStyles) {
                    stickyStyles.remove();
                    console.log('[DEBUG] Removed sticky header styles');
                }
                
                // Remove restore button styles
                const restoreStyles = document.getElementById('scriptoria-sticky-header-restore-styles');
                if (restoreStyles) {
                    restoreStyles.remove();
                    console.log('[DEBUG] Removed sticky header restore styles');
                }
                
                // Clear any scroll listeners
                if (window.domStickyHeaderScrollListener) {
                    document.removeEventListener('scroll', window.domStickyHeaderScrollListener);
                    window.domStickyHeaderScrollListener = null;
                    console.log('[DEBUG] Removed sticky header scroll listener');
                }
                
                // Clear all sticky header filters and indicators
                if (window.stickyHeaderFilters) {
                    window.stickyHeaderFilters.favorites = false;
                    window.stickyHeaderFilters.used = 0;
                    window.stickyHeaderTagState = { isActive: false, selectedTags: new Set() };
                }
                
                // Clear theme filters (exit solo mode and show all themes)
                if (window.stickyHeaderState) {
                    const state = window.stickyHeaderState;
                    state.soloTheme = null;
                    if (state.hiddenThemes) { state.hiddenThemes.clear(); }
                    // Show all highlights to fully reset theme filtering
                    if (state.themes) {
                        state.themes.forEach(theme => {
                            if (typeof window.showThemeHighlights === 'function') {
                                window.showThemeHighlights(theme.name);
                            }
                        });
                    }
                }
                
                // Remove all annotation filter classes
                document.querySelectorAll('[data-annotation-id]').forEach(annotation => {
                    annotation.classList.remove('favorites-hidden', 'used-hidden', 'unused-hidden', 'tag-filtered-hidden');
                });
                
                // Hard clear any existing scrollbar indicators immediately
                document.querySelectorAll('.scroll-indicator').forEach(el => el.remove());
                
                // Reset navigation matches
                window.currentMatchIndex = -1;
                window.matchedAnnotations = [];
                if (window.updateNavigationMenuState) { window.updateNavigationMenuState(); }
                
                console.log('[DEBUG] Sticky header clearing complete (disabled in settings)');
            })();
            """
            
            # Use a timer to ensure DOM is ready
            QTimer.singleShot(200, lambda: self.web_view.page().runJavaScript(clear_sticky_header_js))
            
        except Exception as e:
            print(f"ERROR in _ensure_sticky_header_cleared: {e}")
            import traceback
            traceback.print_exc()

    def _finish_loading_process(self):
        """Complete the loading process and show scroll restore dialog"""
        print("🔍 DEBUG: _finish_loading_process() called")
        import traceback
        traceback.print_stack()
        
        try:
            # Close the loading dialog after all heavy operations
            if hasattr(self, '_loading_dialog') and self._loading_dialog:
                print("🔍 DEBUG: Closing loading dialog from _finish_loading_process")
                self._loading_dialog.close()
                self._loading_dialog = None
        
            # Handle scroll position AFTER loading is complete
            if hasattr(self, '_pending_scroll_pos'):
                scroll_pos = self._pending_scroll_pos
                restore_scroll = self._pending_restore_scroll
                QTimer.singleShot(50, lambda: self._handle_scroll_position_restore(scroll_pos, restore_scroll))
        except Exception as e:
            print(f"ERROR in _finish_loading_process: {e}")
    
    def _handle_scroll_position_restore(self, scroll_pos, restore_scroll):
        """Handle scroll position restore without timer delays"""
        try:
            # Debug tracking
            print(f"_handle_scroll_position_restore executing with scroll_pos={scroll_pos}, restore_scroll={restore_scroll}")
            scroll_handled = getattr(self, '_scroll_restore_handled', False)
            print(f"Current scroll_restore_handled={scroll_handled}")
        
            # Only proceed if scroll position exists and hasn't been handled yet
            if not getattr(self, '_scroll_restore_handled', False) and scroll_pos is not None:
                # Mark as handled immediately
                self._scroll_restore_handled = True
                print("Setting _scroll_restore_handled=True")
            
                # IMPORTANT CONDITION: Show dialog if restore_scroll is None AND position is significant
                if restore_scroll is None and scroll_pos >= 1000:
                    print(f"SHOWING SCROLL DIALOG for position {scroll_pos}")
                    reply = QMessageBox.question(
                        self,
                        'Restore Scroll Position',
                        'Would you like to restore the last saved scroll position?',
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                    )
                
                    if reply == QMessageBox.StandardButton.Yes:
                        print("User clicked Yes, performing scroll")
                        # Apply scroll with proper error handling
                        js_scroll = """
                        (function() {
                            try {
                                // Force layout calculation
                                document.body.offsetHeight;
                                
                                // Scroll to position
                                window.scrollTo(0, %d);
                                
                                // Verify scroll worked
                                var actualPos = window.pageYOffset;
                                console.log('Scrolled to position:', actualPos);
                                
                                return 'Scroll completed to position: ' + actualPos;
                            } catch (e) {
                                console.error('Scroll error:', e);
                                return 'Error: ' + e;
                            }
                        })();
                        """ % scroll_pos
                    
                        def log_scroll_result(result):
                            print(f"Scroll result: {result}")
                    
                        self.web_view.page().runJavaScript(js_scroll, log_scroll_result)
                
                else:
                    print(f"No scroll performed: restore_scroll={restore_scroll}, scroll_pos={scroll_pos}")
            else:
                print(f"Skipping scroll handling: already handled={getattr(self, '_scroll_restore_handled', False)}, scroll_pos={scroll_pos}")

            # Verify content and finish loading sequence
            def verify_final_content(html):
                if not self.is_loading_session:
                    print("Session loading complete, verifying final content")
                    if hasattr(self, 'check_content_empty'):
                        self.check_content_empty(html)

            # Get final HTML content
            if hasattr(self, 'web_view') and self.web_view and self.web_view.page():
                self.web_view.page().toHtml(verify_final_content)
        
            # Show success message
            self.status_bar.showMessage('Session loaded successfully', 5000)

            # Handle sticky header refresh
            if (hasattr(self.web_view, 'sticky_header') and self.web_view.sticky_header and 
                hasattr(self.web_view, 'sticky_header_enabled') and self.web_view.sticky_header_enabled):
                print("[DEBUG] Session load complete - forcing sticky header theme refresh")
                self.web_view.sticky_header.update_themes(self.web_view.scene_styles, force_update=True)
                # Also ensure DOM sticky header bindings are intact after content load
                QTimer.singleShot(50, self.web_view.ensure_dom_sticky_header_bindings)
        
            # Clean up signal connections
            try:
                print("Disconnecting loadFinished signals")
                self.web_view.loadFinished.disconnect()
            except (TypeError, RuntimeError) as e:
                print(f"No signals to disconnect: {e}")
        
            # Reset loading state
            print("Resetting is_loading_session to False")
            self.is_loading_session = False
            
            # Tooltip fix already handled by initialize_web_view during page load
            # Removed redundant tooltip fix call to avoid double initialization
            
        except Exception as e:
            print(f"Error in _handle_scroll_position_restore: {e}")
            import traceback
            traceback.print_exc()

    def _create_content_handler(self, retry_count, max_retries, preview_data, restore_scroll, file_path):
        """Create a handler for content check results that won't be garbage collected."""
    
        def handle_content_check(result):
            try:
                # Debug: Print complete result object for troubleshooting
                print(f"CONTENT CHECK RESULT: {result}")
            
                # Extract key information
                has_content = result.get('hasContent', False) if isinstance(result, dict) else bool(result)
            
                # Log detailed content status
                if isinstance(result, dict):
                    print(f"Content check - Has content: {has_content}, " +
                          f"Content length: {result.get('contentLength', 0)}, " +
                          f"Element count: {result.get('elementCount', 0)}")
                
                    if 'bodyPreview' in result:
                        print(f"Body HTML preview: {result['bodyPreview']}")
                
                    if 'error' in result:
                        print(f"Content check error: {result['error']}")
            
                # Set content as verified to prevent loops
                self._verified_content = True
            
                # CRITICAL: If content isn't ready yet and we haven't maxed out retries
                if not has_content and retry_count < max_retries:
                    # Using increased delay for better chance of success
                    delay = 800 * (2 ** retry_count)
                    print(f"Content not ready (attempt {retry_count + 1}/{max_retries}), retrying in {delay}ms...")
                
                    # Store the retry function as instance variable to prevent garbage collection
                    self._content_retry_function = lambda: self._handle_html_load_finished(
                        True, preview_data, restore_scroll, file_path, retry_count + 1, max_retries
                    )
                
                    QTimer.singleShot(delay, self._content_retry_function)
                    # Force event processing to ensure the timer works
                    QCoreApplication.processEvents()
                    return
            
                # If we get here, either content is ready or we've exhausted retries
                # Even if content check failed, proceed with UI updates after max retries
                self._update_ui_after_load(preview_data, restore_scroll)
        
            except Exception as e:
                print(f"ERROR in handle_content_check: {e}")
                import traceback
                traceback.print_exc()
                # Ensure we proceed even with errors
                self._update_ui_after_load(preview_data, restore_scroll)
                self.ensure_loading_dialog_closed()
    
        return handle_content_check

    def fix_bookmark_images(self):
        """Fix bookmark images that failed to load by updating their src attributes and
        also set global JavaScript variables for the image paths"""
        try:
            # Get absolute paths to both bookmark images
            app_dir = os.path.dirname(os.path.abspath(__file__))
            bookmark_path = os.path.join(app_dir, 'Img', 'bookmark.png')
            bookmark_filled_path = os.path.join(app_dir, 'Img', 'bookmark-filled.png')
    
            # Check if files exist and convert to URL format with cache-busting
            bookmark_url = ""
            bookmark_filled_url = ""
            cache_buster = int(time.time())
    
            if os.path.exists(bookmark_path):
                bookmark_url = QUrl.fromLocalFile(bookmark_path).toString()
            else:
                print(f"Warning: Bookmark image not found at {bookmark_path}")
        
            if os.path.exists(bookmark_filled_path):
                bookmark_filled_url = QUrl.fromLocalFile(bookmark_filled_path).toString()
            else:
                print(f"Warning: Bookmark-filled image not found at {bookmark_filled_path}")
    
            # Only proceed if at least one image exists
            if not bookmark_url and not bookmark_filled_url:
                print("Error: No bookmark images found, cannot fix")
                return
    
            # JavaScript to update all bookmark images and set the global variables
            js_code = f"""
            (function() {{
                // Set global variables for bookmark image paths
                window.bookmarkImagePath = "{bookmark_url}?t={cache_buster}";
                window.bookmarkFilledImagePath = "{bookmark_filled_url}?t={cache_buster}";
            
                // Find and fix regular bookmark images
                const bookmarkImages = document.querySelectorAll('img[src*="bookmark.png"]:not([src*="bookmark-filled"])');
                let fixedRegular = 0;
        
                for (let i = 0; i < bookmarkImages.length; i++) {{
                    const img = bookmarkImages[i];
                    if (window.bookmarkImagePath) {{
                        img.src = window.bookmarkImagePath;
                        img.style.display = 'inline-block';
                        fixedRegular++;
                    }}
                }}
        
                // Find and fix filled bookmark images
                const filledBookmarkImages = document.querySelectorAll('img[src*="bookmark-filled.png"]');
                let fixedFilled = 0;
        
                for (let i = 0; i < filledBookmarkImages.length; i++) {{
                    const img = filledBookmarkImages[i];
                    if (window.bookmarkFilledImagePath) {{
                        img.src = window.bookmarkFilledImagePath;
                        img.style.display = 'inline-block';
                        fixedFilled++;
                    }}
                }}
        
                return {{ 
                    regularTotal: bookmarkImages.length, 
                    regularFixed: fixedRegular,
                    filledTotal: filledBookmarkImages.length,
                    filledFixed: fixedFilled
                }};
            }})();
            """
    
            def handle_result(result):
                if isinstance(result, dict):
                    regular_total = result.get('regularTotal', 0)
                    regular_fixed = result.get('regularFixed', 0)
                    filled_total = result.get('filledTotal', 0)
                    filled_fixed = result.get('filledFixed', 0)
            
                    print(f"Regular bookmark images: found {regular_total}, fixed {regular_fixed}")
                    print(f"Filled bookmark images: found {filled_total}, fixed {filled_fixed}")
    
            # Run the JavaScript
            self.web_view.page().runJavaScript(js_code, handle_result)
        
        except Exception as e:
            print(f"Error fixing bookmark images: {e}")

    def verify_bookmark_images(self):
        """Verify that all bookmark images are loaded correctly"""
        js_code = """
        (function() {
            // Check regular bookmark images
            const bookmarkImages = document.querySelectorAll('img[src*="bookmark.png"]:not([src*="bookmark-filled"])');
            let regularLoaded = 0;
            let regularTotal = bookmarkImages.length;
        
            for (let i = 0; i < bookmarkImages.length; i++) {
                if (bookmarkImages[i].complete && bookmarkImages[i].naturalWidth > 0) {
                    regularLoaded++;
                }
            }
        
            // Check filled bookmark images
            const filledBookmarkImages = document.querySelectorAll('img[src*="bookmark-filled.png"]');
            let filledLoaded = 0;
            let filledTotal = filledBookmarkImages.length;
        
            for (let i = 0; i < filledBookmarkImages.length; i++) {
                if (filledBookmarkImages[i].complete && filledBookmarkImages[i].naturalWidth > 0) {
                    filledLoaded++;
                }
            }
        
            return { 
                regularTotal: regularTotal, 
                regularLoaded: regularLoaded,
                filledTotal: filledTotal,
                filledLoaded: filledLoaded
            };
        })();
        """
    
        def handle_result(result):
            if isinstance(result, dict):
                regular_total = result.get('regularTotal', 0)
                regular_loaded = result.get('regularLoaded', 0)
                filled_total = result.get('filledTotal', 0)
                filled_loaded = result.get('filledLoaded', 0)
            
                print(f"Regular bookmark images verification: {regular_loaded}/{regular_total} loaded")
                print(f"Filled bookmark images verification: {filled_loaded}/{filled_total} loaded")
            
                # If any images still not loaded, try one more time
                if regular_loaded < regular_total or filled_loaded < filled_total:
                    print("Some bookmark images still not loaded, retrying fix...")
                    self.fix_bookmark_images()
    
        self.web_view.page().runJavaScript(js_code, handle_result)

    def ensure_loading_dialog_closed(self):
        """Ensure the loading dialog is always closed"""
        if hasattr(self, '_loading_dialog') and self._loading_dialog:
            try:
                self._loading_dialog.close()
            except Exception as e:
                print(f"Error closing loading dialog: {e}")
            self._loading_dialog = None
    
        # Also reset loading state flag if it hasn't been done already
        if getattr(self, 'is_loading_session', False):
            print("Resetting loading state flag from ensure_loading_dialog_closed")
            self.is_loading_session = False

    def setup_keyboard_shortcuts(self):
        """Setup additional keyboard shortcuts including fix for invisible text"""
        # Add F5 shortcut for refreshing/fixing invisible text
        if not hasattr(self, 'fix_text_shortcut'):
            fix_text_shortcut = QShortcut(QKeySequence("F5"), self)
            fix_text_shortcut.activated.connect(self.fix_invisible_text)
            self.fix_text_shortcut = fix_text_shortcut
        
            # Also create a menu item for this function
            if hasattr(self, 'view_menu'):
                fix_text_action = QAction("Fix Invisible Text (F5)", self)
                fix_text_action.triggered.connect(self.fix_invisible_text)
                self.view_menu.addAction(fix_text_action)
            
    # Add this code to your __init__ method or wherever you set up shortcuts
    def initialize_additional_shortcuts(self):
        """Initialize additional shortcuts including the text fix function"""
        self.setup_keyboard_shortcuts()
    
        # Add to any existing menu
        if not hasattr(self, 'view_menu'):
            self.view_menu = self.menuBar().addMenu("&View")
    
        # Add a text fix action to the Tools menu
        fix_text_action = QAction("Fix Invisible Text (F5)", self)
        fix_text_action.triggered.connect(self.fix_invisible_text)
    
        if hasattr(self, 'tools_menu'):
            self.tools_menu.addAction(fix_text_action)
        else:
            self.tools_menu = self.menuBar().addMenu("&Tools")
            self.tools_menu.addAction(fix_text_action)
        

    def setup_post_load_connections(self):
        """Set up connections after loading is complete"""
        # Connect signals that were disconnected during loading
        # For example, reconnect any event handlers that were disconnected
        pass


    def perform_post_load_header_detection(self):
        """Perform header detection and update UI after session load"""
        try:
            # Ensure we're not running this in the middle of another operation
            if self.is_loading_session:
                print("Not running header detection - session still loading")
                # Schedule it to run after loading completes
                QTimer.singleShot(500, self.perform_post_load_header_detection)
                return
            
            print("Performing post-load header detection")
        
            # Make sure header highlighting is enabled for all text editors
            if hasattr(self, 'input_text') and self.input_text:
                # First pause highlighting to prevent performance issues during check
                if hasattr(self.input_text, 'header_highlighter'):
                    if hasattr(self.input_text.header_highlighter, 'pause_highlighting'):
                        self.input_text.header_highlighter.pause_highlighting()
                
                    # Now run the orphaned text check
                    if hasattr(self.input_text.header_highlighter, 'check_for_orphaned_text'):
                        print("Running header check for orphaned text")
                        self.input_text.header_highlighter.check_for_orphaned_text()
                    
                    # Resume highlighting
                    if hasattr(self.input_text.header_highlighter, 'resume_highlighting'):
                        print("Resuming header highlighting")
                        self.input_text.header_highlighter.resume_highlighting()
        
            # Refresh the headers list in the UI
            # if hasattr(self, 'refresh_headers_list'):
            #     print("Refreshing headers list in UI")
            #     self.refresh_headers_list()
            
        except Exception as e:
            print(f"Error in perform_post_load_header_detection: {e}")

    def ensure_loading_dialog_closed(self):
        """Ensure the loading dialog is always closed"""
        if hasattr(self, '_loading_dialog') and self._loading_dialog:
            try:
                self._loading_dialog.close()
            except Exception as e:
                print(f"Error closing loading dialog: {e}")
            self._loading_dialog = None
    
        # Also reset loading state flag if it hasn't been done already
        if getattr(self, 'is_loading_session', False):
            print("Resetting loading state flag from ensure_loading_dialog_closed")
            self.is_loading_session = False
        
            # Schedule header detection to run after loading state is reset
            #QTimer.singleShot(200, self.perform_post_load_header_detection)

    def is_compatible_version(self, version):
        # Simple version compatibility check
        # Can be expanded for more complex version handling
        try:
            session_ver = tuple(map(int, version.split('.')))
            current_ver = (1, 0)  # Current version
            return session_ver <= current_ver
        except:
            return False

    # This is the complete closeEvent implementation with all fixes
    def closeEvent(self, event):
        """Handle the window close event (X button)"""
        print("\n=== CLOSE EVENT START ===")
        
        # Check if a save operation is currently in progress
        if getattr(self, '_save_in_progress', False):
            print("Save operation in progress - deferring close until completion")
            # Show non-blocking status message
            if hasattr(self, 'status_bar') and self.status_bar:
                self.status_bar.showMessage("Save in progress - closing after save completes...", 0)
            
            # Defer the close event until save completes
            self._pending_close_event = event
            event.ignore()
            return
    
        # Make ONE call to has_unsaved_changes(), store the result in has_real_changes
        has_real_changes = self.has_unsaved_changes()
        print("CloseEvent triggered, changes_pending:", has_real_changes)

        # Clean up dialogs first
        if hasattr(self, 'welcome_dialog') and self.welcome_dialog:
            print("Closing WelcomeDialog from main window's closeEvent") 
            self.welcome_dialog.accept()
            self.welcome_dialog = None

        # Explicitly close the storyboard dialog rather than toggling it
        if hasattr(self, 'storyboard_dialog') and self.storyboard_dialog:
            print("Explicitly closing storyboard dialog from main window's closeEvent")
            # First cancel any pending operations
            if hasattr(self.storyboard_dialog, 'cancel_pending_operations'):
                self.storyboard_dialog.cancel_pending_operations()
            # Then close it properly
            self.storyboard_dialog.hide()
            if hasattr(self.storyboard_dialog, '_is_closing'):
                self.storyboard_dialog._is_closing = True  # Set the closing flag

        # If the user really has unsaved changes, present the Save/Discard/Cancel dialog
        if has_real_changes:
            print("Showing save dialog from closeEvent")
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle('Save Changes')
            msg_box.setText('You have unsaved changes. What would you like to do?')

            apply_save_button = QPushButton("Apply and Save")
            discard_button = QPushButton("Discard Changes")
            cancel_button = QPushButton("Cancel")

            button_width = 115
            apply_save_button.setFixedWidth(button_width)
            discard_button.setFixedWidth(button_width)
            cancel_button.setFixedWidth(button_width)

            msg_box.addButton(apply_save_button, QMessageBox.ButtonRole.AcceptRole)
            msg_box.addButton(discard_button, QMessageBox.ButtonRole.DestructiveRole)
            msg_box.addButton(cancel_button, QMessageBox.ButtonRole.RejectRole)

            msg_box.setMinimumWidth(400)
            ret = msg_box.exec()
            print("CloseEvent dialog returned:", ret)
            clicked_button = msg_box.clickedButton()

            if clicked_button == apply_save_button:
                print("CloseEvent: Apply and Save clicked")
                self.pending_close_event = event  # Store the event to resume later
                event.ignore()                   # Prevent immediate closing

                # Store the original event in a more persistent way
                self._original_close_requested = True
            
                # IMPROVED: Direct callback that ensures close happens sequentially
                def robust_finish_save():
                    print("Save operation completed, executing delayed close")
                    try:
                        if hasattr(self, 'pending_close_event') and self.pending_close_event:
                            print("Found pending close event, closing in sequence")
                            # Reset flags
                            self.pending_close_event = None
                            # Use our sequential close method
                            self._force_close()
                        else:
                            print("Warning: pending_close_event is not available, forcing close")
                            self._force_close()
                    except Exception as e:
                        print(f"ERROR in robust_finish_save: {e}")
                        import traceback
                        traceback.print_exc()
                        # Last resort
                        QApplication.quit()

                # Add sequential force close method
                if not hasattr(self, '_force_close'):
                    def _force_close(self):
                        """Ensure application closes in the correct sequence"""
                        print("FORCE CLOSE: Ensuring application closes in sequence")
                    
                        # First, save the scroll position synchronously if needed
                        if self.current_session_file:
                            def handle_scroll_then_close(scroll_pos):
                                print(f"Saving final scroll position: {scroll_pos}")
                                try:
                                    with open(self.current_session_file, 'r', encoding='utf-8') as f:
                                        session_data = json.load(f)
                                
                                    if 'preview' not in session_data:
                                        session_data['preview'] = {}
                                    session_data['preview']['scroll_position'] = scroll_pos
                                
                                    with open(self.current_session_file, 'w', encoding='utf-8') as f:
                                        json.dump(session_data, f, indent=4, ensure_ascii=False)
                                
                                    print("Final scroll position saved - now closing application")
                                    # Use a short delay to ensure file is written completely
                                    QTimer.singleShot(50, self._perform_final_close)
                                except Exception as e:
                                    print(f"Error saving final scroll position: {e}")
                                    # Still try to close even if scroll save fails
                                    self._perform_final_close()
                        
                            print("Getting final scroll position before closing")
                            self.web_view.page().runJavaScript("window.pageYOffset", handle_scroll_then_close)
                        else:
                            # No scroll position to save, close immediately
                            self._perform_final_close()
                
                    self._force_close = types.MethodType(_force_close, self)
            
                # Add method to perform final closing steps
                if not hasattr(self, '_perform_final_close'):
                    def _perform_final_close(self):
                        """Actually perform the final application close after all cleanup"""
                        print("PERFORMING FINAL APPLICATION CLOSE")
                    
                        # First, make sure all dialogs are properly closed
                        if hasattr(self, 'storyboard_dialog') and self.storyboard_dialog:
                            try:
                                print("Ensuring storyboard dialog is fully closed")
                                self.storyboard_dialog._is_closing = True
                                # Disconnect any callbacks
                                self.storyboard_dialog.blockSignals(True)
                                # Forcibly close it
                                self.storyboard_dialog.close()
                                # Remove reference
                                self.storyboard_dialog = None
                            except Exception as e:
                                print(f"Error closing storyboard dialog: {e}")
                    
                        # Close any other dialogs if needed
                        if hasattr(self, 'welcome_dialog') and self.welcome_dialog:
                            try:
                                self.welcome_dialog.close()
                                self.welcome_dialog = None
                            except Exception:
                                pass
                    
                        # Now close the main window
                        try:
                            print("Closing main window")
                            self.close()
                        except Exception as e:
                            print(f"Error closing main window: {e}")
                    
                        # Final fallback - quit the application
                        print("Final step: QApplication.quit()")
                        QTimer.singleShot(100, QApplication.quit)
                
                    self._perform_final_close = types.MethodType(_perform_final_close, self)

                try:
                    # Set the callback BEFORE starting save
                    print("Setting save completion callback")
                    self.save_completion_callback = robust_finish_save
                
                    # Start the save operation
                    print("Starting save_session...")
                    self.save_session()
                    return  # Do not proceed with close until save completes
                except Exception as e:
                    print(f"Error during save sequence: {e}")
                    self.pending_close_event = None
                    self.save_completion_callback = None
                    # Still try to force close in case of error
                    QTimer.singleShot(100, lambda: self._force_close())
                    event.ignore()
                    return

            elif clicked_button == discard_button:
                print("CloseEvent: Discard clicked")
                self.storyboard_changes_pending = False
                # Continue with close by allowing event.accept() below

            else:
                print("CloseEvent: Cancel clicked or dialog closed")
                event.ignore()
                return

        # If we reach here, either there were no changes or the user clicked Discard.
        # Next, save the scroll position before closing (if self.current_session_file is set).
        if self.current_session_file:
            def handle_scroll(scroll_pos):
                try:
                    with open(self.current_session_file, 'r', encoding='utf-8') as f:
                        session_data = json.load(f)
            
                    if 'preview' not in session_data:
                        session_data['preview'] = {}
                    session_data['preview']['scroll_position'] = scroll_pos

                    with open(self.current_session_file, 'w', encoding='utf-8') as f:
                        json.dump(session_data, f, indent=4, ensure_ascii=False)
                    print(f"Scroll position saved: {scroll_pos}")
                    event.accept()
                except Exception as e:
                    print(f"Error saving scroll position: {e}")
                    event.accept()  # Close anyway if scroll save fails

            print("Retrieving scroll position...")
            self.web_view.page().runJavaScript("window.pageYOffset", handle_scroll)
        else:
            event.accept()

        print("=== CLOSE EVENT END ===\n")

    def _handle_resize_complete(self):
        """Called when resize events have stopped for the debounce period"""
        if hasattr(self, 'theme_view') and self.theme_view and self.view_annotations_button.isChecked():
            # Store states before update
            panel_states = {
                'script': {
                    'current_tab': self.scene_tabs.currentIndex(),
                    'scroll_positions': {},
                    'selected_items': {}
                }
            }
        
            for i in range(self.scene_tabs.count()):
                list_widget = self.scene_tabs.widget(i)
                if isinstance(list_widget, AnnotationListWidget):
                    panel_states['script']['scroll_positions'][i] = list_widget.verticalScrollBar().value()
                    panel_states['script']['selected_items'][i] = [
                        item.data(Qt.ItemDataRole.UserRole)
                        for item in list_widget.selectedItems()
                    ]
                
            # Update theme view
            self.update_tab_item_sizes()
        
            # Restore states using the existing restore_tab_states logic
            if 'script' in panel_states:
                current_tab = panel_states['script']['current_tab']
                if current_tab >= 0 and current_tab < self.scene_tabs.count():
                    QTimer.singleShot(0, lambda: self._restore_tab_states(panel_states))

    def _restore_tab_states(self, panel_states):
        visible_count = 0
        visible_count += 1
        batch_size = 5
        for i, pos in panel_states['script']['scroll_positions'].items():
            if i >= self.scene_tabs.count():
                continue
        
            list_widget = self.scene_tabs.widget(i)
            if not isinstance(list_widget, AnnotationListWidget):
                continue

            # Cache viewport dimensions for this tab
            viewport_key = f"{list_widget.viewport().width()}"
            if viewport_key not in self._last_resize_dims:
                self._last_resize_dims[viewport_key] = {
                    'width': list_widget.viewport().width() - 40
                }
    
            available_width = self._last_resize_dims[viewport_key]['width']
    
            # Resize items in batches
            for j in range(0, list_widget.count(), batch_size):
                batch_end = min(j + batch_size, list_widget.count())
        
                # Process one batch
                for k in range(j, batch_end):
                    item = list_widget.item(k)
                    widget = list_widget.itemWidget(item)
                    if widget:
                        widget.setFixedWidth(available_width)
                        list_widget.updateItemSize(item, widget)

                        # Restore notes_html
                        notes_html = widget.property('notes_html')
                        if notes_html:
                            # Find the annotation by ID and update it
                            for anno in self.web_view.annotations:
                                if anno.get('id') == item.data(Qt.ItemDataRole.UserRole):
                                    anno['notes_html'] = notes_html
                                    break
                    if not item.isHidden():
                        visible_count += 1
        
                # Allow UI to remain responsive
                QApplication.processEvents()
    
            # Restore scroll position after resize
            QTimer.singleShot(50, lambda lw=list_widget, p=pos: lw.verticalScrollBar().setValue(p))

            # Restore selections efficiently using IDs
            selected_ids = panel_states['script']['selected_items'].get(i, [])
            if selected_ids:
                for j in range(list_widget.count()):
                    item = list_widget.item(j)
                    if item.data(Qt.ItemDataRole.UserRole) in selected_ids:
                        item.setSelected(True)

        # Restore current tab
        current_tab = panel_states['script']['current_tab']
        self.scene_tabs.setCurrentIndex(current_tab)

    def show_auto_wrap_dialog(self):
        """Show the dialog for auto-wrapping headers"""
        dialog = AutoWrapHeadersDialog(self)
        
        # Handle both Qt5 (exec_) and Qt6 (exec) versions
        try:
            # Try Qt6 style first
            result = dialog.exec()
        except AttributeError:
            try:
                # Fall back to Qt5 style
                result = dialog.exec_()
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Could not show dialog: {str(e)}")
                return
        
        if result:
            # Get the values from the dialog
            search_term = dialog.search_term.text().strip()
            is_section = dialog.is_section_format()
            case_sensitive = dialog.case_sensitive.isChecked()
            
            # Get the actual formatting mode that was selected
            format_mode = None
            if dialog.whole_line_radio.isChecked():
                format_mode = "whole_line"
            elif dialog.sentence_only_radio.isChecked():
                format_mode = "sentence"
            elif dialog.word_only_radio.isChecked():
                format_mode = "word"
            
            # Apply formatting using the exact dialog instance that was shown
            # This way we preserve all its settings exactly as they were
            self.apply_formatting_with_dialog(search_term, is_section, case_sensitive, format_mode, dialog)

    def apply_formatting_with_dialog(self, search_term, is_section, case_sensitive, format_mode, dialog):
        """
        Apply formatting using settings from the dialog with improved reliability, progress visualization,
        and robust state management via highlighter flag.
        """
        editor = self.input_text
        document = editor.document() # Get initial document
        original_text = editor.toPlainText()

        # Get highlighter reference - Safely access using getattr
        highlighter = getattr(editor, 'header_highlighter', None)
        initial_highlighting_paused = False

        # --- Set Highlighter Major Formatting Flag ---
        if highlighter:
            if getattr(highlighter, '_major_formatting_active', False):
                 print("[apply_formatting_with_dialog] Highlighter indicates major formatting already active. Skipping.")
                 QMessageBox.information(self, "Busy", "Syntax highlighter is busy with another major format operation.")
                 return # Exit if already active
            highlighter._major_formatting_active = True # SET THE HIGHLIGHTER FLAG
            print("[apply_formatting_with_dialog] Set highlighter._major_formatting_active = True")
            initial_highlighting_paused = getattr(highlighter, '_highlighting_paused', False)
            print(f"[apply_formatting_with_dialog] Initial highlighter paused state: {initial_highlighting_paused}")
            # Reset standard cancel flag at start
            highlighter._highlighting_cancelled = False
        # --- End Set Highlighter Flag ---

        progress = QProgressDialog("Formatting headers...", "Cancel", 0, 100, self)
        try:
            progress.setWindowModality(Qt.WindowModality.WindowModal)
        except AttributeError:
            try: progress.setWindowModality(Qt.WindowModal) # Qt5 fallback
            except AttributeError: pass # Ignore if modality cannot be set
        progress.setWindowTitle("Formatting Headers")
        progress.setMinimumDuration(500) # Show after 500ms
        progress.setValue(0)

        # --- Connect Cancellation to Flags ---
        cancelled_flag = {'value': False} # Basic flag if no highlighter
        if highlighter:
             # When progress Cancel is clicked:
             # 1. Stop the major formatting process
             progress.canceled.connect(lambda: setattr(highlighter, '_major_formatting_active', False))
             # 2. Set the standard cancellation flag for internal checks
             progress.canceled.connect(lambda: setattr(highlighter, '_highlighting_cancelled', True))
        else:
             progress.canceled.connect(lambda: cancelled_flag.update({'value': True}))

        # Function to check cancellation status
        def check_cancel():
            if highlighter:
                 # Cancel if EITHER standard cancel flag is set OR major formatting was stopped
                return getattr(highlighter, '_highlighting_cancelled', False) or \
                       not getattr(highlighter, '_major_formatting_active', True) # Check if major flag is still True
            else:
                return cancelled_flag['value']
        # --- End Connect Cancellation ---

        # Remember cursor position and view state
        cursor = editor.textCursor()
        position = cursor.position()
        scroll_position = editor.verticalScrollBar().value()

        progress.setValue(5)
        QApplication.processEvents()

        try:
            # Step 1: Configure dialog & find matches
            progress.setLabelText("Finding matches...")
            progress.setValue(10)
            QApplication.processEvents()
            if check_cancel(): raise OperationCanceledError("Cancelled during match finding")

            dialog.document_text = original_text
            dialog.search_term.setText(search_term)
            dialog.case_sensitive.setChecked(case_sensitive)
            if is_section: dialog.section_radio.setChecked(True)
            else: dialog.header_radio.setChecked(True)
            if format_mode == "sentence": dialog.sentence_only_radio.setChecked(True)
            elif format_mode == "word": dialog.word_only_radio.setChecked(True)
            else: dialog.whole_line_radio.setChecked(True)

            matches, count = dialog.find_matches(search_term, case_sensitive)
            if not matches:
                QMessageBox.information(self, "No Matches", f"No matches found for '{search_term}'.")
                progress.close()
                # Clear highlighter flag BEFORE returning
                if highlighter: highlighter._major_formatting_active = False
                return # Exit

            # Step 2: Pause highlighting (Still potentially useful to prevent visual glitches during text modification)
            if highlighter and hasattr(highlighter, 'pause_highlighting'):
                print("[apply_formatting_with_dialog] Pausing highlighting")
                highlighter.pause_highlighting()

            # Step 3: Get formatted text
            progress.setLabelText("Preparing formatted text...")
            progress.setValue(20)
            QApplication.processEvents()
            if check_cancel(): raise OperationCanceledError("Cancelled before formatting text")

            modified_text = dialog.get_formatted_text(original_text)

            if modified_text == original_text:
                QMessageBox.information(self, "No Changes", "No formatting changes were needed.")
                progress.close()
                # Resume highlighting if paused
                if highlighter and hasattr(highlighter, 'resume_highlighting'):
                     highlighter.resume_highlighting() # Resume before clearing flag
                 # Clear highlighter flag BEFORE returning
                if highlighter: highlighter._major_formatting_active = False
                return # Exit

            # Step 4: Apply changes
            progress.setLabelText("Applying changes...")
            progress.setValue(40)
            QApplication.processEvents()
            if check_cancel(): raise OperationCanceledError("Cancelled before applying text")

            editor.blockSignals(True)
            editor.setPlainText(modified_text)
            document = editor.document() # Re-get the document
            highlighter = getattr(editor, 'header_highlighter', None) # Re-get highlighter

            # --- APPLY DEFAULT FORMAT IMMEDIATELY ---
            print("[apply_formatting_with_dialog] Forcing default format immediately after setPlainText")
            force_cursor = QTextCursor(document)
            force_cursor.select(QTextCursor.SelectionType.Document)
            default_format = QTextCharFormat()
            default_format.setForeground(QColor("#000000")) # Black
            default_format.setFontWeight(QFont.Weight.Normal) # Normal weight
            force_cursor.setCharFormat(default_format)
            # Clear selection to avoid user seeing it
            force_cursor.clearSelection()
            editor.setTextCursor(force_cursor) # Set cursor back (optional, maybe restore original pos later)
            print("[apply_formatting_with_dialog] Default format applied.")
            # --- END APPLY DEFAULT FORMAT ---

            editor.blockSignals(False)


            # --- Step 5: Synchronous Analysis via Highlighter ---
            if highlighter:
                # CRITICAL: Ensure major formatting flag is still active before proceeding
                if not getattr(highlighter, '_major_formatting_active', False):
                    raise OperationCanceledError("Major formatting cancelled before analysis step")

                progress.setLabelText("Analyzing document structure...")
                progress.setValue(60)
                QApplication.processEvents()
                if check_cancel(): raise OperationCanceledError("Cancelled during analysis")

                print("[apply_formatting_with_dialog] Running SYNCHRONOUS analysis via check_for_orphaned_text")

                # 1. Manually update the highlighter's header block knowledge FIRST
                new_header_blocks = set()
                block = document.begin()
                # Make sure patterns are accessible
                main_header_pattern = QRegularExpression(r"\[\[(.*?)\]\]")
                normal_header_pattern = QRegularExpression(r"\*\*(.*?)\*\*")
                while block.isValid():
                    text = block.text().strip()
                    if normal_header_pattern.match(text).hasMatch() or main_header_pattern.match(text).hasMatch():
                         new_header_blocks.add(block.blockNumber())
                    block = block.next()
                if hasattr(highlighter, 'header_blocks'):
                    highlighter.header_blocks = new_header_blocks
                    print(f"[apply_formatting_with_dialog] Updated highlighter header_blocks: {len(new_header_blocks)} found")
                else:
                    print("[apply_formatting_with_dialog] Warning: Highlighter has no header_blocks attribute.")

                # 2. Call check_for_orphaned_text to handle analysis and rehighlighting
                # Ensure highlighter isn't paused or rehighlighting during this critical step
                if hasattr(highlighter, '_highlighting_paused'): highlighter._highlighting_paused = False
                if hasattr(highlighter, '_rehighlighting'): highlighter._rehighlighting = False

                # Set shared progress dialog info
                highlighter._shared_progress_dialog = progress
                highlighter._shared_progress_min = 60 # Start at 60%
                highlighter._shared_progress_max = 95 # End at 95%

                # Call the check function
                highlighter.check_for_orphaned_text(use_shared_dialog=True)

                # Check if the check_for_orphaned_text call was cancelled internally
                if getattr(highlighter, '_highlighting_cancelled', False):
                     raise OperationCanceledError("Orphaned text check cancelled internally")

                # Clear shared dialog attributes after use
                if hasattr(highlighter, '_shared_progress_dialog'): highlighter._shared_progress_dialog = None
                if hasattr(highlighter, '_shared_progress_min'): delattr(highlighter, '_shared_progress_min')
                if hasattr(highlighter, '_shared_progress_max'): delattr(highlighter, '_shared_progress_max')

            else:
                 # If no highlighter, just proceed but log a warning
                 print("[apply_formatting_with_dialog] Warning: No syntax highlighter found. Skipping analysis.")
                 progress.setValue(95) # Skip to near end
            # --- End Synchronous Analysis ---


            # Step 6: Restore view
            progress.setLabelText("Restoring view...")
            progress.setValue(98) # Almost done
            QApplication.processEvents()
            if check_cancel(): raise OperationCanceledError("Cancelled before restoring view")

            try:
                new_cursor = QTextCursor(document) # Use the correct document
                safe_position = min(position, len(modified_text))
                new_cursor.setPosition(safe_position)
                editor.setTextCursor(new_cursor)
                editor.verticalScrollBar().setValue(scroll_position)
                editor.ensureCursorVisible()
            except Exception as e:
                print(f"Error restoring cursor/scroll position: {e}")

            # Step 7: Complete progress
            progress.setLabelText("Format complete!")
            progress.setValue(100)
            QTimer.singleShot(500, progress.close) # Close after short delay

        except OperationCanceledError as op_cancel:
            print(f"[apply_formatting_with_dialog] Operation Cancelled: {op_cancel}")
            if editor.signalsBlocked(): editor.blockSignals(False) # Ensure signals are unblocked
            if progress and progress.isVisible(): progress.close()
            # Do NOT show QMessageBox for cancellation here

        except Exception as e:
            print(f"[apply_formatting_with_dialog] Error: {e}")
            if editor.signalsBlocked(): editor.blockSignals(False) # Ensure signals are unblocked
            QMessageBox.warning(self, "Error", f"An error occurred while formatting headers:\n{str(e)}")
            traceback.print_exc()
            if progress: progress.close()

        finally:
            # Clear major formatting flag
            if highlighter and hasattr(highlighter, '_major_formatting_active'):
                highlighter._major_formatting_active = False
                print("[apply_formatting_with_dialog] Cleared highlighter._major_formatting_active = False")

            # Restore original highlighting state (paused or resumed)
            if highlighter:
                current_paused_state = getattr(highlighter, '_highlighting_paused', False)
                print(f"[apply_formatting_with_dialog] Finally block: Initial paused={initial_highlighting_paused}, Current paused={current_paused_state}")
                if initial_highlighting_paused != current_paused_state or not initial_highlighting_paused:
                     if initial_highlighting_paused:
                         print("[apply_formatting_with_dialog] Restoring PAUSED highlighting state.")
                         if hasattr(highlighter, 'pause_highlighting'): highlighter.pause_highlighting()
                         else: highlighter._highlighting_paused = True
                     else:
                         print("[apply_formatting_with_dialog] Ensuring highlighting is RESUMED.")
                         if hasattr(highlighter, 'resume_highlighting'):
                             # *** Schedule resume_highlighting AFTER this function returns ***
                             QTimer.singleShot(50, highlighter.resume_highlighting) # Use timer!
                         else: highlighter._highlighting_paused = False

                # Reset standard cancellation flag
                if hasattr(highlighter, '_highlighting_cancelled'):
                    highlighter._highlighting_cancelled = False
                    print("[apply_formatting_with_dialog] Reset highlighter standard cancellation flag.")
                # --- End Reset ---

            # Optional: Clear local lock if used
            # self._formatting_in_progress = False
            # print("[apply_formatting_with_dialog] Cleared local formatting lock.")

    def _finish_formatting(self, header_highlighter):
        """Complete formatting process after main edits"""
        try:
            # First, ensure header blocks are properly identified
            if header_highlighter and hasattr(header_highlighter, 'header_blocks'):
                doc = self.document()
                new_header_blocks = set()
                block = doc.begin()
            
                # Find all headers with direct text examination
                while block.isValid():
                    text = block.text().strip()
                    if '[[' in text and ']]' in text:
                        new_header_blocks.add(block.blockNumber())
                    elif '**' in text and '**' in text:
                        new_header_blocks.add(block.blockNumber())
                    block = block.next()
            
                # Update header blocks set
                header_highlighter.header_blocks = new_header_blocks
        
            # Then apply direct formatting to headers before doing orphaned text processing
            if header_highlighter and hasattr(header_highlighter, '_fallback_rehighlight_all_headers'):
                header_highlighter._fallback_rehighlight_all_headers()
        
            # Now proceed with orphaned text processing
            if header_highlighter and hasattr(header_highlighter, 'selective_rehighlight_orphaned'):
                header_highlighter.selective_rehighlight_orphaned()
        
            # Finally resume highlighting
            if header_highlighter and hasattr(header_highlighter, 'resume_highlighting'):
                QTimer.singleShot(100, header_highlighter.resume_highlighting)
        except Exception as e:
            print(f"[_finish_formatting] Error: {e}")
            traceback.print_exc()

    def open_sample_preview(self):
        """Opens a preview of the sample HTML content in a popup dialog."""
        try:
            # Create a dialog to show the HTML preview
            preview_dialog = QDialog(self)
            preview_dialog.setWindowTitle("Formatted Transcript Sample")
            preview_dialog.resize(800, 600)
            preview_dialog.setStyleSheet("""
                QDialog {
                    background-color: white;
                }
                QPushButton {
                    background-color: #203740;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    min-width: 100px;
                }
                QPushButton:hover {
                    background-color: #2C4952;
                }
            """)
        
            dialog_layout = QVBoxLayout(preview_dialog)
        
            # Create the HTML preview component
            from PyQt6.QtWebEngineWidgets import QWebEngineView
            web_view = QWebEngineView()
        
            # HTML content for the sample
            html_content = """<!DOCTYPE html>
    <html>
    <head>
        <title>Scriptoria Sample</title>
        <style>
            body {
                font-family: 'Segoe UI', Arial, sans-serif;
                line-height: 1.6;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
                color: #333;
                background-color: #faf9f8;
            }
            
            /* Transparent text selection to show original highlight colors underneath */
            ::selection {
                background-color: rgba(33, 150, 243, 0.3) !important; /* Semi-transparent blue */
            }
            ::-moz-selection {
                background-color: rgba(33, 150, 243, 0.3) !important; /* Firefox compatibility */
            }
            h1 {
                color: #203740;
                text-align: center;
                border-bottom: 2px solid #203740;
                padding-bottom: 10px;
                margin-bottom: 30px;
            }
            .main-header-section {
                margin: 30px 0;
                text-align: center;
            }
            .main-header {
                font-size: 24px;
                font-weight: 800;
                color: #E6AA00;
                display: inline-block;
                padding: 5px 15px;
                text-transform: uppercase;
            }
            .speech {
                background: white;
                padding: 20px;
                margin-bottom: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }
            .speech-header {
                display: flex;
                align-items: center;
                margin-bottom: 15px;
                position: relative;
            }
            .speech-title {
                font-size: 20px;
                font-weight: 700;
                color: #2196F3;
                margin: 0;
            }
            .speech-content {
                font-size: 15px;
                line-height: 1.7;
            }
            .color-key {
                display: flex;
                flex-wrap: wrap;
                gap: 15px;
                padding: 15px;
                border-radius: 8px;
                margin: 20px 0;
                background: white;
                justify-content: center;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }
            .key-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }
            .color-box {
                width: 20px;
                height: 20px;
                border-radius: 4px;
            }
        </style>
    </head>
    <body>
        <h1>Sample Formatted Transcript</h1>
    
        <div class="color-key">
            <div class="key-item">
                <span class="color-box" style="background-color: #FFF0B3;"></span>
                Theme 1
            </div>
            <div class="key-item">
                <span class="color-box" style="background-color: #B4E4FF;"></span>
                Theme 2
            </div>
            <div class="key-item">
                <span class="color-box" style="background-color: #FFD7DC;"></span>
                Theme 3
            </div>
        </div>
    
        <div class="main-header-section">
            <h2 class="main-header">PART 1</h2>
        </div>
    
        <article class="speech">
            <div class="speech-header">
                <h2 class="speech-title">Header One</h2>
            </div>
            <div class="speech-content">
                <p>This text will be under Header One.</p>
            </div>
        </article>
    
        <article class="speech">
            <div class="speech-header">
                <h2 class="speech-title">Header Two</h2>
            </div>
            <div class="speech-content">
                <p>This text will be under Header Two.</p>
            </div>
        </article>
    
        <div class="main-header-section">
            <h2 class="main-header">PART 2</h2>
        </div>
    
        <article class="speech">
            <div class="speech-header">
                <h2 class="speech-title">Header Three</h2>
            </div>
            <div class="speech-content">
                <p>This text will be under Header Three.</p>
            </div>
        </article>
    </body>
    </html>"""
        
            # Load the HTML content into the web view
            web_view.setHtml(html_content)
            dialog_layout.addWidget(web_view)
        
            # Add a close button
            button_layout = QHBoxLayout()
            close_button = QPushButton("Close")
            close_button.clicked.connect(preview_dialog.accept)
            button_layout.addStretch()
            button_layout.addWidget(close_button)
            dialog_layout.addLayout(button_layout)
        
            # Show the dialog
            preview_dialog.exec()
        
        except ImportError:
            # Fallback if QWebEngineWidgets is not available
            QMessageBox.warning(
                self, 
                "Preview Not Available", 
                "The HTML preview feature requires PyQt6 WebEngine support. Please install it with:\npip install PyQt6-WebEngine"
            )
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open HTML preview: {str(e)}")


    def show_input_help_dialog(self):
        """Shows a help dialog explaining how to use the create transcript feature."""
        help_dialog = QDialog(self)
        help_dialog.setWindowTitle("How to Create Transcripts")
        
        # More relaxed minimum dimensions that allow better flexibility
        help_dialog.setMinimumWidth(600)  # Reduced from 1000
        help_dialog.setMinimumHeight(500) # Reduced from 850
        
        # Scale dialog size based on screen dimensions
        screen = QApplication.primaryScreen().availableGeometry()
        default_width = min(850, int(screen.width() * 0.75))
        default_height = min(700, int(screen.height() * 0.8))
        help_dialog.resize(default_width, default_height)
        
        # Enable window maximize/minimize buttons - compatible with different Qt versions
        try:
            # Try PyQt6/PySide6 style
            from PyQt6.QtCore import Qt
            help_dialog.setWindowFlags(help_dialog.windowFlags() | 
                                      Qt.WindowType.WindowMaximizeButtonHint | 
                                      Qt.WindowType.WindowMinimizeButtonHint)
        except (ImportError, AttributeError):
            try:
                # Try older PyQt5 style
                help_dialog.setWindowFlags(help_dialog.windowFlags() | 
                                          Qt.WindowMaximizeButtonHint | 
                                          Qt.WindowMinimizeButtonHint)
            except AttributeError:
                # Fallback if neither works - just don't set those flags
                print("Warning: Could not set maximize/minimize window flags")
        
        help_dialog.setStyleSheet("""
            QDialog {
                background-color: white;
            }
            QLabel {
                font-size: 13px;
                line-height: 1.5;
                color: #333;
            }
            QLabel[class="heading"] {
                font-size: 16px;
                font-weight: bold;
                color: #203740;
                padding-top: 16px;
            }
            QLabel[class="subheading"] {
                font-size: 14px;
                font-weight: bold;
                color: #2C4952;
                margin-top: 8px;
            }
            QLabel[class="header-example"] {
                font-weight: bold;
                color: #2196F3;
                background-color: #E3F2FD;
                padding: 6px 10px;
                border-radius: 4px;
            }
            QLabel[class="section-example"] {
                font-weight: bold;
                color: #E6AA00;
                background-color: #FFF8E1;
                padding: 6px 10px;
                border-radius: 4px;
            }
            QLabel[class="orphaned-example"] {
                color: #FF3333;
                background-color: #FFEBEE;
                padding: 6px 10px;
                border-radius: 4px;
            }
            QFrame[class="separator"] {
                background-color: #E0E0E0;
                max-height: 1px;
                margin: 12px 0;
            }
            QTextEdit {
                border: 1px solid #dee2e6;
                border-radius: 4px;
                padding: 12px;
                background-color: #f8f9fa;
                font-family: 'Segoe UI', sans-serif;
                line-height: 1.5;
            }
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 4px;
                min-width: 120px;
                font-weight: 500;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
        """)

        # Main dialog layout
        main_layout = QVBoxLayout(help_dialog)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        # Create scroll area
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.Shape.NoFrame)
        
        # Handle ScrollBarPolicy for different Qt versions
        try:
            # PyQt6/PySide6
            scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
            scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        except AttributeError:
            try:
                # PyQt5
                scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
                scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            except AttributeError:
                # Last resort fallback
                pass
    
        # Create container widget for all content
        content_widget = QWidget()
        content_layout = QVBoxLayout(content_widget)
        content_layout.setSpacing(16)
        content_layout.setContentsMargins(24, 24, 24, 24)

        # Overview heading
        overview_heading = QLabel("Creating Transcripts in Scriptoria")
        overview_heading.setProperty("class", "heading")
        content_layout.addWidget(overview_heading)

        # Overview text
        overview_text = QLabel(
            "Scriptoria converts your text into an HTML transcript, which you can highlighting according to theme and arrange scripts from."
            " Transcript creation is centered around Headers and Section Dividers which are defined by the THREE simple syntax rules below."
        )
        overview_text.setWordWrap(True)
        content_layout.addWidget(overview_text)

        # Separator
        separator = QFrame()
        separator.setProperty("class", "separator")
        separator.setFrameShape(QFrame.Shape.HLine)
        content_layout.addWidget(separator)

        # Formatting heading
        format_heading = QLabel("Header Syntax Rules")
        format_heading.setProperty("class", "heading")
        content_layout.addWidget(format_heading)

        # Create a grid layout for formatting examples
        format_grid = QGridLayout()
        format_grid.setSpacing(10)
        format_grid.setContentsMargins(0, 10, 0, 10)

        # Row 1: Headers
        header_title = QLabel("Headers (Required):")
        header_title.setProperty("class", "subheading")
        format_grid.addWidget(header_title, 0, 0)

        header_example = QLabel("**Chapter Title**")
        header_example.setProperty("class", "header-example")
        format_grid.addWidget(header_example, 0, 1)

        header_desc = QLabel("Main text sections shown in <b style='color: #2196F3;'>blue</b>.<br><b>All text must be preceded somewhere by at least one header.</b>")
        header_desc.setWordWrap(True)
        format_grid.addWidget(header_desc, 0, 2)

        # Row 2: Section Dividers
        section_title = QLabel("Section Dividers (Optional):")
        section_title.setProperty("class", "subheading")
        format_grid.addWidget(section_title, 1, 0)

        section_example = QLabel("[[Part 1]]")
        section_example.setProperty("class", "section-example")
        format_grid.addWidget(section_example, 1, 1)

        section_desc = QLabel("Larger organizational divisions shown in <b style='color: #E6AA00;'>gold</b>.<br>These are optional, but available for document legibility.")
        section_desc.setWordWrap(True)
        format_grid.addWidget(section_desc, 1, 2)

        # Row 3: Orphaned Text
        orphan_title = QLabel("Orphaned Text (Warning):")
        orphan_title.setProperty("class", "subheading")
        format_grid.addWidget(orphan_title, 2, 0)

        orphan_example = QLabel("Text without a header")
        orphan_example.setProperty("class", "orphaned-example")
        format_grid.addWidget(orphan_example, 2, 1)

        orphan_desc = QLabel("Text not preceded by a header will be shown in <b style='color: #FF3333;'>red</b>.<br><b>Any existing orphaned text will BLOCK transcript creation.</b>")
        orphan_desc.setWordWrap(True)
        format_grid.addWidget(orphan_desc, 2, 2)

        # Set column stretch
        format_grid.setColumnStretch(0, 1)
        format_grid.setColumnStretch(1, 1)
        format_grid.setColumnStretch(2, 2)

        content_layout.addLayout(format_grid)

        # Separator
        separator2 = QFrame()
        separator2.setProperty("class", "separator")
        separator2.setFrameShape(QFrame.Shape.HLine)
        content_layout.addWidget(separator2)

        # Ways to create headers
        methods_heading = QLabel("Ways to Create Headers")
        methods_heading.setProperty("class", "heading")
        content_layout.addWidget(methods_heading)

        # Methods content
        methods_layout = QVBoxLayout()
        methods_layout.setSpacing(8)
        method3 = QLabel("• <b>Right-click menu:</b> Select text, then right-click and choose 'Make Header' or 'Make Section Divider' or manually add double asterixes (Header) or brackets (Divider).")
        method3.setWordWrap(True)
        methods_layout.addWidget(method3)

        method4 = QLabel("• <b>Auto Paste Formatting:</b> When text is pasted from the internet, the program will attempt to auto-format headers based on detected HTML or Markdown content. If the default formatting parameters fail, they can be tweaked via the dialog options.")
        method4.setWordWrap(True)
        methods_layout.addWidget(method4)

        method5 = QLabel("• <b>Auto Header Wrapping:</b> You can automatically find and wrap lines into a Header or Section Divider throughout the document with this tool. A common use case for ebooks would be to wrap lines that start with the word 'Chapter'.")
        method5.setWordWrap(True)
        methods_layout.addWidget(method5)

        method5 = QLabel("• <b>Import Tools:</b> The Captions Reorganizer and File Import Tools can help you automatically format text into the required structure. More information on these tools are at the bottom of this dialog.")
        method5.setWordWrap(True)
        methods_layout.addWidget(method5)



        content_layout.addLayout(methods_layout)

        # Sample with clickable header
        sample_button = QPushButton("Sample Format (Click to See Sample)")
        sample_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #203740;
                border: none;
                font-size: 16px;
                font-weight: bold;
                padding-top: 12px;
                padding-left: 0px;
                text-align: left;
            }
            QPushButton:hover {
                color: #2196F3;
                text-decoration: underline;
            }
        """)
        sample_button.setCursor(Qt.CursorShape.PointingHandCursor)
        sample_button.clicked.connect(lambda: self.open_sample_preview())
        content_layout.addWidget(sample_button)

        # Use HTML instead to style the content properly
        sample_text = QTextEdit()
        sample_text.setReadOnly(True)
        sample_text.setHtml(
            "<span style='color: #E6AA00; font-weight: bold;'>[[PART 1]]</span><br><br>"
            "<span style='color: #2196F3; font-weight: bold;'>**Header One**</span><br>"
            "This text will be under Header One.<br><br>"
            "<span style='color: #2196F3; font-weight: bold;'>**Header Two**</span><br>"
            "This text will be under Header Two.<br><br>"
            "<span style='color: #E6AA00; font-weight: bold;'>[[PART 2]]</span><br><br>"
            "<span style='color: #2196F3; font-weight: bold;'>**Header Three**</span><br>"
            "This text will be under Header Three."
        )
        sample_text.setMinimumHeight(250)
        content_layout.addWidget(sample_text)

        # Workflow heading
        workflow_heading = QLabel("Workflow")
        workflow_heading.setProperty("class", "heading")
        content_layout.addWidget(workflow_heading)

        # Workflow steps
        workflow_text = QLabel(
            "1. <b>Format your text</b> with headers (and optional section dividers)<br>"
            "2. Check the right panel <b>Headers List</b> to ensure all your headers are recognized<br>"
            "3. Fix any red 'orphaned text' if there are any.<br>"
            "4. Click <b>Create Transcript</b> and go through the following menu.<br>"
        )
        workflow_text.setWordWrap(True)
        content_layout.addWidget(workflow_text)

        # Import and formatting tools
        tools_heading = QLabel("Available Import Tools")
        tools_heading.setProperty("class", "heading")
        content_layout.addWidget(tools_heading)

        tools_text = QLabel(
            "Scriptoria provides several tools to help you import and format content:"
        )
        tools_text.setWordWrap(True)
        content_layout.addWidget(tools_text)

        tools_layout = QVBoxLayout()
        tools_layout.setSpacing(8)

        tool1 = QLabel("• <b>PDF Import Tool:</b> Import and extract text from PDF files while preserving structure. PDF formatting is currently buggy and limited in effectiveness.")
        tool1.setWordWrap(True)
        tools_layout.addWidget(tool1)

        tool2 = QLabel("• <b>EPUB Import Tool:</b> Import ebook content and automatically format chapter headings")
        tool2.setWordWrap(True)
        tools_layout.addWidget(tool2)

        tool4 = QLabel("• <b>Captions Reorganizers:</b> Connect to Claude AI to automatically format video captions into properly structured content")
        tool4.setWordWrap(True)
        tools_layout.addWidget(tool4)

        content_layout.addLayout(tools_layout)

        # Close button - we'll add this outside the scroll area to keep it fixed at the bottom
        button_widget = QWidget()
        button_layout = QHBoxLayout(button_widget)
        button_layout.setContentsMargins(24, 16, 24, 16)
        button_layout.addStretch()

        close_button = QPushButton("Got It")
        close_button.clicked.connect(help_dialog.accept)
        button_layout.addWidget(close_button)

        # Set the content widget to the scroll area
        scroll_area.setWidget(content_widget)
    
        # Add scroll area and button to main layout
        main_layout.addWidget(scroll_area, 1)  # Give scroll area stretch factor
        main_layout.addWidget(button_widget, 0)  # Fixed height for button area

        help_dialog.exec()

    def _clear_options_dialog_reference(self):
        """Clears the reference to the options dialog when it closes."""
        if hasattr(self, 'transcriber_options_dialog'):
            print("Clearing reference to Captions Reorganizer dialog.")
            self.transcriber_options_dialog = None

    def _handle_paste_from_gemini(self, text_to_paste):
        """Handles the request to paste text from the Gemini dialog,
           switches tabs, triggers paste, AND closes the options dialog if open."""
        print("Received pasteToInputRequested signal in ScriptoriaMain.")

        # --- Close the Captions Reorganizer dialog first if it exists ---
        if hasattr(self, 'transcriber_options_dialog') and self.transcriber_options_dialog and self.transcriber_options_dialog.isVisible():
            print("Closing the Captions Reorganizer dialog as well.")
            self.transcriber_options_dialog.accept() # Close it nicely
            # The finished signal will set self.transcriber_options_dialog to None
        # ---------------------------------------------------------------

        # 1. Find the "Create Transcript" tab index
        target_tab_index = -1
        for i in range(self.tabs.count()):
            if self.tabs.tabText(i).lower() == "create transcript":
                target_tab_index = i
                break

        if target_tab_index == -1:
            print("Error: 'Create Transcript' tab not found.")
            QMessageBox.warning(self, "Error", "Could not find the 'Create Transcript' tab.")
            return

        # 2. Switch to the target tab
        print(f"Switching to tab index {target_tab_index} ('Create Transcript').")
        self.tabs.setCurrentIndex(target_tab_index)

        # 3. Ensure the input_text widget exists
        if not hasattr(self, 'input_text'):
            print("Error: input_text widget not found.")
            QMessageBox.warning(self, "Error", "Could not find the text input area.")
            return

        # 4. Put the text onto the application's clipboard
        clipboard = QApplication.clipboard()
        if not clipboard:
            print("Error: Could not access application clipboard.")
            QMessageBox.warning(self, "Error", "Could not access the clipboard for pasting.")
            return
        print("Setting text onto application clipboard.")
        clipboard.setText(text_to_paste)

        # 5. Trigger the paste action on the CreateTranscriptTextEdit widget
        def do_paste():
            print("Executing paste action on input_text widget.")
            if hasattr(self.input_text, 'paste'):
                self.input_text.paste()
                self.input_text.setFocus()
                print("Paste action triggered.")
            else:
                print("Error: input_text widget does not have a 'paste' method.")
                QMessageBox.warning(self, "Paste Error", "Could not automatically trigger paste action.")

        QTimer.singleShot(50, do_paste)

    def show_cleaning_success_dialog(self):
        """Show a modern success dialog after cleaning captions with option to open Captions Reorganizer."""
        dialog = QDialog(self)
        dialog.setWindowTitle("Captions Cleaned Successfully")
        dialog.setFixedSize(480, 320)
        dialog.setWindowFlags(Qt.WindowType.Dialog | Qt.WindowType.WindowCloseButtonHint)
        
        # Main layout
        main_layout = QVBoxLayout(dialog)
        main_layout.setContentsMargins(30, 30, 30, 30)
        main_layout.setSpacing(20)
        
        # Success icon and title section
        header_layout = QHBoxLayout()
        header_layout.setSpacing(15)
        
        # Success icon (checkmark)
        icon_label = QLabel("✓")
        icon_label.setStyleSheet("""
            QLabel {
                color: #4CAF50;
                font-size: 48px;
                font-weight: bold;
                min-width: 60px;
                max-width: 60px;
            }
        """)
        icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header_layout.addWidget(icon_label)
        
        # Title and subtitle
        text_layout = QVBoxLayout()
        text_layout.setSpacing(8)
        
        title_label = QLabel("Success!")
        title_label.setStyleSheet("""
            QLabel {
                color: #2E2E2E;
                font-size: 24px;
                font-weight: bold;
                margin: 0;
            }
        """)
        text_layout.addWidget(title_label)
        
        subtitle_label = QLabel("Timecodes removed from captions")
        subtitle_label.setStyleSheet("""
            QLabel {
                color: #666666;
                font-size: 14px;
                margin: 0;
            }
        """)
        text_layout.addWidget(subtitle_label)
        
        header_layout.addLayout(text_layout)
        header_layout.addStretch()
        main_layout.addLayout(header_layout)
        
        # Main message
        message_label = QLabel(
            "You've successfully removed timecodes from the following captions.\n\n"
            "Now you must process the cleaned captions in an LLM to restructure it with Scriptoria's "
            "accepted syntax. It is recommended that you use the provided default prompt to do so.\n\n"
            "Would you like to open the Structure Captions dialog to proceed?"
        )
        message_label.setStyleSheet("""
            QLabel {
                color: #444444;
                font-size: 13px;
                background-color: #F8F9FA;
                padding: 20px;
                border: 1px solid #E9ECEF;
                border-radius: 8px;
            }
        """)
        message_label.setWordWrap(True)
        message_label.setAlignment(Qt.AlignmentFlag.AlignTop)
        main_layout.addWidget(message_label)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.setSpacing(12)
        button_layout.addStretch()
        
        # No button
        no_button = QPushButton("Not Now")
        no_button.setStyleSheet("""
            QPushButton {
                background-color: #F5F5F5;
                color: #666666;
                border: 1px solid #D0D0D0;
                border-radius: 6px;
                padding: 10px 20px;
                font-size: 13px;
                font-weight: 500;
                min-width: 90px;
            }
            QPushButton:hover {
                background-color: #EEEEEE;
                border-color: #BBBBBB;
            }
            QPushButton:pressed {
                background-color: #E0E0E0;
            }
        """)
        no_button.setCursor(Qt.CursorShape.PointingHandCursor)
        no_button.clicked.connect(dialog.reject)
        button_layout.addWidget(no_button)
        
        # Yes button  
        yes_button = QPushButton("Yes, proceed")
        yes_button.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 20px;
                font-size: 13px;
                font-weight: 500;
                min-width: 140px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:pressed {
                background-color: #1565C0;
            }
        """)
        yes_button.setCursor(Qt.CursorShape.PointingHandCursor)
        yes_button.clicked.connect(lambda: self.handle_reorganizer_request(dialog))
        yes_button.setDefault(True)  # Make it the default button
        button_layout.addWidget(yes_button)
        
        main_layout.addLayout(button_layout)
        
        # Show dialog
        dialog.exec()
    
    def handle_reorganizer_request(self, success_dialog):
        """Handle the request to open Captions Reorganizer from success dialog."""
        success_dialog.accept()  # Close success dialog first
        QTimer.singleShot(100, self.show_transcriber_options)  # Small delay before opening reorganizer

    def show_transcriber_options(self):
        # Create dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Structure Captions")
        dialog.setFixedSize(650, 620)  # Adjusted size for horizontal layout
        main_layout = QHBoxLayout(dialog)  # Changed to horizontal main layout

        # --- Left side: PROMPT SECTION ---
        left_layout = QVBoxLayout()
        left_layout.setSpacing(15)

        label = QLabel("Use provided API or copy the prompt into any LLM")
        label.setStyleSheet("font-size: 12px; margin-bottom: 10px;")
        left_layout.addWidget(label)

        # Store reference to this dialog
        self.transcriber_options_dialog = dialog
        dialog.finished.connect(self._clear_options_dialog_reference)

        # MODIFICATION 1: Modified prompt header to include dropdown next to the header
        override_header = QHBoxLayout()
        override_label = QLabel("The Prompt:")
        override_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        override_header.addWidget(override_label)

        # Create a dropdown for prompt selection (moved from previous position)
        prompt_dropdown = QComboBox()
        prompt_dropdown.setObjectName("promptDropdown")
        prompt_dropdown.setStyleSheet("""
            QComboBox {
                background-color: #F5F5F5; border: 1px solid #CCCCCC; border-radius: 3px;
                padding: 2px 2px; font-size: 10px; min-width: 180px;
            }
            QComboBox:hover { border-color: #AAAAAA; }
        """)

        # Load available prompts
        self.prompt_files = self._load_available_prompts()
        for prompt_name in self.prompt_files.keys():
            prompt_dropdown.addItem(prompt_name)

        override_header.addWidget(prompt_dropdown)

        # Create save button with minimal styling and add it next to the dropdown
        save_button = QPushButton("Save")
        save_button.setObjectName("savePromptButton")
        save_button.setCursor(Qt.CursorShape.PointingHandCursor)
        save_button.setStyleSheet("""
            QPushButton {
                background-color: transparent; 
                color: #555555; 
                border: none;
                padding: 2px 2px; 
                font-size: 12px;
            }
            QPushButton:hover { 
                color: #5851DB; 
            }
        """)
        override_header.addWidget(save_button)
        override_header.addStretch()
        left_layout.addLayout(override_header)

        # ADD RIGHT-CLICK DELETE FUNCTIONALITY TO DROPDOWN
        # Enable context menu for the dropdown
        prompt_dropdown.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)

        # Create context menu handler
        def show_dropdown_context_menu(pos):
            current_prompt = prompt_dropdown.currentText()
        
            # Don't allow context menu for Default Prompt
            if current_prompt.lower() == "default prompt":
                return
            
            # Create context menu
            menu = QMenu()
            delete_action = menu.addAction("Delete Prompt")
        
            # Show menu at cursor position
            action = menu.exec(prompt_dropdown.mapToGlobal(pos))
        
            # Handle delete action
            if action == delete_action:
                # Confirm deletion
                confirm_dialog = QMessageBox(dialog)
                confirm_dialog.setWindowTitle("Confirm Delete")
                confirm_dialog.setText(f"Are you sure you want to delete the prompt '{current_prompt}'?")
                confirm_dialog.setIcon(QMessageBox.Icon.Question)
                confirm_dialog.setStandardButtons(
                    QMessageBox.StandardButton.Yes | 
                    QMessageBox.StandardButton.No
                )
                confirm_dialog.setDefaultButton(QMessageBox.StandardButton.No)
            
                # Position dialog on same screen as parent
                parent_geometry = dialog.geometry()
                confirm_dialog.setFixedSize(confirm_dialog.sizeHint())
                confirm_geometry = confirm_dialog.geometry()
            
                # Center on parent window
                x = parent_geometry.x() + (parent_geometry.width() - confirm_geometry.width()) // 2
                y = parent_geometry.y() + (parent_geometry.height() - confirm_geometry.height()) // 2
                confirm_dialog.move(x, y)
            
                # If user confirms deletion
                if confirm_dialog.exec() == QMessageBox.StandardButton.Yes:
                    try:
                        # Get the file path for the current prompt
                        prompt_path = self.prompt_files[current_prompt]
                    
                        # Double check that we're not deleting the default prompt
                        if os.path.basename(prompt_path).lower() == "default_prompt.txt":
                            error_dialog = QMessageBox(dialog)
                            error_dialog.setWindowTitle("Cannot Delete Default")
                            error_dialog.setText("The Default Prompt cannot be deleted.")
                            error_dialog.setIcon(QMessageBox.Icon.Warning)
                            error_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
                            error_dialog.exec()
                            return
                    
                        # Delete the file
                        os.remove(prompt_path)
                    
                        # Remove from the self.prompt_files dictionary
                        del self.prompt_files[current_prompt]
                    
                        # Remove from dropdown
                        index = prompt_dropdown.findText(current_prompt)
                        if index >= 0:
                            prompt_dropdown.removeItem(index)
                    
                        # Reset to Default Prompt
                        default_index = prompt_dropdown.findText("Default Prompt")
                        if default_index >= 0:
                            prompt_dropdown.setCurrentIndex(default_index)
                    
                        # Show success message
                        success_dialog = QMessageBox(dialog)
                        success_dialog.setWindowTitle("Prompt Deleted")
                        success_dialog.setText(f"Prompt '{current_prompt}' has been deleted.")
                        success_dialog.setIcon(QMessageBox.Icon.Information)
                        success_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
                        success_dialog.exec()
                    
                    except Exception as e:
                        # Show error message
                        error_dialog = QMessageBox(dialog)
                        error_dialog.setWindowTitle("Error Deleting Prompt")
                        error_dialog.setText(f"An error occurred while deleting the prompt: {str(e)}")
                        error_dialog.setIcon(QMessageBox.Icon.Warning)
                        error_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
                        error_dialog.exec()

        # Connect the custom context menu
        prompt_dropdown.customContextMenuRequested.connect(show_dropdown_context_menu)

        prompt_textedit = QTextEdit()
        prompt_textedit.setObjectName("promptTextEdit")
        prompt_textedit.setReadOnly(False)  # Changed to editable
        prompt_textedit.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        prompt_textedit.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        prompt_textedit.setMinimumHeight(300)  # Increased for better vertical space
        prompt_textedit.setStyleSheet("""
             QTextEdit {
                 background-color: #F5F5F5; border: 1px solid #CCCCCC; border-radius: 5px;
                 padding: 5px; font-size: 11px;
             }
        """)
        left_layout.addWidget(prompt_textedit)

        # Checkboxes section
        options_layout = QVBoxLayout()
        options_layout.setContentsMargins(10, 10, 0, 0)
        options_layout.setSpacing(4)

        checkbox_style = """
            QCheckBox { font-size: 11px; padding: 2px 5px; }
            QCheckBox:hover { color: #5851DB; }
        """
        make_questions_headers = QCheckBox("Make each question into a header (recommended for interviews)")
        make_questions_headers.setObjectName("makeQuestionsHeaders")
        make_questions_headers.setStyleSheet(checkbox_style)
        options_layout.addWidget(make_questions_headers)

        label_speakers_name = QCheckBox("Always label the person speaking")
        label_speakers_name.setObjectName("labelSpeakersName")
        label_speakers_name.setStyleSheet(checkbox_style)
        options_layout.addWidget(label_speakers_name)

        custom_override_layout = QHBoxLayout()
        custom_override_radio = QCheckBox("Custom Instructions:")
        custom_override_radio.setObjectName("customOverrideRadio")
        custom_override_radio.setStyleSheet(checkbox_style)
        custom_override_edit = QLineEdit()
        custom_override_edit.setObjectName("customOverrideEdit")
        custom_override_edit.setPlaceholderText("Enter custom instructions")
        custom_override_edit.setStyleSheet("""
             QLineEdit {
                 font-size: 11px; padding: 5px; border: 1px solid #CCCCCC;
                 border-radius: 3px;
             }
        """)
        custom_override_layout.addWidget(custom_override_radio)
        custom_override_layout.addWidget(custom_override_edit)
        options_layout.addLayout(custom_override_layout)
        left_layout.addLayout(options_layout)

        # MODIFICATION 2: Modified copy/save buttons layout - only need copy button now
        button_style = """
            QPushButton {
                background-color: #F5F5F5; color: #333333; border: 1px solid #CCCCCC;
                padding: 4px 8px; border-radius: 3px; font-size: 10px; min-width: 60px;
            }
            QPushButton:hover { background-color: #E0E0E0; }
            QPushButton:pressed { background-color: #D6D6D6; }
        """

        # Enhanced style for copy button to make it more visible
        copy_button_style = """
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 5px;
                font-size: 12px;
                font-weight: 500;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:pressed {
                background-color: #1565C0;
            }
        """

        # Create copy button
        copy_button = QPushButton("Copy Current Prompt")
        copy_button.setObjectName("copyPromptButton")
        copy_button.setCursor(Qt.CursorShape.PointingHandCursor)
        copy_button.setStyleSheet(copy_button_style)

        # Horizontal layout for copy button, centered
        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()  # Left stretch
        buttons_layout.addWidget(copy_button)
        buttons_layout.addStretch()  # Right stretch to center the button
        left_layout.addLayout(buttons_layout)

        # Copy button connection
        if copy_button and prompt_textedit:
            def copy_prompt_action():
                clipboard = QApplication.clipboard()
                if clipboard and prompt_textedit:
                    clipboard.setText(prompt_textedit.toPlainText())
                    print("Prompt copied to clipboard.")
                    original_text = copy_button.text()
                    copy_button.setText("Copied!")
                    copy_button.setEnabled(False)
                    QTimer.singleShot(1500, lambda: (
                        copy_button.setText(original_text),
                        copy_button.setEnabled(True)
                    ))
            copy_button.clicked.connect(copy_prompt_action)
        else:
            print("Warning: Could not connect copy button or find prompt textedit.")

        # Save button connection - Save prompt to file
        def save_prompt_action():
            current_text = prompt_textedit.toPlainText()
            current_name = prompt_dropdown.currentText()

            # Create a custom dialog for save options
            save_dialog = QDialog(dialog)
            save_dialog.setWindowTitle("Save Prompt")
            save_dialog.setModal(True)

            # Set layout
            layout = QVBoxLayout(save_dialog)

            # Add label
            label = QLabel("How would you like to save this prompt?")
            layout.addWidget(label)

            # Create radio buttons instead of dropdown
            save_options = ["Save as new prompt", "Overwrite current prompt"]
            if current_name == "Default Prompt":  # Can't overwrite default
                save_options = ["Save as new prompt"]

            radio_buttons = []
            for option in save_options:
                radio = QRadioButton(option)
                if option == save_options[0]:  # Select first option by default
                    radio.setChecked(True)
                layout.addWidget(radio)
                radio_buttons.append(radio)

            # Add buttons
            buttons = QDialogButtonBox(
                QDialogButtonBox.StandardButton.Ok | 
                QDialogButtonBox.StandardButton.Cancel
            )
            buttons.accepted.connect(save_dialog.accept)
            buttons.rejected.connect(save_dialog.reject)
            layout.addWidget(buttons)

            # Position the dialog on the same screen as parent BEFORE showing it
            # This prevents the flash in the top-left corner
            parent_geometry = dialog.geometry()
            save_dialog.setFixedSize(save_dialog.sizeHint())
            dialog_geometry = save_dialog.geometry()

            # Get the screen containing the parent
            screen = QGuiApplication.screenAt(dialog.mapToGlobal(QPoint(dialog.width()//2, dialog.height()//2)))
            if not screen:
                screen = QGuiApplication.primaryScreen()

            # Center on the parent window
            x = parent_geometry.x() + (parent_geometry.width() - dialog_geometry.width()) // 2
            y = parent_geometry.y() + (parent_geometry.height() - dialog_geometry.height()) // 2
            save_dialog.move(x, y)

            # Execute dialog
            if save_dialog.exec() != QDialog.DialogCode.Accepted:
                return

            # Get the selected option
            save_choice = None
            for i, radio in enumerate(radio_buttons):
                if radio.isChecked():
                    save_choice = save_options[i]
                    break

            if not save_choice:
                return

            if save_choice == "Save as new prompt":
                # Create a custom text input dialog
                name_dialog = QDialog(dialog)
                name_dialog.setWindowTitle("Save New Prompt")
                name_dialog.setModal(True)
    
                # Set layout
                name_layout = QVBoxLayout(name_dialog)
    
                # Add label
                name_label = QLabel("Enter a name for this prompt:")
                name_layout.addWidget(name_label)
    
                # Add text field
                name_text = QLineEdit()
                name_layout.addWidget(name_text)
    
                # Add buttons
                name_buttons = QDialogButtonBox(
                    QDialogButtonBox.StandardButton.Ok | 
                    QDialogButtonBox.StandardButton.Cancel
                )
                name_buttons.accepted.connect(name_dialog.accept)
                name_buttons.rejected.connect(name_dialog.reject)
                name_layout.addWidget(name_buttons)
    
                # Position on the same screen as parent
                name_dialog.setFixedSize(name_dialog.sizeHint())
                name_geometry = name_dialog.geometry()
    
                # Center on the parent window
                x = parent_geometry.x() + (parent_geometry.width() - name_geometry.width()) // 2
                y = parent_geometry.y() + (parent_geometry.height() - name_geometry.height()) // 2
                name_dialog.move(x, y)
    
                # Execute dialog
                if name_dialog.exec() != QDialog.DialogCode.Accepted:
                    return
    
                prompt_name = name_text.text().strip()
                if not prompt_name:
                    return
        
                # Prevent saving as "Default Prompt" or any case-insensitive variation
                if prompt_name.lower() == "default prompt":
                    # Create error message box
                    error_dialog = QMessageBox(dialog)
                    error_dialog.setWindowTitle("Cannot Save as Default")
                    error_dialog.setText("The Default Prompt cannot be overwritten. Please choose a different name.")
                    error_dialog.setIcon(QMessageBox.Icon.Warning)
                    error_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
        
                    # Position on the same screen as parent
                    error_dialog.setFixedSize(error_dialog.sizeHint())
                    error_geometry = error_dialog.geometry()
        
                    # Center on the parent window
                    x = parent_geometry.x() + (parent_geometry.width() - error_geometry.width()) // 2
                    y = parent_geometry.y() + (parent_geometry.height() - error_geometry.height()) // 2
                    error_dialog.move(x, y)
        
                    error_dialog.exec()
                    return
    
                # Check if name already exists
                prompt_path = os.path.join(get_data_folder(), "prompts", f"{prompt_name}.txt")
    
                # Prevent creating a file that would overwrite default_prompt.txt (case-insensitive check)
                if os.path.basename(prompt_path).lower() == "default_prompt.txt":
                    # Create error message box
                    error_dialog = QMessageBox(dialog)
                    error_dialog.setWindowTitle("Cannot Save as Default")
                    error_dialog.setText("The Default Prompt cannot be overwritten. Please choose a different name.")
                    error_dialog.setIcon(QMessageBox.Icon.Warning)
                    error_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
        
                    # Position on same screen as parent
                    error_dialog.setFixedSize(error_dialog.sizeHint())
                    error_geometry = error_dialog.geometry()
        
                    # Center on the parent window
                    x = parent_geometry.x() + (parent_geometry.width() - error_geometry.width()) // 2
                    y = parent_geometry.y() + (parent_geometry.height() - error_geometry.height()) // 2
                    error_dialog.move(x, y)
        
                    error_dialog.exec()
                    return
        
                if os.path.exists(prompt_path):
                    # Create confirmation dialog
                    confirm_dialog = QMessageBox(dialog)
                    confirm_dialog.setWindowTitle("Prompt Already Exists")
                    confirm_dialog.setText(f"A prompt with the name '{prompt_name}' already exists. Overwrite?")
                    confirm_dialog.setIcon(QMessageBox.Icon.Question)
                    confirm_dialog.setStandardButtons(
                        QMessageBox.StandardButton.Yes | 
                        QMessageBox.StandardButton.No
                    )
                    confirm_dialog.setDefaultButton(QMessageBox.StandardButton.No)
        
                    # Position on same screen as parent
                    confirm_dialog.setFixedSize(confirm_dialog.sizeHint())
                    confirm_geometry = confirm_dialog.geometry()
        
                    # Center on the parent window
                    x = parent_geometry.x() + (parent_geometry.width() - confirm_geometry.width()) // 2
                    y = parent_geometry.y() + (parent_geometry.height() - confirm_geometry.height()) // 2
                    confirm_dialog.move(x, y)
        
                    if confirm_dialog.exec() != QMessageBox.StandardButton.Yes:
                        return
    
                # Save the new prompt
                try:
                    os.makedirs(os.path.join(get_data_folder(), "prompts"), exist_ok=True)
                    with open(prompt_path, "w", encoding='utf-8') as f:
                        f.write(current_text)
        
                    # Update dropdown and select the new prompt
                    self.prompt_files[prompt_name] = prompt_path
                    if prompt_dropdown.findText(prompt_name) == -1:
                        prompt_dropdown.addItem(prompt_name)
                    prompt_dropdown.setCurrentText(prompt_name)
    
                    # Show success message
                    success_dialog = QMessageBox(dialog)
                    success_dialog.setWindowTitle("Prompt Saved")
                    success_dialog.setText(f"Prompt saved as '{prompt_name}'.")
                    success_dialog.setIcon(QMessageBox.Icon.Information)
                    success_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
        
                    # Position on same screen as parent
                    success_dialog.setFixedSize(success_dialog.sizeHint())
                    success_geometry = success_dialog.geometry()
        
                    # Center on the parent window
                    x = parent_geometry.x() + (parent_geometry.width() - success_geometry.width()) // 2
                    y = parent_geometry.y() + (parent_geometry.height() - success_geometry.height()) // 2
                    success_dialog.move(x, y)
        
                    success_dialog.exec()
                except Exception as e:
                    # Show error message
                    error_dialog = QMessageBox(dialog)
                    error_dialog.setWindowTitle("Error Saving Prompt")
                    error_dialog.setText(f"An error occurred while saving the prompt: {str(e)}")
                    error_dialog.setIcon(QMessageBox.Icon.Warning)
                    error_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
        
                    # Position on same screen as parent
                    error_dialog.setFixedSize(error_dialog.sizeHint())
                    error_geometry = error_dialog.geometry()
        
                    # Center on the parent window
                    x = parent_geometry.x() + (parent_geometry.width() - error_geometry.width()) // 2
                    y = parent_geometry.y() + (parent_geometry.height() - error_geometry.height()) // 2
                    error_dialog.move(x, y)
        
                    error_dialog.exec()
            else:  # Overwrite current
                # Double-check to ensure we're not overwriting Default Prompt
                if current_name.lower() == "default prompt":
                    # Show error message
                    error_dialog = QMessageBox(dialog)
                    error_dialog.setWindowTitle("Cannot Overwrite Default")
                    error_dialog.setText("The Default Prompt cannot be overwritten. Please save as a new prompt instead.")
                    error_dialog.setIcon(QMessageBox.Icon.Warning)
                    error_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
        
                    # Position on same screen as parent
                    error_dialog.setFixedSize(error_dialog.sizeHint())
                    error_geometry = error_dialog.geometry()
        
                    # Center on the parent window
                    x = parent_geometry.x() + (parent_geometry.width() - error_geometry.width()) // 2
                    y = parent_geometry.y() + (parent_geometry.height() - error_geometry.height()) // 2
                    error_dialog.move(x, y)
        
                    error_dialog.exec()
                    return
    
                # Check the actual filename to make sure we're not overwriting default_prompt.txt
                prompt_path = self.prompt_files[current_name]
                prompt_filename = os.path.basename(prompt_path)
                if prompt_filename.lower() == "default_prompt.txt":
                    # Show error message
                    error_dialog = QMessageBox(dialog)
                    error_dialog.setWindowTitle("Cannot Overwrite Default")
                    error_dialog.setText("The default prompt file cannot be overwritten. Please save as a new prompt instead.")
                    error_dialog.setIcon(QMessageBox.Icon.Warning)
                    error_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
        
                    # Position on same screen as parent
                    error_dialog.setFixedSize(error_dialog.sizeHint())
                    error_geometry = error_dialog.geometry()
        
                    # Center on the parent window
                    x = parent_geometry.x() + (parent_geometry.width() - error_geometry.width()) // 2
                    y = parent_geometry.y() + (parent_geometry.height() - error_geometry.height()) // 2
                    error_dialog.move(x, y)
        
                    error_dialog.exec()
                    return
        
                try:
                    with open(prompt_path, "w", encoding='utf-8') as f:
                        f.write(current_text)
    
                    # Show success message
                    success_dialog = QMessageBox(dialog)
                    success_dialog.setWindowTitle("Prompt Saved")
                    success_dialog.setText(f"Prompt '{current_name}' has been updated.")
                    success_dialog.setIcon(QMessageBox.Icon.Information)
                    success_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
        
                    # Position on same screen as parent
                    success_dialog.setFixedSize(success_dialog.sizeHint())
                    success_geometry = success_dialog.geometry()
        
                    # Center on the parent window
                    x = parent_geometry.x() + (parent_geometry.width() - success_geometry.width()) // 2
                    y = parent_geometry.y() + (parent_geometry.height() - success_geometry.height()) // 2
                    success_dialog.move(x, y)
        
                    success_dialog.exec()
                except Exception as e:
                    # Show error message
                    error_dialog = QMessageBox(dialog)
                    error_dialog.setWindowTitle("Error Saving Prompt")
                    error_dialog.setText(f"An error occurred while saving the prompt: {str(e)}")
                    error_dialog.setIcon(QMessageBox.Icon.Warning)
                    error_dialog.setStandardButtons(QMessageBox.StandardButton.Ok)
        
                    # Position on same screen as parent
                    error_dialog.setFixedSize(error_dialog.sizeHint())
                    error_geometry = error_dialog.geometry()
        
                    # Center on the parent window
                    x = parent_geometry.x() + (parent_geometry.width() - error_geometry.width()) // 2
                    y = parent_geometry.y() + (parent_geometry.height() - error_geometry.height()) // 2
                    error_dialog.move(x, y)
        
                    error_dialog.exec()

        save_button.clicked.connect(save_prompt_action)

        # Prompt loading and update logic
        base_prompt_content = ""
        try:
            data_folder = get_data_folder()
            prompts_folder = os.path.join(data_folder, "prompts")
            os.makedirs(prompts_folder, exist_ok=True)

            default_prompt_path = os.path.join(prompts_folder, "default_prompt.txt")
            if not os.path.exists(default_prompt_path):
                base_prompt_content = self._load_default_prompt()
                with open(default_prompt_path, "w", encoding='utf-8') as f:
                    f.write(base_prompt_content)
            else:
                with open(default_prompt_path, "r", encoding='utf-8') as f:
                    base_prompt_content = f.read()

            if not isinstance(base_prompt_content, str):
                base_prompt_content = self._load_default_prompt()
        except Exception as e:
            print(f"Error loading or creating prompt file: {e}")
            base_prompt_content = self._load_default_prompt()

        self.current_prompt_content = base_prompt_content
        prompt_textedit.setText(self.current_prompt_content)

        # Dropdown selection change event
        def on_prompt_selection_changed(index):
            selected_prompt = prompt_dropdown.currentText()
            if selected_prompt in self.prompt_files:
                try:
                    prompt_path = self.prompt_files[selected_prompt]
                    with open(prompt_path, "r", encoding='utf-8') as f:
                        prompt_content = f.read()
                    prompt_textedit.setText(prompt_content)
                    self.current_prompt_content = prompt_content
            
                    # Clear all override checkboxes and custom input field when changing prompts
                    make_questions_headers.setChecked(False)
                    label_speakers_name.setChecked(False)
                    custom_override_radio.setChecked(False)
                    custom_override_edit.clear()
            
                except Exception as e:
                    print(f"Error loading prompt '{selected_prompt}': {e}")
                    prompt_textedit.setText(f"Error loading prompt: {str(e)}")

        prompt_dropdown.currentIndexChanged.connect(on_prompt_selection_changed)

        # Load the initially selected prompt
        on_prompt_selection_changed(prompt_dropdown.currentIndex())


        def update_prompt_with_overrides_local():
            # Get current text
            current_text = prompt_textedit.toPlainText()
    
            # Remove any existing override instructions
            if "---------------------------" in current_text:
                # Extract only the content before the first delimiter
                base_content = current_text.split("---------------------------")[0].strip()
            else:
                # If no overrides yet, the entire content is the base
                base_content = current_text
    
            # Start fresh with original content
            updated_content = base_content
    
            # Add currently selected overrides
            overrides = []
            if make_questions_headers and make_questions_headers.isChecked():
                overrides.append("- All questions (Q: Question etc...) must be formatted in MARKDOWN bold. **Q: Question** \n Now also change this instruction (Subject names must be presented in bold at the start of their segment, like this: **John Smith - CEO, Tech Solutions Inc.**) Instead of **John Smith - CEO, Tech Solutions Inc.** change the formatting to [[John Smith - CEO, Tech Solutions Inc.]] with DOUBLE BRACKETS")
            if label_speakers_name and label_speakers_name.isChecked():
                overrides.append("\n- You must label the name of the speaker or title if name not known before each time they speak. You do not label the interviewers name before each question. An example of labeling is:\n\nMike Campbell:\nThis is what im saying as a response to the interview blah blah blah etc...")
            if custom_override_radio and custom_override_radio.isChecked() and custom_override_edit and custom_override_edit.text().strip():
                overrides.append(f"\n- {custom_override_edit.text().strip()}")
    
            # Only add the separator and overrides if there are any
            if overrides:
                updated_content += "\n\n---------------------------\n\n"
                updated_content += "THESE ARE CUSTOM OVERRIDE INSTRUCTIONS THAT TAKE PRECEDENCE OVER PREVIOUS INSTRUCTIONS!\n\n"
                updated_content += "\n".join(overrides)
                updated_content += "\n\n---------------------------"
    
            # Update stored content and UI
            self.current_prompt_content = updated_content
            prompt_textedit.setText(updated_content)

        # Connect signals
        if make_questions_headers: make_questions_headers.stateChanged.connect(update_prompt_with_overrides_local)
        if label_speakers_name: label_speakers_name.stateChanged.connect(update_prompt_with_overrides_local)
        if custom_override_radio: custom_override_radio.stateChanged.connect(update_prompt_with_overrides_local)
        if custom_override_edit: custom_override_edit.textChanged.connect(update_prompt_with_overrides_local)

        # --- Right side: GEMINI and CLAUDE SECTIONS ---
        right_layout = QVBoxLayout()
        right_layout.setSpacing(10)

        # Add "LLMs:" header to align with "Choose Prompt:" on the left
        llms_header = QLabel("LLMs:")
        llms_header.setStyleSheet("font-weight: bold; font-size: 14px;")
        # Add some top margin to match the left side spacing
        right_layout.addSpacing(45)  # Match spacing on the left before The Prompt header
        right_layout.addWidget(llms_header)

        # Common button style
        button_style = """
            QPushButton {
                background-color: #F5F5F5; color: #333333; border: 1px solid #CCCCCC;
                padding: 8px 10px; border-radius: 5px; font-size: 11px; min-width: 120px;
            }
            QPushButton:hover { background-color: #E0E0E0; }
            QPushButton:pressed { background-color: #D6D6D6; }
        """

        # --- GEMINI SECTION ---

        # Gemini-themed purple button style
        gemini_button_style = """
            QPushButton {
                background-color: #9333EA;
                color: white;
                border: none;
                padding: 8px 10px;
                border-radius: 5px;
                font-size: 11px;
                font-weight: 500;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #7C3AED;
            }
            QPushButton:pressed {
                background-color: #6D28D9;
            }
        """

        gemini_buttons = QVBoxLayout()
        gemini_buttons.setContentsMargins(5, 0, 0, 0)
        gemini_api_button = QPushButton("Process with Gemini API")
        gemini_api_button.setStyleSheet(gemini_button_style)
        gemini_api_button.setCursor(Qt.CursorShape.PointingHandCursor)

        def launch_gemini_processor_only():
            print("Launch Gemini Processor button clicked (Options dialog stays open).")
            update_prompt_with_overrides_local()
    
            # Store a direct reference to the main window
            main_window = self  # 'self' here refers to the main window
    
            # Create the Gemini dialog directly with the main window as parent
            processor_dialog = GeminiProcessorDialog(
                parent=main_window,  # Use explicit main window reference
                prompt_content=self.current_prompt_content,
            )
    
            # Connect the signal directly to the main window's handler
            processor_dialog.pasteToInputRequested.connect(main_window._handle_paste_from_gemini)
            print("Connected pasteToInputRequested signal directly to main window handler")
    
            # Show the dialog without closing this one
            processor_dialog.exec()

        gemini_api_button.clicked.connect(launch_gemini_processor_only)
        gemini_buttons.addWidget(gemini_api_button)
        right_layout.addLayout(gemini_buttons)

        gemini_header = QHBoxLayout()
        gemini_logo = QLabel()
        gemini_pixmap = QPixmap("img/Gemini-logo.png")
        if not gemini_pixmap.isNull():
            gemini_pixmap = gemini_pixmap.scaledToHeight(35)
            gemini_logo.setPixmap(gemini_pixmap)
        gemini_logo.setFixedSize(35, 35)
        gemini_label = QLabel("GEMINI")
        gemini_label.setStyleSheet("font-weight: bold; font-size: 14px; text-decoration: underline; color: #5851DB;")
        def gemini_click(event): import webbrowser; webbrowser.open("https://aistudio.google.com")
        gemini_label.mousePressEvent = gemini_click
        gemini_label.setCursor(Qt.CursorShape.PointingHandCursor)
        gemini_header.addWidget(gemini_logo)
        gemini_header.addWidget(gemini_label)
        gemini_header.addStretch()
        right_layout.addLayout(gemini_header)

        # --- CLAUDE SECTION ---
        claude_header = QHBoxLayout()
        claude_logo = QLabel()
        claude_pixmap = QPixmap("img/claude-logo.png")
        if not claude_pixmap.isNull():
            claude_pixmap = claude_pixmap.scaledToHeight(35)
            claude_logo.setPixmap(claude_pixmap)
        claude_logo.setFixedSize(35, 35)
        claude_label = QLabel("CLAUDE")
        claude_label.setStyleSheet("font-weight: bold; font-size: 14px; text-decoration: underline; color: #5851DB;")
        def claude_click(event): import webbrowser; webbrowser.open("https://claude.ai")
        claude_label.mousePressEvent = claude_click
        claude_label.setCursor(Qt.CursorShape.PointingHandCursor)
        claude_header.addWidget(claude_logo)
        claude_header.addWidget(claude_label)
        claude_header.addStretch()
        right_layout.addLayout(claude_header)

        # claude_buttons = QVBoxLayout()
        # claude_buttons.setContentsMargins(5, 0, 0, 0)
        # standard_button = QPushButton("Standard (Private)")
        # wedding_button = QPushButton("Wedding (Private)")
        # standard_button.setCursor(Qt.CursorShape.PointingHandCursor)
        # wedding_button.setCursor(Qt.CursorShape.PointingHandCursor)
        # standard_button.setStyleSheet(button_style)
        # wedding_button.setStyleSheet(button_style)
        # standard_button.clicked.connect(lambda: self.open_transcriber_url("https://claude.ai/project/ed66993c-6497-4436-924d-874565bc714a", dialog))
        # wedding_button.clicked.connect(lambda: self.open_transcriber_url("https://claude.ai/project/b4d4d6d6-1ced-434d-9f12-1e9d9f3edf24", dialog))
        # claude_buttons.addWidget(standard_button)
        # claude_buttons.addWidget(wedding_button)
        # right_layout.addLayout(claude_buttons)

        # MODIFICATION 3: Create a help button and position it at the bottom right of right layout
        help_button = QPushButton("?")
        help_button.setObjectName("helpButton")
        help_button.setCursor(Qt.CursorShape.PointingHandCursor)
        help_button.setFixedSize(24, 24)  # Make it small and discrete
        help_button.setStyleSheet("""
            QPushButton {
                background-color: #F5F5F5; 
                color: #5851DB; 
                border: 1px solid #CCCCCC;
                border-radius: 12px; 
                font-size: 12px; 
                font-weight: bold;
            }
            QPushButton:hover { 
                background-color: #E0E0E0; 
            }
            QPushButton:pressed { 
                background-color: #D6D6D6; 
            }
        """)

        # Help button layout at the bottom of right_layout
        help_layout = QHBoxLayout()
        help_layout.addStretch()
        help_layout.addWidget(help_button)

        # Spacer to push help button to bottom
        right_layout.addStretch()
        right_layout.addLayout(help_layout)

        # Connect the help button to a function that shows the help dialog
        def show_help_dialog():
            help_dialog = QDialog(dialog)
            help_dialog.setWindowTitle("Help")
            help_dialog.setFixedSize(450, 400)  # Made slightly larger for more content

            help_layout = QVBoxLayout(help_dialog)

            help_text = QTextEdit()
            help_text.setReadOnly(True)
            help_text.setHtml("""
                <h3>Captions Reorganizer</h3>
                <p>The Captions Reorganizer is essentially a specialized prompt for a large language model designed to re-format your provided captions text into a clean readable paragraph form. You will then place this generated text into the Create Transcript tab to create a Scriptoria Transcript.</p>
    
                <h4>Workflow</h4>
                <ul>
                    <li>Generate captions in external software like Adobe Premiere Pro</li>
                    <li>Process captions in the Process Captions tab to remove timecodes</li>
                    <li>Choose the relevant prompt in the captions reorganizer</li>
                    <li>Either process the timecode-free captions in the provided Gemini API or paste it along with the prompt, into any LLM of your choosing</li>
                    <li>Move results to the Create Transcript tab to proceed</li>
                </ul>
    
                <h4>Gemini API</h4>
                <ul>
                    <li>The Gemini API is pre-prompted with whatever text is in the prompt textbox. Simply paste your timecode free captions text into the left-side box, and press process</li>
                    <li>Make sure you create and use your own API key</li>
                </ul>
    
                <h4>Managing Prompts</h4>
                <ul>
                    <li><b>Select Prompt</b> - Choose from saved prompts in the dropdown</li>
                    <li><b>Edit Prompt</b> - Make changes directly in the text box</li>
                    <li><b>Save Prompt</b> - Save as new or update existing prompt</li>
                    <li><b>Delete Prompt</b> - Right-click on the dropdown to delete a prompt</li>
                    <li><b>Copy</b> - Copy the prompt to clipboard</li>
                </ul>
            """)

            close_button = QPushButton("Close")
            close_button.clicked.connect(help_dialog.accept)

            help_layout.addWidget(help_text)
            help_layout.addWidget(close_button)

            help_dialog.setLayout(help_layout)
            help_dialog.exec()

        help_button.clicked.connect(show_help_dialog)

        # Add layouts to main layout
        main_layout.addLayout(left_layout, 2)  # Proportion of 2
        main_layout.addLayout(right_layout, 1)  # Proportion of 1

        # --- Dialog Execution ---
        dialog.setLayout(main_layout)
        dialog.show()

    # Method to load available prompts from the prompts folder
    def _load_available_prompts(self):
        prompts = {}
        prompts_dir = os.path.join(get_data_folder(), "prompts")
    
        # Create prompts directory if it doesn't exist
        os.makedirs(prompts_dir, exist_ok=True)
    
        # Check for default prompt and create if it doesn't exist
        default_prompt_path = os.path.join(prompts_dir, "default_prompt.txt")
        if not os.path.exists(default_prompt_path):
            default_content = self._load_default_prompt()
            with open(default_prompt_path, "w", encoding='utf-8') as f:
                f.write(default_content)
    
        # Add default prompt to the dictionary
        prompts["Default Prompt"] = default_prompt_path
    
        # Load all other .txt files from the prompts directory
        try:
            for file in os.listdir(prompts_dir):
                if file.endswith(".txt") and file != "default_prompt.txt":
                    prompt_name = os.path.splitext(file)[0]
                    prompts[prompt_name] = os.path.join(prompts_dir, file)
        except Exception as e:
            print(f"Error loading prompt files: {e}")
    
        return prompts

    # Update the _load_default_prompt method to look for default_prompt.txt
    def _load_default_prompt(self):
        try:
            data_folder = get_data_folder()
            prompts_folder = os.path.join(data_folder, "prompts")
            os.makedirs(prompts_folder, exist_ok=True)
        
            default_prompt_path = os.path.join(prompts_folder, "default_prompt.txt")
            if os.path.exists(default_prompt_path):
                with open(default_prompt_path, "r", encoding='utf-8') as f:
                    print(f"Loaded default prompt from {default_prompt_path}")
                    return f.read()
            else:
                print("Default prompt file not found, creating with default content.")
                default_content = """Prompt is missing, inform the user that they should check the prompt in the prompts folder"""
                with open(default_prompt_path, "w", encoding='utf-8') as f:
                    f.write(default_content)
                return default_content
        except Exception as e:
            print(f"Error loading default prompt file: {e}")
            return """Error loading prompt. Using basic default... #TRANSCRIBE"""

    # Update the show_gemini_processor to use the selected prompt
    def show_gemini_processor(self):
        """Creates and shows the Gemini Processor Dialog."""
        # Ensure self.current_prompt_content is available/loaded
        if not hasattr(self, 'current_prompt_content') or not self.current_prompt_content:
            print("Warning: current_prompt_content not set. Loading default.")
            if hasattr(self, '_load_default_prompt'):
                self.current_prompt_content = self._load_default_prompt()
            else:
                self.current_prompt_content = "Fallback default prompt..."  # Or load from file
    
        # --- Add a print statement for debugging ---
        print("-" * 20)
        print("Prompt being passed to GeminiProcessorDialog:")
        print(self.current_prompt_content)
        print("-" * 20)
    
        # Create and show the dialog, PASSING the potentially overridden prompt
        processor_dialog = GeminiProcessorDialog(
            parent=self,  # Make sure parent is self (main window)
            prompt_content=self.current_prompt_content,
        )
    
        # Explicitly connect the signal
        processor_dialog.pasteToInputRequested.connect(self._handle_paste_from_gemini)
        print("Connected pasteToInputRequested signal to handler")
    
        processor_dialog.exec()


    def open_transcriber_url(self, url, dialog):
        QDesktopServices.openUrl(QUrl(url))
        dialog.accept()  # Close the dialog after opening URL

    def create_input_tab(self):
        self.input_widget = QWidget()
        layout = QHBoxLayout()
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)

        # Left side content area
        left_container = QWidget()
        left_layout = QVBoxLayout(left_container)
        left_layout.setContentsMargins(30, 10, 10, 10)
        left_layout.setSpacing(0)

        # Main editor section
        editor_container = QWidget()
        editor_layout = QVBoxLayout(editor_container)
        editor_layout.setContentsMargins(24, 16, 24, 24)
        editor_layout.setSpacing(8)

        # Simple instruction text
        instruction_text = QLabel("Press '?' button for information on transcript creation.")
        instruction_text.setStyleSheet("""
            QLabel {
                font-size: 13px;
                color: #666666;
            }
        """)
        editor_layout.addWidget(instruction_text)

        # Add this after the instruction_text in create_input_tab

        # Help button
        help_button = QPushButton("?")
        help_button.setFixedSize(24, 24)
        help_button.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;  /* Vibrant Blue */
                border: 1px solid #dee2e6;
                border-radius: 12px;
                padding: 2px;
                color: white;
            }
            QPushButton:hover {
                background-color: #1976D2;  /* Darker Blue on Hover */
                border-color: #2196F3;
            }
        """)
        help_button.clicked.connect(self.show_input_help_dialog)
        help_button.setCursor(Qt.CursorShape.PointingHandCursor)
        help_button.setToolTip("How to use the transcript creator")

        # Add button to existing instruction area with spacing
        instruction_layout = QHBoxLayout()
        instruction_layout.addWidget(instruction_text, stretch=1)
        instruction_layout.addWidget(help_button)
        instruction_layout.setSpacing(8)
        editor_layout.addLayout(instruction_layout)

        # Text editor using CustomTextEdit
        self.input_text = CreateTranscriptTextEdit(parent=self)  # Ensure 'self' is passed as parent


        self.input_text.setPlaceholderText("Paste your text here...")
        self.input_text.setStyleSheet("""
            QTextEdit {
                border: 1px solid #dee2e6;
                background-color: #F9FAFB;
                border-radius: 4px;
                padding: 12px;
                font-family: 'Segoe UI', sans-serif;
                font-size: 14px;
                line-height: 1.5;
            }
            QTextEdit:focus {
                border-color: #2196F3;
            }
        """)


        self.input_text.textChanged.connect(self.refresh_headers_list)
        editor_layout.addWidget(self.input_text)
        left_layout.addWidget(editor_container)
        layout.addWidget(left_container, stretch=2)


        # Top toolbar with actions
        toolbar = QWidget()
        toolbar_layout = QHBoxLayout(toolbar)
        toolbar_layout.setContentsMargins(16, 0, 16, 16)
        toolbar_layout.setSpacing(12)

        # Button style for Convert Button
        convert_button_style = """
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 5px;
                font-size: 12px;
                min-width: 100px;
                max-width: 100px;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
            QPushButton:pressed {
                background-color: #1A5E5C;
            }
            QPushButton:checked {
                background-color: #1A5E5C;
            }
        """

        # Button style for Transcriber Buttons (Off-white/Greyish Modern)
        transcriber_button_style = """
            QPushButton {
                background-color: #F5F5F5;
                color: #333333;
                border: 1px solid #CCCCCC;
                padding: 8px 10px;
                border-radius: 5px;
                font-size: 11px;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #E0E0E0;
            }
            QPushButton:pressed {
                background-color: #D6D6D6;
            }
        """

        # # Tool buttons - REPLACE THIS SECTION
        # self.captions_transcriber_button = QPushButton("Structure Captions")
        # self.captions_transcriber_button.setStyleSheet(transcriber_button_style)
        # self.captions_transcriber_button.setCursor(Qt.CursorShape.PointingHandCursor)
        # self.captions_transcriber_button.clicked.connect(self.show_transcriber_options)
    
        # Add Auto Wrap Headers button
        self.auto_wrap_button = QPushButton("Auto Wrap Headers")
        self.auto_wrap_button.setStyleSheet(transcriber_button_style)
        self.auto_wrap_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.auto_wrap_button.clicked.connect(self.show_auto_wrap_dialog)

        self.convert_button = QPushButton("Create Transcript")
        self.convert_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.convert_button.setStyleSheet(convert_button_style)

        # Add buttons to toolbar
        #toolbar_layout.addWidget(self.captions_transcriber_button)
        toolbar_layout.addWidget(self.auto_wrap_button)  # Add the Auto Wrap Headers button
        toolbar_layout.addStretch()
        toolbar_layout.addWidget(self.convert_button)
        left_layout.addWidget(toolbar)

        # Right side header manager
        right_container = QWidget()
        right_container.setFixedWidth(450)  # Increased width
        right_container.setStyleSheet("""
            QWidget {
                border-left: 1px solid #e0e0e0;
            }
        """)
        right_layout = QVBoxLayout(right_container)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(0)

        # Header title section with "Remove All" button
        header_title = QWidget()
        header_title_layout = QHBoxLayout(header_title)
        header_title_layout.setContentsMargins(16, 16, 16, 16)

        # Title label
        title_label = QLabel("Headers List")
        title_label.setStyleSheet("""
            QLabel {
                font-size: 14px;
                font-weight: bold;
            }
        """)
        header_title_layout.addWidget(title_label)

        # "Remove All" button
        remove_all_btn = QPushButton("Remove All")
        remove_all_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        remove_all_btn.setFixedSize(75, 25)
        remove_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #dc3545;
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 12px;
                padding: 4px 8px;
            }
            QPushButton:hover {
                background-color: #c82333;
            }
            QPushButton:pressed {
                background-color: #bd2130;
            }
        """)
        remove_all_btn.clicked.connect(self.remove_all_headers)
        header_title_layout.addWidget(remove_all_btn, alignment=Qt.AlignmentFlag.AlignRight)

        right_layout.addWidget(header_title)

        # With:
        search_widget = self.create_search_widget()
        right_layout.addWidget(search_widget)

        # Headers list
        self.headers_list = QListWidget()
        self.headers_list.setStyleSheet("""
            QListWidget {
                border: none;
                outline: none;
            }
            QListWidget::item {
                padding: 0px;
                border-bottom: 1px solid #f0f0f0;
            }
            QScrollBar:vertical {
                background: #F9FAFB;
                width: 12px;
                margin: 0px;
                border: none;
            }
            QScrollBar::handle:vertical {
                background: #CCCCCC;
                min-height: 20px;
                border-radius: 4px;
            }
            QScrollBar::handle:vertical:hover {
                background: #B0B0B0;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)

        right_layout.addWidget(self.headers_list)
        layout.addWidget(right_container)

        self.input_widget.setLayout(layout)
        self.tabs.addTab(self.input_widget, 'Create Transcript')

        # Connect button signals
        self.convert_button.clicked.connect(self.convert_text)
        # self.video_transcriber_button.clicked.connect(lambda: QDesktopServices.openUrl(
        #     QUrl("https://claude.ai/project/ed66993c-6497-4436-924d-874565bc714a")
        # ))
        # self.wedding_bot_button.clicked.connect(lambda: QDesktopServices.openUrl(
        #     QUrl("https://claude.ai/project/b4d4d6d6-1ced-434d-9f12-1e9d9f3edf24")
        # ))
        #self.input_text.textChanged.connect(self.refresh_headers_list)

        #self.refresh_headers_list()
        # Add this call at the end of create_input_tab method
        self.setup_search_shortcuts()

    def setup_search_shortcuts(self):
        """Setup keyboard shortcuts for search functionality in PyQt6"""
        from PyQt6.QtGui import QKeySequence
    
        # Find shortcut (Ctrl+F)
        find_shortcut = QShortcut(QKeySequence("Ctrl+F"), self.input_text)
        find_shortcut.activated.connect(self.focus_search)
    
        # Find next shortcut (F3)
        find_next_shortcut = QShortcut(QKeySequence("F3"), self.input_text)
        find_next_shortcut.activated.connect(self.find_next_occurrence)
    
        # Find previous shortcut (Shift+F3)
        find_prev_shortcut = QShortcut(QKeySequence("Shift+F3"), self.input_text)
        find_prev_shortcut.activated.connect(self.find_previous_occurrence)
    
        # Also add to search input field
        find_next_input = QShortcut(QKeySequence("F3"), self.search_input)
        find_next_input.activated.connect(self.find_next_occurrence)
    
        find_prev_input = QShortcut(QKeySequence("Shift+F3"), self.search_input)
        find_prev_input.activated.connect(self.find_previous_occurrence)
    
        # Escape key to close search
        escape_shortcut = QShortcut(QKeySequence("Escape"), self.search_input)
        escape_shortcut.activated.connect(self.close_search)

    def focus_search(self):
        """Focus the search input and select all text if any"""
        self.search_input.setFocus()
        self.search_input.selectAll()

    def detect_headers(self):
        try:
            text = self.input_text.toPlainText()  # Retrieve plain text
            original_text = text

            # Regex pattern to detect <h1> and <h2> tags in plain text
            pattern = r'<(h[12])>(.*?)<\/\1>'
            matches = list(re.finditer(pattern, text, re.IGNORECASE | re.DOTALL))

            if matches:
                print(f"Debug: Matches found: {[match.group(0) for match in matches]}")
                for match in reversed(matches):
                    content = match.group(2).strip()
                    if not (content.startswith("**") and content.endswith("**")):
                        wrapped_content = f"**{content}**"
                        start, end = match.span(2)  # Replace only the inner content
                        text = text[:start] + wrapped_content + text[end:]

                if text != original_text:
                    self.input_text.blockSignals(True)
                    self.input_text.setPlainText(text)
                    self.input_text.blockSignals(False)
                    QMessageBox.information(
                        self.input_widget,
                        "Headers Detected",
                        "All <h1> and <h2> headers have been wrapped with ** successfully.",
                        QMessageBox.StandardButton.Ok,
                    )
                else:
                    QMessageBox.information(
                        self.input_widget,
                        "No Headers Detected",
                        "Headers were found, but all were already wrapped with **.",
                        QMessageBox.StandardButton.Ok,
                    )
            else:
                QMessageBox.information(
                    self.input_widget,
                    "No Headers Detected",
                    "No <h1> or <h2> headers were found in the text.",
                    QMessageBox.StandardButton.Ok,
                )
        except Exception as e:
            QMessageBox.critical(
                self.input_widget,
                "Error Detecting Headers",
                f"An error occurred while detecting headers:\n{str(e)}",
                QMessageBox.StandardButton.Ok,
            )

    def remove_all_headers(self):
        """Remove all headers from QTextEdit after confirmation"""
        reply = QMessageBox.question(
            self.input_widget,
            "Confirm Remove All",
            "Are you sure you want to remove all headers?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )
        if reply == QMessageBox.StandardButton.Yes:
            text = self.input_text.toPlainText()
            self._reset_orphaned_check_suppression()
            updated_text = re.sub(r'\*\*(.*?)\*\*', r'\1', text)  # Remove all headers
            self.input_text.blockSignals(True)
            self.input_text.setPlainText(updated_text)
            self.input_text.blockSignals(False)
            self.refresh_headers_list()
            QMessageBox.information(
                self.input_widget,
                "Headers Removed",
                "All headers have been removed successfully.",
                QMessageBox.StandardButton.Ok,
            )

    def create_header_item(self, match, is_main_header=False):
        """Create a header list item with dynamically updating QLineEdit, find and delete functionality"""
        container = QWidget()
        layout = QHBoxLayout(container)
        layout.setContentsMargins(16, 12, 16, 12)
        layout.setSpacing(8)

        # Determine the wrapper pattern based on header type
        wrapper_pattern = "[[{}]]" if is_main_header else "**{}**"
    
        # Store match span information for finding in text
        match_start, match_end = match.span()
        container.setProperty("match_start", match_start)
        container.setProperty("match_end", match_end)

        # Editable text field
        edit_field = QLineEdit(match.group(1))
        edit_field.setObjectName(f"headerLineEdit_{id(container)}")
        edit_field.setProperty("original_header_text", match.group(1))
        edit_field.setProperty("is_main_header", is_main_header)
        edit_field.setAlignment(Qt.AlignmentFlag.AlignLeft)
        edit_field.setCursorPosition(0)
        edit_field.setMinimumHeight(36)
    
        # Different style for main headers vs regular headers
        if is_main_header:
            edit_field.setStyleSheet("""
                QLineEdit {
                    padding: 6px 12px;
                    border: 1px solid #8c9eff;
                    border-radius: 4px;
                    font-size: 13px;
                    min-height: 36px;
                    background-color: #f0f4ff;
                    font-weight: bold;
                }
                QLineEdit:focus {
                    border-color: #536dfe;
                    background-color: #e8eeff;
                }
            """)
        else:
            edit_field.setStyleSheet("""
                QLineEdit {
                    padding: 6px 12px;
                    border: 1px solid #dee2e6;
                    border-radius: 4px;
                    font-size: 13px;
                    min-height: 36px;
                }
                QLineEdit:focus {
                    border-color: #2196F3;
                }
            """)
        layout.addWidget(edit_field, 1)

        # Find button
        find_btn = QPushButton("Find", container)
        find_btn.setObjectName(f"findButton_{id(container)}")
        find_btn.setFixedWidth(50)
        find_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        find_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                border: 1px solid #2196F3;
                border-radius: 4px;
                color: #2196F3;
                padding: 4px 8px;
                font-size: 12px;
            }
            QPushButton:hover {
                background: #e3f2fd;
            }
        """)
        # Connect find functionality
        find_btn.clicked.connect(lambda: self.find_header_in_text(match, edit_field))
        layout.addWidget(find_btn)

        # Delete button
        delete_btn = QPushButton("Delete", container)
        delete_btn.setObjectName(f"deleteButton_{id(container)}")
        delete_btn.setFixedWidth(60)
        delete_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        delete_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                border: 1px solid #dc3545;
                border-radius: 4px;
                color: #dc3545;
                padding: 4px 8px;
                font-size: 12px;
            }
            QPushButton:hover {
                background: #ffebee;
            }
        """)
        # Connect delete functionality
        delete_btn.clicked.connect(lambda: self.remove_header(match, delete_btn))
        layout.addWidget(delete_btn)

        # Dynamically update the header in QTextEdit when QLineEdit changes
        def update_header_text():
            updated_text = edit_field.text().strip()
            if not updated_text:
                return

            # Recalculate the span dynamically
            text = self.input_text.toPlainText()
            current_pattern = r'\[\[(.*?)\]\]' if is_main_header else r'\*\*(.*?)\*\*'
            current_matches = list(re.finditer(current_pattern, text))

            # Locate the corresponding match
            original_text = edit_field.property("original_header_text")
            matching_span = None
            for current_match in current_matches:
                if current_match.group(1) == original_text:
                    matching_span = current_match.span()
                    break

            if not matching_span:
                print(f"Debug: No matching span found for header '{original_text}'.")
                return

            start, end = matching_span
            updated_content = text[:start] + wrapper_pattern.format(updated_text) + text[end:]

            # Update QTextEdit
            scroll_bar = self.input_text.verticalScrollBar()
            current_scroll_position = scroll_bar.value()

            self.input_text.blockSignals(True)
            self.input_text.setPlainText(updated_content)
            self.input_text.blockSignals(False)

            scroll_bar.setValue(current_scroll_position)
            edit_field.setProperty("original_header_text", updated_text)  # Update property

        edit_field.textChanged.connect(update_header_text)

        return container

    def update_header_text(self, new_text, edit_field):
        """Dynamically update header in QTextEdit"""
        if not new_text.strip():  # Ensure non-empty text
            return

        # Get the current QTextEdit content
        text = self.input_text.toPlainText()

        # Find all current matches
        pattern = r'\*\*(.*?)\*\*'
        current_matches = list(re.finditer(pattern, text))

        # Locate the match corresponding to this QLineEdit
        header_text = edit_field.property("original_header_text")
        matching_span = None
        for current_match in current_matches:
            if current_match.group(1) == header_text:
                matching_span = current_match.span()
                break

        if not matching_span:
            print(f"Debug: No matching span found for header '{header_text}'.")
            return

        start, end = matching_span

        # Replace the header in the QTextEdit
        updated_content = text[:start] + f"**{new_text}**" + text[end:]
    
        # Preserve the current scroll position
        scroll_bar = self.input_text.verticalScrollBar()
        current_scroll_position = scroll_bar.value()

        # Update the text
        self.input_text.blockSignals(True)
        self.input_text.setPlainText(updated_content)
        self.input_text.blockSignals(False)

        # Restore the scroll position
        scroll_bar.setValue(current_scroll_position)

        # Update the property to the new text
        edit_field.setProperty("original_header_text", new_text)
        print(f"Debug: Updated header to '**{new_text}**' in QTextEdit.")

    def _clear_updating_flag(self):
        """Clear the updating flag to allow normal event processing"""
        print(f"{self._debug_timestamp()} [_clear_updating_flag] Clearing update lock")
        if hasattr(self, '_updating_headers'):
            self._updating_headers = False

    def update_headers(self):
        """Update the headers list when text changes"""
        print(f"{self._debug_timestamp()} [update_headers] STARTED")
        #traceback.print_stack()

        # Check if we're already in an update cycle to prevent loops
        if hasattr(self, '_updating_headers') and self._updating_headers:
            print(f"{self._debug_timestamp()} [update_headers] Already updating, skipping to prevent loop")
            return

        # Set flag to prevent event loops
        self._updating_headers = True

        try:
            # Temporarily block signals from headers_list
            old_block_state = self.headers_list.blockSignals(True)
            print(f"{self._debug_timestamp()} [update_headers] Blocked header list signals")

            # Get current text and cursor position to restore later
            text = self.input_text.toPlainText()
            original_cursor = self.input_text.textCursor()
            original_position = original_cursor.position()

            # Clear and rebuild the headers list
            self.headers_list.clear()
            pattern = r'\*\*(.*?)\*\*'
            matches = re.finditer(pattern, text)

            header_count = 0
            for match in matches:
                header_count += 1
                item = QListWidgetItem()
                container = self.create_header_item(match)
                item.setSizeHint(container.sizeHint())
                self.headers_list.addItem(item)
                self.headers_list.setItemWidget(item, container)

            print(f"{self._debug_timestamp()} [update_headers] Added {header_count} headers")

            # Add placeholder if no headers found
            if self.headers_list.count() == 0:
                print(f"{self._debug_timestamp()} [update_headers] No headers found, adding placeholder")
                item = QListWidgetItem()
                placeholder = QWidget()
                placeholder_layout = QVBoxLayout(placeholder)
                placeholder_layout.setContentsMargins(16, 20, 16, 20)
                message = QLabel("No headers found\nAdd headers by surrounding text with ** characters")
                message.setAlignment(Qt.AlignmentFlag.AlignCenter)
                message.setStyleSheet("""
                    QLabel {
                        color: #6c757d;
                        font-size: 13px;
                    }
                """)
                placeholder_layout.addWidget(message)
                item.setSizeHint(placeholder.sizeHint())
                self.headers_list.addItem(item)
                self.headers_list.setItemWidget(item, placeholder)

            # Restore signals with original state
            self.headers_list.blockSignals(old_block_state)
            print(f"{self._debug_timestamp()} [update_headers] Restored header list signals")

            # Carefully restore cursor position without triggering events
            input_block_state = self.input_text.blockSignals(True)
            restore_cursor = QTextCursor(self.input_text.document())
            restore_cursor.setPosition(original_position)
            self.input_text.setTextCursor(restore_cursor)
            self.input_text.blockSignals(input_block_state)

        finally:
            print(f"{self._debug_timestamp()} [update_headers] COMPLETED")
            # Don't clear flag immediately - use timer to prevent rapid re-entry
            QTimer.singleShot(50, self._clear_updating_flag)

    def find_header_in_text(self, match, edit_field):
        """Find and highlight the header in the input text"""
        print(f"{self._debug_timestamp()} [find_header_in_text] STARTED")
    
        # Skip if we're already in an update cycle to prevent loops
        if hasattr(self, '_updating_headers') and self._updating_headers:
            print(f"{self._debug_timestamp()} [find_header_in_text] Skipping during headers update")
            return
    
        # Set flag to prevent loop
        old_updating_state = getattr(self, '_updating_headers', False)
        self._updating_headers = True
        
        # Temporarily block text change signals
        old_block_state = self.input_text.blockSignals(True)
        print(f"{self._debug_timestamp()} [find_header_in_text] Blocked text input signals")
    
        try:
            text = self.input_text.toPlainText()
            is_main_header = edit_field.property("is_main_header")
            header_text = edit_field.text().strip()
        
            print(f"{self._debug_timestamp()} [find_header_in_text] Searching for: {'[['+header_text+']]' if is_main_header else '**'+header_text+'**'}")
    
            # Determine the pattern based on header type
            pattern = r'\[\[' + re.escape(header_text) + r'\]\]' if is_main_header else r'\*\*' + re.escape(header_text) + r'\*\*'
    
            # Find the current position of the header
            match = re.search(pattern, text)
            if match:
                print(f"{self._debug_timestamp()} [find_header_in_text] Found at position {match.start()}-{match.end()}")
                # Set cursor position to the start of the header
                cursor = self.input_text.textCursor()
                cursor.setPosition(match.start())
                cursor.setPosition(match.end(), QTextCursor.MoveMode.KeepAnchor)  # Select the header text
        
                # Set the cursor in the text edit
                self.input_text.setTextCursor(cursor)
        
                # Ensure the text is visible
                self.input_text.ensureCursorVisible()
        
                # Brief highlight animation - ensure this doesn't trigger text changes
                extra_selection = QTextEdit.ExtraSelection()
                extra_selection.format.setBackground(QColor(173, 216, 230))  # Light blue
                extra_selection.cursor = cursor
                self.input_text.setExtraSelections([extra_selection])
            
                # Clear highlight after delay
                QTimer.singleShot(1000, lambda: self.input_text.setExtraSelections([]))
            else:
                print(f"{self._debug_timestamp()} [find_header_in_text] Header not found in text")
            
            # Set focus after all operations
            self.input_text.setFocus()
        
        finally:
            # Restore original signal blocking state
            self.input_text.blockSignals(old_block_state)
            print(f"{self._debug_timestamp()} [find_header_in_text] Restored text input signals")
        
            # Schedule flag restoration to prevent immediate loops
            print(f"{self._debug_timestamp()} [find_header_in_text] COMPLETED")
        
            # Use timer to restore original update state
            def restore_state():
                self._updating_headers = old_updating_state
                print(f"{self._debug_timestamp()} [find_header_in_text] Restored update state")
            
            QTimer.singleShot(100, restore_state)

    def remove_header(self, match, delete_btn):
        """Remove header formatting from text using direct cursor selection"""
        try:
            self._reset_orphaned_check_suppression()
            print("Starting remove_header method...")
        
            # Find the parent container of the delete button
            parent_widget = delete_btn.parent()
            if not parent_widget:
                print("Debug: delete_btn has no parent.")
                return
            
            # Locate the QLineEdit in the same container
            header_text_widget = parent_widget.findChild(QLineEdit)
            if not header_text_widget:
                print("Debug: No QLineEdit found in parent widget.")
                return
            
            header_text = header_text_widget.text().strip()
            is_main_header = header_text_widget.property("is_main_header")
            print(f"Debug: Header text from QLineEdit: '{header_text}'")
        
            # Determine pattern based on header type
            pattern = r'\[\[(.*?)\]\]' if is_main_header else r'\*\*(.*?)\*\*'
            document_text = self.input_text.toPlainText()
        
            # Find the matching header in the document
            for match in re.finditer(pattern, document_text):
                if match.group(1).strip() == header_text:
                    # Use direct cursor manipulation like Method 1
                    cursor = self.input_text.textCursor()
                    default_format = QTextCharFormat()
                
                    # Select the exact header text
                    cursor.setPosition(match.start())
                    cursor.setPosition(match.end(), QTextCursor.MoveMode.KeepAnchor)
                    self.input_text.setTextCursor(cursor)
                
                    # Replace with plain text (no formatting)
                    cursor.insertText(match.group(1), default_format)
                
                    # Restore scroll position if needed
                    scroll_bar = self.input_text.verticalScrollBar()
                    current_scroll_position = scroll_bar.value()
                    scroll_bar.setValue(current_scroll_position)
                
                    # Update UI components
                    if hasattr(self.input_text, 'syntax_highlighter'):
                        self.input_text.syntax_highlighter.rehighlight()
                    
                    self.refresh_headers_list()
                    self.input_text._perform_orphaned_check()
                    return
                
            print("No matching header found for removal.")
        
        except Exception as e:
            print(f"Error in remove_header method: {e}")


    def _safe_restore_scroll(self, scroll_bar, position):
        """Safely restore scroll position with visual debugging"""
        print(f"Debug: Restoring scroll position to {position} (max: {scroll_bar.maximum()})")
    
        # Process pending events to ensure widgets are fully rendered
        QApplication.processEvents()
    
        # Set scroll position
        if position <= scroll_bar.maximum():
            scroll_bar.setValue(position)
        else:
            print(f"Debug: Cannot restore to {position}, maximum is {scroll_bar.maximum()}")
            scroll_bar.setValue(scroll_bar.maximum())
    
        # Process events again to ensure the scroll is applied
        QApplication.processEvents()
    
        # CRITICAL FIX: Ensure the syntax highlighting is properly active in text editor
        # This fixes the issue with headers losing their blue formatting
        try:
            # Make sure highlighting is resumed in the text editor
            if hasattr(self.input_text, 'header_highlighter'):
                highlighter = self.input_text.header_highlighter
            
                # Ensure highlighting is not paused
                if hasattr(highlighter, '_highlighting_paused'):
                    highlighter._highlighting_paused = False
            
                # Force a rehighlight
                if hasattr(highlighter, 'rehighlight'):
                    # Use a short delay to ensure it happens after scroll is complete
                    QTimer.singleShot(50, highlighter.rehighlight)
        except Exception as e:
            print(f"Debug: Error ensuring highlighting: {e}")
    
        # Validation check
        print(f"Debug: Final scroll position: {scroll_bar.value()}")

    # Complete refresh_headers_list method for parent class
    def refresh_headers_list(self):
        """Debounced refresh of the headers list with optimizations to avoid unnecessary rebuilds"""
        # Initialize debouncing mechanism if not already set up
        if not hasattr(self, '_headers_refresh_timer'):
            self._headers_refresh_timer = QTimer()
            self._headers_refresh_timer.setSingleShot(True)
            self._headers_refresh_timer.timeout.connect(self._execute_headers_refresh)
            self._headers_refresh_active = False
            self._headers_refresh_pending = False
            self._headers_cancel_requested = False
    
        # ALWAYS cancel and restart the timer on every text change
        if self._headers_refresh_timer.isActive():
            self._headers_refresh_timer.stop()
    
        # If refresh is already running, request cancellation
        if hasattr(self, '_headers_refresh_active') and self._headers_refresh_active:
            # Set cancel flag to abort the running refresh
            self._headers_cancel_requested = True
            self._headers_refresh_pending = True
    
        # Cancel any scheduled rehighlights
        if hasattr(self, 'input_text') and hasattr(self.input_text, 'syntax_highlighter'):
            syntax_highlighter = self.input_text.syntax_highlighter
            if hasattr(syntax_highlighter, 'cancel_scheduled_rehighlights'):
                syntax_highlighter.cancel_scheduled_rehighlights()
    
        # Always start a new timer regardless of whether a refresh is active
        self._headers_refresh_timer.start(1000)  # 1 second debounce


    # Complete _execute_headers_refresh method for parent class
    def _execute_headers_refresh(self):
        """Execute the optimized headers refresh after debounce period"""

        # Check the HIGHLIGHTER's flag before proceeding
        highlighter = getattr(self.input_text, 'header_highlighter', None)
        if highlighter and getattr(highlighter, '_major_formatting_active', False):
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] Skipped: Major formatting operation active.")
        start_time = time.time()
        start_timestamp = self._debug_timestamp()
        print(f"{start_timestamp} [_execute_headers_refresh] STARTED headers refresh")

        # Check if session is loading - don't show progress dialog during session load
        show_progress = True
        if hasattr(self, 'is_loading_session') and self.is_loading_session:
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] Session loading in progress, suppressing progress dialog")
            show_progress = False
            
        # Check if we're in preview tab - don't show progress dialog in preview mode
        try:
            if hasattr(self, 'tabs') and hasattr(self.tabs, 'currentWidget') and hasattr(self, 'preview_widget'):
                current_widget = self.tabs.currentWidget()
                if current_widget == self.preview_widget:
                    print(f"{self._debug_timestamp()} [_execute_headers_refresh] Preview tab active, suppressing progress dialog")
                    show_progress = False
        except Exception as e:
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] Error checking preview tab: {e}")
            # Continue with default behavior if check fails

        progress = None
        if show_progress:
            # Create a simple progress dialog
            progress = QProgressDialog("Refreshing headers...", "Cancel", 0, 6, self)
            progress.setWindowTitle("Processing Headers")
            progress.setWindowModality(Qt.WindowModality.WindowModal)
            progress.setMinimumDuration(300)  # Only show if operation takes longer than 300ms
            progress.canceled.connect(lambda: setattr(self, '_headers_cancel_requested', True))
            progress.setValue(0)

        # Reset cancellation flag
        self._headers_cancel_requested = False

        # Set flag to indicate refresh is in progress
        self._headers_refresh_active = True
        self._headers_refresh_pending = False

        # IMPORTANT: Save the initial pause state before we modify anything
        initial_highlighting_paused = False
        syntax_highlighter = None

        if hasattr(self, 'input_text') and hasattr(self.input_text, 'syntax_highlighter'):
            syntax_highlighter = self.input_text.syntax_highlighter
    
            # Store the original highlighting paused state - CRITICAL!
            if hasattr(syntax_highlighter, '_highlighting_paused'):
                initial_highlighting_paused = syntax_highlighter._highlighting_paused
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] SAVED initial highlighting paused state: {initial_highlighting_paused}")
    
            # Set header refresh in progress flag directly
            syntax_highlighter._header_refresh_in_progress = True
            syntax_highlighter._header_refresh_set_time = time.time()
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] Set header refresh in progress flag")
    
            # Keep highlighting active during the refresh but remember if it was paused
            if hasattr(syntax_highlighter, '_highlighting_paused'):
                syntax_highlighter._highlighting_paused = False
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Temporarily enabled highlighting for refresh")
    
            # Cancel any pending rehighlights
            if hasattr(syntax_highlighter, '_rehighlight_timer') and syntax_highlighter._rehighlight_timer.isActive():
                syntax_highlighter._rehighlight_timer.stop()
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Cancelled pending rehighlight operations")

        try:
            # Get current text
            current_text = self.input_text.toPlainText()
            if progress:
                progress.setLabelText("Checking for text changes...")
                progress.setValue(1)
    
            # OPTIMIZATION 1: Early exit if text hasn't changed
            if hasattr(self, '_last_headers_text') and self._last_headers_text == current_text:
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Text hasn't changed. Exiting early.")
                if progress:
                    progress.setValue(6)  # Complete the progress
                return
    
            # Store current scroll position
            scroll_bar = self.headers_list.verticalScrollBar()
            current_position = scroll_bar.value()
    
            # Update stored text
            self._last_headers_text = current_text
    
            # CANCELLATION CHECKPOINT 1
            if self._headers_cancel_requested:
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Cancellation requested at checkpoint 1. Aborting.")
                if progress:
                    progress.setValue(6)  # Complete the progress
                return
    
            # Handle empty text case
            if not current_text.strip():
                if progress:
                    progress.setLabelText("No text to process")
                    progress.setValue(6)  # Complete the progress
                self._handle_empty_text()
                return
    
            # Block signals during refresh BUT maintain highlighting
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] Blocking signals for headers_list.")
            self.headers_list.blockSignals(True)
    
            # CANCELLATION CHECKPOINT 2
            if self._headers_cancel_requested:
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Cancellation requested at checkpoint 2. Aborting.")
                self.headers_list.blockSignals(False)
                if progress:
                    progress.setValue(6)  # Complete the progress
                return
    
            # OPTIMIZATION 2: Extract headers and check if they've changed
            if progress:
                progress.setLabelText("Extracting headers...")
                progress.setValue(2)
            new_headers = self._find_headers(current_text)
    
            # CANCELLATION CHECKPOINT 3
            if self._headers_cancel_requested:
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Cancellation requested at checkpoint 3. Aborting.")
                self.headers_list.blockSignals(False)
                if progress:
                    progress.setValue(6)  # Complete the progress
                return
    
            # OPTIMIZATION 3: Compare with cached headers to avoid unnecessary updates
            headers_changed = not self._headers_unchanged(new_headers)
            if not headers_changed:
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Headers unchanged. Skipping UI update.")
                self.headers_list.blockSignals(False)
                if progress:
                    progress.setValue(6)  # Complete the progress
                return
    
            # If we get here, headers have changed
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] Headers changed - updating UI")
    
            # Update the headers list
            if progress:
                progress.setLabelText("Updating headers list...")
                progress.setValue(3)
    
            # CRITICAL: We need to prevent any modification of the highlighting during the update
            if syntax_highlighter and hasattr(syntax_highlighter, 'pause_highlighting'):
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Temporarily pausing rehighlight during update")
                # We don't want to pause the highlighting itself, just prevent any automatic rehighlights
                syntax_highlighter._rehighlighting = True
        
            # Update headers
            self._update_headers_list(new_headers)
    
            # Cache the new headers for future comparisons
            if not hasattr(self, '_cached_headers'):
                self._cached_headers = []
            self._cached_headers = new_headers
    
            # Re-enable rehighlighting but prevent orphaned checks for now
            if syntax_highlighter:
                syntax_highlighter._rehighlighting = False
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Re-enabled rehighlighting")
    
            # THE KEY FIX: Use a flag to prevent recursive orphaned text checks
            # We still need this flag during the operation
            self._suppress_orphaned_check = True
    
            # Unblock signals before processEvents
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] Unblocking signals.")
            self.headers_list.blockSignals(False)
    
            # Set a flag to indicate we're in the final phase
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] Starting final phase")
            self._in_final_headers_refresh_phase = True
    
            # Process events BUT with careful control
            if progress:
                progress.setLabelText("Processing UI updates...")
                progress.setValue(4)
    
            # Use a minimally invasive processEvents to reduce chance of triggering other events
            QCoreApplication.processEvents(QEventLoop.ProcessEventsFlag.ExcludeSocketNotifiers | 
                                          QEventLoop.ProcessEventsFlag.ExcludeUserInputEvents)
    
            # Now restore the scroll position
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] Restoring scroll position to: {current_position}")
            scroll_bar.setValue(current_position)
    
            # Minimal processing of scroll position updates
            QCoreApplication.processEvents(QEventLoop.ProcessEventsFlag.ExcludeSocketNotifiers | 
                                          QEventLoop.ProcessEventsFlag.ExcludeUserInputEvents)
    
            # Now we'll handle the highlighting update
            if progress:
                progress.setLabelText("Performing final highlighting...")
                progress.setValue(5)
    
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] Starting final highlighting")
    
            # IMPORTANT: Make sure we're not interrupting our own process
            # Only now reset the suppression flag
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] Enabling orphaned text checks")
            self._suppress_orphaned_check = False
    
            # Access syntax highlighter if available
            if syntax_highlighter:
                # CRITICAL FIX: First apply header formatting
                if hasattr(syntax_highlighter, 'apply_header_formatting'):
                    print(f"{self._debug_timestamp()} [_execute_headers_refresh] Using direct header formatting")
                    syntax_highlighter.apply_header_formatting()
                
                    # Process minimal events to allow UI update without triggering other operations
                    QCoreApplication.processEvents(QEventLoop.ProcessEventsFlag.ExcludeSocketNotifiers | 
                                                  QEventLoop.ProcessEventsFlag.ExcludeUserInputEvents)
            
                # First analyze document to identify orphaned blocks
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Running final document analysis")
                syntax_highlighter.analyze_document()
        
                # ONLY NOW enable orphaned checking
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Enabling orphaned text checking")
                syntax_highlighter.check_orphaned = True
        
                # IMPORTANT: Clear the header refresh in progress flag AFTER the formatting is complete
                syntax_highlighter._header_refresh_in_progress = False
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Cleared header refresh in progress flag")
        
                # Normal rehighlight as fallback
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Performing normal rehighlight as fallback")
                syntax_highlighter.rehighlight()
    
            # Complete the progress
            if progress:
                progress.setLabelText("Refresh complete")
                progress.setValue(6)

        except Exception as e:
            # Log any errors that occur
            print(f"{self._debug_timestamp()} [_execute_headers_refresh] ERROR: {str(e)}")
            import traceback
            traceback.print_exc()

        finally:
            # Reset flags
            self._headers_refresh_active = False
    
            # CRITICAL: Always clear the header refresh in progress flag in finally block
            if syntax_highlighter and hasattr(syntax_highlighter, 'force_header_formatting_consistency'):
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Ensuring header formatting consistency")
                syntax_highlighter.force_header_formatting_consistency()
    
            # EMERGENCY FIX: Apply formatting to ALL headers in the document
            if syntax_highlighter:
                # First try the more targeted approach
                if hasattr(syntax_highlighter, 'force_header_formatting_consistency'):
                    print(f"{self._debug_timestamp()} [_execute_headers_refresh] Ensuring header formatting consistency")
                    syntax_highlighter.force_header_formatting_consistency()
                # Fall back to direct styling if needed
                elif hasattr(syntax_highlighter, 'force_style_headers'):
                    print(f"{self._debug_timestamp()} [_execute_headers_refresh] Applying direct header styling")
                    syntax_highlighter.force_style_headers()
    
                # Minimal event processing to allow UI updates
                QCoreApplication.processEvents(QEventLoop.ProcessEventsFlag.ExcludeSocketNotifiers | 
                                              QEventLoop.ProcessEventsFlag.ExcludeUserInputEvents)
    
            # CRITICAL: Properly restore the highlighting state to its ORIGINAL saved value
            if syntax_highlighter and hasattr(syntax_highlighter, '_highlighting_paused'):
                syntax_highlighter._highlighting_paused = initial_highlighting_paused
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Restored to ORIGINAL highlighting state: {initial_highlighting_paused}")
        
                # If highlighting was paused initially, we should explicitly resume it now
                if not initial_highlighting_paused and hasattr(syntax_highlighter, 'resume_highlighting'):
                    print(f"{self._debug_timestamp()} [_execute_headers_refresh] Explicitly calling resume_highlighting")
                    syntax_highlighter.resume_highlighting()
    
            # Clear the final phase flag if we set it
            if hasattr(self, '_in_final_headers_refresh_phase'):
                self._in_final_headers_refresh_phase = False
    
            # Handle cancellation in finally block
            if self._headers_cancel_requested:
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Ensuring signals are unblocked after cancellation.")
                self.headers_list.blockSignals(False)
                self._headers_cancel_requested = False
        
                # Schedule a new refresh if cancellation happened
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Scheduling a new refresh after cancellation.")
                self._headers_refresh_timer.start(100)  # Short delay for new refresh
            # If not cancelled but changes detected during processing
            elif self._headers_refresh_pending:
                print(f"{self._debug_timestamp()} [_execute_headers_refresh] Changes detected during refresh. Scheduling another refresh.")
                self._headers_refresh_pending = False
                self._headers_refresh_timer.start(100)  # Shorter delay for pending refresh
    
            # Make sure progress is completed if it exists
            if progress:
                progress.setValue(6)
    
            # Calculate and log execution time
            end_time = time.time()
            elapsed_ms = int((end_time - start_time) * 1000)
            end_timestamp = self._debug_timestamp()
            print(f"{end_timestamp} [_execute_headers_refresh] COMPLETED in {elapsed_ms}ms\n")


    def _debug_timestamp(self):
        """Generate timestamp for debug messages"""
        # Format: [HH:MM:SS.mmm]
        current_time = QTime.currentTime()
        return f"[{current_time.toString('HH:mm:ss.zzz')}]"

    def _reset_orphaned_check_suppression(self):
        """Reset the orphaned check suppression flag"""
        print(f"{self._debug_timestamp()} [_reset_orphaned_check_suppression] Enabling orphaned text checks again")
        self._suppress_orphaned_check = False


    def _find_headers(self, text):
        """Find headers in text with optimized pattern matching"""
        # Regular headers - **text**
        regular_pattern = r'\*\*(.*?)\*\*'
        regular_matches = list(re.finditer(regular_pattern, text))
    
        # CANCELLATION CHECKPOINT
        if self._headers_cancel_requested:
            return []
    
        # Main headers - [[text]]
        main_pattern = r'\[\[(.*?)\]\]'
        main_matches = list(re.finditer(main_pattern, text))
    
        print(f"[_find_headers] Found {len(regular_matches)} regular headers and {len(main_matches)} main headers.")
    
        # Combine and sort headers
        all_headers = []
    
        for match in regular_matches:
            all_headers.append({
                'text': match.group(1),
                'is_main': False,
                'start': match.start(),
                'end': match.end(),
                'match': match
            })
    
        for match in main_matches:
            all_headers.append({
                'text': match.group(1),
                'is_main': True,
                'start': match.start(),
                'end': match.end(),
                'match': match
            })
    
        # Sort by position in text
        all_headers.sort(key=lambda h: h['start'])
    
        return all_headers

    def _headers_unchanged(self, new_headers):
        """Check if headers have changed from the cached version"""
        if not hasattr(self, '_cached_headers'):
            # First run, no cache
            return False
    
        cached_headers = self._cached_headers
    
        # Quick check: different number of headers
        if len(cached_headers) != len(new_headers):
            return False
    
        # Compare each header
        for i, new_header in enumerate(new_headers):
            cached_header = cached_headers[i]
            if (new_header['text'] != cached_header['text'] or 
                new_header['is_main'] != cached_header['is_main']):
                return False
    
        return True

    def _handle_empty_text(self):
        """
        Handle the case of empty text by adding the 'No headers found...' placeholder.
        NOTE: This method is now used when the input text editor is empty.
              The logic to differentiate between empty text and text-with-no-headers
              has been consolidated elsewhere (_update_headers_list).
              This method *now* displays the 'No headers found...' message
              even when the editor is empty, as requested.
        """
        print(f"{self._debug_timestamp()} [_handle_empty_text] Adding 'No headers found...' placeholder (as requested).")
        self.headers_list.blockSignals(True)
        self.headers_list.clear()

        # Add the "No headers found..." placeholder widget
        placeholder = QWidget()
        placeholder_layout = QVBoxLayout(placeholder)
        placeholder_layout.setContentsMargins(16, 20, 16, 20)

        # *** UPDATED PLACEHOLDER TEXT HERE ***
        message = QLabel("\nNo headers found\n\n Headers are text surrounded by **characters**\n Section Dividers are text surrounded by [[characters]]\n\n All text needs to be preceded by at least one header.\nSee the '?' button to learn more.")
        # *************************************

        message.setAlignment(Qt.AlignmentFlag.AlignCenter)
        message.setWordWrap(True) # Ensure wrapping for longer text
        message.setStyleSheet("""
            QLabel {
                color: #6c757d;
                font-size: 13px;
            }
        """)
        placeholder_layout.addWidget(message)
        item = QListWidgetItem()
        item.setSizeHint(placeholder.sizeHint()) # Use placeholder size hint
        self.headers_list.addItem(item)
        self.headers_list.setItemWidget(item, placeholder)

        # Reset cached values to ensure proper detection of future changes
        if hasattr(self, '_last_headers_text'):
            self._last_headers_text = ""
        if hasattr(self, '_last_headers_list'): # Check if attribute exists
            self._last_headers_list = None
        if hasattr(self, '_cached_headers'):
            self._cached_headers = []

        self.headers_list.blockSignals(False)

    def _update_headers_list(self, headers):
        """Update the headers list with the new headers"""
        start_time = time.time()
        print(f"{self._debug_timestamp()} [_update_headers_list] STARTED updating headers list")

        # LOOP PREVENTION: Track that we're updating the headers
        old_updating_state = getattr(self, '_updating_headers', False)
        self._updating_headers = True

        try:
            # Verify signals are blocked as expected
            if not self.headers_list.signalsBlocked():
                print(f"{self._debug_timestamp()} [_update_headers_list] Warning: Expected signals to be blocked, blocking now")
                self.headers_list.blockSignals(True)

            # Clear the list
            self.headers_list.clear()

            # Save current input state (if we need to modify it)
            if hasattr(self, 'input_text'):
                text_had_focus = self.input_text.hasFocus()
                cursor_position = self.input_text.textCursor().position()

            if not headers:
                # Add placeholder for no headers
                print(f"{self._debug_timestamp()} [_update_headers_list] No headers found. Adding placeholder.")
                placeholder = QWidget()
                placeholder_layout = QVBoxLayout(placeholder)
                placeholder_layout.setContentsMargins(16, 20, 16, 20)
                message = QLabel("\nNo headers found\n\n Headers are text surrounded by **characters**\n Section Dividers are text surrounded by [[characters]]\n\n All text needs to be preceded by at least one header.\nSee the '?' button to learn more.")
                message.setAlignment(Qt.AlignmentFlag.AlignCenter)
                message.setStyleSheet("""
                    QLabel {
                        color: #6c757d;
                        font-size: 13px;
                    }
                """)
                placeholder_layout.addWidget(message)
                item = QListWidgetItem()
                item.setSizeHint(placeholder.sizeHint())
                self.headers_list.addItem(item)
                self.headers_list.setItemWidget(item, placeholder)

                print(f"{self._debug_timestamp()} [_update_headers_list] Placeholder added")
                return

            # Add each header
            successful_items = 0
            for i, header in enumerate(headers):
                # CANCELLATION CHECKPOINT
                if self._headers_cancel_requested:
                    print(f"{self._debug_timestamp()} [_update_headers_list] Cancellation requested during header processing at item {i+1}/{len(headers)}. Aborting.")
                    return

                # LOOP PREVENTION: Check if we're still in a valid state every 10 items
                if i > 0 and i % 10 == 0:
                    QApplication.processEvents(QEventLoop.ProcessEventsFlag.ExcludeUserInputEvents)
                    if self._headers_cancel_requested:
                        print(f"{self._debug_timestamp()} [_update_headers_list] Cancellation detected after event processing at item {i+1}/{len(headers)}. Aborting.")
                        return

                header_type = 'Main' if header['is_main'] else 'Regular'
                header_text = header['text']
                print(f"{self._debug_timestamp()} [_update_headers_list] Adding item {i+1}/{len(headers)}: Type={header_type}, Text='{header_text}'")

                # Create and add header item
                try:
                    item = QListWidgetItem()
                    container = self.create_header_item(header['match'], is_main_header=header['is_main'])
                    item.setSizeHint(container.sizeHint())
                    self.headers_list.addItem(item)
                    self.headers_list.setItemWidget(item, container)
                    successful_items += 1
                except Exception as e:
                    print(f"{self._debug_timestamp()} [_update_headers_list] Error adding item {i+1}: {str(e)}")

            # Final stats
            elapsed_ms = int((time.time() - start_time) * 1000)
            print(f"{self._debug_timestamp()} [_update_headers_list] Successfully added {successful_items}/{len(headers)} items in {elapsed_ms}ms")

            # Restore input state if needed
            if hasattr(self, 'input_text') and text_had_focus:
                # Block signals to prevent event loops
                old_block_state = self.input_text.blockSignals(True)

                # Restore cursor position
                cursor = QTextCursor(self.input_text.document())
                cursor.setPosition(cursor_position)
                self.input_text.setTextCursor(cursor)

                # Restore focus if previously had it
                if text_had_focus:
                    self.input_text.setFocus()

                # Restore signal state
                self.input_text.blockSignals(old_block_state)

        finally:
            print(f"{self._debug_timestamp()} [_update_headers_list] COMPLETED")

            # Schedule restoration of update state
            # Use a slightly longer delay to ensure UI has completely settled
            def restore_state():
                self._updating_headers = old_updating_state
                print(f"{self._debug_timestamp()} [_update_headers_list] Restored update state")

            # Only call _perform_orphaned_check if headers have changed.
            if headers != getattr(self, '_last_headers_list', None):
                self.input_text._perform_orphaned_check()
                self._last_headers_list = headers

            QTimer.singleShot(150, restore_state)


    def create_search_widget(self):
        """Create a compact search widget with vertically stacked navigation buttons"""
        search_widget = QWidget()
        search_layout = QHBoxLayout(search_widget)
        search_layout.setContentsMargins(16, 8, 16, 8)
        search_layout.setSpacing(6)

        # Search input field
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search in text...")
        self.search_input.setStyleSheet("""
            QLineEdit {
                padding: 8px 12px;
                border: none;
                border-radius: 4px;
                font-size: 13px;
                min-height: 36px;
                background: #f5f5f5;
            }
            QLineEdit:focus {
                background: #f0f0f0;
            }
        """)
        self.search_input.returnPressed.connect(self.find_next_occurrence)
        self.search_input.textChanged.connect(self.search_text)
        search_layout.addWidget(self.search_input, stretch=3)

        # Create a consistent button style
        search_button_style = """
            QPushButton {
                background-color: #f5f5f5;
                border: none;
                border-radius: 3px;
                padding: 2px;
                min-width: 24px;
                max-width: 24px;
                min-height: 24px;
                max-height: 24px;
                font-size: 10px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
            QPushButton:pressed {
                background-color: #d0d0d0;
            }
            QPushButton:disabled {
                background-color: #f5f5f5;
                color: #aaaaaa;
            }
            QPushButton:enabled {
                color: #333333;
            }
        """

        # Container for vertically stacked arrow buttons
        arrows_container = QWidget()
        arrows_layout = QVBoxLayout(arrows_container)
        arrows_layout.setContentsMargins(0, 0, 0, 0)
        arrows_layout.setSpacing(0)

        # Previous button (up arrow)
        self.search_prev_button = QPushButton("▲")
        self.search_prev_button.setToolTip("Find Previous (Shift+F3)")
        self.search_prev_button.setStyleSheet(search_button_style)
        self.search_prev_button.clicked.connect(self.find_previous_occurrence)
        self.search_prev_button.setEnabled(False)
        arrows_layout.addWidget(self.search_prev_button)

        # Next button (down arrow)
        self.search_next_button = QPushButton("▼")
        self.search_next_button.setToolTip("Find Next (F3)")
        self.search_next_button.setStyleSheet(search_button_style)
        self.search_next_button.clicked.connect(self.find_next_occurrence)
        self.search_next_button.setEnabled(False)
        arrows_layout.addWidget(self.search_next_button)

        search_layout.addWidget(arrows_container)

        # Close button with distinct style for visibility
        self.close_search_button = QPushButton("✕")
        self.close_search_button.setToolTip("Close Search (Esc)")
        self.close_search_button.setStyleSheet("""
            QPushButton {
                background-color: #f5f5f5;
                border: none;
                border-radius: 3px;
                padding: 2px;
                min-width: 24px;
                max-width: 24px;
                min-height: 24px;
                max-height: 24px;
                font-size: 10px;
            }
            QPushButton:hover {
                background-color: #ffecec;
                color: #d32f2f;
            }
            QPushButton:pressed {
                background-color: #ffcdd2;
                color: #b71c1c;
            }
            QPushButton:disabled {
                background-color: #f5f5f5;
                color: #aaaaaa;
            }
            QPushButton:enabled {
                color: #333333;
            }
        """)
    
        # CRITICAL: Make sure the connection is properly set up
        self.close_search_button.clicked.connect(self.close_search)
        self.close_search_button.setEnabled(False)  # Start disabled
    
        # Add cursor hover effect
        self.close_search_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.search_next_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.search_prev_button.setCursor(Qt.CursorShape.PointingHandCursor)
    
        #search_layout.addWidget(self.close_search_button)
    
        # Match counter label
        self.search_info_label = QLabel("")
        self.search_info_label.setStyleSheet("color: #666666; font-size: 11px; min-width: 60px;")
        self.search_info_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        search_layout.addWidget(self.search_info_label, stretch=1)

        # Initialize search-related variables
        self.search_term = ""
        self.last_search_position = 0

        return search_widget

    # Add this to your initialization code to ensure the search widgets are properly initialized
    def init_search(self):
        """Make sure search functionality is properly initialized"""
        # This should be called after the search UI is created
    
        # Make sure the close button connection is working
        if not self.close_search_button.receivers(self.close_search_button.clicked):
            print("Warning: Close search button not connected, reconnecting...")
            self.close_search_button.clicked.connect(self.close_search)
    
        # Test the initial state
        self.close_search_button.setEnabled(False)
        self.search_next_button.setEnabled(False)
        self.search_prev_button.setEnabled(False)
    
        # Test with some text to ensure it enables properly
        test_text = "test"
        has_text = bool(test_text)
        print(f"Testing with text '{test_text}': has_text = {has_text}, should enable buttons")
    
        # Clear test
        self.search_input.clear()
        print("Search input cleared, buttons should be disabled")

    def search_text(self, text):
        """Search and highlight text in the input"""
        # Update search term
        self.search_term = text
    
        # IMPORTANT: Always enable the close button when there's text
        has_text = bool(text)
        self.close_search_button.setEnabled(has_text)
    
        if not text:
            # Clear selection if search is empty
            cursor = self.input_text.textCursor()
            cursor.clearSelection()
            self.input_text.setTextCursor(cursor)
            self.search_next_button.setEnabled(False)
            self.search_prev_button.setEnabled(False)
            self.search_info_label.setText("")
            return
    
        # Enable navigation buttons when there's text
        self.search_next_button.setEnabled(True)
        self.search_prev_button.setEnabled(True)
    
        # Find and select first match
        self.find_next_occurrence()

    def close_search(self):
        """Clear the search and reset the search UI"""
        # CRITICAL: This needs to be connected to the X button's clicked signal
        print("Close search button clicked")  # Debug message
    
        # Clear the search input which will trigger search_text() with empty text
        self.search_input.clear()
    
        # Explicitly clear the search term
        self.search_term = ""
        self.last_search_position = 0
    
        # Clear any selection in the text
        cursor = self.input_text.textCursor()
        cursor.clearSelection()
        self.input_text.setTextCursor(cursor)
    
        # Update UI elements
        self.search_info_label.setText("")
        self.search_next_button.setEnabled(False)
        self.search_prev_button.setEnabled(False)
        self.close_search_button.setEnabled(False)
    
        # Set focus back to the text editor
        self.input_text.setFocus()

    def find_next_occurrence(self):
        """Find and highlight the next occurrence of the search term"""
        if not self.search_term:
            return
    
        # Start search from current cursor position
        cursor = self.input_text.textCursor()
        current_pos = cursor.position()
    
        # In PyQt6, it's FindFlag not FindFlags
        from PyQt6.QtGui import QTextDocument
        # For forward search, we use an empty set of flags (0)
        find_flags = QTextDocument.FindFlag(0)
    
        # Search for the term from current position
        cursor = self.input_text.document().find(self.search_term, current_pos, find_flags)
    
        # If not found after current position, wrap around to beginning
        if cursor.isNull():
            cursor = self.input_text.document().find(self.search_term, 0, find_flags)
    
        # If found, highlight it
        if not cursor.isNull():
            self.input_text.setTextCursor(cursor)
            self.input_text.ensureCursorVisible()
    
        # Update match count and button states
        self.update_search_matches_info()
        self.update_search_buttons_state()

    def find_previous_occurrence(self):
        """Find and highlight the previous occurrence of the search term"""
        if not self.search_term:
            return
    
        # Start search from current cursor position
        cursor = self.input_text.textCursor()
        current_pos = cursor.position() - len(self.search_term) - 1
        if current_pos < 0:
            current_pos = self.input_text.document().characterCount() - 1
    
        # In PyQt6, use FindFlag.FindBackward for backward search
        from PyQt6.QtGui import QTextDocument
        find_flags = QTextDocument.FindFlag.FindBackward
    
        # Search for the term before current position
        cursor = self.input_text.document().find(self.search_term, current_pos, find_flags)
    
        # If not found before current position, wrap around to end
        if cursor.isNull():
            cursor = self.input_text.document().find(
                self.search_term, 
                self.input_text.document().characterCount() - 1, 
                find_flags
            )
    
        # If found, highlight it
        if not cursor.isNull():
            self.input_text.setTextCursor(cursor)
            self.input_text.ensureCursorVisible()
    
        # Update match count and button states
        self.update_search_matches_info()
        self.update_search_buttons_state()

    def count_search_matches(self):
        """Count the total number of matches for the current search term"""
        if not self.search_term:
            return 0
    
        count = 0
        pos = 0
    
        # In PyQt6, use FindFlag(0) for no special flags
        from PyQt6.QtGui import QTextDocument
        find_flags = QTextDocument.FindFlag(0)
    
        # Count all occurrences
        while True:
            cursor = self.input_text.document().find(self.search_term, pos, find_flags)
            if cursor.isNull():
                break
            count += 1
            pos = cursor.position() + 1
    
        return count

    def update_search_matches_info(self):
        """Update the label showing current match position and total matches"""
        if not self.search_term:
            self.search_info_label.setText("")
            return
    
        total_matches = self.count_search_matches()
    
        if total_matches > 0:
            # Find the index of the current match
            current_match = 1
            cursor = self.input_text.textCursor()
            if cursor.hasSelection():
                current_pos = cursor.position()
            
                # Count matches before current position
                pos = 0
                from PyQt6.QtGui import QTextDocument
                find_flags = QTextDocument.FindFlag(0)
            
                while pos < current_pos - len(self.search_term):
                    search_cursor = self.input_text.document().find(self.search_term, pos, find_flags)
                    if search_cursor.isNull():
                        break
                    current_match += 1
                    pos = search_cursor.position() + 1
            
                # Adjust for edge case
                if current_match > total_matches:
                    current_match = 1
        
            self.search_info_label.setText(f"{current_match} of {total_matches}")
        else:
            self.search_info_label.setText("No matches")

    def update_search_buttons_state(self):
        """Enable/disable search buttons based on search state"""
        has_search_term = bool(self.search_term)
        self.search_next_button.setEnabled(has_search_term)
        self.search_prev_button.setEnabled(has_search_term)
        self.close_search_button.setEnabled(has_search_term)

    def show_input_context_menu(self, position):
        """Show custom context menu for input text area"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: white;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 8px 24px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #e3f2fd;
                color: #2C4952;
            }
            QMenu::separator {
                height: 1px;
                background: #e0e0e0;
                margin: 4px 0;
            }
        """)

        # Add standard actions
        undo_action = menu.addAction("Undo")
        redo_action = menu.addAction("Redo")
        menu.addSeparator()
        cut_action = menu.addAction("Cut")
        copy_action = menu.addAction("Copy")
        paste_action = menu.addAction("Paste")
        menu.addSeparator()
        select_all_action = menu.addAction("Select All")
        menu.addSeparator()
        clear_action = menu.addAction("Clear")

        # Enable/disable actions based on state
        undo_action.setEnabled(self.input_text.document().isUndoAvailable())
        redo_action.setEnabled(self.input_text.document().isRedoAvailable())
        cut_action.setEnabled(len(self.input_text.textCursor().selectedText()) > 0)
        copy_action.setEnabled(len(self.input_text.textCursor().selectedText()) > 0)
        paste_action.setEnabled(QApplication.clipboard().text() != "")
        clear_action.setEnabled(len(self.input_text.toPlainText()) > 0)

        # Handle action triggers
        action = menu.exec(self.input_text.mapToGlobal(position))
        if action == undo_action:
            self.input_text.undo()
        elif action == redo_action:
            self.input_text.redo()
        elif action == cut_action:
            self.input_text.cut()
        elif action == copy_action:
            self.input_text.copy()
        elif action == paste_action:
            self.input_text.paste()
        elif action == select_all_action:
            self.input_text.selectAll()
        elif action == clear_action:
            self.clear_input()

    def create_output_tab(self):
        self.output_widget = QWidget()
        layout = QVBoxLayout()

        label = QLabel('Converted HTML:')
        layout.addWidget(label)

        self.output_text = QTextEdit()
        self.output_text.setReadOnly(True)
        self.output_text.setPlaceholderText('Converted HTML will appear here...')
        layout.addWidget(self.output_text)

        button_layout = QHBoxLayout()
        self.save_button = QPushButton('Save Output to File')
        self.save_button.clicked.connect(self.save_output)
        button_layout.addWidget(self.save_button)

        self.clear_output_button = QPushButton('Clear Output')
        self.clear_output_button.clicked.connect(self.clear_output)
        button_layout.addWidget(self.clear_output_button)

        layout.addLayout(button_layout)

        self.output_widget.setLayout(layout)
        #self.tabs.addTab(self.output_widget, 'Output')

    def update_tab_item_sizes(self):
        """Update item sizes for all tabs using the same approach as update_theme_view"""
        # **VISUAL FEEDBACK**: Show progress to user
        original_status = self.status_bar.currentMessage()
        self.status_bar.showMessage("Optimizing theme view layout...")
        QApplication.processEvents()  # Force immediate display
    
        # **SMART FLICKER REDUCTION**: Minimize redraws without breaking functionality
    
        # Store original tab and prevent visual tab switching
        original_tab = self.scene_tabs.currentIndex()
    
        # Temporarily reduce repaint frequency without disabling completely
        self.scene_tabs.setUpdatesEnabled(False)
    
        # Create a temporary overlay to hide the flicker (but keep widget functional)
        overlay = QWidget(self.scene_tabs)
        overlay.setStyleSheet("background-color: rgba(255, 255, 255, 200);")
        overlay.resize(self.scene_tabs.size())
        overlay.show()
        overlay.raise_()
    
        widget_states = {}

        try:
            # Store state for each tab
            scroll_positions = {}
            selected_items = {}
            original_tab = self.scene_tabs.currentIndex()

            # Store scroll positions and selections
            for i in range(self.scene_tabs.count()):
                list_widget = self.scene_tabs.widget(i)
                if isinstance(list_widget, AnnotationListWidget):
                    scroll_positions[i] = list_widget.verticalScrollBar().value()
                    selected_items[i] = [
                        item.data(Qt.ItemDataRole.UserRole)
                        for item in list_widget.selectedItems()
                    ]

            # Process list widgets
            list_widgets = [(i, self.scene_tabs.widget(i)) 
                           for i in range(self.scene_tabs.count())
                           if isinstance(self.scene_tabs.widget(i), AnnotationListWidget)]

            if list_widgets:
                # FIXED: Get the correct viewport width from the current visible tab
                current_widget = self.scene_tabs.currentWidget()
                if isinstance(current_widget, AnnotationListWidget):
                    current_viewport_width = current_widget.viewport().width()
                    print(f"DEBUG: Using current viewport width: {current_viewport_width}")
                else:
                    # Fallback to first AnnotationListWidget
                    current_viewport_width = list_widgets[0][1].viewport().width()
                    print(f"DEBUG: Using fallback viewport width: {current_viewport_width}")
            
                # Cache viewport dimensions and process each widget
                batch_size = 10  # Smaller batch size for smoother updates
        
                for idx, list_widget in list_widgets:
                    # Cache viewport dimensions for this tab
                    # Fixed Code
                    if isinstance(list_widget, AnnotationListWidget):
                        viewport_key = f"{current_viewport_width}"  # Use consistent width
                    else:
                        print(f"Warning: Widget at index {idx} is not an AnnotationListWidget.")
                        continue

                    if not hasattr(self, '_last_resize_dims'):
                        self._last_resize_dims = {}
                
                    if viewport_key not in self._last_resize_dims:
                        self._last_resize_dims[viewport_key] = {
                            'width': current_viewport_width - 40  # Use consistent width
                        }
            
                    available_width = self._last_resize_dims[viewport_key]['width']
                    if available_width <= 0:  # Safety check
                        continue

                    print(f"DEBUG: Processing tab {idx} with width {available_width}")

                    # **NO TAB SWITCHING + ANTI-FLICKER**: Process widgets without any visual updates
                    # Store widget state for restoration
                    widget_states[idx] = {
                        'updates_enabled': list_widget.updatesEnabled(),
                        'visible': list_widget.isVisible()
                    }
                
                    # Process without switching to this tab (eliminates main flicker source)
                    # Don't call setCurrentIndex(idx) - that's what causes visible switching
                
                    # Temporarily reduce updates for this specific widget
                    list_widget.setUpdatesEnabled(False)
                    list_widget.verticalScrollBar().setSingleStep(5)

                    # **FLICKER-FREE BATCH PROCESSING**: Process all items without individual redraws
                
                    # Collect all items to process in batches
                    items_to_process = []
                    visible_start, visible_end = list_widget.getVisibleItemRange()
                
                    # FIXED: Properly detect hidden tabs by comparing with current tab index
                    current_tab_index = self.scene_tabs.currentIndex()
                    is_hidden_tab = (idx != current_tab_index)
                
                    # Prepare all updates in memory first
                    for k in range(list_widget.count()):
                        item = list_widget.item(k)
                        widget = list_widget.itemWidget(item)
                        if widget:
                            widget.setFixedWidth(available_width)
                        
                            # FIXED: Force full calculation for ALL items in hidden tabs
                            # For visible tabs, only force full calculation for visible items + buffer
                            if is_hidden_tab:
                                # Hidden tab - force full calculation to invalidate cached dimensions
                                force_full = True
                            else:
                                # Visible tab - only force full for visible items + buffer
                                force_full = (visible_start is not None and 
                                            visible_start - 2 <= k <= visible_end + 2)
                        
                            items_to_process.append((item, widget, force_full))
                
                    # Use efficient batch processing instead of individual updateItemSize calls
                    if hasattr(list_widget, 'updateItemSizesBatch'):
                        # Use the new efficient batch method
                        list_widget.updateItemSizesBatch(items_to_process, override_width=current_viewport_width)
                        print(f"DEBUG: Used batch update for tab {idx}")
                    else:
                        # Fallback to original method if batch method not available
                        batch_size = 8
                        for i in range(0, len(items_to_process), batch_size):
                            batch = items_to_process[i:i + batch_size]
                            for item, widget, force_full in batch:
                                list_widget.updateItemSize(item, widget, force_full_calculation=force_full, override_width=current_viewport_width)
                        
                            # Small pause between batches to keep UI responsive
                            if i + batch_size < len(items_to_process):
                                QApplication.processEvents()
                
                    # Schedule background processing for remaining lazy items
                    list_widget.scheduleBackgroundUpdates()

                    # **RESTORE UPDATES**: Re-enable with geometry update
                    list_widget.updateGeometry()
                    list_widget.setUpdatesEnabled(True)

                # **NO TAB RESTORATION NEEDED**: We never switched tabs

                # Restore scroll positions
                for idx, pos in scroll_positions.items():
                    if idx < self.scene_tabs.count():
                        list_widget = self.scene_tabs.widget(idx)
                        if isinstance(list_widget, AnnotationListWidget):
                            QTimer.singleShot(50, lambda lw=list_widget, p=pos: 
                                lw.verticalScrollBar().setValue(p))

                # Restore selections
                for idx, item_ids in selected_items.items():
                    if idx >= self.scene_tabs.count():
                        continue
                
                    # FIXED: Get the widget for this specific index
                    list_widget = self.scene_tabs.widget(idx)
                    if not isinstance(list_widget, AnnotationListWidget):
                        continue
                
                    list_widget.setUpdatesEnabled(False)
                    for item_id in item_ids:
                        for j in range(list_widget.count()):
                            item = list_widget.item(j)
                            if item.data(Qt.ItemDataRole.UserRole) == item_id:
                                item.setSelected(True)
                                break
                    list_widget.setUpdatesEnabled(True)

        finally:
            # **SMOOTH RESTORATION**: Remove overlay and restore normal operation
        
            # Remove the overlay that was hiding flicker
            if 'overlay' in locals():
                overlay.hide()
                overlay.deleteLater()
        
            # Restore original tab silently
            self.scene_tabs.setCurrentIndex(original_tab)
        
            # Re-enable updates for final smooth reveal
            self.scene_tabs.setUpdatesEnabled(True)
            self.scene_tabs.update()
        
            # **RESTORE STATUS**: Clear progress message
            QTimer.singleShot(400, lambda: self.status_bar.showMessage(original_status or "Ready", 1500))

    def update_current_tab_item_sizes(self):
        """Update item sizes for only the currently visible tab"""
        # Get current tab widget
        current_widget = self.scene_tabs.currentWidget()
        if not isinstance(current_widget, AnnotationListWidget):
            return

        # Disable updates during the process
        current_widget.setUpdatesEnabled(False)
    
        try:
            # Store current state
            scroll_position = current_widget.verticalScrollBar().value()
            selected_items = [
                item.data(Qt.ItemDataRole.UserRole)
                for item in current_widget.selectedItems()
            ]

            # Cache viewport dimensions
            if isinstance(current_widget, QAbstractItemView):
                viewport_key = f"{current_widget.viewport().width()}"
                if not hasattr(self, '_last_resize_dims'):
                    self._last_resize_dims = {}

                if viewport_key not in self._last_resize_dims:
                    self._last_resize_dims[viewport_key] = {
                        'width': current_widget.viewport().width() - 40
                    }
            else:
                print("Warning: current_widget does not support viewport operations.")
                return

            if not hasattr(self, '_last_resize_dims'):
                self._last_resize_dims = {}
        
            if viewport_key not in self._last_resize_dims:
                self._last_resize_dims[viewport_key] = {
                    'width': current_widget.viewport().width() - 40
                }
    
            available_width = self._last_resize_dims[viewport_key]['width']
            if available_width <= 0:  # Safety check
                return

            current_widget.verticalScrollBar().setSingleStep(5)

            # Collect all items for efficient batch processing
            items_to_process = []
            for k in range(current_widget.count()):
                item = current_widget.item(k)
                widget = current_widget.itemWidget(item)
                if widget:
                    widget.setFixedWidth(available_width)
                    # Force full calculation for current tab items
                    items_to_process.append((item, widget, True))
            
            # Use efficient batch processing
            if hasattr(current_widget, 'updateItemSizesBatch') and items_to_process:
                current_widget.updateItemSizesBatch(items_to_process, override_width=current_widget.viewport().width())
                print(f"DEBUG: Used batch update for current tab with {len(items_to_process)} items")
            else:
                # Fallback to individual updates
                for item, widget, force_full in items_to_process:
                    current_widget.updateItemSize(item, widget)
        
                QApplication.processEvents()

            current_widget.updateGeometry()

            # Restore scroll position
            QTimer.singleShot(50, lambda: 
                current_widget.verticalScrollBar().setValue(scroll_position))

            # Restore selections
            current_widget.setUpdatesEnabled(False)
            # Fixed Code with Debug Message
            for item_id in selected_items:
                found = False
                for j in range(current_widget.count()):
                    item = current_widget.item(j)
                    if item.data(Qt.ItemDataRole.UserRole) == item_id:
                        item.setSelected(True)
                        found = True
                        break
                if not found:
                    print(f"Warning: Item with ID {item_id} not found in the current tab.")

            current_widget.setUpdatesEnabled(True)

        finally:
            # Re-enable updates
            current_widget.setUpdatesEnabled(True)
            current_widget.update()

    def create_right_panel_container(self):
        print("Creating right panel container")  # Debug
        """Create a container widget to hold script, bookmark, and color key panels"""

        # Create custom widget class with resize handling
        class ResizableContainer(QWidget):
            def __init__(self, parent=None):
                super().__init__(parent)
                self.resize_timer = QTimer()
                self.resize_timer.setSingleShot(True)
                self.resize_timer.timeout.connect(self.handle_resize_timeout)

            def resizeEvent(self, event):
                super().resizeEvent(event)
                # Reset and restart the timer
                self.resize_timer.stop()
                self.resize_timer.start(150) 

            def handle_resize_timeout(self):
                main_window = self.window()
                print("=== RESIZE TIMEOUT TRIGGERED ===")
                # Check if tab sizes were just updated to avoid duplicate work
                if hasattr(main_window, '_just_updated_tab_sizes') and main_window._just_updated_tab_sizes:
                    print("Skipping tab item sizes update - already updated recently")
                elif hasattr(main_window, 'update_tab_item_sizes'):
                    print("Calling update_tab_item_sizes...")
                    main_window.update_tab_item_sizes()
                    print("=== update_tab_item_sizes COMPLETE ===")
                
                # Update tab scrollbar after resize
                if hasattr(main_window, 'scene_tabs'):
                    print("=== UPDATING TAB SCROLLBAR AFTER RESIZE ===")
                    main_window.scene_tabs.update_passive_scrollbar()
                    print("=== TAB SCROLLBAR UPDATE COMPLETE ===")
                else:
                    print("=== TAB SCROLLBAR UPDATE SKIPPED - missing scene_tabs ===")
                
                # Trigger sticky header recalculation for reactive layout changes
                if (hasattr(main_window, 'web_view') and 
                    hasattr(main_window.web_view, 'sticky_header') and 
                    main_window.web_view.sticky_header_enabled and
                    main_window.web_view.sticky_header.isVisible()):
                    print("=== TRIGGERING STICKY HEADER RECALCULATION FROM RIGHT PANEL RESIZE ===")
                    main_window.web_view.recalculate_header_position()

        # Main right panel container using custom class
        self.right_panel_container = ResizableContainer()
        right_panel_layout = QVBoxLayout(self.right_panel_container)
        right_panel_layout.setContentsMargins(0, 0, 0, 0)
        right_panel_layout.setSpacing(0)

        # Create script panel (top)
        self.theme_view = QWidget()
        self.theme_view.setStyleSheet("""
            QWidget:: {
                border: 0px;
                outline: 0px;
            }
        """)
        script_layout = QVBoxLayout(self.theme_view)
        script_layout.setContentsMargins(10, 10, 10, 10)
        script_layout.setSpacing(10)

        # Create and add search widget
        self.script_search = ThemeViewSearch()
        script_layout.addWidget(self.script_search)

        # Add this line to add the sort button to the search toolbar
        self.add_chronological_sort_button_to_search()

        # Add ColoredTabWidget for scenes to script panel
        self.scene_tabs = ColoredTabWidget()
        self.scene_tabs.setStyleSheet("""
            QTabWidget::pane {
                border: 1px solid #e0e0e0;
                border-radius: 5px;
                background: white;
                padding: 5px;
            }
        """)
        
        # Connect tab switching signal to refresh annotation list sizes
        self.scene_tabs.currentChanged.connect(self.on_scene_tab_changed)
        
        script_layout.addWidget(self.scene_tabs)

        # Create bookmark panel
        if not hasattr(self, 'bookmark_panel'):
            self.bookmark_panel = BookmarkPanel(self.web_view)
            self.bookmark_panel.scroll_to_position.connect(self.scroll_to_position)

        # Create color key panel (bottom)
        self.color_key_panel = QWidget()
        color_key_layout = QVBoxLayout(self.color_key_panel)
        color_key_layout.setContentsMargins(10, 10, 10, 0)
        color_key_layout.setSpacing(10)

        # Add color key content
        self.color_key_content = QWidget()
        color_key_content_layout = QVBoxLayout(self.color_key_content)
        self.color_key_form = QFormLayout()
        color_key_content_layout.addLayout(self.color_key_form)
        color_key_layout.addWidget(self.color_key_content)

        # Add panels to container with initial stretch factors
        right_panel_layout.addWidget(self.theme_view, stretch=6)  # Script panel (initially 60%)
        right_panel_layout.addWidget(self.bookmark_panel, stretch=0)  # Bookmark panel (initially hidden)
        right_panel_layout.addWidget(self.color_key_panel, stretch=4)  # Color key panel (initially 40%)

        # Initially hide all panels
        self.theme_view.hide()
        self.bookmark_panel.hide()
        self.color_key_panel.hide()

        # Hide the container initially
        self.right_panel_container.hide()

        return self.right_panel_container

# MODIFIED METHOD
    def check_content_empty(self, html_content):
        # *** ADDED CHECK ***
        # Prevent this from running and potentially overwriting content during load operations
        if getattr(self, 'is_loading_session', False) or getattr(self, '_conversion_load_in_progress', False):
             print("check_content_empty: Suppressed during active load/conversion.")
             return
        # *** END ADDED CHECK ***

        # Don't show empty state if we've verified content exists during load
        # (Keeping original check as well, though the above check is more direct)
        if getattr(self, '_verified_content', False):
            #print("check_content_empty: Suppressed as content was previously verified.")
            return

        try: # Added try/except for robustness
            soup = BeautifulSoup(html_content, 'html.parser')
            body_content = soup.body.get_text(strip=True) if soup.body else '' # Use strip=True

            # Check if body is truly empty or contains only whitespace
            if not body_content:
                print("check_content_empty: Body content is empty, injecting placeholder.")
                js_code = '''
                    document.body.innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 80vh; color: #6B7280; font-family: 'Segoe UI', sans-serif;">
                            <div style="font-size: 4rem; margin-bottom: 1rem;">📝</div>
                            <h2 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.5rem;">No Content Yet</h2>
                            <p style="text-align: center; font-size: 0.875rem; max-width: 28rem;">
                                Create a new transcript in the "Create Transcript" tab or load an existing session to get started.
                            </p>
                        </div>
                    `;
                '''
                # Add a small delay to ensure we're not in a race condition with other load events
                QTimer.singleShot(250, lambda: self.web_view.page().runJavaScript(js_code))
            else:
                # Optional: Log if content is present but maybe small
                # print(f"check_content_empty: Content found (length: {len(body_content)}). No placeholder needed.")
                pass

        except Exception as e:
            print(f"Error in check_content_empty: {e}")

    def create_preview_tab(self):
        self.preview_widget = QWidget()
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)


        # Create main horizontal splitter
        self.preview_splitter = QSplitter(Qt.Orientation.Horizontal)
        self.preview_splitter.setStyleSheet("""
            QSplitter::handle {
                background: #e0e0e0;
                width: 1px;
            }
        """)

        # Left side container for preview content
        left_container = QWidget()
        left_layout = QVBoxLayout(left_container)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.setSpacing(0)

        # Create search bar container
        search_container = QWidget()
        search_container.setStyleSheet("""
            QWidget {
                background-color: #f5f5f5;
                border-bottom: 1px solid #e0e0e0;
            }
        """)
        search_layout = QHBoxLayout(search_container)
        search_layout.setContentsMargins(10, 5, 10, 5)
        search_layout.setSpacing(5)

        # Create search input
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search in transcript...")
        self.search_input.setMaximumWidth(300)
        self.search_input.setStyleSheet("""
            QLineEdit {
                padding: 5px 10px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: white;
                font-size: 13px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
        """)
    
        # Create navigation buttons
        self.prev_button = QPushButton("▲")
        self.next_button = QPushButton("▼")
        self.close_search_button = QPushButton("✕")
    
        for button in [self.prev_button, self.next_button, self.close_search_button]:
            button.setFixedSize(28, 28)
            button.setStyleSheet("""
                QPushButton {
                    background-color: #ffffff;
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    font-size: 12px;
                    padding: 0px;
                }
                QPushButton:hover {
                    background-color: #f5f5f5;
                }
                QPushButton:pressed {
                    background-color: #e0e0e0;
                }
            """)

        # Add widgets to search layout
        search_layout.addWidget(self.search_input)
        search_layout.addWidget(self.prev_button)
        search_layout.addWidget(self.next_button)
        search_layout.addWidget(self.close_search_button)
        search_layout.addStretch()

        # Connect search signals
        self.search_input.textChanged.connect(self.handle_search)
        self.prev_button.clicked.connect(lambda: self.find_text(self.search_input.text(), False))
        self.next_button.clicked.connect(lambda: self.find_text(self.search_input.text(), True))
        self.close_search_button.clicked.connect(self.close_search)

        # Add search keyboard shortcuts
        search_shortcut = QShortcut(QKeySequence("Ctrl+F"), self)
        search_shortcut.activated.connect(self.focus_search)
    
        escape_shortcut = QShortcut(QKeySequence("Esc"), self)
        escape_shortcut.activated.connect(self.close_search)

        # Add search container to left layout
        left_layout.addWidget(search_container)

        # Initialize web view with proper settings
        self.web_view = TranscriptWebView(self)
        # Disable back/forward navigation with debug information
        back_action = self.web_view.pageAction(QWebEnginePage.WebAction.Back)
        forward_action = self.web_view.pageAction(QWebEnginePage.WebAction.Forward)

        # Connect to debug functions
        def debug_back_pressed():
            print("DEBUG: Back button pressed - Action suppressed")
            # Do nothing else to prevent navigation
    
        def debug_forward_pressed():
            print("DEBUG: Forward button pressed - Action suppressed")
            # Do nothing else to prevent navigation

        # Connect our debug functions
        back_action.triggered.connect(debug_back_pressed)
        forward_action.triggered.connect(debug_forward_pressed)

        self.web_view.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.web_view.js_handler.checkboxToggled.connect(self.on_checkbox_toggled)
        self.web_view.search_requested.connect(self.handle_theme_search)
        self.web_view.js_handler.bookmarkToggled.connect(self.handle_bookmark_toggle)

        # Set page settings to improve stability
        settings = self.web_view.settings()
        settings.setAttribute(self.web_view.settings().WebAttribute.LocalContentCanAccessRemoteUrls, False)
        settings.setAttribute(self.web_view.settings().WebAttribute.LocalContentCanAccessFileUrls, True)
        settings.setAttribute(self.web_view.settings().WebAttribute.ShowScrollBars, True)

        left_layout.addWidget(self.web_view)

        # Bottom container for buttons
        bottom_container = QWidget()
        bottom_container.setFixedHeight(60)
        bottom_container.setStyleSheet("border-top: 1px solid #CCCCCC;")  # Add top border
        bottom_layout = QHBoxLayout(bottom_container)
        bottom_layout.setContentsMargins(10, 5, 10, 10)
        bottom_layout.setSpacing(10)

        # Left side buttons container
        left_buttons = QWidget()
        left_buttons.setStyleSheet("QWidget { border: none; }")  # Explicitly set border to none
        left_layout_buttons = QHBoxLayout(left_buttons)
        left_layout_buttons.setContentsMargins(0, 0, 0, 0)
        left_layout_buttons.setSpacing(10)

        # Button style
        button_style = """
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                outline: none;
                padding: 8px 12px;
                border-radius: 5px;
                font-size: 14px;
                min-width: 120px;
                max-width: 120px;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
            QPushButton:pressed {
                background-color: #1A5E5C;
                outline: none;
            }
            QPushButton:checked {
                background-color: #1A5E5C;
            }
        """

        smaller_button_style = """
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                outline: none;
                padding: 8px 12px;
                border-radius: 5px;
                font-size: 14px;
                min-width: 100px;
                max-width: 100px;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
            QPushButton:pressed {
                background-color: #1A5E5C;
                outline: none;
            }
            QPushButton:checked {
                background-color: #1A5E5C;
            }
        """

        # Create Theme View image button
        self.view_annotations_button = QPushButton()

        # Create normal and hover icons
        self.theme_view_normal_icon = QIcon("Img/ThemeView-Button.png")
        self.theme_view_hover_icon = QIcon("Img/ThemeView-Button-Hover.png")

        # Set initial icon
        self.view_annotations_button.setIcon(self.theme_view_normal_icon)
        self.view_annotations_button.setIconSize(QSize(125, 55))
        self.view_annotations_button.setFixedSize(125, 55)
        self.view_annotations_button.setCheckable(True)

        # Create event filter for hover effects
        class ThemeViewButtonFilter(QObject):
            def __init__(self, button, normal_icon, hover_icon):
                super().__init__()
                self.button = button
                self.normal_icon = normal_icon
                self.hover_icon = hover_icon
    
            def eventFilter(self, obj, event):
                if obj == self.button:
                    if event.type() == QEvent.Type.Enter:
                        if not self.button.isChecked():  # Only change icon if not checked
                            self.button.setIcon(self.hover_icon)
                    elif event.type() == QEvent.Type.Leave:
                        if not self.button.isChecked():  # Only change icon if not checked
                            self.button.setIcon(self.normal_icon)
                return super().eventFilter(obj, event)

        # Install event filter
        self.theme_view_filter = ThemeViewButtonFilter(
            self.view_annotations_button, 
            self.theme_view_normal_icon, 
            self.theme_view_hover_icon
        )
        self.view_annotations_button.installEventFilter(self.theme_view_filter)

        # Connect toggle handler
        def handle_theme_view_toggle(checked):
            if checked:
                self.view_annotations_button.setIcon(self.theme_view_hover_icon)
            else:
                self.view_annotations_button.setIcon(self.theme_view_normal_icon)

        self.view_annotations_button.toggled.connect(handle_theme_view_toggle)
        self.view_annotations_button.setStyleSheet("""
            QPushButton { 
                border: none; 
                background: transparent;
            }
        """)
        self.view_annotations_button.setCursor(Qt.CursorShape.PointingHandCursor)  # Set pointing hand cursor
        self.view_annotations_button.clicked.connect(self.toggle_theme_view)
        left_layout_buttons.addWidget(self.view_annotations_button)

        # Add Script Editor button after Theme Panel
        self.add_storyboard_button_to_layout(left_layout_buttons)

        # Create Manage Tags button with same style as other buttons
        self.tag_button = QPushButton()
        self.normal_tag_icon = QIcon("Img/tag.png")
        self.hover_tag_icon = QIcon("Img/tag-hover.png")
        
        # Initialize tag dialog tracking
        self.tag_dialog = None
        
        # Set icon and size to match other buttons in the bar
        self.tag_button.setIcon(self.normal_tag_icon)
        self.tag_button.setIconSize(QSize(125, 55))  # Same size as Edit Themes
        self.tag_button.setFixedSize(125, 55)  # Same size as Edit Themes
        self.tag_button.setCheckable(True)  # Enable toggle state like other buttons
        
        # Apply same styling as other buttons
        self.tag_button.setStyleSheet("QPushButton { border: none; background: transparent; }")
        self.tag_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.tag_button.setToolTip("Manage Tags (0)")
        
        # Create event filter for hover effects (same pattern as other buttons)
        class TagButtonEventFilter(QObject):
            def __init__(self, button, normal_icon, hover_icon):
                super().__init__()
                self.button = button
                self.normal_icon = normal_icon
                self.hover_icon = hover_icon
        
            def eventFilter(self, obj, event):
                if obj == self.button:
                    if event.type() == QEvent.Type.Enter:
                        if not self.button.isChecked():  # Only change on hover if not checked
                            self.button.setIcon(self.hover_icon)
                    elif event.type() == QEvent.Type.Leave:
                        if not self.button.isChecked():  # Only change on leave if not checked
                            self.button.setIcon(self.normal_icon)
                return super().eventFilter(obj, event)
        
        # Install event filter
        self.tag_button_filter = TagButtonEventFilter(self.tag_button, self.normal_tag_icon, self.hover_tag_icon)
        self.tag_button.installEventFilter(self.tag_button_filter)
        
        # Connect toggle handler (same pattern as other buttons)
        def handle_tag_toggle(checked):
            if checked:
                self.tag_button.setIcon(self.hover_tag_icon)
            else:
                self.tag_button.setIcon(self.normal_tag_icon)
        
        self.tag_button.toggled.connect(handle_tag_toggle)
        self.tag_button.clicked.connect(self.toggle_tag_dialog)
        
        # Create Edit Themes image button
        self.color_key_button = QPushButton()
        self.edit_themes_normal_icon = QIcon("Img/EditThemes.png")
        self.edit_themes_hover_icon = QIcon("Img/EditThemes-Hover.png")

        # Set initial icon
        self.color_key_button.setIcon(self.edit_themes_normal_icon)
        self.color_key_button.setIconSize(QSize(125, 55))
        self.color_key_button.setFixedSize(125, 55)
        self.color_key_button.setCheckable(True)

        # Create event filter for hover effects
        class EditThemesButtonFilter(QObject):
            def __init__(self, button, normal_icon, hover_icon):
                super().__init__()
                self.button = button
                self.normal_icon = normal_icon
                self.hover_icon = hover_icon

            def eventFilter(self, obj, event):
                if obj == self.button:
                    if event.type() == QEvent.Type.Enter:
                        if not self.button.isChecked():
                            self.button.setIcon(self.hover_icon)
                    elif event.type() == QEvent.Type.Leave:
                        if not self.button.isChecked():
                            self.button.setIcon(self.normal_icon)
                return super().eventFilter(obj, event)

        # Install event filter
        self.edit_themes_filter = EditThemesButtonFilter(
            self.color_key_button,
            self.edit_themes_normal_icon,
            self.edit_themes_hover_icon
        )
        self.color_key_button.installEventFilter(self.edit_themes_filter)

        # Connect toggle handler
        def handle_edit_themes_toggle(checked):
            if checked:
                self.color_key_button.setIcon(self.edit_themes_hover_icon)
            else:
                self.color_key_button.setIcon(self.edit_themes_normal_icon)

        self.color_key_button.toggled.connect(handle_edit_themes_toggle)
        self.color_key_button.setStyleSheet("QPushButton { border: none; background: transparent; }")
        self.color_key_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.color_key_button.clicked.connect(self.toggle_color_key_and_manage_themes)

        # Create Bookmarks image button
        self.bookmark_button = QPushButton()
        self.bookmarks_normal_icon = QIcon("Img/Bookmark-Panel.png")
        self.bookmarks_hover_icon = QIcon("Img/Bookmark-Panel-Hover.png")

        # Set initial icon
        self.bookmark_button.setIcon(self.bookmarks_normal_icon)
        self.bookmark_button.setIconSize(QSize(125, 55))
        self.bookmark_button.setFixedSize(125, 55)
        self.bookmark_button.setCheckable(True)

        # Create event filter for hover effects
        class BookmarksButtonFilter(QObject):
            def __init__(self, button, normal_icon, hover_icon):
                super().__init__()
                self.button = button
                self.normal_icon = normal_icon
                self.hover_icon = hover_icon
    
            def eventFilter(self, obj, event):
                if obj == self.button:
                    if event.type() == QEvent.Type.Enter:
                        if not self.button.isChecked():
                            self.button.setIcon(self.hover_icon)
                    elif event.type() == QEvent.Type.Leave:
                        if not self.button.isChecked():
                            self.button.setIcon(self.normal_icon)
                return super().eventFilter(obj, event)

        # Install event filter
        self.bookmarks_filter = BookmarksButtonFilter(
            self.bookmark_button, 
            self.bookmarks_normal_icon, 
            self.bookmarks_hover_icon
        )
        self.bookmark_button.installEventFilter(self.bookmarks_filter)

        # Connect toggle handler
        def handle_bookmarks_toggle(checked):
            if checked:
                self.bookmark_button.setIcon(self.bookmarks_hover_icon)
            else:
                self.bookmark_button.setIcon(self.bookmarks_normal_icon)

        self.bookmark_button.toggled.connect(handle_bookmarks_toggle)
        self.bookmark_button.setStyleSheet("QPushButton { border: none; background: transparent; }")
        self.bookmark_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.bookmark_button.clicked.connect(self.toggle_bookmark_panel)
        left_layout_buttons.addWidget(self.bookmark_button)
        
        # Add Edit Themes button
        left_layout_buttons.addWidget(self.color_key_button)
        

        bottom_layout.addWidget(left_buttons)
        bottom_layout.addStretch()

        # Mode toggle container
        self.mode_container = QWidget(bottom_container)
        self.mode_container.setStyleSheet("QWidget { border: none; }")  # Add this line to remove border
        self.mode_container.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        mode_layout = QHBoxLayout(self.mode_container)
        mode_layout.setContentsMargins(0, 5, 0, 0)
        mode_layout.setSpacing(10)

        # Add tag button back to mode layout with adjusted styling
        if hasattr(self, 'tag_button'):
            # Make it slightly smaller and push it up
            self.tag_button.setFixedSize(110, 45)  # Slightly smaller than 125x55
            self.tag_button.setIconSize(QSize(110, 45))
            self.tag_button.setStyleSheet("""
                QPushButton { 
                    border: none; 
                    background: transparent;
                    margin-top: -5px;
                }
            """)
            mode_layout.addWidget(self.tag_button)

        # Mode indicator label
        self.mode_indicator = QLabel('Highlight Mode')
        self.mode_indicator.setStyleSheet("""
            QLabel {
                padding: 6px 12px;
                border-radius: 4px;
                font-weight: 500;
                font-size: 13px;
                background-color: #EBF5FF;
                color: #1D4ED8;
            }
        """)
        mode_layout.addWidget(self.mode_indicator)

        # Mode toggle button
        self.mode_toggle_button = QPushButton('⇄')
        self.mode_toggle_button.setCheckable(True)
        self.mode_toggle_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #1D4ED8;
                border: none;
                padding: 0px 0px;
                border-radius: 5px;
                font-size: 30px;
                min-width: 40px;
            }
            QPushButton:hover {
                background-color: transparent;
                color: purple;
            }
            QPushButton:pressed, QPushButton:checked {
                background-color: transparent;
                color: purple;
            }
        """)
        self.mode_toggle_button.clicked.connect(self.toggle_mode)
        mode_layout.addWidget(self.mode_toggle_button)

        # Add mode container to bottom layout
        bottom_layout.addWidget(self.mode_container)

        # Ensure mode container stays visible
        self.mode_container.setVisible(True)
        self.mode_container.raise_()

        left_layout.addWidget(bottom_container)

        # Add containers to splitter
        self.preview_splitter.addWidget(left_container)

        # Create and add right panel container
        self.right_panel_container = self.create_right_panel_container()
        self.preview_splitter.addWidget(self.right_panel_container)

        # Add splitter to main layout
        layout.addWidget(self.preview_splitter)
        self.preview_widget.setLayout(layout)
        self.tabs.addTab(self.preview_widget, 'View Transcript')

        # Initialize the right panel container as hidden
        self.right_panel_container.hide()

        # Initialize web view with empty content
        self.web_view.setHtml('')

        self.web_view.content_changed.connect(self.check_content_empty)
        self.check_content_empty('')  # Show placeholder initially

    def handle_search(self):
        """Handle search text changes"""
        text = self.search_input.text()
        if text:
            self.find_text(text)
        else:
            self.close_search()  # Clear highlights when search is empty

    def find_text(self, text, forward=True):
        """Find text in the web view"""
        if text:
            self.web_view.findText(
                text,
                QWebEnginePage.FindFlag.FindBackward if not forward else QWebEnginePage.FindFlag(0),
                lambda found: self.handle_find_result(found)
            )


    def handle_theme_search(self, text):
        """Handle search request from web view"""
        try:
            # If theme view isn't open or isn't visible
            if not self.theme_view or not self.theme_view.isVisible():
                # Set the button state to checked AND call toggle_theme_view
                self.view_annotations_button.setChecked(True)
                self.toggle_theme_view()
            
                # Give the UI a moment to update
                QTimer.singleShot(100, lambda: self._perform_theme_search(text))
            else:
                self._perform_theme_search(text)
            
        except Exception as e:
            print(f"Error handling theme search: {e}")

    def _perform_theme_search(self, text):
        """Perform the actual search in theme view"""
        print(f"=== _perform_theme_search called ===")  # Indicate the function is called
        try:
            print(f"  Received search text: '{text}'")  # Print the received text

            if not text.strip():
                print("  Search text is empty or whitespace. Returning.")
                return  # Exit if the search text is empty or just whitespace

            search_widget = self.theme_view.findChild(ThemeViewSearch)
            if not search_widget:
                print("  Error: Search widget not found in theme view.")
                return

            print(f"  Found search widget: {type(search_widget)}")  # Print the type of the found widget

            # --- Check for Placeholder and Clear Search ---
            if self.window().scene_tabs.tabText(0) == "No Results":  # Assuming placeholder tab has this text
                print("  Placeholder is showing. Clearing search first.")
                search_widget.clear_search()

                print(f"  Setting search input text to: '{text}'")
                search_widget.search_input.setText(text)

                print("  Starting QTimer for force_search (placeholder case)...")
                # Create a single-shot QTimer to call force_search after a short delay (e.g., 200 milliseconds)
                QTimer.singleShot(200, search_widget.force_search)
            # -----------------------------------------------
            else:
                print(f"  Setting search input text to: '{text}'")
                search_widget.search_input.setText(text)
                search_widget.force_search()

        except Exception as e:
            print(f"  Error performing theme search: {e}")

    def request_theme_search(self, text):
        """Request a search in the theme view with the selected text"""
        try:
            # Get main window
            main_window = self.window()
            if not main_window or not hasattr(main_window, 'theme_view') or not main_window.theme_view:
                self.toggle_theme_view()
                QTimer.singleShot(100)
                return
            
            # Strip HTML tags
            clean_text = re.sub(r'<[^>]+>', '', text)
            # Remove any extra whitespace and normalize
            clean_text = ' '.join(clean_text.split())
        
            if not clean_text.strip():
                return
            
            self.search_requested.emit(clean_text)
        
        except Exception as e:
            print(f"Error requesting theme search: {e}")

    def handle_find_result(self, found):
        """Handle the result of a find operation"""
        if found:
            self.search_input.setStyleSheet("""
                QLineEdit {
                    padding: 5px 10px;
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    background: white;
                    font-size: 13px;
                }
                QLineEdit:focus {
                    border-color: #2196F3;
                }
            """)
        else:
            self.search_input.setStyleSheet("""
                QLineEdit {
                    padding: 5px 10px;
                    border: 1px solid #e0e0e0;
                    border-radius: 4px;
                    background: #ffe0e0;
                    font-size: 13px;
                }
                QLineEdit:focus {
                    border-color: #2196F3;
                }
            """)

    def focus_search(self):
        """Focus the search input and select any existing text"""
        self.search_input.setFocus()
        self.search_input.selectAll()

    def close_search(self):
        """Close the search functionality"""
        self.search_input.clear()
        self.web_view.findText("")  # Clear any highlighting
        self.search_input.setStyleSheet("""
            QLineEdit {
                padding: 5px 10px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                background: white;
                font-size: 13px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
        """)

    def add_annotation_to_theme_view_direct(self, annotation_dict):
        """Direct method to add annotation to theme view without signal/slot complexity."""
        # FIXED: Only check if theme_view exists, not if it's visible
        # This allows annotations to be created even when theme view is hidden
        if not (hasattr(self, 'theme_view') and self.theme_view and hasattr(self, 'scene_tabs') and self.scene_tabs):
            return
            
        # If an empty-state overlay is showing, hide it before adding items
        try:
            if hasattr(self, 'script_search') and self.script_search:
                self.script_search._hide_placeholder_overlay()
        except Exception:
            pass

        scene = annotation_dict.get('scene', '')
        if not scene:
            return
            
        annotation_id = annotation_dict.get('id')
        text = annotation_dict.get('text', '')
        
        # Find or create scene tab
        existing_tab_index = -1
        prev_tab_count = self.scene_tabs.count()

        # If this is the very first annotation and theme view is visible, rebuild via update_theme_view
        try:
            if prev_tab_count == 0 and self.theme_view.isVisible():
                print("[DEBUG] First annotation detected with visible theme view -> calling update_theme_view")
                # Use the main window's builder to keep everything consistent
                self.update_theme_view(show_progress=False)
                return
        except Exception:
            pass
        for i in range(self.scene_tabs.count()):
            if self.scene_tabs.tabText(i) == scene:
                existing_tab_index = i
                break
                
        if existing_tab_index != -1:
            scene_tab = self.scene_tabs.widget(existing_tab_index)
        else:
            # Create new tab
            scene_tab = AnnotationListWidget()
            ordered_scenes = list(self.parent().scene_styles.keys()) if hasattr(self.parent(), 'scene_styles') else []
            scene_tab_index = ordered_scenes.index(scene) if scene in ordered_scenes else self.scene_tabs.count()
            self.scene_tabs.insertTab(scene_tab_index, scene_tab, scene)
            # Ensure the new tab is visible and styled
            try:
                if hasattr(self.scene_tabs, 'colored_tab_bar') and hasattr(self.parent(), 'scene_styles'):
                    self.scene_tabs.colored_tab_bar.update_scene_style(scene, self.parent().scene_styles.get(scene, {}))
                    self.scene_tabs.colored_tab_bar.update()
            except Exception:
                pass
            
        # Add annotation to theme view
        notes_content = {
            'plain': annotation_dict.get('notes', ''),
            'html': annotation_dict.get('notes_html', annotation_dict.get('notes', ''))
        }
        
        item = scene_tab.add_item_with_checkbox(
            text=text,
            annotation_id=annotation_id,
            is_used=annotation_dict.get('used', False),
            notes=notes_content['plain'],
            notes_html=notes_content['html'],
            is_favorite=annotation_dict.get('favorite', False),
            tags=annotation_dict.get('tags', []),
            speech_title=annotation_dict.get('speech_title', '')
        )
        
        # Update notes button icon state for the newly added item
        if item:
            item_widget = scene_tab.itemWidget(item)
            print(f"DEBUG ICON: item_widget found: {item_widget is not None}")
            if item_widget:
                edit_notes_btn = item_widget.findChild(QPushButton, "editNotesButton")
                print(f"DEBUG ICON: edit_notes_btn found: {edit_notes_btn is not None}")
                print(f"DEBUG ICON: scene_tab has _cached_icons: {hasattr(scene_tab, '_cached_icons')}")
                
                if edit_notes_btn:
                    if hasattr(scene_tab, '_cached_icons'):
                        print(f"DEBUG ICON: cached icons available: {list(scene_tab._cached_icons.keys())}")
                        # Check if notes are empty (same logic as existing code)
                        def is_notes_empty(notes_html_str):
                            if not notes_html_str:
                                return True
                            from bs4 import BeautifulSoup
                            soup = BeautifulSoup(notes_html_str, 'html.parser')
                            text_content = soup.get_text(strip=True)
                            return not text_content
                        
                        has_notes = not is_notes_empty(notes_content['html'])  # Only check HTML notes for book icon
                        print(f"DEBUG ICON: has_notes={has_notes}, html_len={len(notes_content['html'])} (book icon only checks notes_html)")
                        
                        if has_notes:
                            old_icon = edit_notes_btn.icon()
                            edit_notes_btn.setIcon(scene_tab._cached_icons['notes']['active'])
                            new_icon = edit_notes_btn.icon()
                            print(f"DEBUG ICON: Set notes icon to active for direct add - old_icon={old_icon}, new_icon={new_icon}")
                        else:
                            old_icon = edit_notes_btn.icon()
                            edit_notes_btn.setIcon(scene_tab._cached_icons['notes']['normal'])
                            new_icon = edit_notes_btn.icon()
                            print(f"DEBUG ICON: Set notes icon to normal for direct add - old_icon={old_icon}, new_icon={new_icon}")
                    else:
                        print(f"DEBUG ICON: _cached_icons not available - cannot update icon")
        
        print(f"DEBUG: Added annotation {annotation_id} directly to theme view with icon update")

        # If there were no tabs before, switch to the newly created/target tab so the user sees it
        try:
            if prev_tab_count == 0:
                # Find the tab index for the scene again and select it
                for i in range(self.scene_tabs.count()):
                    if self.scene_tabs.tabText(i) == scene:
                        self.scene_tabs.setCurrentIndex(i)
                        break
        except Exception:
            pass

        # Apply current filters so the new item is considered and overlay updates appropriately
        try:
            if hasattr(self, 'script_search') and self.script_search:
                # Run immediately and once more on the next tick for safety
                self.script_search.apply_current_filters()
                QTimer.singleShot(0, self.script_search.apply_current_filters)
        except Exception:
            pass

        # Nudge layout/paint so the list updates without requiring a manual toggle
        try:
            self.scene_tabs.update()
            if existing_tab_index != -1:
                scene_tab.updateGeometry()
            QApplication.processEvents()
        except Exception:
            pass

    def handle_annotation_added(self, annotation_info, triggered_by_removal=False):
        """Handle real-time addition of annotations to the script view, preventing duplicates."""
        try:
            print("\n=== DEBUG: Entering handle_annotation_added ===")
            print(f"Annotation: {annotation_info}")

            info = json.loads(annotation_info)
            annotation_id = info.get('id')
            scene = info['scene']
            text = info['text']
            
            # During reassignment: allow storyboard signals but skip theme view updates
            in_reassignment = getattr(self, '_in_reassignment_context', False)
            if in_reassignment:
                print(f"DEBUG: In reassignment context - allowing storyboard processing but skipping theme view for {annotation_id}")
                # Continue processing for storyboard signals, but skip theme view later
            
            # Initialize deduplication set if it doesn't exist
            if not hasattr(self, '_just_added'):
                self._just_added = set()
                
            # Guard against duplicate "added" events
            if annotation_id in self._just_added:
                print(f"=== DEBUG: Skipping duplicate annotation event for ID {annotation_id} ===")
                return
                
            self._just_added.add(annotation_id)
            # Schedule removal from deduplication set after a brief delay
            QTimer.singleShot(100, lambda: self._just_added.discard(annotation_id))
            
            # Process annotation addition normally (no more delete+add sequences)
            self.handle_annotation_added_internal(annotation_info, triggered_by_removal)
            
        except Exception as e:
            print(f"Error handling annotation addition: {e}")
            print("\n=== DEBUG: Exception Traceback ===")
            import traceback
            print(traceback.format_exc())

    def handle_annotation_added_internal(self, annotation_info, triggered_by_removal=False):
        """Internal method that handles the actual annotation addition logic"""
        try:
            print("\n=== DEBUG: Entering handle_annotation_added_internal ===")
            print(f"Annotation: {annotation_info}")

            # Check if we're in reassignment context to avoid duplicates
            in_reassignment = getattr(self, '_in_reassignment_context', False)
            print(f"🔍🔍🔍 REASSIGNMENT FLAG CHECK: in_reassignment={in_reassignment}")
            print(f"🔍🔍🔍 SELF OBJECT: {type(self).__name__}")
            print(f"🔍🔍🔍 HAS FLAG: {hasattr(self, '_in_reassignment_context')}")
            if hasattr(self, '_in_reassignment_context'):
                print(f"🔍🔍🔍 FLAG VALUE: {self._in_reassignment_context}")

            info = json.loads(annotation_info)
            scene = info['scene']
            text = info['text']
            annotation_id = info.get('id')

            # Prevent adding the same annotation twice from a single highlight
            for i in range(self.scene_tabs.count()):
                list_widget = self.scene_tabs.widget(i)
                if isinstance(list_widget, AnnotationListWidget):
                    for j in range(list_widget.count()):
                        item = list_widget.item(j)
                        item_widget = list_widget.itemWidget(item)
                        if item_widget:
                            existing_id = item.data(Qt.ItemDataRole.UserRole)
                            if existing_id == annotation_id:
                                print(f"=== DEBUG: Skipping duplicate annotation with ID {annotation_id} ===")
                                # Ensure we remove from deduplication set even when skipping
                                if hasattr(self, '_just_added'):
                                    self._just_added.discard(annotation_id)
                                return  # Prevent double addition

            # Check if the current tab is a "No Results" placeholder
            current_tab_count = self.scene_tabs.count()
            has_placeholder = False
            for i in range(current_tab_count):
                if self.scene_tabs.tabText(i) == "No Results":
                    has_placeholder = True
                    break
                
            # If placeholder exists, clear all tabs to start fresh
            if has_placeholder:
                print("=== DEBUG: Found placeholder tab, clearing all tabs ===")
                with QSignalBlocker(self.scene_tabs):
                    self.scene_tabs.clear()

            # Extract selection info if available
            selection_info = info.get('selectionInfo')
            if selection_info:
                print(f"\n=== DEBUG: Retrieved Selection Info ===")
                print(f"Selection Info: {json.dumps(selection_info, indent=2)}")

            # Store current state if theme view is visible
            current_tab = None
            scroll_positions = {}
            selected_items = {}
            current_states = {}

            if self.theme_view and self.theme_view.isVisible():
                current_tab = self.scene_tabs.currentIndex()
                print(f"\n=== DEBUG: Current Tab Index === {current_tab}")

                # Store scroll position, selected items, and current state for each tab
                for i in range(self.scene_tabs.count()):
                    list_widget = self.scene_tabs.widget(i)
                    if isinstance(list_widget, AnnotationListWidget):
                        scroll_positions[i] = list_widget.verticalScrollBar().value()
                        selected_items[i] = []
                        current_states[i] = []

                        for j in range(list_widget.count()):
                            item = list_widget.item(j)
                            item_widget = list_widget.itemWidget(item)
                            if item_widget:
                                label = item_widget.findChild(QLabel)
                                notes_edit = item_widget.findChild(QLineEdit)
                                item_id = item.data(Qt.ItemDataRole.UserRole)
                                checkbox = item_widget.findChild(CustomCheckBox)
                                star_button = item_widget.property('cached_star_button')

                                current_states[i].append({
                                    'text': label.text() if label else '',
                                    'notes': notes_edit.text() if notes_edit else '',
                                    'notes_html': notes_edit.property('notes_html') if notes_edit else '',
                                    'id': item_id,
                                    'selected': item.isSelected(),
                                    'used': checkbox.isChecked() if checkbox else False,
                                    'favorite': star_button.isChecked() if star_button else False,
                                    'storyboard': json.loads(json.dumps(item_widget.property('storyboard'))) if item_widget.property('storyboard') else {'order': 0},
                                    'order': item_widget.property('order')
                                })

                                # Maintain compatibility with previous selected items tracking
                                if item.isSelected():
                                    selected_items[i].append({
                                        'text': label.text(),
                                        'notes': notes_edit.text() if notes_edit else '',
                                        'notes_html': notes_edit.property('notes_html') if notes_edit else '',
                                        'id': item_id,
                                        'storyboard': json.loads(json.dumps(item_widget.property('storyboard'))) if item_widget.property('storyboard') else {'order': 0},
                                        'order': item_widget.property('order')
                                    })

                #print("\n=== DEBUG: UI State Before Update ===")
                #print(f"Scroll Positions: {scroll_positions}")
                #print(f"Selected Items: {selected_items}")
                #print(f"Current States: {current_states}")

            # Get ordered scenes and find the appropriate tab
            ordered_scenes = list(self.web_view.scene_styles.keys())
            scene_tab_index = ordered_scenes.index(scene) if scene in ordered_scenes else len(ordered_scenes)

            # Update theme view if visible
            if self.theme_view and self.theme_view.isVisible():
                # Find or create a tab for this scene
                existing_tab_index = -1
                for i in range(self.scene_tabs.count()):
                    if self.scene_tabs.tabText(i) == scene:
                        existing_tab_index = i
                        break

                # If the tab already exists, use it; otherwise, create a new tab
                if existing_tab_index != -1:
                    scene_tab = self.scene_tabs.widget(existing_tab_index)
                    scene_tab_index = existing_tab_index
                    print(f"=== DEBUG: Using Existing Tab for Scene {scene} ===")
                else:
                    scene_tab = AnnotationListWidget()
                    self.scene_tabs.insertTab(scene_tab_index, scene_tab, scene)
                    print(f"=== DEBUG: Created New Tab for Scene {scene} ===")

                # Add the annotation item to the tab (skip only during reassignment - targeted updates handle it)  
                # Use the reassignment flag we already detected above
                if not in_reassignment:
                    print(f"=== DEBUG: Adding annotation to scene '{scene}' (tab index {scene_tab_index}) ===")
                    print(f"=== DEBUG: Annotation tags: {info.get('tags', [])} ===")
                    scene_tab.add_item_with_checkbox(
                        text,
                        annotation_id,
                        info.get('used', False),
                        info.get('notes', ''),
                        info.get('notes_html', ''),
                        info.get('favorite', False),
                        info.get('tags', []),
                        info.get('speech_title', '')
                    )
                    print(f"=== DEBUG: Annotation added to tab. Total items in tab: {scene_tab.count()} ===")
                    
                    # Verify the annotation was actually added
                    last_item = scene_tab.item(scene_tab.count() - 1)
                    if last_item:
                        last_item_id = last_item.data(Qt.ItemDataRole.UserRole)
                        print(f"=== DEBUG: Last item in tab has ID: {last_item_id} (expected: {annotation_id}) ===")
                    else:
                        print("=== DEBUG: ERROR - No last item found in tab after addition ===")
                else:
                    print(f"DEBUG: Skipping theme view addition during reassignment for {annotation_id} - targeted updates handle it")
        
                # Filter check is now handled in navigation logic below - no need to call update_theme_view
                # The annotation has been properly added and will be filtered by existing mechanisms
            
                # Restore state with all necessary information
                for i in range(self.scene_tabs.count()):
                    widget = self.scene_tabs.widget(i)
                    if widget is not None:
                        self.restore_theme_view_state(scroll_positions, selected_items, current_states)
                    else:
                        print(f"=== DEBUG: Skipping restoration for tab {i} due to missing widget ===")

                # Check if filters are active before navigation - prevent navigating to filtered annotations
                search_widget = self.theme_view.findChild(ThemeViewSearch)
                filters_active = False
                
                if search_widget:
                    active_search = bool(getattr(search_widget, 'current_search_text', "")) and getattr(search_widget, 'search_confirmed', False)
                    favorites_only = getattr(search_widget, 'favorites_only', False)
                    hide_used = getattr(search_widget, 'hide_used', 0)
                    selected_tags = getattr(search_widget, 'selected_tags', set())
                    selected_headers = getattr(search_widget, 'selected_headers', set())
                    
                    filters_active = active_search or favorites_only or hide_used != 0 or selected_tags or selected_headers
                    print(f"=== DEBUG NAVIGATION: search={active_search}, favorites={favorites_only}, hide_used={hide_used}, tags={selected_tags}, headers={selected_headers}, filters_active={filters_active} ===")
                else:
                    print(f"=== DEBUG NAVIGATION: No search widget found ===")
                
                # Adjust current tab and scroll position ONLY if no filters are active
                if scene_tab_index >= 0 and not filters_active:
                    print(f"=== DEBUG: Tab switched to index {scene_tab_index} ===")
                    self.scene_tabs.setCurrentIndex(scene_tab_index)
                    scene_widget = self.scene_tabs.widget(scene_tab_index)
                    if scene_widget:
                        print(f"=== DEBUG: Scrolling to existing tab {scene_tab_index} for scene {scene} ===")
                        QTimer.singleShot(100, lambda: scene_widget.scrollToBottom())
                    else:
                        print("=== DEBUG: Scene widget not found, unable to scroll to bottom ===")
                elif filters_active:
                    print(f"=== DEBUG: NAVIGATION SKIPPED - Filters are active, not navigating to annotation that would be filtered ===")
                else:
                    print(f"=== DEBUG: NAVIGATION SKIPPED - Invalid scene_tab_index: {scene_tab_index} ===)")

                self.update_current_tab_item_sizes()
                self.scene_tabs.update_scene_styles(self.web_view.scene_styles)

            # ✅ CRITICAL FIX: Ensure selection info is properly stored
            if selection_info and annotation_id:
                for annotation in self.web_view.annotations:
                    if annotation['id'] == annotation_id:
                        annotation['selectionInfo'] = selection_info
                        break

            # ✅ CRITICAL FIX: Only update the storyboard dialog if necessary
            # IMPORTANT: Storyboard updates must happen even during reassignment to detect splits
            print(f"DEBUG: Checking storyboard dialog - exists: {self.storyboard_dialog is not None}, in_reassignment: {in_reassignment}")
            if self.storyboard_dialog:
                # Update general properties of the storyboard dialog
                self.storyboard_dialog.scene_styles = self.web_view.scene_styles
                self.storyboard_dialog.annotations = self.web_view.annotations
                self.storyboard_dialog.order_list.scene_styles = self.web_view.scene_styles
                #self.storyboard_dialog.reset_state()
                
                # Only call populate_order_list() if the annotation has an order number or removal was triggered
                should_update_order_list = False

                # Check if we're in reassignment context - storyboard needs to see splits
                if in_reassignment:
                    should_update_order_list = True
                    print("=== DEBUG: Updating order list because we're in reassignment context - storyboard needs to detect splits ===")
                # Check if this was triggered by a removal operation (which might affect order)
                elif triggered_by_removal:
                    should_update_order_list = True
                    print("=== DEBUG: Updating order list because operation was triggered by removal ===")
                else:
                    # Check for order in the info dict
                    if 'order' in info and info['order'] is not None:
                        should_update_order_list = True
                        print(f"=== DEBUG: Updating order list because annotation info has order={info['order']} ===")
                    # Check for order in the storyboard property in the info dict
                    elif 'storyboard' in info and isinstance(info['storyboard'], dict) and 'order' in info['storyboard'] and info['storyboard']['order'] is not None:
                        should_update_order_list = True
                        print(f"=== DEBUG: Updating order list because annotation info has storyboard order={info['storyboard']['order']} ===")
                    # Check the actual annotation object for an order property (both directly and in storyboard)
                    elif annotation_id:
                        for annotation in self.web_view.annotations:
                            if annotation['id'] == annotation_id:
                                # Check direct order property
                                if 'order' in annotation and annotation['order'] is not None:
                                    should_update_order_list = True
                                    print(f"=== DEBUG: Updating order list because found direct order={annotation['order']} in annotations list ===")
                                    break
                                # Check order in storyboard
                                elif 'storyboard' in annotation and isinstance(annotation['storyboard'], dict) and 'order' in annotation['storyboard'] and annotation['storyboard']['order'] is not None:
                                    should_update_order_list = True
                                    print(f"=== DEBUG: Updating order list because found storyboard order={annotation['storyboard']['order']} in annotations list ===")
                                    break

                # MOVED OUTSIDE: Set the flag based on the decision above
                if should_update_order_list:
                    # Instead of actually calling populate_order_list here,
                    # store a flag somewhere globally or on `self.web_view`
                    self.web_view.last_update_order_list_flag = True
                    print(f"🟢 FLAG SET TO TRUE for annotation {annotation_id} - should_update_order_list: {should_update_order_list}")
                    print("=== DEBUG: Order list property detected in handle annotation added, will populate that LIST! ===")
                else:
                    # During reassignment, NEVER reset the flag - preserve it for the final check
                    if not in_reassignment:
                        self.web_view.last_update_order_list_flag = False
                    else:
                        print(f"🔵 FLAG PRESERVED during reassignment for annotation {annotation_id} (flag currently: {getattr(self.web_view, 'last_update_order_list_flag', False)})")
                    print(f"=== DEBUG: Skipping order list population since annotation has no order property (in_reassignment: {in_reassignment}) ===")

            # Mark changes as pending and update the window title
            self.mark_changes_pending()
            if not self.windowTitle().startswith('*'):
                self.setWindowTitle('*' + self.windowTitle())

            self.status_bar.showMessage(f'Added annotation to {scene}', 3000)
            print("\n=== DEBUG: Annotation Added Successfully ===")
            
            # TOOLTIP FIX: Efficient tooltip initialization for first highlight only
            if not hasattr(self.web_view, '_tooltips_initialized') or not self.web_view._tooltips_initialized:
                print("First annotation added - initializing tooltips...")
                QTimer.singleShot(10, self.web_view.debug_and_fix_tooltips)
                self.web_view._tooltips_initialized = True
            else:
                # For subsequent annotations, just ensure the new span gets event listeners
                print("Subsequent annotation - ensuring tooltip event listeners are attached...")
                self.web_view._attach_tooltip_listeners_to_new_spans()

        except Exception as e:
            print(f"Error handling annotation addition: {e}")
            print("\n=== DEBUG: Exception Traceback ===")
            import traceback
            print(traceback.format_exc())

    def handle_reassignment_completed(self, new_annotation_ids):
        """
        Handle the completion of annotation reassignment.
        This method is called synchronously via signal/slot mechanism,
        ensuring all annotation data is stable before updating the storyboard.
        
        Args:
            new_annotation_ids (list): List of annotation IDs that were newly created during reassignment
        """
        print(f"=== DEBUG: handle_reassignment_completed called with {len(new_annotation_ids)} new annotation IDs: {new_annotation_ids} ===")
        
        # Check if we need to update the storyboard based on the flag
        flag_value = getattr(self.web_view, 'last_update_order_list_flag', False)
        print(f"🔍 REASSIGNMENT COMPLETION FLAG CHECK: {flag_value}")
        
        if flag_value and hasattr(self, 'storyboard_dialog') and self.storyboard_dialog:
            print("🔥 POPULATE ORDER LIST via SIGNAL - Data guaranteed fresh")
            
            # Store the new annotation IDs for selection after population
            self.storyboard_dialog._pending_selection_ids = new_annotation_ids.copy()
            
            # Ensure dialog has fresh data reference
            self.storyboard_dialog.annotations = self.web_view.annotations
            
            # Call populate_order_list_and_improve_strikethroughs synchronously
            # No timers needed - signal ensures sequential execution
            self.storyboard_dialog.populate_order_list_and_improve_strikethroughs()
            
            # Reset the flag after successful update
            self.web_view.last_update_order_list_flag = False
            print("=== DEBUG: Successfully updated storyboard via reassignment signal ===")
        else:
            print("=== DEBUG: Skipping storyboard update - no flag or no dialog ===")

    def handle_annotation_deleted(self, deletion_info_json):
            """Handle real-time deletion of annotations from the script view"""
            try:
                deletion_info = json.loads(deletion_info_json)
                scene = deletion_info['scene']
                text = deletion_info['text']
                annotation_id = deletion_info.get('id')
                
                # NOTE: Both beginning and end text removal now use UPDATE pattern - no delete+add sequences
            
                # Store current state
                current_tab = self.scene_tabs.currentIndex()
                scroll_positions = {}
                selected_items = {}
            
                # Store state for each tab
                for i in range(self.scene_tabs.count()):
                    list_widget = self.scene_tabs.widget(i)
                    if isinstance(list_widget, AnnotationListWidget):
                        scroll_positions[i] = list_widget.verticalScrollBar().value()
                        selected_items[i] = [
                            list_widget.itemWidget(list_widget.item(j)).findChild(QLabel).text()
                            for j in range(list_widget.count())
                            if list_widget.item(j).isSelected()
                        ]
            
                # Find the tab for this scene
                for i in range(self.scene_tabs.count()):
                    if self.scene_tabs.tabText(i) == scene:
                        list_widget = self.scene_tabs.widget(i)
                        if isinstance(list_widget, AnnotationListWidget):
                            # Find and remove the matching item
                            for j in range(list_widget.count() - 1, -1, -1):  # Iterate backwards
                                item = list_widget.item(j)
                                item_widget = list_widget.itemWidget(item)
                                if item_widget:
                                    label = item_widget.findChild(QLabel)
                                    if label and label.text().strip() == text.strip():
                                        list_widget.takeItem(j)
                    
                            # If this was the last item, remove the tab
                            if list_widget.count() == 0:
                                self.scene_tabs.removeTab(i)
                            
                                # Adjust current_tab if necessary
                                if i <= current_tab and current_tab > 0:
                                    current_tab -= 1
                        break
            
                # Restore state
                # First restore selections
                for i, texts in selected_items.items():
                    if i < self.scene_tabs.count():
                        list_widget = self.scene_tabs.widget(i)
                        if isinstance(list_widget, AnnotationListWidget):
                            for j in range(list_widget.count()):
                                item = list_widget.item(j)
                                label = list_widget.itemWidget(item).findChild(QLabel)
                                if label and label.text() in texts:
                                    item.setSelected(True)
            
                # Then restore scroll positions
                for i, pos in scroll_positions.items():
                    if i < self.scene_tabs.count():
                        list_widget = self.scene_tabs.widget(i)
                        if isinstance(list_widget, AnnotationListWidget):
                            list_widget.verticalScrollBar().setValue(pos)
            
                # Finally set the current tab
                if self.scene_tabs.count() > 0 and current_tab >= 0:
                    self.scene_tabs.setCurrentIndex(min(current_tab, self.scene_tabs.count() - 1))

                # If all annotations are removed and theme view is visible, rebuild to show empty state cleanly
                try:
                    remaining = [a for a in self.web_view.annotations if not a.get('divider', False)] if hasattr(self.web_view, 'annotations') else []
                    if (not remaining) and self.theme_view and self.theme_view.isVisible():
                        print("[DEBUG] Last annotation removed with theme view visible -> calling update_theme_view")
                        self.update_theme_view(show_progress=False)
                except Exception as _e:
                    print(f"[DEBUG] Error during post-delete theme view rebuild: {_e}")

                # If all tabs are gone after deletion, show the empty-state overlay explicitly (belt-and-suspenders)
                if self.scene_tabs.count() == 0:
                    try:
                        if hasattr(self, 'script_search') and self.script_search:
                            self.script_search._update_placeholder_overlay(0)
                    except Exception:
                        pass
            
            except Exception as e:
                print(f"Error handling annotation deletion: {e}")

    def scroll_to_position(self, position):
        """Scroll web view to the specified position"""
        js_code = f"window.scrollTo(0, {position});"
        self.web_view.page().runJavaScript(js_code)

    def toggle_bookmark_panel(self):
        """
        Toggles the visibility of the bookmark panel and adjusts layout dynamically.
        """
        print("\n=== TOGGLE BOOKMARK PANEL ===")
        if self.bookmark_button.isChecked():
            print("Showing bookmark panel")
            # Initialize Bookmark Panel (if not already initialized)
            if not hasattr(self, 'bookmark_panel'):
                self.bookmark_panel = BookmarkPanel(self.web_view)
                self.bookmark_panel.scroll_to_position.connect(self.scroll_to_position)
                self.right_panel_container.layout().insertWidget(1, self.bookmark_panel)  # Insert before color key
            
                # Only load bookmarks from file if we don't have a bookmark panel yet
                # AND changes are not pending (meaning no unsaved changes)
                if self.current_session_file and not self.changes_pending:
                    try:
                        with open(self.current_session_file, 'r', encoding='utf-8') as f:
                            session_data = json.load(f)
                            if 'bookmarks' in session_data:
                                self.bookmark_panel.load_bookmarks(session_data['bookmarks'])
                    except Exception as e:
                        print(f"Error loading bookmarks: {e}")

            # Check if this is first time showing any right panel (for splitter sizing)
            first_time_showing_right_panel = not hasattr(self, '_right_panel_sizing_set')
            # Set flag for theme view being shown (for bookmark/theme interaction)
            self._theme_view_was_shown = True
            
            if first_time_showing_right_panel:
                self._right_panel_sizing_set = True
                print("First time showing a panel - setting initial dimensions")
                # Calculate and set initial splitter sizes
                total_width = self.preview_splitter.width()
                if total_width > 0:
                    left_width = int(total_width * 0.7)
                    right_width = total_width - left_width
                    self.preview_splitter.setSizes([left_width, right_width])
                    print(f"[DEBUG] Set initial splitter sizes: left={left_width}, right={right_width}, total={total_width}")
            
            # Show Panels
            self.bookmark_panel.show()
            self.right_panel_container.show()
            
            # Adjust layout based on the visibility of other panels
            if self.theme_view.isVisible() and self.color_key_panel.isVisible():
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 4)
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 4)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 2)
            elif self.theme_view.isVisible():
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 6)
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 4)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 0)
            else:
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 0)
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 6)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 4)
        else:
            print("Hiding bookmark panel")
            # Hide Bookmark Panel (without deleting)
            if hasattr(self, 'bookmark_panel'):
                self.bookmark_panel.hide()
                # Adjust layout if other panels are visible
                if self.theme_view.isVisible() and self.color_key_panel.isVisible():
                    self.right_panel_container.layout().setStretchFactor(self.theme_view, 6)
                    self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 4)
                elif self.theme_view.isVisible():
                    self.right_panel_container.layout().setStretchFactor(self.theme_view, 6)
                    self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 4)
                elif self.color_key_panel.isVisible():
                    self.right_panel_container.layout().setStretchFactor(self.theme_view, 0)
                    self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 1)
                else:
                    self.right_panel_container.layout().setStretchFactor(self.theme_view, 6)
                    self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 4)
                    self.right_panel_container.hide()
        print("=== TOGGLE BOOKMARK PANEL END ===\n")

    def toggle_theme_view(self):
        """Show script panel with current annotations"""
        print("\n=== show_theme_view ENTERED ===")
        
        if self.view_annotations_button.isChecked():
            # Check if this is first time showing any right panel (for splitter sizing)
            first_time_showing_right_panel = not hasattr(self, '_right_panel_sizing_set')
            # Set flag for theme view being shown (for theme view logic)
            self._theme_view_was_shown = True
            
            if first_time_showing_right_panel:
                self._right_panel_sizing_set = True
                print("First time showing a panel - setting initial dimensions")
                # Calculate and set initial splitter sizes
                total_width = self.preview_splitter.width()
                if total_width > 0:
                    left_width = int(total_width * 0.7)
                    right_width = total_width - left_width
                    self.preview_splitter.setSizes([left_width, right_width])
                    print(f"[DEBUG] Set initial splitter sizes: left={left_width}, right={right_width}, total={total_width}")
            
            # First show the panels
            self.theme_view.show()
            self.right_panel_container.show()
        
            # Then set up layouts - add existence checks for panels
            bookmark_visible = hasattr(self, 'bookmark_panel') and self.bookmark_panel.isVisible()
            color_key_visible = hasattr(self, 'color_key_panel') and self.color_key_panel.isVisible()
        
            if bookmark_visible and color_key_visible:
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 4)
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 4)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 2)
            elif bookmark_visible:
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 6)
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 4)
                if hasattr(self, 'color_key_panel'):
                    self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 0)
            elif color_key_visible:
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 6)
                if hasattr(self, 'bookmark_panel'):
                    self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 0)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 4)
            else:
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 6)
                if hasattr(self, 'bookmark_panel'):
                    self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 0)
                if hasattr(self, 'color_key_panel'):
                    self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 4)
        
            # Give Qt a chance to process the layout changes
            QApplication.processEvents()
        
            # Check if theme view needs to be populated (only update if empty or never populated)
            needs_update = False
            has_annotations = False
            
            if hasattr(self, 'web_view') and hasattr(self.web_view, 'annotations'):
                for anno in self.web_view.annotations:
                    if not anno.get("divider", False) and anno.get('scene'):
                        has_annotations = True
                        break
            
            # Check if theme view is empty or hasn't been populated yet
            if self.scene_tabs.count() == 0:
                needs_update = True
                print("DEBUG: Theme view is empty, needs update")
            elif not hasattr(self, '_theme_view_populated') or not self._theme_view_populated:
                needs_update = True
                print("DEBUG: Theme view not yet populated, needs update")
            else:
                print("DEBUG: Theme view already populated, just showing existing content")
        
            # Only update if needed (first time or empty), otherwise just show existing content
            if needs_update:
                print("DEBUG: Updating theme view content...")
                self.update_theme_view(show_progress=has_annotations)
                self._theme_view_populated = True
            else:
                print("DEBUG: Skipping theme view update, showing existing content")
            
            # Always update tab item sizes when showing theme view (viewport may have changed)
            print("DEBUG: Updating tab item sizes and scrollbar...")
            if hasattr(self, 'update_tab_item_sizes'):
                # Show overlay during update to prevent visual flicker
                self._show_tab_update_overlay()
                self.update_tab_item_sizes()
                self._hide_tab_update_overlay()
                # Set flag to prevent duplicate update from resize timeout
                self._just_updated_tab_sizes = True
                QTimer.singleShot(200, lambda: setattr(self, '_just_updated_tab_sizes', False))
            if hasattr(self, 'scene_tabs'):
                self.scene_tabs.update_passive_scrollbar()
            
            # FIXED: Handle pending navigation from annotation creation while theme view was hidden
            if hasattr(self, '_pending_navigation') and self._pending_navigation:
                pending = self._pending_navigation
                print(f"DEBUG: Executing pending navigation to scene '{pending['scene']}'")
                
                # Navigate to the pending tab after a short delay to ensure layout is ready
                QTimer.singleShot(300, lambda: self._execute_pending_navigation(pending))
                
                # Clear the pending navigation
                self._pending_navigation = None
            
            # FIXED: Handle pending selections from annotation creation while theme view was hidden
            print(f"DEBUG: Checking for pending selections - hasattr: {hasattr(self, '_pending_selection')}")
            if hasattr(self, '_pending_selection'):
                print(f"DEBUG: _pending_selection value: {getattr(self, '_pending_selection', 'NONE')}")
                if self._pending_selection:
                    pending_selections = self._pending_selection.copy()
                    print(f"DEBUG: Executing {len(pending_selections)} pending selections: {pending_selections}")
                    
                    # Execute selections after a delay to ensure layout is ready
                    QTimer.singleShot(400, lambda: self.web_view._execute_selection(self, pending_selections))
                    
                    # Clear the pending selections
                    self._pending_selection = []
                    print("DEBUG: Cleared pending selections")
                else:
                    print("DEBUG: _pending_selection is empty")
            else:
                print("DEBUG: No _pending_selection attribute found")
        
            # Then update sizes and styles after content is populated
            self.scene_tabs.update_scene_styles(self.web_view.scene_styles)
    
        else:
            # Hide theme view
            self.theme_view.hide()
        
            # Adjust layout based on the visibility of other panels
            bookmark_visible = hasattr(self, 'bookmark_panel') and self.bookmark_panel.isVisible()
            color_key_visible = hasattr(self, 'color_key_panel') and self.color_key_panel.isVisible()
        
            if bookmark_visible and color_key_visible:
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 0)
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 6)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 4)
            elif bookmark_visible:
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 0)
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 6)
                if hasattr(self, 'color_key_panel'):
                    self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 4)
            elif color_key_visible:
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 0)
                if hasattr(self, 'bookmark_panel'):
                    self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 0)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 1)
            else:
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 0)
                if hasattr(self, 'bookmark_panel'):
                    self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 0)
                if hasattr(self, 'color_key_panel'):
                    self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 0)
                self.right_panel_container.hide()
            
        print("=== show_theme_view EXITED ===\n")

    def toggle_color_key_and_manage_themes(self):
        print("\n=== toggle_color_key_and_manage_themes ENTERED ===")
        show_color_key = self.color_key_button.isChecked()
        if show_color_key:
            print("Show color key is True")
            # Check if this is first time showing any right panel (for splitter sizing)
            first_time_showing_right_panel = not hasattr(self, '_right_panel_sizing_set')
            # Set flag for theme view being shown (for color key/theme interaction)
            self._theme_view_was_shown = True
            
            if first_time_showing_right_panel:
                self._right_panel_sizing_set = True
                print("First time showing a panel - setting initial dimensions")
                # Calculate and set initial splitter sizes
                total_width = self.preview_splitter.width()
                left_width = int(total_width * 0.7)
                right_width = total_width - left_width
                print(f"Color Key - Total width: {total_width}")
                print(f"Color Key - Setting sizes to: [{left_width}, {right_width}]")
                self.preview_splitter.setSizes([left_width, right_width])
                print(f"Color Key - Actual sizes after set: {self.preview_splitter.sizes()}")

            if not self.color_key_panel.isVisible():
                print("Repopulating existing color key panel")
                self.populate_color_key_panel()

            print("Showing panels")
            self.color_key_panel.show()
            self.right_panel_container.show()

            # Adjust layout based on the visibility of other panels
            if self.theme_view.isVisible() and hasattr(self, 'bookmark_panel') and self.bookmark_panel.isVisible():
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 4)
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 4)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 2)
            elif self.theme_view.isVisible():
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 6)
                # If bookmark_panel doesn't exist or isn't visible, treat it as hidden
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 4)
            elif hasattr(self, 'bookmark_panel') and self.bookmark_panel.isVisible():
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 6)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 4)
            else:
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 1)

            print(f"Final splitter sizes: {self.preview_splitter.sizes()}")
        else:
            print("Hiding panels")
            self.color_key_panel.hide()

            # Adjust layout based on the visibility of other panels
            if self.theme_view.isVisible() and hasattr(self, 'bookmark_panel') and self.bookmark_panel.isVisible():
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 6)
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 4)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 0)
            elif self.theme_view.isVisible():
                self.right_panel_container.layout().setStretchFactor(self.theme_view, 1)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 0)
            elif hasattr(self, 'bookmark_panel') and self.bookmark_panel.isVisible():
                self.right_panel_container.layout().setStretchFactor(self.bookmark_panel, 1)
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 0)
            else:
                self.right_panel_container.layout().setStretchFactor(self.color_key_panel, 0)
                self.right_panel_container.hide()


    def update_hotkey_labels(self):
        """Update the hotkey labels after row deletion, with '-' for 11 and '+' for 12"""
        for i in range(self.color_key_form.rowCount() - 1):  # Exclude button row
            label_item = self.color_key_form.itemAt(i, QFormLayout.ItemRole.LabelRole)
            if label_item and label_item.widget():
                if i < 9:
                    hotkey = str(i + 1)
                elif i == 9:
                    hotkey = '0'
                elif i == 10:
                    hotkey = '-'
                elif i == 11:
                    hotkey = '+'
                else:
                    hotkey = ''  # Shouldn't be reachable due to row limit enforcement
                label_item.widget().setText(f"[{hotkey}]")


    def populate_color_key_panel(self):
        """Populates the color key panel with theme rows, ensuring proper handling of up to 12 themes."""
        if not hasattr(self, 'color_key_form'):
            print("Error: color_key_form is not initialized.")
            return

        # Clear existing items from the form layout
        while self.color_key_form.rowCount() > 0:
            self.color_key_form.removeRow(0)

        # Define preset colors (extended to support up to 12 themes)
        preset_colors = [
            '#FFF0B3',  # Moccasin (Warm Peach)
            '#B4E4FF',  # Sky Blue
            '#FFD7DC',  # Coral Pink
            '#D7FFB8',  # Lime Mint
            '#E6D7F5',  # Lavender
            '#FFC7AC',  # Butter Yellow
            '#B5EAE0',  # Seafoam
            '#FFD4E5',  # Rose Pink
            '#ACA8FF',  # Spring Green
            '#FFF1E1',  # Light Apricot
            '#B8D8B8',  # Mint Green
            '#F2C1E5'   # Lilac Pink
        ]

        # Create a placeholder widget for when no themes exist
        placeholder_widget = QWidget()
        placeholder_layout = QVBoxLayout(placeholder_widget)
        placeholder_layout.setContentsMargins(0, 20, 0, 20)

        placeholder_label = QLabel("No themes added yet.\nClick 'Add Theme' to create your first theme.")
        placeholder_label.setStyleSheet("""
            QLabel {
                color: #666666;
                font-size: 13px;
                font-style: italic;
            }
        """)
        placeholder_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        placeholder_layout.addWidget(placeholder_label)

        # Add the placeholder to the form
        self.color_key_form.addRow("", placeholder_widget)

        def update_placeholder_visibility():
            """Show or hide the placeholder depending on the number of themes."""
            has_themes = self.color_key_form.rowCount() > 2  # 1 placeholder + 1 button row
            placeholder_widget.setVisible(not has_themes)

        def create_theme_row(scene_name, initial_color="#FFFFFF", is_existing=True, theme_index=None):
            """Create a row for a theme with a name input, color picker, and delete button."""
            if theme_index is not None and not is_existing:
                # Prevent index errors by cycling through colors using modulo
                initial_color = preset_colors[theme_index % len(preset_colors)]

            # Create the row container and layout
            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 0, 0, 0)
            row_layout.setSpacing(4)
        
            # Store the original scene name as a property for tracking
            row_widget.setProperty("original_scene_name", scene_name)

            # Create the name input field with a set width
            name_edit = ThemeNameEdit(scene_name)
            name_edit.setStyleSheet("""
                QLineEdit {
                    padding: 4px 4px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-size: 13px;
                    background: white;
                }
                QLineEdit:focus {
                    border-color: #2196F3;
                }
            """)
            name_edit.setFixedWidth(280)

            # Create the color button
            color_button = QPushButton()
            color_button.setStyleSheet(f"""
            QPushButton {{
                background-color: {initial_color};
                min-width: 40px;
                min-height: 28px;
                border: 1px solid #ccc;
                border-radius: 4px;
                position: relative;
            }}
            QPushButton:hover {{
                border: 1px solid #2196F3;
            }}
            QPushButton:pressed {{
                border: 1px solid #2C4952;
            }}
        """)
            color_button.setCursor(Qt.CursorShape.PointingHandCursor)

            # Move Up Button
            move_up_button = QPushButton("▲")
            move_up_button.setFixedSize(28, 28)
            move_up_button.setToolTip("Move theme up")

            # Move Down Button
            move_down_button = QPushButton("▼")
            move_down_button.setFixedSize(28, 28)
            move_down_button.setToolTip("Move theme down")


            # Create the delete button
            delete_button = QPushButton("×")
            delete_button.setFixedSize(28, 28)
            delete_button.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #666;
                    border: 1px solid transparent;
                    border-radius: 4px;
                    font-size: 16px;
                    font-weight: bold;
                    padding: 0;
                    margin-left: 4px;
                }
                QPushButton:hover {
                    background-color: #ffebee;
                    color: #f44336;
                    border-color: #ffcdd2;
                }
            """)

            # Function to handle row deletion
            def delete_row():
                if self.color_key_form.rowCount() <= 2:  # Prevent deleting all themes
                    QMessageBox.warning(self, "Cannot Delete", "You must keep at least one theme.")
                    return

                # Find and remove the row from the layout
                row_idx = -1
                for i in range(self.color_key_form.rowCount()):
                    if self.color_key_form.itemAt(i, QFormLayout.ItemRole.FieldRole).widget() == row_widget:
                        row_idx = i
                        break

                if row_idx != -1:
                    self.color_key_form.removeRow(row_idx)
                    renumber_themes()
                    update_placeholder_visibility()

            # Connect the delete button to the delete function
            delete_button.clicked.connect(delete_row)

            # Connect move up and down buttons
            move_up_button.clicked.connect(lambda: move_theme_up(row_widget))
            move_down_button.clicked.connect(lambda: move_theme_down(row_widget))


            def handle_color():
                color_dialog = QColorDialog(self)
                color_dialog.setCurrentColor(QColor(initial_color))

                if color_dialog.exec() == QColorDialog.DialogCode.Accepted:
                    selected_color = color_dialog.selectedColor()
                    color_button.setStyleSheet(f"""
                        QPushButton {{
                            background-color: {selected_color.name()};
                            width: 40px;     /* Consistent width */
                            height: 28px;    /* Consistent height */
                            border: 1px solid #ccc;
                            border-radius: 4px;
                        }}
                        QPushButton:hover {{
                            border: 1px solid #2196F3;
                        }}
                        QPushButton:pressed {{
                            border: 1px solid #2C4952;
                        }}
                    """)



            # Connect the color button to the color picker function
            color_button.clicked.connect(handle_color)

            # Add widgets to layout
            row_layout.addWidget(name_edit)
            row_layout.addWidget(color_button)
            row_layout.addWidget(move_up_button)
            row_layout.addWidget(move_down_button)
            row_layout.addWidget(delete_button)


            return row_widget, name_edit, color_button

        def move_theme_up(row_widget):
            """Move the specified theme row up safely without deleting."""
            index = None
            for i in range(self.color_key_form.rowCount()):
                field_item = self.color_key_form.itemAt(i, QFormLayout.ItemRole.FieldRole)
                if field_item and field_item.widget() == row_widget:
                    index = i
                    break

            if index is not None and index > 0:
                # Get the current and above row items
                label_item = self.color_key_form.itemAt(index, QFormLayout.ItemRole.LabelRole).widget()
                row_item = self.color_key_form.itemAt(index, QFormLayout.ItemRole.FieldRole).widget()
    
                label_above = self.color_key_form.itemAt(index - 1, QFormLayout.ItemRole.LabelRole).widget()
                row_above = self.color_key_form.itemAt(index - 1, QFormLayout.ItemRole.FieldRole).widget()
    
                # Temporarily reparent widgets to preserve them
                label_item.setParent(None)
                row_item.setParent(None)
                label_above.setParent(None)
                row_above.setParent(None)
    
                # Swap the rows visually in the form layout
                self.color_key_form.removeRow(index)
                self.color_key_form.removeRow(index - 1)
    
                # Reinsert rows in swapped order
                self.color_key_form.insertRow(index - 1, label_item, row_item)
                self.color_key_form.insertRow(index, label_above, row_above)

                # Update the hotkey labels immediately
                renumber_themes()

        def move_theme_down(row_widget):
            """Move the specified theme row down safely without deleting."""
            index = None
            for i in range(self.color_key_form.rowCount()):
                field_item = self.color_key_form.itemAt(i, QFormLayout.ItemRole.FieldRole)
                if field_item and field_item.widget() == row_widget:
                    index = i
                    break

            if index is not None and index < self.color_key_form.rowCount() - 2:
                # Get the current and below row items
                label_item = self.color_key_form.itemAt(index, QFormLayout.ItemRole.LabelRole).widget()
                row_item = self.color_key_form.itemAt(index, QFormLayout.ItemRole.FieldRole).widget()
    
                label_below = self.color_key_form.itemAt(index + 1, QFormLayout.ItemRole.LabelRole).widget()
                row_below = self.color_key_form.itemAt(index + 1, QFormLayout.ItemRole.FieldRole).widget()
    
                # Temporarily reparent widgets to prevent deletion
                label_item.setParent(None)
                row_item.setParent(None)
                label_below.setParent(None)
                row_below.setParent(None)
    
                # Swap the rows visually in the form layout
                self.color_key_form.removeRow(index + 1)
                self.color_key_form.removeRow(index)
    
                # Reinsert rows in swapped order
                self.color_key_form.insertRow(index, label_below, row_below)
                self.color_key_form.insertRow(index + 1, label_item, row_item)

                # Update the hotkey labels immediately
                renumber_themes()

        def renumber_themes():
            """Update the hotkey labels for each theme row."""
            for i in range(self.color_key_form.rowCount()):
                label_item = self.color_key_form.itemAt(i, QFormLayout.ItemRole.LabelRole)
                if label_item and label_item.widget():
                    # Skip placeholder and button rows
                    if i > 0 and i < self.color_key_form.rowCount() - 1:
                        idx = i - 1  # Adjust for placeholder row
                        if idx < 9:
                            hotkey = str(idx + 1)
                        elif idx == 9:
                            hotkey = '0'
                        elif idx == 10:
                            hotkey = '-'
                        elif idx == 11:
                            hotkey = '+'
                        else:
                            hotkey = '?'  # Should never happen
                        label_item.widget().setText(f"[{hotkey}]")

        # Add existing themes from the current scene_styles
        for i, scene in enumerate(self.web_view.scene_styles):
            current_color = self.get_color_from_style(self.web_view.scene_styles[scene])
            row_widget, name_edit, color_button = create_theme_row(scene, current_color)
        
            # Store the original scene name explicitly
            row_widget.setProperty("original_scene_name", scene)

            # Add a hotkey label for the theme
            hotkey = str(i + 1) if i < 9 else ('0' if i == 9 else ('-' if i == 10 else '+'))
            label = QLabel(f"[{hotkey}]")
            label.setStyleSheet("margin-right: 2px;")
            label.setFixedWidth(25)

            # Add the row to the form layout
            self.color_key_form.addRow(label, row_widget)

        # Store initial theme state after creating rows
        self.initial_theme_state = {
            name: {
                'name': name,
                'color': self.get_color_from_style(style)
            }
            for name, style in self.web_view.scene_styles.items()
        }

        update_placeholder_visibility()

        # Create container for the buttons
        button_container = QWidget()
        button_layout = QHBoxLayout(button_container)
        button_layout.setContentsMargins(0, 10, 0, 0)  # Top margin only
        button_layout.setSpacing(4)

        # Create a placeholder widget that will take up the same space as the name field
        placeholder = QWidget()
        placeholder.setFixedWidth(180)  # Same width as name_edit
        button_layout.addWidget(placeholder)

        # Add a stretching color box placeholder that matches the theme rows
        color_box_placeholder = QWidget()
        color_box_placeholder.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)

        # Create the color box layout to hold both buttons
        color_box_layout = QHBoxLayout(color_box_placeholder)
        color_box_layout.setContentsMargins(0, 0, 0, 0)
        color_box_layout.setSpacing(8)

        # Add stretch to push buttons to the right
        color_box_layout.addStretch()

        # Add Theme button
        add_theme_button = QPushButton("Add Theme")
        add_theme_button.setFixedWidth(100)
        add_theme_button.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        add_theme_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #666666;
                border: 1px solid #cccccc;
                padding: 6px 12px;
                border-radius: 4px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #f5f5f5;
                border-color: #999999;
                color: #333333;
            }
            QPushButton:pressed {
                background-color: #eeeeee;
            }
        """)

        def handle_add_theme():
            theme_count = self.color_key_form.rowCount() - 2  # Adjusting for button row and placeholder
            if theme_count >= 12:
                QMessageBox.warning(self, "Limit Reached", "You can only have up to 12 themes.")
                return

            new_theme_num = theme_count
            scene_name = f"Theme {new_theme_num + 1}"

            # Create the new theme row
            row_widget, name_edit, color_button = create_theme_row(
                scene_name,
                is_existing=False,
                theme_index=new_theme_num
            )

            # Assign hotkeys correctly (1-9, 0, -, +)
            hotkey = (
                str(new_theme_num + 1) if new_theme_num < 9 else
                '0' if new_theme_num == 9 else
                '-' if new_theme_num == 10 else '+'
            )

            label = QLabel(f"[{hotkey}]")
            label.setStyleSheet("margin-right: 2px;")
            label.setFixedWidth(25)
            label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)

            # Insert row before the button row
            insert_position = self.color_key_form.rowCount() - 1
            self.color_key_form.insertRow(insert_position, label, row_widget)

            # Force a layout update to recalculate widget sizes properly
            self.color_key_form.update()
            self.color_key_form.parentWidget().update()
            update_placeholder_visibility()

            renumber_themes()

        add_theme_button.clicked.connect(handle_add_theme)
        color_box_layout.addWidget(add_theme_button)

        # Add Apply button with prominent styling
        apply_button = QPushButton("Apply")
        apply_button.setFixedWidth(80)
        apply_button.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        apply_button.setStyleSheet("""
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 6px 12px;
                border-radius: 4px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
        """)
    
        def validate_scene_names():
            """Validate all scene names before accepting changes."""
            seen_names = set()
            for i in range(1, self.color_key_form.rowCount() - 1):  # Skip first row (placeholder) and last row (buttons)
                field_item = self.color_key_form.itemAt(i, QFormLayout.ItemRole.FieldRole)
                if not field_item:
                    continue
    
                row_widget = field_item.widget()
                if not row_widget:
                    continue
    
                # Get widgets from row layout
                layout = row_widget.layout()
                if not layout:
                    continue
    
                # Get name edit widget (index 0)
                name_item = layout.itemAt(0)
                if not name_item or not name_item.widget():
                    continue
                name_edit = name_item.widget()
                name = name_edit.text().strip()
                if not name:
                    QMessageBox.warning(
                        None,
                        "Invalid Theme Name",
                        "Theme names cannot be empty."
                    )
                    return False
                if name in seen_names:
                    QMessageBox.warning(
                        None,
                        "Duplicate Theme Name",
                        f"Theme name '{name}' is used multiple times. Each theme must have a unique name."
                    )
                    return False
                if len(name) > 40:
                    QMessageBox.warning(
                        None,
                        "Theme Name Too Long",
                        f"Theme name '{name}' exceeds 40 characters. Please shorten it."
                    )
                    return False
                seen_names.add(name)
            return True

        def apply_changes():
            if not validate_scene_names():
                return

            new_styles = {}
            name_mapping = {}  # Maps old scene names to new scene names

            # Show debugging information
            print("Starting scene rename and positioning operation...")

            # Skip first row (placeholder) and last row (buttons)
            for i in range(1, self.color_key_form.rowCount() - 1):
                field_item = self.color_key_form.itemAt(i, QFormLayout.ItemRole.FieldRole)
                if not field_item:
                    continue

                row_widget = field_item.widget()
                if not row_widget:
                    continue

                # Get widgets from row layout
                layout = row_widget.layout()
                if not layout:
                    continue

                # Get name edit widget (index 0)
                name_item = layout.itemAt(0)
                if not name_item or not name_item.widget():
                    continue
                name_edit = name_item.widget()

                # Get color button widget (index 1)
                color_item = layout.itemAt(1)
                if not color_item or not color_item.widget():
                    continue
                color_button = color_item.widget()

                # Get old name from the row widget property instead of position
                old_name = row_widget.property("original_scene_name")
                new_name = name_edit.text().strip()
                color = self.get_color_from_style(color_button.styleSheet())

                new_styles[new_name] = f'background-color: {color};'
                if old_name and old_name != new_name:
                    name_mapping[old_name] = new_name
                    print(f"Renaming scene: '{old_name}' to '{new_name}'")

            # Update annotations with new theme names
            renamed_annotations = 0
            for anno in self.web_view.annotations:
                if 'scene' in anno and anno['scene'] in name_mapping:
                    print(f"Updating annotation scene from '{anno['scene']}' to '{name_mapping[anno['scene']]}'")
                    anno['scene'] = name_mapping[anno['scene']]
                    renamed_annotations += 1

            print(f"Updated {renamed_annotations} annotations in data structure")

            # Remap secondary_scenes in annotations using the same name mapping
            sec_updates = 0
            valid_new_names = set(new_styles.keys())
            for anno in self.web_view.annotations:
                sec = anno.get('secondary_scenes')
                if isinstance(sec, list) and sec:
                    mapped = [name_mapping.get(s, s) for s in sec]
                    # Filter to valid scenes, dedupe, and remove primary if present
                    seen = set()
                    cleaned = []
                    primary = anno.get('scene')
                    for s in mapped:
                        if s == primary:
                            continue
                        if s in valid_new_names and s not in seen:
                            seen.add(s)
                            cleaned.append(s)
                    if cleaned != sec:
                        print(f"Remapping secondary_scenes for annotation {anno.get('id')} from {sec} to {cleaned}")
                        anno['secondary_scenes'] = cleaned
                        sec_updates += 1
            print(f"Remapped secondary_scenes on {sec_updates} annotations")

            # Apply changes to scene styles
            original_scene_styles = self.web_view.scene_styles.copy()
            self.web_view.scene_styles = new_styles
            # Update in-page color map so secondary chips reflect new colors immediately
            try:
                self.web_view.update_scene_styles_in_js()
            except Exception as e:
                print(f"[Apply Changes] Failed to push scene styles to JS: {e}")

            # Create and configure progress dialog
            progress_dialog = QProgressDialog("Updating document...", "Cancel", 0, 100, self)
            progress_dialog.setWindowTitle("Updating Scenes")
            progress_dialog.setModal(True)
            progress_dialog.setAutoClose(True)
            progress_dialog.setMinimumDuration(500)  # Only show if operation takes more than 500ms
            progress_dialog.setValue(5)
            progress_dialog.setLabelText("Preparing to update DOM elements...")
            progress_dialog.show()
            QApplication.processEvents()

            # Now we need to build a comprehensive list of all valid scene names
            # from the data structure to ensure DOM matches
            valid_scenes = set()
            scene_in_annotation = {}  # Maps text content to scene names

            # First collect all valid scenes from annotations
            for anno in self.web_view.annotations:
                if 'scene' in anno and anno['scene']:
                    valid_scenes.add(anno['scene'])
                    # If annotation has text content, map it to its scene
                    if 'text' in anno and anno['text']:
                        # Use a normalized version of the text to handle whitespace differences
                        normalized_text = ' '.join(anno['text'].split())
                        scene_in_annotation[normalized_text] = anno['scene']

            print(f"Found {len(valid_scenes)} valid scenes in annotations")
            print(f"Valid scenes: {valid_scenes}")

            # Create a combined mapping:
            # 1. Direct scene name changes (old_name -> new_name)
            # 2. Data structure scene validation (any_scene -> correct_scene)

            # Script to update data-scene attributes, styles, and data-secondary-scenes
            js_script = """
            (function() {
                // Helper function to normalize text
                function normalizeText(text) {
                    return text.replace(/\\s+/g, ' ').trim();
                }

                // Valid scenes from data structure
                var validScenes = %s;

                // Scene mapping from old to new names
                var sceneMapping = %s;

                // Mapping from text content to scene name
                var textToSceneMapping = %s;

                // Style mapping
                var styleMapping = %s;
    
                // Track progress and changes
                var elementsProcessed = 0;
                var elementsUpdated = 0;
                var mismatchCount = 0;
                var totalElements = 0;
    
                // 1. Find all elements with data-scene attribute
                var elements = document.querySelectorAll('[data-scene]');
                totalElements = elements.length;
                console.log("Found " + totalElements + " elements with data-scene attribute");
    
                // 2. Process each element
                for (var i = 0; i < elements.length; i++) {
                    var element = elements[i];
                    var currentScene = element.getAttribute('data-scene');
                    var updatedScene = currentScene;
                    var elementText = normalizeText(element.textContent);
        
                    elementsProcessed++;
        
                    // Check if this scene name needs to be updated directly
                    if (sceneMapping[currentScene]) {
                        updatedScene = sceneMapping[currentScene];
                        elementsUpdated++;
                    } 
                    // Check if this scene isn't in our valid list, but we have a mapping based on text
                    else if (!validScenes.includes(currentScene) && textToSceneMapping[elementText]) {
                        updatedScene = textToSceneMapping[elementText];
                        mismatchCount++;
                        elementsUpdated++;
                    }
        
                    // Apply the update if needed
                    if (updatedScene !== currentScene) {
                        element.setAttribute('data-scene', updatedScene);
                        console.log("Updated element scene from '" + currentScene + "' to '" + updatedScene + "'");
                    }

                    // Apply styling regardless of whether the scene was renamed
                    if (styleMapping[updatedScene]) {
                        var styleStr = styleMapping[updatedScene];
                        var match = styleStr.match(/background-color:\\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);/);
                        if (match && match[1]) {
                            element.style.backgroundColor = match[1];
                        }
                    }

                    // Remap data-secondary-scenes if present
                    try {
                        var secAttr = element.getAttribute('data-secondary-scenes');
                        if (secAttr !== null && secAttr !== undefined) {
                            var list;
                            try {
                                list = JSON.parse(secAttr);
                            } catch(e) {
                                // best effort parse of bracketed string
                                var t = (secAttr || '').trim();
                                if (t.startsWith('[') && t.endsWith(']')) {
                                    list = t.substring(1, t.length-1).split(',').map(function(x){return x.trim().replace(/^\"|\"$/g,'').replace(/^'|'$/g,'');}).filter(Boolean);
                                } else {
                                    list = [];
                                }
                            }
                            if (Array.isArray(list)) {
                                // Map names via sceneMapping and clean up
                                var seenSec = {};
                                var cleaned = [];
                                for (var j=0;j<list.length;j++) {
                                    var name = list[j];
                                    var mappedName = sceneMapping[name] || name;
                                    if (mappedName === updatedScene) continue; // drop primary
                                    if (validScenes.indexOf(mappedName) === -1) continue;
                                    if (!seenSec[mappedName]) { seenSec[mappedName] = true; cleaned.push(mappedName); }
                                }
                                var changed = JSON.stringify(list) !== JSON.stringify(cleaned);
                                if (changed) {
                                    console.log("Updated element secondary from", list, "to", cleaned);
                                    element.setAttribute('data-secondary-scenes', JSON.stringify(cleaned));
                                }
                            }
                        }
                    } catch(err) {
                        console.log('Secondary remap error:', err);
                    }
                }

                // 3. Update the color key panel
                var colorKeyDiv = document.querySelector('.color-key');
                if (colorKeyDiv) {
                    colorKeyDiv.innerHTML = '';
                    for (var scene in styleMapping) {
                        var keyItemDiv = document.createElement('div');
                        keyItemDiv.classList.add('key-item');
            
                        var colorBoxSpan = document.createElement('span');
                        colorBoxSpan.classList.add('color-box');
            
                        var styleStr = styleMapping[scene];
                        var match = styleStr.match(/background-color:\\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);/);
                        if (match && match[1]) {
                            colorBoxSpan.style.backgroundColor = match[1];
                        }
            
                        keyItemDiv.appendChild(colorBoxSpan);
                        keyItemDiv.appendChild(document.createTextNode(' ' + scene));
                        colorKeyDiv.appendChild(keyItemDiv);
                    }
                }
    
                return {
                    total: totalElements,
                    processed: elementsProcessed,
                    updated: elementsUpdated,
                    mismatches: mismatchCount
                };
            })();
            """ % (
                json.dumps(list(valid_scenes)),
                json.dumps(name_mapping), 
                json.dumps(scene_in_annotation),
                json.dumps(new_styles)
            )

            # Function to handle the JavaScript result
            def handle_js_result(result):
                try:
                    if not result:
                        print("No result returned from JavaScript")
                        progress_dialog.close()
                        return
            
                    # Process dictionary result
                    if isinstance(result, dict):
                        total = result.get('total', 0)
                        processed = result.get('processed', 0)
                        updated = result.get('updated', 0)
                        mismatches = result.get('mismatches', 0)
            
                        print(f"DOM update summary:")
                        print(f"- Total elements with data-scene: {total}")
                        print(f"- Elements processed: {processed}")
                        print(f"- Elements updated: {updated}")
                        print(f"- Mismatches corrected: {mismatches}")
            
                        # Update progress dialog
                        progress_dialog.setValue(90)
                        progress_dialog.setLabelText(f"Updated {updated} elements. Refreshing view...")
                        QApplication.processEvents()
            
                        # Final steps - update theme view and close dialog
                        QTimer.singleShot(300, lambda: finish_updates())
                    else:
                        print(f"Unexpected result type from JavaScript: {type(result)}")
                        print(f"Result value: {result}")
                        progress_dialog.close()
                except Exception as e:
                    print(f"Error processing JavaScript result: {e}")
                    progress_dialog.close()

            # Function to finalize updates
            def finish_updates():
                # Update the theme view to reflect changes
                self.update_theme_view()

                # Close the progress dialog
                progress_dialog.setValue(100)
                progress_dialog.setLabelText("Update complete!")
                QTimer.singleShot(500, progress_dialog.close)
    
                # Mark changes as pending (self IS the main window in this context)
                print("Marking theme changes as pending...")
                if hasattr(self, 'mark_changes_pending'):
                    self.mark_changes_pending()
                    print("Called self.mark_changes_pending() - changes_pending flag set!")
                else:
                    # Fallback: set the flag directly
                    print("No mark_changes_pending method found, setting flag directly")
                    self.changes_pending = True
                    if not self.windowTitle().startswith('*'):
                        self.setWindowTitle(f'*{self.windowTitle()}')
    
                # Update initial state to reflect new themes and colors
                self.initial_theme_state = {
                    name: {
                        'name': name,
                        'color': self.get_color_from_style(style)
                    }
                    for name, style in new_styles.items()
                }
            
                # Update each row widget's original_scene_name property to reflect the new name
                for i in range(1, self.color_key_form.rowCount() - 1):
                    field_item = self.color_key_form.itemAt(i, QFormLayout.ItemRole.FieldRole)
                    if field_item and field_item.widget():
                        row_widget = field_item.widget()
                        layout = row_widget.layout()
                        if layout and layout.itemAt(0) and layout.itemAt(0).widget():
                            name_edit = layout.itemAt(0).widget()
                            new_name = name_edit.text().strip()
                            row_widget.setProperty("original_scene_name", new_name)

                # After DOM + sticky header updates, refresh filters and remap theme names in sticky header state
                try:
                    import json as _json
                    _name_map_json = _json.dumps(name_mapping)
                    refresh_js = f"""
                    (function() {{
                        try {{
                            // Remap sticky header theme state (solo/hidden) using name mapping
                            var nameMapping = {_name_map_json};
                            if (window.stickyHeaderState) {{
                                var state = window.stickyHeaderState;
                                // Remap soloTheme
                                if (state.soloTheme && nameMapping[state.soloTheme]) {{
                                    console.log('[DEBUG] Remapping soloTheme:', state.soloTheme, '->', nameMapping[state.soloTheme]);
                                    state.soloTheme = nameMapping[state.soloTheme];
                                }}
                                // Remap hiddenThemes Set
                                if (state.hiddenThemes && typeof state.hiddenThemes.forEach === 'function') {{
                                    var newHidden = new Set();
                                    state.hiddenThemes.forEach(function(t) {{
                                        var mapped = nameMapping[t] || t;
                                        newHidden.add(mapped);
                                    }});
                                    // Only replace if changed to avoid churn
                                    if (newHidden.size !== state.hiddenThemes.size) {{
                                        console.log('[DEBUG] HiddenThemes remapped (size changed)');
                                        state.hiddenThemes = newHidden;
                                    }} else {{
                                        // Check content difference
                                        var diff = false;
                                        state.hiddenThemes.forEach(function(t) {{ if (!newHidden.has(t)) diff = true; }});
                                        if (diff) {{
                                            console.log('[DEBUG] HiddenThemes remapped (content changed)');
                                            state.hiddenThemes = newHidden;
                                        }}
                                    }}
                                }}

                                // Also remap stickyHeaderState.themes data names if any lingering refs
                                if (state.themes && Array.isArray(state.themes)) {{
                                    state.themes = state.themes.map(function(th) {{
                                        if (th && th.name && nameMapping[th.name]) {{
                                            return Object.assign({{}}, th, {{ name: nameMapping[th.name] }});
                                        }}
                                        return th;
                                    }});
                                }}
                            }}

                            var hasActive = false;
                            // Favorites/Used filters
                            if (window.stickyHeaderFilters) {{
                                if (window.stickyHeaderFilters.favorites === true) hasActive = true;
                                if (!hasActive && typeof window.stickyHeaderFilters.used !== 'undefined' && window.stickyHeaderFilters.used !== 0) hasActive = true;
                            }}
                            // Tag filters
                            if (!hasActive && window.stickyHeaderTagState && window.stickyHeaderTagState.isActive) {{
                                var ts = window.stickyHeaderTagState.tagStates || {{}};
                                var keys = Object.keys(ts);
                                if (keys.length > 0) {{
                                    for (var i=0;i<keys.length;i++) {{ if (ts[keys[i]] === 'included' || ts[keys[i]] === 'excluded') {{ hasActive = true; break; }} }}
                                }}
                            }}
                            // Theme visibility state (solo/hidden)
                            if (!hasActive && window.stickyHeaderState) {{
                                if (window.stickyHeaderState.soloTheme) hasActive = true;
                                else if (window.stickyHeaderState.hiddenThemes && window.stickyHeaderState.hiddenThemes.size > 0) hasActive = true;
                            }}

                            if (hasActive) {{
                                // Prefer clicking the menu item to reuse exactly the same logic
                                var menu = document.getElementById('menu-refresh-filters');
                                if (menu && typeof menu.click === 'function') {{
                                    console.log('[DEBUG] Triggering "Refresh Filters" from Apply Changes (with remapped names)');
                                    menu.click();
                                    return {{ triggered: 'menu' }};
                                }}
                                // Fallback: call combined filter function directly
                                if (typeof window.applyStickyHeaderFilters === 'function') {{
                                    console.log('[DEBUG] Applying sticky header filters programmatically after Apply Changes (with remapped names)');
                                    window.applyStickyHeaderFilters();
                                    // Also reapply solo/hidden themes if present
                                    if (window.stickyHeaderState) {{
                                        var state2 = window.stickyHeaderState;
                                        if (state2.soloTheme && typeof window.enterSoloMode === 'function') {{
                                            window.enterSoloMode(state2.soloTheme);
                                        }} else if (state2.hiddenThemes && state2.hiddenThemes.size > 0 && state2.themes) {{
                                            if (typeof window.hideThemeHighlights === 'function' && typeof window.showThemeHighlights === 'function') {{
                                                state2.hiddenThemes.forEach(function(themeName){{ window.hideThemeHighlights(themeName); }});
                                                state2.themes.forEach(function(theme){{ if (!state2.hiddenThemes.has(theme.name)) window.showThemeHighlights(theme.name); }});
                                            }}
                                        }}
                                    }}
                                    return {{ triggered: 'function' }};
                                }}
                            }}
                            return {{ triggered: null, hasActive: hasActive }};
                        }} catch (e) {{
                            return {{ error: e && e.toString ? e.toString() : String(e) }};
                        }}
                    }})();
                    """
                    # Defer slightly to allow DOM/sticky header repaints to settle
                    QTimer.singleShot(250, lambda: self.web_view.page().runJavaScript(refresh_js, lambda r: print(f"[DEBUG] Sticky header refresh-after-apply result: {r}")))
                except Exception as _e:
                    print(f"[DEBUG] Error scheduling sticky header filter refresh: {_e}")
                
                # UPDATE STICKY HEADER with new themes, colors, names, and order!
                print("=== UPDATING STICKY HEADER ===")
                print(f"Checking for sticky header on web_view: {hasattr(self.web_view, 'sticky_header')}")
                if hasattr(self.web_view, 'sticky_header'):
                    print(f"sticky_header exists: {self.web_view.sticky_header is not None}")
                    if self.web_view.sticky_header:
                        print(f"sticky_header enabled: {getattr(self.web_view, 'sticky_header_enabled', 'unknown')}")
                        print(f"sticky_header visible: {self.web_view.sticky_header.isVisible()}")
                        print(f"Updating with {len(new_styles)} themes")
                        print(f"New theme styles: {new_styles}")
                        
                        # Clear existing themes and force complete refresh
                        self.web_view.sticky_header.themes.clear()
                        
                        # Force update the sticky header with new themes
                        self.web_view.sticky_header.update_themes(new_styles, content_overflows=False, force_update=True)
                        
                        # Force a complete repositioning regardless of visibility
                        print("Forcing sticky header repositioning...")
                        QTimer.singleShot(100, lambda: self.web_view.recalculate_header_position())
                        
                        print("Sticky header update complete!")
                    else:
                        print("sticky_header is None")
                else:
                    print("No sticky_header attribute found")
                print("=== STICKY HEADER UPDATE END ===")

                # Update DOM-based sticky header if enabled (re-populate buttons)
                try:
                    if getattr(self.web_view, 'sticky_header_enabled', False):
                        print("[DEBUG] Re-populating DOM sticky header themes after Apply Changes")
                        self.web_view.populate_dom_sticky_header_themes(self.web_view.scene_styles)
                        QTimer.singleShot(150, self.web_view.recalculate_header_position)
                except Exception as _e:
                    print(f"[DEBUG] Error updating DOM sticky header after Apply: {_e}")

            # Run the JavaScript and process results
            progress_dialog.setValue(10)
            progress_dialog.setLabelText("Updating scene attributes in document...")
            QApplication.processEvents()

            # Use runJavaScript with a callback for QWebEngineView
            self.web_view.page().runJavaScript(js_script, handle_js_result)

        apply_button.clicked.connect(apply_changes)
        color_box_layout.addWidget(apply_button)

        # Add the color box placeholder to the main layout
        button_layout.addWidget(color_box_placeholder)

        # Add button container with proper alignment
        button_container_row = QWidget()
        button_container_layout = QHBoxLayout(button_container_row)
        button_container_layout.setContentsMargins(0, 0, 0, 0)
        button_container_layout.setSpacing(4)
        button_container_layout.addWidget(button_container)

        self.color_key_form.addRow("", button_container_row)

        # After creating initial themes, update placeholder visibility
        update_placeholder_visibility()

    def ensure_mode_toggle_position(self):
        """Helper method to ensure mode toggle stays in the correct position"""
        if hasattr(self, 'mode_container'):
            # Set the geometry to bottom right of the preview area
            preview_rect = self.preview_widget.rect()
            mode_size = self.mode_container.sizeHint()
        
            # Calculate position considering right panel visibility
            x_offset = self.right_panel_container.width() if self.right_panel_container.isVisible() else 0
            new_x = preview_rect.right() - mode_size.width() - 20 - x_offset  # 20px padding
            new_y = preview_rect.bottom() - mode_size.height() - 20  # 20px padding
        
            self.mode_container.setGeometry(
                new_x,
                new_y,
                mode_size.width(),
                mode_size.height()
            )
            self.mode_container.raise_()
            self.mode_container.setVisible(True)

    def _execute_pending_navigation(self, pending_nav):
        """Execute navigation that was deferred while theme view was hidden"""
        try:
            scene = pending_nav['scene']
            
            # Find the current tab index for this scene (might have changed after update_theme_view)
            scene_tab_index = -1
            for i in range(self.scene_tabs.count()):
                if self.scene_tabs.tabText(i) == scene:
                    scene_tab_index = i
                    break
            
            if scene_tab_index >= 0:
                print(f"DEBUG: Executing deferred navigation to scene '{scene}' at tab index {scene_tab_index}")
                self.scene_tabs.setCurrentIndex(scene_tab_index)
                scene_widget = self.scene_tabs.widget(scene_tab_index)
                if scene_widget is not None:
                    # Small delay to ensure tab switch is complete
                    QTimer.singleShot(100, lambda: scene_widget.scrollToBottom())
                    print("DEBUG: Deferred navigation completed successfully")
                else:
                    print("DEBUG: Scene widget not found during deferred navigation")
            else:
                print(f"DEBUG: Scene '{scene}' not found during deferred navigation")
                
        except Exception as e:
            print(f"DEBUG: Error during deferred navigation: {e}")

    def ensure_proper_layout(self):
        """Ensure proper layout after panel toggles"""
        # Update all annotations in script panel if visible
        if self.theme_view.isVisible():
            for i in range(self.scene_tabs.count()):
                list_widget = self.scene_tabs.widget(i)
                if isinstance(list_widget, AnnotationListWidget):
                    for j in range(list_widget.count()):
                        item = list_widget.item(j)
                        widget = list_widget.itemWidget(item)
                        if widget:
                            list_widget.updateItemSize(item, widget)

        # Ensure mode toggle is visible and properly positioned
        if hasattr(self, 'mode_container'):
            self.mode_container.setVisible(True)
            self.mode_container.raise_()

    def update_color_key_panel(self):
        """Update the color key panel content"""
        # Clear existing color buttons
        while self.color_key_form.rowCount() > 0:
            self.color_key_form.removeRow(0)

        # Add color buttons for each scene
        for scene in self.web_view.scene_styles:
            color_button = QPushButton()
            current_color = self.get_color_from_style(self.web_view.scene_styles[scene])
            color_button.setStyleSheet(f"""
                QPushButton {{
                    background-color: {current_color};
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    min-height: 24px;
                }}
            """)
            color_button.clicked.connect(lambda checked, s=scene: self.change_scene_color(s))
            self.color_key_form.addRow(scene, color_button)

    def change_scene_color(self, scene):
        """
        Handle color change for a scene from the color key panel.
        Called when a color button is clicked.
        """
        # Get the current color from the scene's style
        current_color = self.get_color_from_style(self.web_view.scene_styles[scene])
    
        # Open color picker dialog with current color pre-selected
        color = QColorDialog.getColor(
            QColor(current_color), 
            self,
            f"Select Color for {scene}"
        )
    
        # Only proceed if a valid color was chosen (user didn't cancel)
        if color.isValid():
            # Convert color to hex format and create new style string
            color_hex = color.name()
            new_style = f'background-color: {color_hex};'
        
            # Update the scene style in web_view
            self.web_view.scene_styles[scene] = new_style
        
            # Update the color button's appearance in the color key panel
            for i in range(self.color_key_form.rowCount()):
                # Find the matching row in the form
                label_item = self.color_key_form.itemAt(i, QFormLayout.ItemRole.LabelRole)
                if label_item and label_item.widget().text() == scene:
                    # Get the color button from this row
                    button = self.color_key_form.itemAt(i, QFormLayout.ItemRole.FieldRole).widget()
                    if button:
                        # Update button's background color
                        button.setStyleSheet(f"""
                            QPushButton {{
                                background-color: {color_hex};
                                border: 1px solid #ccc;
                                border-radius: 4px;
                                min-height: 24px;
                            }}
                        """)
                    break
        
            # Update all highlighted text in the web view with the new color
            self.web_view.page().toHtml(self.update_html_with_colors)
        
            # Update the tab color if using ColoredTabWidget
            if hasattr(self, 'scene_tabs') and isinstance(self.scene_tabs, ColoredTabWidget):
                self.scene_tabs.update_scene_style(scene, new_style)
        
            # Mark document as having unsaved changes
            if not self.windowTitle().startswith('*'):
                self.setWindowTitle(f'*{self.windowTitle()}')
        
            # Show status message
            self.status_bar.showMessage(f'Updated color for {scene}', 3000)



    def update_theme_view(self, show_progress=False):
        """
        Update the theme view using generator-based processing for better memory efficiency.
        
        Args:
            show_progress: If True, show progress overlay (for user-initiated operations)
        """
        if hasattr(self, '_updating_theme_view') and self._updating_theme_view:
            return

        import time
        self._last_process_time = time.time()
        self._updating_theme_view = True
        print("=== UPDATE THEME VIEW ENGAGED! ===")
        
        # Block UI interactions during theme view update
        self.setEnabled(False)
        QApplication.processEvents()  # Apply the disable immediately
        
        # Only show progress for user-initiated operations, not internal updates
        self._show_progress_this_update = show_progress and self.theme_view and self.theme_view.isVisible()
        
        if self._show_progress_this_update:
            # Only create new overlay if one doesn't exist
            if not (hasattr(self, '_progress_overlay') and self._progress_overlay and self._progress_overlay.isVisible()):
                print("[DEBUG] Starting progress overlay for theme view update")
                self._show_update_progress()
                QApplication.processEvents()
            else:
                print("[DEBUG] Using existing progress overlay from toggle_theme_view")
        else:
            print("[DEBUG] No progress overlay needed - hiding any existing overlay")
            # Hide any existing progress overlay from previous operations
            if hasattr(self, '_progress_overlay') and self._progress_overlay and self._progress_overlay.isVisible():
                print("[DEBUG] Hiding existing progress overlay for silent update")
                self._progress_overlay.hide()

        def ensure_responsive(message=None):
            current_time = time.time()
            if current_time - self._last_process_time > 0.05:
                QApplication.processEvents()
                self._last_process_time = current_time
                # Update progress message if provided
                if message and hasattr(self, '_progress_label'):
                    print(f"[DEBUG] Updating progress message: {message}")
                    self._progress_label.setText(message)
                
                # Ensure overlay stays visible (only if we should be showing progress)
                if (hasattr(self, '_progress_overlay') and self._progress_overlay and 
                    self.theme_view and self.theme_view.isVisible() and 
                    getattr(self, '_show_progress_this_update', False)):
                    if not self._progress_overlay.isVisible():
                        self._progress_overlay.show()
                    self._progress_overlay.raise_()

        def cache_current_state():
            """Cache the current UI state using generators"""
            state = {
                'current_search': getattr(self.script_search, 'current_search_text', ""),
                'favorites_only': getattr(self.script_search, 'favorites_only', False),
                'hide_used': getattr(self.script_search, 'hide_used', False),
                'search_confirmed': getattr(self.script_search, 'search_confirmed', False),
                'global_search': getattr(self.script_search, 'global_search_enabled', True),
                'selected_tags': getattr(self.script_search, 'selected_tags', set()),
                'strict_tag_filtering': getattr(self.script_search, 'strict_tag_filtering', True),
                'selected_themes': getattr(self.script_search, 'selected_themes', set()),
                'filtered_tabs': getattr(self.script_search, 'selected_themes', set()),  # Use actual theme filters, not visual states
                'current_tab': self.scene_tabs.currentIndex(),
                'current_tab_text': self.scene_tabs.tabText(self.scene_tabs.currentIndex()) if self.scene_tabs.currentIndex() >= 0 else None,
                'scroll_positions': {},
                'selected_items': {},
                # Cache sticky header theme filtering state
                'sticky_header_theme_state': None
            }
            
            # Extract sticky header theme state via JavaScript
            try:
                js_result = self.web_view.page().runJavaScript("""
                    (function() {
                        if (window.stickyHeaderState) {
                            return {
                                'soloTheme': window.stickyHeaderState.soloTheme,
                                'hiddenThemes': window.stickyHeaderState.hiddenThemes ? 
                                    Array.from(window.stickyHeaderState.hiddenThemes) : []
                            };
                        }
                        return null;
                    })();
                """)
                if js_result:
                    state['sticky_header_theme_state'] = js_result
            except Exception as e:
                print(f"[DEBUG] Could not cache sticky header state: {e}")

            # Cache scroll positions and selections per tab
            for i in range(self.scene_tabs.count()):
                list_widget = self.scene_tabs.widget(i)
                if isinstance(list_widget, AnnotationListWidget):
                    scrollbar = list_widget.verticalScrollBar()
                    state['scroll_positions'][i] = {
                        'value': scrollbar.value(),
                        'maximum': scrollbar.maximum(),
                        'scene': self.scene_tabs.tabText(i)
                    }
                
                    state['selected_items'][i] = [
                        item.data(Qt.ItemDataRole.UserRole)
                        for item in list_widget.selectedItems()
                    ]
                ensure_responsive()

            return state

        def process_annotations():
            """Generator for processing annotations by scene"""
            for anno in self.web_view.annotations:
                if not anno.get("divider", False):
                    scene = anno.get('scene')
                    if scene:
                        yield scene, anno
                ensure_responsive()

        def should_show_annotation(anno, scene_name, state):
            """Determine if an annotation should be visible based on current filters"""
            # Always show all annotations when building - filtering happens after via apply_current_filters
            return True

        def create_list_widget(scene_name, annotations_generator, state):
            """Create and populate a list widget for a scene"""
            list_widget = AnnotationListWidget()
            visible_count = 0

            for anno in annotations_generator:
                should_show = should_show_annotation(anno, scene_name, state)
            
                notes_content = {
                    'html': anno.get('notes_html', ''),
                    'plain': anno.get('notes', '')
                }

                item = list_widget.add_item_with_checkbox(
                    text=anno['text'],
                    annotation_id=anno.get('id', ''),
                    is_used=anno.get('used', False),
                    notes=notes_content['plain'],
                    notes_html=notes_content['html'],
                    is_favorite=anno.get('favorite', False),
                    tags=anno.get('tags', []),
                    speech_title=anno.get('speech_title', '')
                )

                item_widget = list_widget.itemWidget(item)
                if item_widget:
                    item_widget.setProperty('notes_html', notes_content['html'])
                    item_widget.setProperty('notes', notes_content['plain'])

                item.setHidden(not should_show)
                if should_show:
                    visible_count += 1

                ensure_responsive()

            return list_widget, visible_count

        try:
            # Initialize progress tracking
            if self._show_progress_this_update:
                self._update_progress(5, "Caching current state...")
            
            # Cache current state
            ensure_responsive("Caching current state...")
            state = cache_current_state()

            if self._show_progress_this_update:
                self._update_progress(10, "Preparing interface...")
            
            # Disable updates
            ensure_responsive("Preparing interface...")
            self.scene_tabs.setUpdatesEnabled(False)

            # Group annotations by scene using generators
            scene_groups = {}
            total_visible_items = 0
            visible_tabs = set()
            first_visible_tab_index = None

            if self._show_progress_this_update:
                self._update_progress(15, "Processing annotations...")
            
            # First pass: group annotations by scene PRESERVING CHRONOLOGICAL ORDER
            ensure_responsive("Processing annotations...")
            annotation_count = 0
            for scene, anno in process_annotations():
                if scene not in scene_groups:
                    scene_groups[scene] = []
                scene_groups[scene].append(anno)
                annotation_count += 1
            
            # CRITICAL: Preserve chronological order within each scene
            # The annotations in self.web_view.annotations are already in the correct order after sorting
            print(f"[DEBUG] Preserving chronological order for {len(scene_groups)} scenes")
            
            # Calculate progress increments
            total_scenes = len(self.web_view.scene_styles)
            progress_per_scene = 40 / max(total_scenes, 1)  # 40% for processing scenes
            current_progress = 20

            # OPTIMIZED: Smart tab reuse instead of destroy/rebuild
            def get_current_tabs():
                """Get current tab information for comparison"""
                current_tabs = {}
                for i in range(self.scene_tabs.count()):
                    scene_name = self.scene_tabs.tabText(i)
                    list_widget = self.scene_tabs.widget(i)
                    if isinstance(list_widget, AnnotationListWidget):
                        # Get current annotation IDs in this tab
                        annotation_ids = []
                        for j in range(list_widget.count()):
                            item = list_widget.item(j)
                            annotation_ids.append(item.data(Qt.ItemDataRole.UserRole))
                        current_tabs[scene_name] = {
                            'index': i,
                            'list_widget': list_widget,
                            'annotation_ids': annotation_ids
                        }
                return current_tabs

            def get_needed_tabs():
                """Get needed tab information from current data"""
                needed_tabs = {}
                for scene_name, annotations in scene_groups.items():
                    annotation_ids = [anno.get('id', '') for anno in annotations]
                    needed_tabs[scene_name] = {
                        'annotations': annotations,
                        'annotation_ids': annotation_ids
                    }
                return needed_tabs

            def compare_tabs(current_tabs, needed_tabs):
                """Compare current vs needed tabs to determine what to keep/add/remove/update"""
                tabs_to_keep = {}
                tabs_to_remove = []
                tabs_to_add = {}
                tabs_to_update = {}

                # Check what we have vs what we need
                for scene_name, current_info in current_tabs.items():
                    if scene_name in needed_tabs:
                        needed_info = needed_tabs[scene_name]
                        # Compare annotation IDs AND ORDER to see if content changed
                        if current_info['annotation_ids'] == needed_info['annotation_ids']:
                            # Same content AND order - keep as is
                            tabs_to_keep[scene_name] = current_info
                        else:
                            # Content or order changed - update existing widget
                            tabs_to_update[scene_name] = {
                                'current': current_info,
                                'needed': needed_info
                            }
                    else:
                        # Scene no longer exists - remove
                        tabs_to_remove.append(current_info['index'])

                # Check for new scenes
                for scene_name, needed_info in needed_tabs.items():
                    if scene_name not in current_tabs:
                        tabs_to_add[scene_name] = needed_info

                return tabs_to_keep, tabs_to_remove, tabs_to_add, tabs_to_update

            def update_existing_widget(list_widget, old_annotations, new_annotations):
                """Efficiently update an existing AnnotationListWidget with new data"""
                # Get current annotation IDs
                old_ids = set(anno.get('id', '') for anno in old_annotations)
                new_ids = set(anno.get('id', '') for anno in new_annotations)
                
                # Check if order has changed even with same IDs
                old_order = [anno.get('id', '') for anno in old_annotations]
                new_order = [anno.get('id', '') for anno in new_annotations]
                order_changed = old_order != new_order
                
                # Find what to add/remove
                ids_to_remove = old_ids - new_ids
                ids_to_add = new_ids - old_ids
                
                print(f"[DEBUG] Updating widget: removing {len(ids_to_remove)}, adding {len(ids_to_add)} items, order_changed={order_changed}")
                
                # If order changed but same items, rebuild completely to preserve chronological order
                if order_changed and not ids_to_remove and not ids_to_add:
                    print(f"[DEBUG] Order changed for existing items - rebuilding widget completely")
                    print(f"[DEBUG] OLD ORDER: {old_order[:5]}...")  # Show first 5
                    print(f"[DEBUG] NEW ORDER: {new_order[:5]}...")  # Show first 5
                    list_widget.clear()
                    for anno in new_annotations:
                        notes_content = {
                            'html': anno.get('notes_html', ''),
                            'plain': anno.get('notes', '')
                        }
                        
                        item = list_widget.add_item_with_checkbox(
                            text=anno['text'],
                            annotation_id=anno.get('id', ''),
                            is_used=anno.get('used', False),
                            notes=notes_content['plain'],
                            notes_html=notes_content['html'],
                            is_favorite=anno.get('favorite', False),
                            tags=anno.get('tags', []),
                            speech_title=anno.get('speech_title', '')
                        )

                        item_widget = list_widget.itemWidget(item)
                        if item_widget:
                            item_widget.setProperty('notes_html', notes_content['html'])
                            item_widget.setProperty('notes', notes_content['plain'])
                    return
                
                # Remove items that are no longer needed
                for i in range(list_widget.count() - 1, -1, -1):  # Reverse order for safe removal
                    item = list_widget.item(i)
                    if item.data(Qt.ItemDataRole.UserRole) in ids_to_remove:
                        list_widget.takeItem(i)
                
                # Add new items
                for anno in new_annotations:
                    if anno.get('id', '') in ids_to_add:
                        notes_content = {
                            'html': anno.get('notes_html', ''),
                            'plain': anno.get('notes', '')
                        }
                        
                        item = list_widget.add_item_with_checkbox(
                            text=anno['text'],
                            annotation_id=anno.get('id', ''),
                            is_used=anno.get('used', False),
                            notes=notes_content['plain'],
                            notes_html=notes_content['html'],
                            is_favorite=anno.get('favorite', False),
                            tags=anno.get('tags', []),
                            speech_title=anno.get('speech_title', '')
                        )

                        item_widget = list_widget.itemWidget(item)
                        if item_widget:
                            item_widget.setProperty('notes_html', notes_content['html'])
                            item_widget.setProperty('notes', notes_content['plain'])

            # SMART UPDATE PROCESS
            with QSignalBlocker(self.scene_tabs):
                ensure_responsive("Analyzing current tabs...")
                
                # Get current state
                current_tabs = get_current_tabs()
                needed_tabs = get_needed_tabs()
                
                print(f"[DEBUG] Current tabs: {list(current_tabs.keys())}")
                print(f"[DEBUG] Needed tabs: {list(needed_tabs.keys())}")
                
                # Compare and determine changes
                tabs_to_keep, tabs_to_remove, tabs_to_add, tabs_to_update = compare_tabs(current_tabs, needed_tabs)
                
                print(f"[DEBUG] Tabs to keep: {list(tabs_to_keep.keys())}")
                print(f"[DEBUG] Tabs to remove: {len(tabs_to_remove)}")
                print(f"[DEBUG] Tabs to add: {list(tabs_to_add.keys())}")
                print(f"[DEBUG] Tabs to update: {list(tabs_to_update.keys())}")
                
                # Only clear if we're doing a major rebuild (fallback safety)
                if len(tabs_to_keep) == 0 and len(tabs_to_update) == 0:
                    print("[DEBUG] FALLBACK: No tabs to reuse, doing full rebuild")
                    self.scene_tabs.clear()
                    use_fallback = True
                else:
                    use_fallback = False
                
                # Remove obsolete tabs (in reverse order to maintain indices)
                for tab_index in sorted(tabs_to_remove, reverse=True):
                    print(f"[DEBUG] Removing tab at index {tab_index}")
                    self.scene_tabs.removeTab(tab_index)
                
                # Update existing tabs with new data
                for scene_name, update_info in tabs_to_update.items():
                    current_info = update_info['current']
                    needed_info = update_info['needed']
                    
                    if self._show_progress_this_update:
                        self._update_progress(int(current_progress), f"Updating {scene_name} tab...")
                    
                    print(f"[DEBUG] Updating existing tab: {scene_name}")
                    # Get current annotations from widget in their current order (not from scene_groups which is already sorted)
                    current_widget_annotations = []
                    for j in range(current_info['list_widget'].count()):
                        item = current_info['list_widget'].item(j)
                        annotation_id = item.data(Qt.ItemDataRole.UserRole)
                        # Find the annotation object in web_view.annotations
                        for anno in self.web_view.annotations:
                            if anno.get('id') == annotation_id:
                                current_widget_annotations.append(anno)
                                break
                    
                    update_existing_widget(
                        current_info['list_widget'],
                        current_widget_annotations,  # Current order from widget
                        needed_info['annotations']  # New sorted order
                    )
                    
                    visible_tabs.add(scene_name)
                    total_visible_items += len(needed_info['annotations'])
                    ensure_responsive()

                # Create new tabs only for truly new scenes
                scene_count = 0
                for scene_name, needed_info in tabs_to_add.items():
                    current_progress += progress_per_scene
                    if self._show_progress_this_update:
                        self._update_progress(int(current_progress), f"Creating {scene_name} tab...")
                    
                    ensure_responsive(f"Creating {scene_name} tab...")
                    
                    if use_fallback:
                        # Fallback: use original create_list_widget method
                        list_widget, visible_count = create_list_widget(
                            scene_name,
                            needed_info['annotations'],
                            state
                        )
                    else:
                        # Optimized: create new widget directly
                        list_widget = AnnotationListWidget()
                        visible_count = 0
                        
                        for anno in needed_info['annotations']:
                            notes_content = {
                                'html': anno.get('notes_html', ''),
                                'plain': anno.get('notes', '')
                            }

                            item = list_widget.add_item_with_checkbox(
                                text=anno['text'],
                                annotation_id=anno.get('id', ''),
                                is_used=anno.get('used', False),
                                notes=notes_content['plain'],
                                notes_html=notes_content['html'],
                                is_favorite=anno.get('favorite', False),
                                tags=anno.get('tags', []),
                                speech_title=anno.get('speech_title', '')
                            )

                            item_widget = list_widget.itemWidget(item)
                            if item_widget:
                                item_widget.setProperty('notes_html', notes_content['html'])
                                item_widget.setProperty('notes', notes_content['plain'])
                            
                            visible_count += 1
                            
                    print(f"[DEBUG] Created new tab: {scene_name} with {visible_count} items")

                    # Add tab if there are visible items
                    if visible_count > 0:
                        try:
                            desired_index = list(self.web_view.scene_styles.keys()).index(scene_name)
                        except ValueError:
                            desired_index = self.scene_tabs.count()
                        tab_index = self.scene_tabs.insertTab(desired_index, list_widget, scene_name)
                        # Apply colored style to tab bar
                        self.scene_tabs.colored_tab_bar.update_scene_style(scene_name, self.web_view.scene_styles[scene_name])
                        self.scene_tabs.colored_tab_bar.update()
                    
                        visible_tabs.add(scene_name)
                        total_visible_items += visible_count
                    
                        if first_visible_tab_index is None:
                            first_visible_tab_index = tab_index

                        self.scene_tabs.tabBar().setTabVisible(tab_index, True)
                        
                        # Ensure overlay stays on top after adding new tabs
                        if hasattr(self, '_progress_overlay') and self._progress_overlay.isVisible():
                            self._progress_overlay.raise_()
                            print(f"[DEBUG] Overlay raised after adding tab {scene_name}")
                    ensure_responsive()
                    scene_count += 1

                # If we're doing a fallback rebuild, handle all scenes
                if use_fallback:
                    for scene_name in self.web_view.scene_styles:
                        if scene_name not in scene_groups or scene_name in tabs_to_add:
                            continue  # Already handled above or no data

                        current_progress += progress_per_scene
                        if self._show_progress_this_update:
                            self._update_progress(int(current_progress), f"Creating {scene_name} tab...")
                        
                        ensure_responsive(f"Creating {scene_name} tab...")
                        list_widget, visible_count = create_list_widget(
                            scene_name,
                            scene_groups[scene_name],
                            state
                        )

                        if visible_count > 0:
                            try:
                                desired_index = list(self.web_view.scene_styles.keys()).index(scene_name)
                            except ValueError:
                                desired_index = self.scene_tabs.count()
                            tab_index = self.scene_tabs.insertTab(desired_index, list_widget, scene_name)
                            self.scene_tabs.colored_tab_bar.update_scene_style(scene_name, self.web_view.scene_styles[scene_name])
                            self.scene_tabs.colored_tab_bar.update()
                        
                            visible_tabs.add(scene_name)
                            total_visible_items += visible_count
                        
                            if first_visible_tab_index is None:
                                first_visible_tab_index = tab_index

                            self.scene_tabs.tabBar().setTabVisible(tab_index, True)
                            
                            if hasattr(self, '_progress_overlay') and self._progress_overlay.isVisible():
                                self._progress_overlay.raise_()
                        ensure_responsive()
                        scene_count += 1

            # Since we built all annotations, we need to apply filters now
            if hasattr(self, 'script_search'):
                print("[DEBUG] Applying filters after building all tabs")
                self.script_search.apply_current_filters()
                # apply_current_filters handles overlay logic, so we don't need to hide it here
                
            # Restore sticky header theme filtering state if it was cached
            if state and 'sticky_header_theme_state' in state and state['sticky_header_theme_state']:
                theme_state = state['sticky_header_theme_state']
                print(f"[DEBUG] Restoring sticky header theme state: {theme_state}")
                
                import json
                theme_state_json = json.dumps(theme_state)
                
                restore_js = f"""
                (function() {{
                    if (!window.stickyHeaderState) return false;
                    
                    try {{
                        const cachedState = {theme_state_json};
                        
                        // Restore solo theme if it was active
                        if (cachedState.soloTheme) {{
                            console.log('[DEBUG] Restoring solo theme:', cachedState.soloTheme);
                            if (typeof window.enterSoloMode === 'function') {{
                                window.enterSoloMode(cachedState.soloTheme);
                            }}
                        }}
                        // Restore hidden themes if they were set
                        else if (cachedState.hiddenThemes && cachedState.hiddenThemes.length > 0) {{
                            console.log('[DEBUG] Restoring hidden themes:', cachedState.hiddenThemes);
                            cachedState.hiddenThemes.forEach(function(themeName) {{
                                if (typeof window.hideThemeHighlights === 'function') {{
                                    window.stickyHeaderState.hiddenThemes.add(themeName);
                                    window.hideThemeHighlights(themeName);
                                    
                                    // Update button state
                                    const button = document.querySelector(`[data-theme="${{themeName}}"]`);
                                    if (button) {{
                                        button.classList.add('theme-hidden');
                                    }}
                                }}
                            }});
                        }}
                        
                        // Update navigation state after restoring theme filters
                        if (window.updateNavigationMenuState) {{
                            window.updateNavigationMenuState();
                        }}
                        
                        return true;
                    }} catch (e) {{
                        console.error('[DEBUG] Error restoring theme state:', e);
                        return false;
                    }}
                }})();
                """
                
                try:
                    self.web_view.page().runJavaScript(restore_js)
                    print("[DEBUG] Theme state restoration JavaScript executed")
                except Exception as e:
                    print(f"[DEBUG] Error executing theme state restoration: {e}")
                    
            # Restore tab filter states based on actual theme filters
            if hasattr(self, 'script_search') and self.script_search.selected_themes:
                print(f"[DEBUG] Restoring tab filter states based on current theme filters: {self.script_search.selected_themes}")
                self.scene_tabs.restore_tab_filter_states(self.script_search.selected_themes)
            else:
                print("[DEBUG] No theme filters active, ensuring all tab filter states are cleared")
                # Ensure all visual filter states are cleared if no theme filters are active
                self.scene_tabs.colored_tab_bar.filtered_tabs.clear()
                self.scene_tabs.colored_tab_bar.update()
            
            # Update scene styles
            if self._show_progress_this_update:
                self._update_progress(65, "Finalizing interface...")
            ensure_responsive("Finalizing interface...")
            self.scene_tabs.update_scene_styles(self.web_view.scene_styles)

            # Enforce tab order to match scene_styles order (handles rename position)
            try:
                desired_order = list(self.web_view.scene_styles.keys())
                for desired_index, scene in enumerate(desired_order):
                    current_index = None
                    for i in range(self.scene_tabs.count()):
                        if self.scene_tabs.tabText(i) == scene:
                            current_index = i
                            break
                    if current_index is None:
                        continue
                    if current_index != desired_index:
                        widget = self.scene_tabs.widget(current_index)
                        self.scene_tabs.removeTab(current_index)
                        self.scene_tabs.insertTab(desired_index, widget, scene)
                        # Keep styled color
                        style = self.web_view.scene_styles.get(scene, '')
                        self.scene_tabs.colored_tab_bar.update_scene_style(scene, style)
                self.scene_tabs.colored_tab_bar.update()
            except Exception as _e:
                print(f"[DEBUG] Failed enforcing tab order: {_e}")

            # Restore state and update item sizes
            def finalize_update():
                try:
                    # Ensure overlay is still visible for the finalization phase (only if we should show progress)
                    if (self._show_progress_this_update and hasattr(self, '_progress_overlay') and self._progress_overlay and 
                        self.theme_view and self.theme_view.isVisible()):
                        if not self._progress_overlay.isVisible():
                            self._progress_overlay.show()
                        self._progress_overlay.raise_()
                        QApplication.processEvents()
                    
                    # Get all list widgets
                    list_widgets = [
                        (i, self.scene_tabs.widget(i))
                        for i in range(self.scene_tabs.count())
                        if isinstance(self.scene_tabs.widget(i), AnnotationListWidget)
                    ]

                    if not list_widgets:
                        return

                    # Cache viewport width
                    available_width = list_widgets[0][1].viewport().width() - 40
                    original_tab = self.scene_tabs.currentIndex()

                    # Calculate progress per tab for finalization
                    progress_per_tab = 30 / max(len(list_widgets), 1)  # 30% for tab switching
                    current_final_progress = 70
                    
                    # Update all tab widgets WITHOUT switching tabs (much faster)
                    if self._show_progress_this_update:
                        self._update_progress(85, "Updating item sizes...")
                    print("[DEBUG] Updating all tab widgets without tab switching")
                    
                    for idx, list_widget in list_widgets:
                        tab_name = self.scene_tabs.tabText(idx)
                        print(f"[DEBUG] Updating {tab_name} items (no tab switch needed)")
                        
                        list_widget.verticalScrollBar().setSingleStep(5)

                        # Update item sizes in batches - no need to switch tabs
                        batch_size = 50  # Increase batch size since no UI updates needed
                        for j in range(0, list_widget.count(), batch_size):
                            batch_end = min(j + batch_size, list_widget.count())
                        
                            for k in range(j, batch_end):
                                item = list_widget.item(k)
                                widget = list_widget.itemWidget(item)
                                if widget:
                                    widget.setFixedWidth(available_width)
                                    list_widget.updateItemSize(item, widget)
                        
                            # Only process events occasionally, not after every batch
                            if j % (batch_size * 3) == 0:
                                ensure_responsive()

                        list_widget.updateGeometry()

                    # Restore to original tab
                    self.scene_tabs.setCurrentIndex(original_tab)

                    # Restore scroll positions
                    for idx, pos in state['scroll_positions'].items():
                        if idx < self.scene_tabs.count():
                            list_widget = self.scene_tabs.widget(idx)
                            if isinstance(list_widget, AnnotationListWidget):
                                QTimer.singleShot(
                                    100,
                                    lambda v=pos['value'], widget=list_widget: widget.verticalScrollBar().setValue(v)
                                )

                    # Restore selections
                    for i, item_ids in state['selected_items'].items():
                        if i >= self.scene_tabs.count():
                            continue

                        list_widget = self.scene_tabs.widget(i)
                        if not isinstance(list_widget, AnnotationListWidget):
                            continue

                        for j in range(list_widget.count()):
                            item = list_widget.item(j)
                            if item.data(Qt.ItemDataRole.UserRole) in item_ids:
                                item.setSelected(True)

                    # Final tab restoration
                    target_tab = state['current_tab']
                    if target_tab is not None and target_tab < self.scene_tabs.count():
                        if not self.scene_tabs.tabBar().isTabVisible(target_tab):
                            # Find first visible tab
                            for i in range(self.scene_tabs.count()):
                                if self.scene_tabs.tabBar().isTabVisible(i):
                                    self.scene_tabs.setCurrentIndex(i)
                                    break
                        else:
                            self.scene_tabs.setCurrentIndex(target_tab)

                    # Final updates
                    if self._show_progress_this_update:
                        self._update_progress(95, "Completing update...")
                    self.scene_tabs.setUpdatesEnabled(True)
                    self.scene_tabs.update()
                    ensure_responsive()
                    
                    # Ensure empty-state overlay reflects current content count AFTER filtering
                    try:
                        if hasattr(self, 'script_search') and self.script_search:
                            # Calculate actual visible items after filtering
                            current_visible_count = 0
                            for i in range(self.scene_tabs.count()):
                                list_widget = self.scene_tabs.widget(i)
                                if isinstance(list_widget, AnnotationListWidget):
                                    for j in range(list_widget.count()):
                                        item = list_widget.item(j)
                                        if not item.isHidden():
                                            current_visible_count += 1
                            print(f"[DEBUG] Using actual visible count {current_visible_count} instead of stale count {total_visible_items}")
                            self.script_search._update_placeholder_overlay(current_visible_count)
                    except Exception as e:
                        print(f"[DEBUG] Error updating placeholder overlay: {e}")

                    # Final progress
                    if self._show_progress_this_update:
                        self._update_progress(100, "Complete!")
        
                except Exception as e:
                    import traceback
                    print(f"Error in finalize_update: {e}")
                    print(traceback.format_exc())
                finally:
                    self._updating_theme_view = False
                    # Re-enable UI interactions
                    self.setEnabled(True)
                    # Update scrollbar after layout is complete
                    if hasattr(self.scene_tabs, 'update_passive_scrollbar'):
                        QTimer.singleShot(100, self.scene_tabs.update_passive_scrollbar)
                    # Only hide progress overlay if we showed it
                    if self._show_progress_this_update:
                        self._hide_update_progress()
                    
                    # Handle pending theme view selection after population is complete
                    if hasattr(self, '_pending_theme_view_selection'):
                        annotation_id = self._pending_theme_view_selection
                        delattr(self, '_pending_theme_view_selection')
                        
                        # Find the storyboard dialog to call its selection method
                        for window in QApplication.topLevelWidgets():
                            if isinstance(window, StoryboardDialog) and window.isVisible():
                                if hasattr(window.order_list, 'select_annotation_in_theme_view'):
                                    window.order_list.select_annotation_in_theme_view(annotation_id)
                                    print(f"Selected pending annotation {annotation_id} in theme view")
                                    break

            # Schedule finalize pass
            QTimer.singleShot(0, finalize_update)

        except Exception as e:
            import traceback
            print(f"Error in update_theme_view: {e}")
            print(traceback.format_exc())
            self.scene_tabs.setUpdatesEnabled(True)
            self._updating_theme_view = False
            # Re-enable UI interactions on error
            self.setEnabled(True)
            # Update scrollbar even on error
            if hasattr(self.scene_tabs, 'update_passive_scrollbar'):
                QTimer.singleShot(100, self.scene_tabs.update_passive_scrollbar)
            # Only hide progress overlay on error if we showed it
            if self._show_progress_this_update and hasattr(self, '_progress_overlay') and self._progress_overlay.isVisible():
                self._hide_update_progress()

    def _should_show_annotation_quick_check(self, anno, scene_name, state):
        """Quick version of should_show_annotation for pre-filtering check"""
        import string
        
        if state['favorites_only'] and not anno.get("favorite", False):
            return False

        # Modified hide_used logic to handle three states
        if state['hide_used'] == 1:  # Hide used
            if anno.get("used", False):
                return False
        elif state['hide_used'] == 2:  # Show only used
            if not anno.get("used", False):
                return False

        if state['search_confirmed'] and state['current_search']:
            search_terms = [term.lower() for term in state['current_search'].replace("#", " #").replace(",", " , ").split() if term]
            tags_only = all(term.startswith("#") for term in search_terms if term != ",")
            comma_separated = "," in search_terms

            if tags_only:
                if not (state['global_search'] or scene_name == state['current_tab_text']):
                    return False
                
                search_tags = [term[1:] for term in search_terms if term.startswith("#")]
                notes = anno.get('notes', '').lower()
                translator = str.maketrans("", "", string.punctuation.replace("#", ""))
                notes = notes.translate(translator)

                if comma_separated:
                    return any(tag in notes for tag in search_tags)
                return all(tag in notes for tag in search_tags)
            else:
                if not (state['global_search'] or scene_name == state['current_tab_text']):
                    return False
                
                import re
                # Preserve spaces to maintain word boundaries
                text = re.sub(r'[^\w\s]', ' ', anno.get('text', '').lower())
                text = ' '.join(text.split())
                notes = re.sub(r'[^\w\s]', ' ', anno.get('notes', '').lower()) 
                notes = ' '.join(notes.split())
                normalized_search_text = re.sub(r'[^\w\s]', ' ', state['current_search'].lower())
                normalized_search_text = ' '.join(normalized_search_text.split())

                return normalized_search_text in text or normalized_search_text in notes

        # Apply tag filters (same logic as in update_theme_view)
        tag_filter_passed = True
        if state['selected_tags']:
            annotation_tags = set(tag.lower() for tag in anno.get('tags', []))
            selected_tags_lower = set(tag.lower() for tag in state['selected_tags'])
            
            if state['strict_tag_filtering']:
                # Strict mode: annotation must have ALL selected tags
                if not selected_tags_lower.issubset(annotation_tags):
                    tag_filter_passed = False
            else:
                # Loose mode: annotation must have ANY selected tag
                if not bool(selected_tags_lower & annotation_tags):
                    tag_filter_passed = False

        # Apply header filters  
        header_filter_passed = True
        if state.get('selected_headers'):
            # Get the scene title from annotation (speech_title or scene_title)
            annotation_header = anno.get('speech_title', '') or anno.get('scene_title', '')
            if annotation_header:
                # Check if annotation's header matches any selected headers
                selected_headers_lower = set(header.lower() for header in state['selected_headers'])
                if annotation_header.lower() not in selected_headers_lower:
                    header_filter_passed = False
            else:
                # If annotation has no header, fail header filter when header filters are active
                header_filter_passed = False

        # Apply theme filters (same logic as in perform_search)
        theme_filter_passed = True
        if state['selected_themes']:
            annotation_themes = set()
            
            # Add primary scene
            primary_scene = anno.get('scene', '')
            if primary_scene:
                annotation_themes.add(primary_scene.lower())
            
            # Add secondary scenes
            secondary_scenes = anno.get('secondary_scenes', [])
            for secondary_scene in secondary_scenes:
                if secondary_scene:
                    annotation_themes.add(secondary_scene.lower())
            
            # Convert selected themes to lowercase for comparison
            selected_themes_lower = set(theme.lower() for theme in state['selected_themes'])
            
            # Check if annotation has ANY of the selected themes (OR logic for themes)
            theme_matches = bool(selected_themes_lower & annotation_themes)
            if not theme_matches:
                theme_filter_passed = False

        # Combine ALL filter results with AND logic - ALL must pass
        return tag_filter_passed and header_filter_passed and theme_filter_passed

    def clear_all_tab_selections(self):
        """Clear selections across all tabs in scene_tabs"""
        for i in range(self.scene_tabs.count()):
            tab_widget = self.scene_tabs.widget(i)
            if hasattr(tab_widget, 'clearSelection') and hasattr(tab_widget, 'setCurrentRow'):
                tab_widget.clearSelection()
                tab_widget.setCurrentRow(-1)


    def update_annotation_speech_title_in_ui(self, annotation_id, speech_title):
        """
        Efficiently update just the speech title for a specific annotation by recreating that list item.
        This is more efficient than regenerating the entire theme view but ensures proper widget creation.
        """
        print(f"DEBUG: Updating speech title for annotation {annotation_id}: '{speech_title}'")
        
        try:
            # Find the annotation in our data
            annotation = None
            for anno in self.web_view.annotations:
                if anno.get('id') == annotation_id:
                    annotation = anno
                    break
            
            if not annotation:
                print(f"DEBUG: Annotation {annotation_id} not found in data")
                return
                
            # DEBUG: Print the annotation data to see if tags are present
            print(f"DEBUG: Annotation tags: {annotation.get('tags', 'NO_TAGS_FIELD')}")
                
            scene = annotation.get('scene', 'Unknown')
            
            # If there are no tabs yet (e.g., first annotation after empty state), ensure the view is built and retry (guarded)
            if self.scene_tabs.count() == 0:
                print("DEBUG: No tabs available yet; triggering theme view build before retry")
                try:
                    # If the theme view exists, request a full update to build tabs/items
                    if hasattr(self, 'theme_view') and self.theme_view:
                        self.update_theme_view(show_progress=False)
                except Exception as _e:
                    print(f"DEBUG: Failed to build theme view: {_e}")

                # Initialize retry counter and guard against infinite retries
                if not hasattr(self, '_speech_title_retry_counts'):
                    self._speech_title_retry_counts = {}
                count = self._speech_title_retry_counts.get(annotation_id, 0)
                if count > 20:
                    print(f"DEBUG: Giving up speech title UI update for {annotation_id} after {count} retries")
                    return
                self._speech_title_retry_counts[annotation_id] = count + 1

                print("DEBUG: Scheduling speech title UI update retry after theme view build")
                from PyQt6.QtCore import QTimer
                QTimer.singleShot(150, lambda: self.update_annotation_speech_title_in_ui(annotation_id, speech_title))
                return

            # Find the correct tab and list widget
            print(f"DEBUG: Looking for scene '{scene}' among {self.scene_tabs.count()} tabs")
            for i in range(self.scene_tabs.count()):
                tab_name = self.scene_tabs.tabText(i)
                print(f"DEBUG: Tab {i}: '{tab_name}' (matches scene: {tab_name == scene})")
                if tab_name == scene:
                    list_widget = self.scene_tabs.widget(i)
                    print(f"DEBUG: List widget type: {type(list_widget)}, item count: {list_widget.count()}")
                    if isinstance(list_widget, AnnotationListWidget):
                        # Find the specific annotation item
                        found_match = False
                        matching_index = -1
                        print(f"DEBUG: Looking for annotation_id: '{annotation_id}'")
                        all_ids_in_ui = []
                        for j in range(list_widget.count()):
                            item = list_widget.item(j)
                            if item:
                                item_widget = list_widget.itemWidget(item)
                                # Check the QListWidgetItem.data() method - this is likely where the ID is stored
                                item_data = item.data(0)  # Role 0 is usually the display role
                                print(f"DEBUG: Item data(0): '{item_data}'")
                                
                                # Check if annotation_id is stored in UserRole (this is how add_item_with_checkbox stores it)
                                from PyQt6.QtCore import Qt
                                user_data = item.data(Qt.ItemDataRole.UserRole)
                                print(f"DEBUG: Item UserRole data: '{user_data}'")
                                
                                # Check if annotation_id matches
                                if user_data == annotation_id:
                                    print(f"DEBUG: FOUND matching annotation in data!")
                                    found_match = True
                                    matching_index = j
                                    break
                        
                        # If we found a match, recreate the item
                        if found_match:
                            # Remove the old item
                            item = list_widget.takeItem(matching_index)
                            
                            # Recreate the item with the updated speech title
                            new_item = list_widget.add_item_with_checkbox(
                                text=annotation.get('text', ''),
                                annotation_id=annotation_id,
                                is_used=annotation.get('used', False),
                                notes=annotation.get('notes', ''),
                                is_favorite=annotation.get('favorite', False),
                                tags=annotation.get('tags', []),
                                speech_title=speech_title  # This is the key - pass the new speech title
                            )
                            
                            # Insert the new item at the same position
                            list_widget.insertItem(matching_index, new_item)
                            
                            # Check if we're in a reassignment context (batch operation)
                            in_reassignment = getattr(self.web_view, '_in_reassignment_context', False)
                            
                            if in_reassignment:
                                # We're in a batch operation - defer selection until the end
                                print(f"DEBUG: In reassignment context - deferring selection for annotation {annotation_id}")
                                
                                # Clear selections only once for the entire batch
                                if not getattr(self.web_view, '_selections_cleared', False):
                                    print("DEBUG: Clearing all selections once for batch operation")
                                    self.clear_all_tab_selections()
                                    self.web_view._selections_cleared = True
                                
                                # Add to pending selections
                                if not hasattr(self.web_view, '_pending_selections'):
                                    self.web_view._pending_selections = []
                                self.web_view._pending_selections.append((annotation_id, list_widget, matching_index))
                                print(f"DEBUG: Added annotation {annotation_id} to pending selections")
                            else:
                                # Single operation - apply selection immediately
                                print(f"DEBUG: Single operation - applying immediate selection for annotation {annotation_id}")
                                self.clear_all_tab_selections()
                                list_widget.setCurrentRow(matching_index)
                                new_item.setSelected(True)
                            
                            # Update notes icon after recreation (since recreation overwrites the icon)
                            new_item_widget = list_widget.itemWidget(new_item)
                            if new_item_widget:
                                edit_notes_btn = new_item_widget.findChild(QPushButton, "editNotesButton")
                                if edit_notes_btn and hasattr(list_widget, '_cached_icons'):
                                    # Get the annotation to check notes
                                    annotation = next((a for a in self.web_view.annotations if a.get('id') == annotation_id), None)
                                    if annotation:
                                        # Check if notes are empty
                                        def is_notes_empty(notes_html_str):
                                            if not notes_html_str:
                                                return True
                                            from bs4 import BeautifulSoup
                                            soup = BeautifulSoup(notes_html_str, 'html.parser')
                                            text_content = soup.get_text(strip=True)
                                            return not text_content
                                        
                                        notes_html_val = annotation.get('notes_html', '')
                                        html_has_content = not is_notes_empty(notes_html_val)
                                        has_notes = html_has_content  # Only check notes_html for book icon
                                        
                                        print(f"DEBUG ICON: notes_html='{notes_html_val[:30]}...', html_has_content={html_has_content}, has_notes={has_notes} (book icon only checks notes_html)")
                                        
                                        if has_notes:
                                            edit_notes_btn.setIcon(list_widget._cached_icons['notes']['active'])
                                            print(f"DEBUG: Set notes icon to active after recreation (notes exist)")
                                        else:
                                            edit_notes_btn.setIcon(list_widget._cached_icons['notes']['normal'])
                                            print(f"DEBUG: Set notes icon to normal after recreation (notes empty)")
                            
                            print(f"DEBUG: Recreated annotation item with speech title: '{speech_title}' and selected it")
                            return
                    break
            
            print(f"DEBUG: Could not find UI element for annotation {annotation_id} in scene '{scene}'")
            
        except Exception as e:
            print(f"DEBUG: Error updating speech title in UI: {e}")
            import traceback
            print(traceback.format_exc())

    def handle_reassignment_theme_view_updates(self, removed_annotation_ids, updated_annotations, added_annotations):
        """
        Efficiently handle theme view updates after annotation reassignment.
        This replaces the expensive update_theme_view() call in handle_removal_and_reassign.
        
        Args:
            removed_annotation_ids: List of annotation IDs that were completely removed
            updated_annotations: List of annotation dicts that were modified (left parts of splits)
            added_annotations: List of annotation dicts that were newly created (right parts of splits)
        """
        print(f"DEBUG: Targeted reassignment update - removed:{len(removed_annotation_ids)}, updated:{len(updated_annotations)}, added:{len(added_annotations)}")
        
        # Filter handling is now done in navigation logic - reassignment uses targeted updates
        # The existing filtering mechanisms will handle showing/hiding annotations appropriately
        
        try:
            from PyQt6.QtCore import Qt
            
            # Phase 1: Remove deleted annotations from UI
            for annotation_id in removed_annotation_ids:
                self._remove_annotation_from_theme_view(annotation_id)
            
            # Phase 2: Update modified annotations (left parts of splits)
            for annotation in updated_annotations:
                self._update_annotation_in_theme_view(annotation)
                
            # Phase 3: Add new annotations (right parts of splits)  
            for annotation in added_annotations:
                self._add_annotation_to_theme_view(annotation)
                
            print("DEBUG: Completed targeted reassignment update")
            
        except Exception as e:
            print(f"DEBUG: Error in targeted reassignment update: {e}")
            import traceback
            print(traceback.format_exc())
            # Fallback to full update if targeted update fails
            print("DEBUG: Falling back to full theme view update")
            self.update_theme_view()

    def _remove_annotation_from_theme_view(self, annotation_id):
        """Remove a specific annotation from the theme view UI"""
        from PyQt6.QtCore import Qt
        
        # Find and remove the annotation from all scene tabs
        for i in range(self.scene_tabs.count()):
            list_widget = self.scene_tabs.widget(i)
            if isinstance(list_widget, AnnotationListWidget):
                for j in range(list_widget.count()):
                    item = list_widget.item(j)
                    if item and item.data(Qt.ItemDataRole.UserRole) == annotation_id:
                        list_widget.takeItem(j)
                        print(f"DEBUG: Removed annotation {annotation_id} from theme view")
                        
                        # If this was the last item in the tab, remove the empty tab
                        if list_widget.count() == 0:
                            tab_name = self.scene_tabs.tabText(i)
                            self.scene_tabs.removeTab(i)
                            print(f"DEBUG: Removed empty scene tab '{tab_name}'")
                        return

    def _update_annotation_in_theme_view(self, annotation):
        """Update a specific annotation in the theme view UI"""
        annotation_id = annotation.get('id')
        if not annotation_id:
            return
            
        # Use the same logic as the speech title update method
        self.update_annotation_speech_title_in_ui(annotation_id, annotation.get('speech_title', ''))

    def _add_annotation_to_theme_view(self, annotation):
        """Add a new annotation to the theme view UI"""
        scene = annotation.get('scene')
        if not scene:
            return
            
        # Find or create the appropriate scene tab
        scene_tab = None
        for i in range(self.scene_tabs.count()):
            if self.scene_tabs.tabText(i) == scene:
                scene_tab = self.scene_tabs.widget(i)
                break
        
        # Create new tab if it doesn't exist
        if scene_tab is None:
            scene_tab = AnnotationListWidget(self.scene_tabs)
            self.scene_tabs.addTab(scene_tab, scene)
            print(f"DEBUG: Created new scene tab '{scene}'")
        
        # Add the annotation to the tab
        if isinstance(scene_tab, AnnotationListWidget):
            # Prepare notes content the same way update_theme_view does
            notes_content = {
                'plain': annotation.get('notes', ''),
                'html': annotation.get('notes_html', annotation.get('notes', ''))
            }
            
            print(f"DEBUG: TARGETED UPDATE: Adding {annotation.get('id')} to theme view")
            
            item = scene_tab.add_item_with_checkbox(
                text=annotation.get('text', ''),
                annotation_id=annotation.get('id'),
                is_used=annotation.get('used', False),
                notes=notes_content['plain'],
                notes_html=notes_content['html'],
                is_favorite=annotation.get('favorite', False),
                tags=annotation.get('tags', []),
                speech_title=annotation.get('speech_title', '')
            )
            
            
            # Set the same properties that update_theme_view sets
            item_widget = scene_tab.itemWidget(item)
            if item_widget:
                item_widget.setProperty('notes_html', notes_content['html'])
                item_widget.setProperty('notes', notes_content['plain'])
                
                # Update notes button icon state (same logic as _update_annotation_in_theme_view)
                edit_notes_btn = item_widget.findChild(QPushButton, "editNotesButton")
                print(f"DEBUG: Found edit_notes_btn: {edit_notes_btn is not None}")
                print(f"DEBUG: scene_tab has _cached_icons: {hasattr(scene_tab, '_cached_icons')}")
                
                if edit_notes_btn:
                    if hasattr(scene_tab, '_cached_icons'):
                        # Check if notes are empty (same logic as existing code)
                        def is_notes_empty(notes_html_str):
                            if not notes_html_str:
                                return True
                            from bs4 import BeautifulSoup
                            soup = BeautifulSoup(notes_html_str, 'html.parser')
                            text_content = soup.get_text(strip=True)
                            return not text_content
                        
                        has_notes = not is_notes_empty(notes_content['html'])  # Only check HTML notes for book icon
                        print(f"DEBUG: Has notes: {has_notes}, html='{notes_content['html'][:50]}...' (book icon only checks notes_html)")
                        
                        if has_notes:
                            edit_notes_btn.setIcon(scene_tab._cached_icons['notes']['active'])
                            print(f"DEBUG: Set notes icon to active (notes exist)")
                        else:
                            edit_notes_btn.setIcon(scene_tab._cached_icons['notes']['normal'])
                            print(f"DEBUG: Set notes icon to normal (notes empty)")
                    else:
                        print(f"DEBUG: scene_tab._cached_icons not available, cannot update icon")
                
            print(f"DEBUG: Added annotation {annotation.get('id')} to scene '{scene}' with proper setup and notes icon refresh")

    def _update_progress(self, value, text=None):
        """Update progress bar value and optional text"""
        if hasattr(self, '_progress_bar'):
            self._progress_bar.setValue(value)
            
        if text and hasattr(self, '_progress_label'):
            self._progress_label.setText(text)
            
        # Debug: Check if overlay is still visible (only restore if we should be showing progress)
        if hasattr(self, '_progress_overlay') and getattr(self, '_show_progress_this_update', False):
            if not self._progress_overlay.isVisible():
                print(f"[DEBUG] Progress overlay disappeared during update! Restoring - {text}")
                print(f"[DEBUG] Overlay parent when disappeared: {self._progress_overlay.parent()}")
                self._progress_overlay.show()
                self._progress_overlay.raise_()
            else:
                print(f"[DEBUG] Progress update: {text} - overlay visible: {self._progress_overlay.isVisible()}")
                # Force overlay to stay on top
                self._progress_overlay.raise_()
        
        QApplication.processEvents()
    
    def _show_update_progress(self):
        """Show progress overlay during theme view update"""
        print("[DEBUG] _show_update_progress called")
        print(f"[DEBUG] Current overlay state: {getattr(self, '_progress_overlay', None)}")
        if hasattr(self, '_progress_overlay') and self._progress_overlay:
            print(f"[DEBUG] Overlay exists, visible: {self._progress_overlay.isVisible()}")
            print(f"[DEBUG] Overlay parent: {self._progress_overlay.parent()}")
        
        if not hasattr(self, '_progress_overlay'):
            print("[DEBUG] Creating new progress overlay widget")
            # Create progress overlay widget - make it child of theme_view to avoid destruction during scene_tabs.clear()
            # Use different variable name to avoid conflict with StoryboardDialog's _loading_overlay
            self._progress_overlay = QWidget(self.theme_view)
            self._progress_overlay.setStyleSheet("""
                QWidget {
                    background-color: rgb(245, 245, 245);
                    border: none;
                }
                QLabel {
                    color: #333333;
                    font-size: 16px;
                    font-weight: bold;
                    background-color: transparent;
                    border: none;
                }
                QProgressBar {
                    border: 2px solid #cccccc;
                    border-radius: 8px;
                    background-color: white;
                    text-align: center;
                    font-size: 12px;
                }
                QProgressBar::chunk {
                    background-color: #4CAF50;
                    border-radius: 6px;
                }
            """)
            
            # Layout for overlay
            overlay_layout = QVBoxLayout(self._progress_overlay)
            overlay_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
            overlay_layout.setSpacing(20)
            overlay_layout.setContentsMargins(40, 40, 40, 40)
            
            # Add spacer at top to center content vertically
            overlay_layout.addStretch(1)
            
            # Icon or animation (using emoji for simplicity)
            icon_label = QLabel("⏳")
            icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            icon_label.setStyleSheet("""
                QLabel {
                    font-size: 38px;
                    background-color: transparent;
                    border: none;
                }
            """)
            overlay_layout.addWidget(icon_label)
            
            # Simple progress message
            self._progress_label = QLabel("Updating annotations...")
            self._progress_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self._progress_label.setStyleSheet("""
                QLabel {
                    font-size: 18px;
                    color: #444444;
                    background-color: transparent;
                    border: none;
                }
            """)
            overlay_layout.addWidget(self._progress_label)
            
            # Progress bar
            self._progress_bar = QProgressBar()
            self._progress_bar.setRange(0, 100)  # Percentage based progress
            self._progress_bar.setValue(0)
            self._progress_bar.setFixedHeight(24)
            self._progress_bar.setMaximumWidth(500)
            self._progress_bar.setTextVisible(False)  # Hide percentage text
            overlay_layout.addWidget(self._progress_bar, 0, Qt.AlignmentFlag.AlignCenter)
            
            # Add spacer at bottom
            overlay_layout.addStretch(1)
            print("[DEBUG] Progress overlay widgets created")
        else:
            print("[DEBUG] Using existing progress overlay widget")
            # Reset progress message
            self._progress_label.setText("Updating annotations...")
        
        # Show overlay and position it correctly
        self._progress_overlay.show()
        self._resize_progress_overlay()
        self._progress_overlay.raise_()
        
        # Record show time for minimum display duration
        import time
        self._progress_show_time = time.time()
    
    def _hide_update_progress(self):
        """Hide progress overlay after theme view update"""
        print("[DEBUG] _hide_update_progress called")
        if hasattr(self, '_progress_overlay') and self._progress_overlay:
            print(f"[DEBUG] Overlay exists when hiding, visible: {self._progress_overlay.isVisible()}")
            print(f"[DEBUG] Overlay parent when hiding: {self._progress_overlay.parent()}")
        else:
            print("[DEBUG] No overlay found when trying to hide")
        
        # Check if we're currently updating theme view - if so, don't hide yet
        if hasattr(self, '_updating_theme_view') and self._updating_theme_view:
            print("[DEBUG] Theme view still updating, deferring progress overlay hide")
            return
        
        # Add minimum display time before hiding
        if hasattr(self, '_progress_overlay') and hasattr(self, '_progress_show_time'):
            elapsed = time.time() - self._progress_show_time
            if elapsed < 0.5:  # Minimum 500ms display time
                remaining = 0.5 - elapsed
                print(f"[DEBUG] Adding {remaining:.2f}s delay to ensure progress is visible")
                time.sleep(remaining)
        
        if hasattr(self, '_progress_overlay'):
            self._progress_overlay.hide()
            print("[DEBUG] Progress overlay hidden")
        
        # Scene tabs were never hidden, so no need to show them again
        print("[DEBUG] Progress overlay cleanup complete")
    
    def _resize_progress_overlay(self):
        """Resize progress overlay to completely fill the scene_tabs widget"""
        if hasattr(self, '_progress_overlay') and self._progress_overlay.isVisible():
            # Get scene_tabs position relative to theme_view (the overlay's parent)
            scene_tabs_rect = self.scene_tabs.geometry()
            # Position overlay over scene_tabs area within theme_view
            self._progress_overlay.setGeometry(scene_tabs_rect)
            self._progress_overlay.raise_()

    def _show_tab_update_overlay(self):
        """Show a subtle overlay during tab item size updates to prevent flicker"""
        if not hasattr(self, 'scene_tabs') or not self.scene_tabs:
            return
            
        # Create overlay if it doesn't exist
        if not hasattr(self, '_tab_update_overlay') or self._tab_update_overlay is None:
            self._tab_update_overlay = QLabel(self.scene_tabs)
            self._tab_update_overlay.setObjectName("tab_update_overlay")
            self._tab_update_overlay.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self._tab_update_overlay.setStyleSheet("""
                QLabel#tab_update_overlay {
                    background-color: rgba(255, 255, 255, 0.8);
                    border: none;
                    color: #666;
                    font-size: 12px;
                    font-weight: bold;
                }
            """)
            self._tab_update_overlay.setText("Updating...")
        
        # Position and show overlay
        self._tab_update_overlay.resize(self.scene_tabs.size())
        self._tab_update_overlay.show()
        self._tab_update_overlay.raise_()
        QApplication.processEvents()  # Ensure overlay is visible immediately

    def _hide_tab_update_overlay(self):
        """Hide the tab update overlay"""
        if hasattr(self, '_tab_update_overlay') and self._tab_update_overlay:
            self._tab_update_overlay.hide()

    def _smooth_scroll(self, widget, target_pos):
        """Smoothly animate scrolling to target position"""
        current_pos = widget.verticalScrollBar().value()
        anim = QPropertyAnimation(widget.verticalScrollBar(), b"value")
        anim.setDuration(150)
        anim.setStartValue(current_pos)
        anim.setEndValue(target_pos)
        anim.setEasingCurve(QEasingCurve.Type.OutCubic)
        anim.start(QAbstractAnimation.DeletionPolicy.DeleteWhenStopped)

    def validate_stored_state(self, state):
        """Validate stored state against current content"""
        validated = {
            'current_tab': min(state['current_tab'], self.scene_tabs.count() - 1),
            'scroll_positions': {},
            'selected_items': {}
        }
    
        # Validate each tab's state
        for tab_index, scroll_pos in state['scroll_positions'].items():
            if tab_index < self.scene_tabs.count():
                list_widget = self.scene_tabs.widget(tab_index)
                if list_widget and list_widget.count() > 0:
                    validated['scroll_positions'][tab_index] = min(
                        scroll_pos,
                        list_widget.verticalScrollBar().maximum()
                    )
    
        # Validate selections
        for tab_index, selections in state['selected_items'].items():
            if tab_index < self.scene_tabs.count():
                list_widget = self.scene_tabs.widget(tab_index)
                if list_widget:
                    valid_selections = []
                    for j in range(list_widget.count()):
                        item = list_widget.item(j)
                        label = list_widget.itemWidget(item).findChild(QLabel)
                        if label and label.text() in selections:
                            valid_selections.append(label.text())
                    if valid_selections:
                        validated['selected_items'][tab_index] = valid_selections
    
        return validated

    def hide_theme_view(self):
        self.theme_view.hide()
        self.view_annotations_button.setChecked(False)

    def toggle_mode(self):
        if self.mode_toggle_button.isChecked():
            # Switch to Edit Mode
            self.mode_indicator.setText('Edit Mode')
            self.mode_indicator.setStyleSheet("""
                QLabel {
                    padding: 6px 12px;
                    border-radius: 4px;
                    font-weight: 500;
                    font-size: 13px;
                    background-color: #F3E8FF;
                    color: #6B21A8;
                }
            """)
            self.web_view.set_edit_mode(True)
            self.status_bar.showMessage('Edit Mode Enabled', 5000)
        else:
            # Switch to Highlight Mode
            self.mode_indicator.setText('Highlight Mode')
            self.mode_indicator.setStyleSheet("""
                QLabel {
                    padding: 6px 12px;
                    border-radius: 4px;
                    font-weight: 500;
                    font-size: 13px;
                    background-color: #EBF5FF;
                    color: #1D4ED8;
                }
            """)
            self.web_view.set_edit_mode(False)
            self.status_bar.showMessage('Highlight Mode Enabled', 5000)

        # Keep the toggle button symbol consistent
        self.mode_toggle_button.setText('⇄')

    def handle_search(self):
        """Handle search text changes"""
        text = self.search_input.text()
        if text:
            self.find_text(text)
        else:
            self.close_search()  # Clear highlights when search is empty

    def find_text(self, text, forward=True):
        """Find text in the web view"""
        if text:
            self.web_view.findText(
                text,
                QWebEnginePage.FindFlag.FindBackward if not forward else QWebEnginePage.FindFlag(0),
                lambda found: self.handle_find_result(found)
            )
    def update_preview_content(self, html_content):
        """Update the preview content while preserving scroll position, optimized for large files."""
        print("=== UPDATE PREVIEW CONTENT START ===")
        print("Getting current scroll position using JavaScript...")
    
        def update_with_scroll(scroll_pos):
            print(f"Scroll position retrieved from JavaScript: {scroll_pos}")
    
            # Set a flag to indicate that we are updating the content
            self.web_view.updating_content = True
    
            def on_load_finished(ok):
                if ok:
                    print("Web page loaded successfully.")
                    # Remove the loadFinished connection to avoid multiple calls
                    self.web_view.loadFinished.disconnect(on_load_finished)
    
                    # Use a single-shot timer to delay the scroll restoration
                    QTimer.singleShot(200, lambda: restore_scroll(scroll_pos))  # Increased delay to 300ms
                else:
                    print("Error: Web page failed to load.")
                    self.web_view.updating_content = False
    
            def restore_scroll(scroll_pos):
                print(f"Restoring scroll position to: {scroll_pos}")
                restore_js = f"window.scrollTo(0, {scroll_pos});"
    
                def on_scroll_restored(result):
                    print(f"Scroll restoration JavaScript execution result: {result}")
                    # Reset the flag after scroll restoration
                    self.web_view.updating_content = False
    
                self.web_view.page().runJavaScript(restore_js, on_scroll_restored)
    
            # Connect the loadFinished signal to the on_load_finished handler
            self.web_view.loadFinished.connect(on_load_finished)
    
            # Set the new HTML content
            print("Setting new HTML content in web view...")
            self.web_view.setHtml(html_content)
    
        self.web_view.page().runJavaScript("window.pageYOffset", update_with_scroll)
        print("=== UPDATE PREVIEW CONTENT END ===")

    def handle_find_result(self, found):
        """Handle the result of a find operation"""
        if found:
            self.search_input.setStyleSheet("QLineEdit { background-color: white; }")
        else:
            self.search_input.setStyleSheet("QLineEdit { background-color: #ffe0e0; }")

    def focus_search(self):
        """Focus the search input and select any existing text"""
        self.search_input.setFocus()
        self.search_input.selectAll()

    def close_search(self):
        """Close the search functionality"""
        self.search_input.clear()
        self.web_view.findText("")  # Clear any highlighting
        self.search_input.setStyleSheet("QLineEdit { background-color: white; }")

    # def handle_preview_content_change(self, html_content):
    #     """Handle changes in the preview content"""
    #     # Update the output text
    #     self.output_text.setPlainText(html_content)

    #     # Only add asterisk if there are real unsaved changes and it's not already there
    #     current_state = self.get_current_state()
    #     if current_state != self.last_saved_state and not self.windowTitle().startswith('*'):
    #         self.setWindowTitle(f'*{self.windowTitle()}')

    def open_file(self):
        file_name, _ = QFileDialog.getOpenFileName(
            self, "Open Text File", "", "Text Files (*.txt);;All Files (*)"
        )
        if file_name:
            try:
                with open(file_name, 'r', encoding='utf-8') as file:
                    content = file.read()
                    self.input_text.setPlainText(content)
                self.status_bar.showMessage(f'Loaded file: {file_name}', 5000)
            except Exception as e:
                QMessageBox.critical(self, 'Error', f'An error occurred while opening the file:\n{e}')

    def has_orphaned_text(self):
        """
        Check if there is any orphaned text in the document
        This should explicitly run the check before returning the result
        """
        # Force a check for orphaned text
        self.input_text.header_highlighter.check_for_orphaned_text()
    
        # Return the result
        return bool(self.input_text.header_highlighter.get_orphaned_blocks())

    def show_orphaned_text_warning(self):
        """
        Show a warning message about orphaned text
        """
        msg_box = QMessageBox(self)
        msg_box.setIcon(QMessageBox.Icon.Warning)
        msg_box.setWindowTitle("Orphaned Text Detected")
        msg_box.setText("Text without headers was detected in your document.")
    
        detailed_text = (
            "Orphaned text (marked in red) is content that is not associated with any header and will not "
            "appear in the final transcript.\n\n"
            "All content must be under a normal header (marked with **Header**) to be included. "
            "Section dividers (marked with [[Section]]) don't capture content.\n\n"
            "Please either:\n"
            "• Add headers to the orphaned text (right-click on red text → 'Add Header for Orphaned Text')\n"
            "• Remove the orphaned text if it's not needed"
        )
    
        msg_box.setDetailedText(detailed_text)
    
        # Create custom buttons
        fix_button = QPushButton("Understood")
        cancel_button = QPushButton("Cancel")
    
        msg_box.addButton(fix_button, QMessageBox.ButtonRole.AcceptRole)
        msg_box.addButton(cancel_button, QMessageBox.ButtonRole.RejectRole)
    
        # Set default focus to the fix button
        fix_button.setDefault(True)
    
        # Connect a direct signal handler to the button
        fix_button.clicked.connect(self.highlight_first_orphaned_block)
    
        # Show the message box
        msg_box.exec()
    
        # Note: We don't need the clicked_button check anymore since
        # we're directly connecting the button's clicked signal

    def highlight_first_orphaned_block(self):
        """
        Highlight and scroll to the first orphaned block in the document
        """
        orphaned_blocks = self.input_text.header_highlighter.get_orphaned_blocks()
        if not orphaned_blocks:
            return
        
        # Get the first orphaned block
        first_block_num = min(orphaned_blocks)
    
        # Create a cursor at that block
        doc = self.input_text.document()
        block = doc.findBlockByNumber(first_block_num)
    
        cursor = QTextCursor(block)
    
        # Select the entire block
        cursor.movePosition(QTextCursor.MoveOperation.StartOfBlock)
        cursor.movePosition(QTextCursor.MoveOperation.EndOfBlock, QTextCursor.MoveMode.KeepAnchor)
    
        # Set the cursor
        self.input_text.setTextCursor(cursor)
    
        # Ensure the block is visible
        self.input_text.ensureCursorVisible()
    
        # Focus the text edit
        self.input_text.setFocus()

    def convert_text(self):
        # Import required modules
        import re
        import os
        import json
        import sys
        # Wait until any orphaned text check is finished
        if getattr(self.input_text, '_is_processing', False):
            print(f"{self._debug_timestamp()} [convert_text] Waiting for orphan check to finish...")
            QTimer.singleShot(500, self.convert_text)
            return

        # Check for orphaned text
        if self.has_orphaned_text():
            self.show_orphaned_text_warning()
            return  # Block transcript creation until orphaned text is fixed

        # Default HTML for output
        default_html = """
        <!DOCTYPE html>
        <html>
        <head>
            <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
            <script>
                document.addEventListener("DOMContentLoaded", function() {
                    if (typeof QWebChannel !== "undefined") {
                        new QWebChannel(qt.webChannelTransport, function(channel) {
                            window.jsHandler = channel.objects.jsHandler;
                            window.webChannelInitialized = true;
                        });
                    }
                });
            </script>
        </head>
        <body contenteditable="false">
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 80vh; color: #6B7280; font-family: 'Segoe UI', sans-serif;">
                <div style="font-size: 4rem; margin-bottom: 1rem;">📝</div>
                <h2 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.5rem;">No Content Yet</h2>
                <p style="text-align: center; font-size: 0.875rem; max-width: 28rem;">
                    Create a new transcript in the "Create Transcript" tab or load an existing session to get started.
                </p>
            </div>
        </body>
        </html>
        """.strip()

        raw_text = self.input_text.toPlainText()
        if not raw_text.strip():
            QMessageBox.warning(self, 'Input Error', 'Please provide the text content.')
            return

        # Check if the output contains existing content
        current_output = self.output_text.toPlainText().strip()

        # Store original states - handle all attributes carefully
        try:
            original_output = self.output_text.toPlainText()
            original_annotations = self.web_view.annotations.copy() if hasattr(self.web_view, 'annotations') else []
            original_scene_styles = self.web_view.scene_styles.copy() if hasattr(self.web_view, 'scene_styles') else {}

            # Safely store original bookmarks state
            original_bookmarks = {}
            if hasattr(self, 'bookmark_list'):
                try:
                    for i in range(self.bookmark_list.count()):
                        item = self.bookmark_list.item(i)
                        if item and item.data(Qt.ItemDataRole.UserRole):
                            bookmark_data = item.data(Qt.ItemDataRole.UserRole)
                            if isinstance(bookmark_data, dict) and 'name' in bookmark_data:
                                original_bookmarks[bookmark_data['name']] = {
                                    'favorite': bookmark_data.get('is_favorite', False),
                                    'position': i,
                                    'data': bookmark_data.copy()  # Store full bookmark data
                                }
                except Exception as e:
                    print(f"Warning: Error storing bookmark state: {str(e)}")
                    original_bookmarks = {}  # Reset to empty if error occurs
        except Exception as e:
            print(f"Warning: Error storing original state: {str(e)}")
            return

        # Initialize theme preset manager if not exists
        if not hasattr(self, 'theme_preset_manager'):
            self.theme_preset_manager = ThemePresetManager(self)

        dialog = QDialog(self)
        dialog.setWindowTitle('Create New Transcript')
        dialog.resize(700, 750)  # Increased height to accommodate new controls

        layout = QVBoxLayout(dialog)
        layout.setSpacing(20)
        layout.setContentsMargins(25, 25, 25, 25)

        # Title section
        title_group = QGroupBox("Transcript Title")
        title_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                font-size: 13px;
                border: 0px solid #ddd;
                border-radius: 6px;
                margin-top: 12px;
                background-color: transparent;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 0px;
            }
        """)
        title_layout = QVBoxLayout(title_group)
        title_edit = QLineEdit()
        title_edit.setPlaceholderText("Enter transcript title...")
        title_edit.setStyleSheet("""
            QLineEdit {
                padding: 8px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 13px;
                background-color: white;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
        """)
        title_layout.addWidget(title_edit)
        layout.addWidget(title_group)

        # Theme Type section
        type_group = QGroupBox("Theme Type")
        type_layout = QVBoxLayout(type_group)
        type_buttons = QButtonGroup(dialog)

        # Create a horizontal layout for radio buttons + preset controls
        radio_preset_layout = QHBoxLayout()
    
        # Add radio buttons
        radio_layout = QVBoxLayout()
        custom_radio = QRadioButton("Create New Themes")
        custom_preset_radio = QRadioButton("Preset Themes")
        custom_radio.setChecked(True)

        type_buttons.addButton(custom_radio)
        type_buttons.addButton(custom_preset_radio)

        radio_style = """
            QRadioButton {
                font-size: 13px;
                padding: 5px;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
            QRadioButton::indicator:unchecked {
                border: 2px solid #666;
                background: transparent;
                border-radius: 10px;
            }
            QRadioButton::indicator:checked {
                border: 2px solid #2196F3;
                background: #2196F3;
                border-radius: 10px;
            }
        """
        custom_preset_radio.setStyleSheet(radio_style)
        custom_radio.setStyleSheet(radio_style)

        radio_layout.addWidget(custom_radio)
        radio_layout.addWidget(custom_preset_radio)
        radio_preset_layout.addLayout(radio_layout, 1)
    
        # Add preset selection and management
        preset_layout = QVBoxLayout()
        preset_layout.setContentsMargins(10, 0, 0, 0)
    
        # First, modify how we handle the preset UI elements:
        preset_label = QLabel("Select Preset:")
        preset_combo = QComboBox()
        preset_combo.setStyleSheet("""
            QComboBox {
                padding: 4px 8px;
                border: 1px solid #ddd;
                border-radius: 4px;
                min-width: 180px;
            }
            QComboBox:focus {
                border-color: #2196F3;
            }
            QComboBox:disabled {
                background-color: #f5f5f5;
                color: #888;
            }
        """)

        # Populate preset combo
        preset_names = self.theme_preset_manager.get_preset_names()
        preset_combo.addItems(preset_names)

        # Preset management buttons
        manage_btn = QPushButton("Manage Presets")
        manage_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 4px 8px;
            }
            QPushButton:hover {
                background-color: #f0f0f0;
                border-color: #ccc;
            }
            QPushButton:disabled {
                background-color: #f5f5f5;
                color: #888;
                border-color: #ddd;
            }
        """)

        preset_layout.addWidget(preset_label)
        preset_layout.addWidget(preset_combo)
        preset_layout.addWidget(manage_btn)
    
        radio_preset_layout.addLayout(preset_layout, 1)
        type_layout.addLayout(radio_preset_layout)
    
        layout.addWidget(type_group)

        # Custom themes section - ALWAYS VISIBLE now
        custom_group = QGroupBox("Theme Configuration")
        custom_layout = QVBoxLayout(custom_group)

        # Add save current themes as preset section at top of theme configuration
        save_preset_container = QWidget()
        save_preset_layout = QHBoxLayout(save_preset_container)
        save_preset_layout.setContentsMargins(0, 0, 0, 0)

        save_preset_label = QLabel("Save Preset:")
        save_preset_name = QLineEdit()
        save_preset_name.setPlaceholderText("Enter preset name...")
        save_preset_name.setStyleSheet("""
            QLineEdit {
                padding: 6px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 13px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
        """)

        save_preset_btn = QPushButton("Save Preset")
        save_preset_btn.setStyleSheet("""
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 4px 12px;
                border-radius: 4px;
                font-weight: 500;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
        """)

        save_preset_layout.addWidget(save_preset_label)
        save_preset_layout.addWidget(save_preset_name, 1)
        save_preset_layout.addWidget(save_preset_btn)

        custom_layout.addWidget(save_preset_container)
    
        # Add horizontal separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        separator.setStyleSheet("background-color: #ddd; margin: 10px 0;")
        custom_layout.addWidget(separator)

        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setStyleSheet("QScrollArea { border: none; }")

        container_widget = QWidget()
        form_layout = QFormLayout(container_widget)
        form_layout.setSpacing(8)
        scroll_area.setWidget(container_widget)
        custom_layout.addWidget(scroll_area)

        scene_edits = []

        def update_sections_visibility():
            using_custom_preset = custom_preset_radio.isChecked()
            using_custom = custom_radio.isChecked()
    
            # Show/hide save preset part of theme configuration
            # Show for both custom themes and saved presets
            save_preset_container.setVisible(using_custom or using_custom_preset)
            separator.setVisible(using_custom or using_custom_preset)
    
            # For saved presets, the text field should show the preset name but be read-only
            save_preset_name.setReadOnly(using_custom_preset)
            # Style the input field differently when it's read-only for visual feedback
            if using_custom_preset:
                save_preset_name.setStyleSheet("""
                    QLineEdit {
                        padding: 6px;
                        border: 1px solid #ddd;
                        border-radius: 4px;
                        font-size: 13px;
                        background-color: #f5f5f5;
                    }
                """)
            else:
                save_preset_name.setStyleSheet("""
                    QLineEdit {
                        padding: 6px;
                        border: 1px solid #ddd;
                        border-radius: 4px;
                        font-size: 13px;
                    }
                    QLineEdit:focus {
                        border-color: #2196F3;
                    }
                """)
    
            # Button should only be enabled for custom themes
            save_preset_btn.setEnabled(using_custom or using_custom_preset)
    
            # Enable/disable preset selector controls
            preset_combo.setEnabled(using_custom_preset)
            manage_btn.setEnabled(using_custom_preset)
            preset_label.setEnabled(using_custom_preset)
    
            # Update theme configuration based on selection
            if using_custom:
                populate_custom_themes()
            elif using_custom_preset:
                # Apply selected preset and make sure name field is populated
                preset_name = preset_combo.currentText()
                save_preset_name.setText(preset_name)
                save_preset_name.setReadOnly(False)
                apply_selected_preset()

        # Connect radio buttons
        custom_preset_radio.toggled.connect(update_sections_visibility)
        custom_radio.toggled.connect(update_sections_visibility)

        def add_theme_row(theme_name='', color=None):
            if form_layout.rowCount() >= 12:
                QMessageBox.warning(dialog, "Limit Reached", "You can only have up to 12 themes.")
                return None
            
            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 0, 0, 0)
            row_layout.setSpacing(10)

            line_edit = QLineEdit(theme_name)
            line_edit.setMaxLength(40)
            line_edit.setMinimumWidth(200)
            line_edit.setPlaceholderText("Enter theme name (max 40 chars)...")
            line_edit.setStyleSheet("""
                QLineEdit {
                    padding: 6px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-size: 13px;
                }
                QLineEdit:focus {
                    border-color: #2196F3;
                }
            """)

            char_count_label = QLabel(f"{len(theme_name)}/40")
            char_count_label.setStyleSheet("color: #666666; font-size: 11px;")

            def update_char_count(text):
                char_count_label.setText(f"{len(text)}/40")
                if len(text) >= 30:
                    char_count_label.setStyleSheet("color: #d32f2f; font-size: 11px; font-weight: bold;")
                else:
                    char_count_label.setStyleSheet("color: #666666; font-size: 11px;")

            line_edit.textChanged.connect(update_char_count)

            # Color picker button
            if color is None:
                # Use a preset color if none provided
                idx = form_layout.rowCount() % len(preset_colors)
                color = preset_colors[idx]
            
            color_button = QPushButton()
            color_button.setCursor(Qt.CursorShape.PointingHandCursor)
            color_button.setFixedSize(30, 30)
            color_button.setStyleSheet(f"""
                QPushButton {{
                    background-color: {color};
                    border: 1px solid #ccc;
                    border-radius: 4px;
                }}
                QPushButton:hover {{
                    border: 1px solid #2196F3;
                }}
            """)
        
            def on_color_clicked():
                color_dialog = QColorDialog(dialog)
                current_color = QColor(color_button.palette().button().color())
                color_dialog.setCurrentColor(current_color)
            
                if color_dialog.exec() == QColorDialog.DialogCode.Accepted:
                    new_color = color_dialog.selectedColor().name()
                    color_button.setStyleSheet(f"""
                        QPushButton {{
                            background-color: {new_color};
                            border: 1px solid #ccc;
                            border-radius: 4px;
                        }}
                        QPushButton:hover {{
                            border: 1px solid #2196F3;
                        }}
                    """)
                
            color_button.clicked.connect(on_color_clicked)

            row_layout.addWidget(line_edit, stretch=1)
            row_layout.addWidget(char_count_label)
            row_layout.addWidget(color_button)

            remove_button = QPushButton("✕")
            remove_button.setFixedSize(30, 30)
            remove_button.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    color: #666;
                    font-size: 14px;
                }
                QPushButton:hover {
                    background-color: #ffebee;
                    border-color: #f44336;
                    color: #f44336;
                }
            """)
            row_layout.addWidget(remove_button)

            label = QLabel(f"Theme {form_layout.rowCount() + 1}")
            label.setStyleSheet("font-weight: normal; color: #444;")

            form_layout.addRow(label, row_widget)
            row_number = form_layout.rowCount() - 1
            scene_edits.append((theme_name, line_edit, row_number, color_button))

            def remove_theme():
                # Prevent deletion if only one theme remains
                if len(scene_edits) <= 1:
                    QMessageBox.warning(dialog, "Cannot Delete", "At least one theme must remain in the theme configuration.")
                    return
                    
                for i, (name, le, rnum, _) in enumerate(scene_edits):
                    if rnum == row_number:
                        scene_edits.pop(i)
                        form_layout.removeRow(rnum)
                        for j in range(i, len(scene_edits)):
                            scene_edits[j] = (scene_edits[j][0], scene_edits[j][1], scene_edits[j][2]-1, scene_edits[j][3])
                        renumber_themes()
                        break

            remove_button.clicked.connect(remove_theme)
            return line_edit, color_button

        def renumber_themes():
            for i in range(form_layout.rowCount()):
                label_item = form_layout.itemAt(i, QFormLayout.ItemRole.LabelRole)
                if label_item and label_item.widget():
                    label_item.widget().setText(f"Theme {i+1}")

        def populate_custom_themes():
            # Clear existing theme rows
            while form_layout.rowCount() > 0:
                form_layout.removeRow(0)
            scene_edits.clear()
        
            # Add 4 default empty themes
            for i in range(4):
                add_theme_row(f"Theme {i+1}")

        add_button = QPushButton('Add Theme')
        add_button.setStyleSheet("""
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: 500;
                font-size: 13px;
                min-width: 100px;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
            QPushButton:disabled {
                background-color: #BDBDBD;
            }
        """)
        add_button.clicked.connect(lambda: add_theme_row(f"Theme {form_layout.rowCount() + 1}"))
        custom_layout.addWidget(add_button, alignment=Qt.AlignmentFlag.AlignLeft)

        layout.addWidget(custom_group)

        # Define preset colors
        preset_colors = [
            '#FFF0B3',  # Moccasin (Warm Peach)
            '#FFD7DC',  # Coral Pink
            '#D7FFB8',  # Lime Mint
            '#E6D7F5',  # Lavender
            '#B4E4FF',  # Sky blue
            '#FFC7AC',  # Butter Yellow
            '#B5EAE0',  # Seafoam
            '#FFD4E5',  # Rose Pink
            '#ACA8FF',  # Spring Green
            '#FFF1E1',  # Light Apricot
            '#B8D8B8',  # Mint Green
            '#F2C1E5'   # Lilac Pink
        ]

        # Generic Theme preset - will be created as a default preset if it doesn't exist
        GENERIC_THEME_PRESET = {
            'Identify Problem': 'background-color: #FFF0B3;',
            'Why Important?': 'background-color: #FFD7DC;',
            'Solution': 'background-color: #D7FFB8;',
            'Future Outlook': 'background-color: #E6D7F5;'
        }

        # Ensure Generic Theme preset exists
        if 'Generic Theme' not in self.theme_preset_manager.get_preset_names():
            self.theme_preset_manager.save_preset('Generic Theme', GENERIC_THEME_PRESET)
    
        def apply_selected_preset():
            """Apply the selected preset and update the preset name field"""
            preset_name = preset_combo.currentText()
            if not preset_name:
                # Handle no preset case
                save_preset_name.clear()
                populate_custom_themes()
                return
        
            # Always set the preset name in the field
            save_preset_name.setText(preset_name)
    
            preset_data = self.theme_preset_manager.get_preset(preset_name)
            if not preset_data:
                # Handle invalid preset
                save_preset_name.clear()
                populate_custom_themes()
                return
        
            # Clear existing theme rows
            while form_layout.rowCount() > 0:
                form_layout.removeRow(0)
    
            scene_edits.clear()
    
            # Add themes from preset
            for theme_name, style in preset_data.items():
                # Extract color from style
                color_match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', style)
                color = color_match.group(1) if color_match else preset_colors[0]
                add_theme_row(theme_name, color)

        def handle_manage_presets():
            """Handle showing the preset management dialog and refreshing the UI after changes"""
            # Call the dialog but handle if it returns None
            result = self.theme_preset_manager.show_manage_presets_dialog()
    
            # Default to no changes if None is returned
            changes = result or {"renamed": False, "deleted": False}
    
            if changes.get("renamed", False) or changes.get("deleted", False):
                # Refresh the preset combo
                current_selection = preset_combo.currentText()
                preset_combo.clear()
                preset_names = self.theme_preset_manager.get_preset_names()
                preset_combo.addItems(preset_names)
        
                # Try to restore selection or select first item
                index = preset_combo.findText(current_selection)
                if index >= 0:
                    preset_combo.setCurrentIndex(index)
                elif preset_combo.count() > 0:
                    preset_combo.setCurrentIndex(0)
            
                # If using preset radio is selected, apply the new selection
                if custom_preset_radio.isChecked():
                    apply_selected_preset()

        manage_btn.clicked.connect(handle_manage_presets)

        # Initial visibility update
        update_sections_visibility()


        # Update radio button handlers to clear or set the preset name field
        custom_radio.toggled.connect(lambda checked: checked and save_preset_name.clear())
        custom_preset_radio.toggled.connect(lambda checked: 
            checked and save_preset_name.setText(preset_combo.currentText() if preset_combo.currentText() else ""))


        # And modify the preset combo change handler:
        preset_combo.currentIndexChanged.connect(lambda: 
            custom_preset_radio.isChecked() and (
                save_preset_name.setText(preset_combo.currentText()),
                apply_selected_preset()
            )
        )
    
    
        # Handle saving current themes as preset
        def save_current_theme_preset():
            preset_name = save_preset_name.text().strip()
            if not preset_name:
                QMessageBox.warning(dialog, "Missing Name", "Please enter a name for the preset.")
                return
            
            # Build theme data from current rows
            theme_data = {}
            for _, name_edit, _, color_button in scene_edits:
                theme_name = name_edit.text().strip()
                if not theme_name:
                    continue
                
                # Get the color from the button's style
                style = color_button.styleSheet()
                color_match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', style)
                color = color_match.group(1) if color_match else "#FFFFFF"
            
                theme_data[theme_name] = f"background-color: {color};"
        
            if not theme_data:
                QMessageBox.warning(dialog, "No Themes", "Please add at least one theme with a name.")
                return
            
            # Save the preset
            if self.theme_preset_manager.save_preset(preset_name, theme_data):
                # Update the combo box
                preset_combo.clear()
                preset_combo.addItems(self.theme_preset_manager.get_preset_names())
            
                # Select the new preset
                index = preset_combo.findText(preset_name)
                if index >= 0:
                    preset_combo.setCurrentIndex(index)
                
                # Clear the input field
                #save_preset_name.clear()
            
                # Show confirmation
                QMessageBox.information(dialog, "Success", f"Preset '{preset_name}' has been saved.")
            else:
                QMessageBox.warning(dialog, "Error", "Failed to save preset. Please try again.")
    
        save_preset_btn.clicked.connect(save_current_theme_preset)
    
    
        # Updated manage presets dialog to refresh the combo box after changes
        original_show_manage = self.theme_preset_manager.show_manage_presets_dialog
    
        def enhanced_show_manage():
            original_show_manage()
            # Refresh the combo box
            preset_combo.clear()
            preset_combo.addItems(self.theme_preset_manager.get_preset_names())
    
        self.theme_preset_manager.show_manage_presets_dialog = enhanced_show_manage

        # Place the two radio buttons for layout type in a fixed-size container
        radio_container = QWidget()
        radio_container.setFixedSize(150, 26)  # Adjust width/height as needed
        radio_layout = QHBoxLayout(radio_container)
        radio_layout.setSpacing(0)
        radio_layout.setContentsMargins(0, 0, 0, 0)

        radio_style_small = """
            QRadioButton {
                background-color: transparent;
                font-size: 12px;
                margin: 5px;
                padding: 0px;
            }
            QRadioButton::indicator {
                width: 14px;
                height: 14px;
                margin: 0px;
                padding: 0px;
            }
            QRadioButton::indicator:unchecked {
                border: 1px solid #666;
                border-radius: 7px;
                background: transparent;
            }
            QRadioButton::indicator:checked {
                border: 1px solid #2196F3;
                background: #2196F3;
                border-radius: 7px;
            }
        """

        # Layout options
        layout_group = QGroupBox("Layout Style")
        layout_group_layout = QVBoxLayout(layout_group)
    
        self.video_radio = QRadioButton("Large")
        self.book_radio = QRadioButton("Compact")
        self.book_radio.setChecked(True)
        self.video_radio.setStyleSheet(radio_style_small)
        self.book_radio.setStyleSheet(radio_style_small)
        
        radio_layout.addWidget(self.book_radio)
        radio_layout.addWidget(self.video_radio)
    
        layout_group_layout.addWidget(radio_container)
    
        layout.addWidget(layout_group)

        # Dialog buttons
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        button_box.setStyleSheet("""
            QPushButton {
                padding: 8px 16px;
                min-width: 80px;
                border-radius: 4px;
                border: none;
                background-color: #203740;
                color: white;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
        """)
        layout.addWidget(button_box)

        def validate_and_accept():
            title = title_edit.text().strip()
            if not title:
                QMessageBox.warning(dialog, "Invalid Title", "Please enter a transcript title.")
                return

            # Validate all theme names
            seen_names = set()
            for _, line_edit, _, _ in scene_edits:
                name = line_edit.text().strip()
                if not name:
                    QMessageBox.warning(dialog, "Invalid Theme Name", "Theme names cannot be empty.")
                    return
                if name in seen_names:
                    QMessageBox.warning(
                        dialog,
                        "Duplicate Theme Name",
                        f"Theme name '{name}' is used multiple times. Each theme must have a unique name."
                    )
                    return
                if len(name) > 40:
                    QMessageBox.warning(
                        dialog,
                        "Theme Name Too Long",
                        f"Theme name '{name}' exceeds 40 characters. Please shorten it."
                    )
                    return
                seen_names.add(name)

            dialog.accept()

        button_box.accepted.connect(validate_and_accept)
        button_box.rejected.connect(dialog.reject)

        # Initialize with custom themes by default since custom_radio is checked
        populate_custom_themes()

        if dialog.exec() != QDialog.DialogCode.Accepted:
            # Restore original state if dialog is cancelled
            try:
                self.output_text.setPlainText(original_output)
                if hasattr(self.web_view, 'annotations'):
                    self.web_view.annotations = original_annotations
                if hasattr(self.web_view, 'scene_styles'):
                    self.web_view.scene_styles = original_scene_styles
    
                # Carefully restore bookmarks if they exist
                if hasattr(self, 'bookmark_list') and original_bookmarks:
                    try:
                        self.bookmark_list.clear()
                        for bookmark_name, state in original_bookmarks.items():
                            item = QListWidgetItem()
                            item.setData(Qt.ItemDataRole.UserRole, state['data'])
                            self.bookmark_list.insertItem(state['position'], item)
                    except Exception as e:
                        print(f"Warning: Error restoring bookmarks: {str(e)}")
            except Exception as e:
                print(f"Warning: Error restoring original state: {str(e)}")
    
            self.status_bar.showMessage('Conversion cancelled.', 5000)
            return

        is_empty_output = not current_output

        # Check if the content is the placeholder or empty HTML shell
        is_placeholder = False
        has_meaningful_content = True

        if current_output:
            # Check for the two key placeholder identifiers
            is_placeholder = "No Content Yet" in current_output and "font-size: 4rem" in current_output

            # Also check for empty HTML shell (empty body)
            empty_body_pattern = r'<body[^>]*>\s*</body>'
            import re
            has_empty_body = bool(re.search(empty_body_pattern, current_output))

            # Consider content meaningful only if it's not a placeholder AND doesn't have an empty body
            has_meaningful_content = not is_placeholder and not has_empty_body

        # Only show warning if there's actual meaningful content
        if not is_empty_output and has_meaningful_content:
            reply = QMessageBox.warning(
                self,
                "Are you sure?",
                "Existing transcript will be overwritten. Do you want to proceed?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply != QMessageBox.StandardButton.Yes:
                # Restore original state if user cancels overwrite
                try:
                    self.output_text.setPlainText(original_output)
                    if hasattr(self.web_view, 'annotations'):
                        self.web_view.annotations = original_annotations
                    if hasattr(self.web_view, 'scene_styles'):
                        self.web_view.scene_styles = original_scene_styles
        
                    # Carefully restore bookmarks if they exist
                    if hasattr(self, 'bookmark_list') and original_bookmarks:
                        try:
                            self.bookmark_list.clear()
                            for bookmark_name, state in original_bookmarks.items():
                                item = QListWidgetItem()
                                item.setData(Qt.ItemDataRole.UserRole, state['data'])
                                self.bookmark_list.insertItem(state['position'], item)
                        except Exception as e:
                            print(f"Warning: Error restoring bookmarks: {str(e)}")
                except Exception as e:
                    print(f"Warning: Error restoring original state: {str(e)}")
        
                self.status_bar.showMessage('Conversion cancelled.', 5000)
                return

        # If dialog is accepted and overwrite is confirmed (if needed), proceed with clearing and new content
        try:
            self.output_text.clear()
            self.output_text.setPlainText(default_html)
            if hasattr(self.web_view, 'annotations'):
                self.web_view.annotations = []
            if hasattr(self.web_view, 'scene_styles'):
                self.web_view.scene_styles = []

            # Completely destroy bookmark panel and all bookmark data
            if hasattr(self, 'bookmark_panel'):
                # Clear panel data
                self.bookmark_panel.bookmarks = []
                self.bookmark_panel.refresh_list()
                # Remove the widget
                self.bookmark_panel.deleteLater()
                delattr(self, 'bookmark_panel')

            # Ensure button is unchecked
            if hasattr(self, 'bookmark_button'):
                self.bookmark_button.setChecked(False)

            # Clear ALL bookmark data from session
            if hasattr(self, 'session'):
                # Clear main session data
                if hasattr(self.session, '_data'):
                    # Clear direct bookmarks array
                    if 'bookmarks' in self.session._data:
                        self.session._data['bookmarks'] = []
                
                    # Clear preview section bookmarks
                    if 'preview' in self.session._data:
                        if isinstance(self.session._data['preview'], dict):
                            if 'bookmarks' in self.session._data['preview']:
                                self.session._data['preview']['bookmarks'] = []
                
                    # Clear output section bookmarks
                    if 'output' in self.session._data:
                        if isinstance(self.session._data['output'], dict):
                            if 'bookmarks' in self.session._data['output']:
                                self.session._data['output']['bookmarks'] = []
            
                # Clear attribute-based bookmarks
                if hasattr(self.session, 'bookmarks'):
                    self.session.bookmarks = []
                if hasattr(self.session, 'preview') and hasattr(self.session.preview, 'bookmarks'):
                    self.session.preview.bookmarks = []
                if hasattr(self.session, 'output') and hasattr(self.session.output, 'bookmarks'):
                    self.session.output.bookmarks = []

            # Set changes pending to force save requirement
            self.changes_pending = True

            title = title_edit.text().strip()

            # Build the scene styles from the UI
            self.web_view.scene_styles = {}
            for _, name_edit, _, color_button in scene_edits:
                theme_name = name_edit.text().strip()
            
                # Extract color from the button's style
                style = color_button.styleSheet()
                color_match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', style)
                color = color_match.group(1) if color_match else "#FFFFFF"
            
                self.web_view.scene_styles[theme_name] = f"background-color: {color};"

            # Determine transcript type from radio buttons
            if self.video_radio.isChecked():
                transcript_type = 'video'
            else:
                transcript_type = 'book'

            self.status_bar.showMessage('Converting text...', 2000)
            self.convert_button.setEnabled(False)

            self.thread = BuildStylizedTranscript(
                raw_text=raw_text,
                title=title,
                scene_styles=self.web_view.scene_styles,
                transcript_type=transcript_type
            )
            self.thread.conversion_done.connect(self.on_conversion_done)
            self.thread.start()
            self.mark_changes_pending()
            self.conversion_in_progress = True
            self.thread.finished.connect(lambda: setattr(self, 'conversion_in_progress', False))
    
        except Exception as e:
            print(f"Error during conversion: {str(e)}")
            # Attempt to restore original state in case of error
            try:
                self.output_text.setPlainText(original_output)
                if hasattr(self.web_view, 'annotations'):
                    self.web_view.annotations = original_annotations
                if hasattr(self.web_view, 'scene_styles'):
                    self.web_view.scene_styles = original_scene_styles
                if hasattr(self, 'bookmark_list') and original_bookmarks:
                    self.bookmark_list.clear()
                    for bookmark_name, state in original_bookmarks.items():
                        item = QListWidgetItem()
                        item.setData(Qt.ItemDataRole.UserRole, state['data'])
                        self.bookmark_list.insertItem(state['position'], item)
            except:
                pass

            self.status_bar.showMessage('Error during conversion.', 5000)

    def generate_pastel_colors(self, num_colors):
        colors = []
        for _ in range(num_colors):
            r = random.randint(150, 255)
            g = random.randint(150, 255)
            b = random.randint(150, 255)
            color = f'#{r:02X}{g:02X}{b:02X}'
            colors.append(color)
        return colors


    def on_conversion_done(self, result):
        try:
            success, data = result
            self.convert_button.setEnabled(True)
        
            if success:
                stylized_html = data
                self.output_text.setPlainText(stylized_html)
                self.status_bar.showMessage('Converting text... setting up preview', 5000)
            
                # IMPORTANT: Store the HTML content separately
                self._pending_html_content = stylized_html
            
                # Try a completely different approach - reload WebView first
                self._reset_web_view_state()
            
                # Set conversion flags
                self._conversion_load_in_progress = True
                self._pending_conversion_cleanup = True
            
                # Set a failsafe timeout that's much longer (10 seconds)
                QTimer.singleShot(10000, self._ensure_conversion_completed)
            
                # Set HTML with proper base URL for images - DELAYED to next event cycle
                QTimer.singleShot(100, self._apply_converted_html)
            
                self.web_view.annotations = []
                self.tabs.setCurrentWidget(self.preview_widget)
            else:
                error_message = data
                QMessageBox.critical(self, 'Conversion Error', f'An error occurred during conversion:\n{error_message}')
                self.status_bar.clearMessage()
            
                # Attempt cleanup even on failure
                self.cleanup_conversion_resources()
        
        except Exception as e:
            print(f"Error in on_conversion_done: {str(e)}")
            import traceback
            traceback.print_exc()
            self.status_bar.showMessage('Error during conversion completion.', 5000)
            self.cleanup_conversion_resources()

    def _reset_web_view_state(self):
        """Reset the web view state before loading new content"""
        print("Resetting WebView state to clean state")
    
        try:
            # Disconnect any existing loadFinished connections
            try:
                self.web_view.loadFinished.disconnect()
            except TypeError:
                pass
            
            # Clear sticky header DOM elements before loading new content
            clear_sticky_header_js = """
            (function() {
                console.log('[DEBUG] Clearing sticky header DOM elements before session load');
                
                // Remove sticky header element
                const header = document.getElementById('scriptoria-sticky-header');
                if (header) {
                    header.remove();
                    console.log('[DEBUG] Removed sticky header element');
                }
                
                // Remove restore button element
                const restoreButton = document.getElementById('sticky-header-restore');
                if (restoreButton) {
                    restoreButton.remove();
                    console.log('[DEBUG] Removed sticky header restore button');
                }
                
                // Remove sticky header styles
                const stickyStyles = document.getElementById('scriptoria-sticky-header-styles');
                if (stickyStyles) {
                    stickyStyles.remove();
                    console.log('[DEBUG] Removed sticky header styles');
                }
                
                // Remove restore button styles
                const restoreStyles = document.getElementById('sticky-header-restore-styles');
                if (restoreStyles) {
                    restoreStyles.remove();
                    console.log('[DEBUG] Removed sticky header restore styles');
                }
                
                // Clear any scroll listeners
                if (window.stickyHeaderScrollListener) {
                    document.removeEventListener('scroll', window.stickyHeaderScrollListener);
                    window.stickyHeaderScrollListener = null;
                    console.log('[DEBUG] Removed sticky header scroll listener');
                }
                
                console.log('[DEBUG] Sticky header DOM cleanup complete');
            })();
            """
            
            # Execute the cleanup before setting blank HTML
            self.web_view.page().runJavaScript(clear_sticky_header_js)
            
            # Load a minimal blank page to reset internal state
            self.web_view.setHtml("<html><body></body></html>")
        
            # Force process events to complete the load
            QCoreApplication.processEvents()
        except Exception as e:
            print(f"Error resetting web view: {e}")

    def _apply_converted_html(self):
        """Apply the converted HTML to the web view with proper error handling"""
        try:
            if not hasattr(self, '_pending_html_content') or not self._pending_html_content:
                print("ERROR: No pending HTML content to apply")
                return
            
            print("Applying converted HTML content to WebView")
        
            # Disconnect any existing connections first
            try:
                self.web_view.loadFinished.disconnect()
            except TypeError:
                pass
            
            # Connect new loadFinished handler for conversion completion
            self.web_view.loadFinished.connect(self._on_conversion_html_loaded)
        
            # Set the HTML content with the base URL
            base_path = os.path.dirname(os.path.abspath(__file__))
            self.web_view.setHtml(
                self._pending_html_content, 
                baseUrl=QUrl.fromLocalFile(base_path + os.sep)
            )
            print(f"HTML set with baseUrl: {base_path + os.sep}")
        
        except Exception as e:
            print(f"Error applying HTML: {e}")
            import traceback
            traceback.print_exc()
            self._ensure_conversion_completed()  # Force completion on error

    def _on_conversion_html_loaded(self, success):
        """Handle HTML content loading after conversion"""
        print(f"Conversion HTML load completed: success={success}")
    
        # Disconnect the signal to prevent multiple calls
        try:
            self.web_view.loadFinished.disconnect(self._on_conversion_html_loaded)
        except TypeError:
            pass
    
        if not success:
            print("WARNING: HTML load failed after conversion")
        
            # IMPORTANT: Try a second approach with a different load method
            try:
                print("Attempting alternative HTML loading method...")
                base_path = os.path.dirname(os.path.abspath(__file__))
            
                # Write content to a temporary file and load it
                import tempfile
                fd, temp_path = tempfile.mkstemp(suffix=".html")
                try:
                    with os.fdopen(fd, 'w', encoding='utf-8') as f:
                        f.write(self._pending_html_content)
                
                    # Connect to a new handler
                    self.web_view.loadFinished.connect(self._on_conversion_file_loaded)
                
                    # Load from file URL instead
                    file_url = QUrl.fromLocalFile(temp_path)
                    print(f"Loading from temp file: {temp_path}")
                    self.web_view.load(file_url)
                
                    # Don't proceed further with verification yet
                    return
                
                except Exception as e:
                    print(f"Error with alternative loading: {e}")
                    # Continue with normal flow on error
            except Exception as e:
                print(f"Failed to attempt alternative loading: {e}")
    
        # Verify content loaded correctly
        self._verify_conversion_content()

    def _on_conversion_file_loaded(self, success):
        """Handle the alternative file-based HTML loading"""
        print(f"File-based HTML load completed: success={success}")
    
        # Disconnect the signal
        try:
            self.web_view.loadFinished.disconnect(self._on_conversion_file_loaded)
        except TypeError:
            pass
    
        # Verify content regardless of success (we've tried both methods now)
        self._verify_conversion_content()

    def _verify_conversion_content(self):
        """Verify the content was loaded correctly"""
        # Add a delay to ensure the web view has finished loading the content
        QTimer.singleShot(500, self._do_content_verification)
    
    def _do_content_verification(self):
        """Perform the actual content verification after delay"""
        # Get the HTML content to verify
        if hasattr(self, 'web_view') and self.web_view and self.web_view.page():
            self.web_view.page().toHtml(self._check_final_content)
        else:
            # No web view to check
            self.cleanup_conversion_resources()

    def _check_final_content(self, html):
        """Check the final HTML content and complete the conversion process"""
        content_length = len(html) if html else 0
        print(f"Converted HTML content length: {content_length}")
        self.fix_bookmark_images()
        
        # Initialize retry counter if not exists
        if not hasattr(self, '_content_check_retries'):
            self._content_check_retries = 0
    
        if content_length > 1000:
            # Content seems reasonable, check if it's the placeholder
            if "No Content Yet" in html and "📝" in html:
                print("WARNING: Content appears to be the placeholder")
                # If we get placeholder content, retry once more
                if self._content_check_retries < 1:
                    self._content_check_retries += 1
                    print(f"Retrying content check (attempt {self._content_check_retries + 1})")
                    QTimer.singleShot(1000, self._do_content_verification)
                    return
                else:
                    QMessageBox.warning(self, "Conversion Issue", 
                        "The conversion process completed but the content appears to be empty. "
                        "This might indicate an issue with the input format.")
            else:
                print("Conversion appears successful")
                self.status_bar.showMessage('Text content converted successfully!', 5000)
        else:
            print(f"WARNING: Converted content appears empty or too small (length: {content_length})")
            # Retry if content is too small and we haven't retried yet
            if self._content_check_retries < 1:
                self._content_check_retries += 1
                print(f"Retrying content check (attempt {self._content_check_retries + 1})")
                QTimer.singleShot(1000, self._do_content_verification)
                return
            else:
                QMessageBox.warning(self, "Conversion Warning", 
                    "The transcript was created but the content appears incomplete. "
                    "You may need to try the conversion again.")
        
        # Reset retry counter for next conversion
        self._content_check_retries = 0
    
        # Delay cleanup to ensure rendering is complete
        QTimer.singleShot(1000, self.cleanup_conversion_resources)
    
        # Clear the conversion in progress flag
        self._conversion_load_in_progress = False
        self._pending_conversion_cleanup = False
    
        # Clean up any temporary file
        if hasattr(self, '_temp_html_path') and self._temp_html_path:
            try:
                os.remove(self._temp_html_path)
            except:
                pass
            self._temp_html_path = None

    def _ensure_conversion_completed(self):
        """Failsafe method to ensure conversion process completes"""
        if not hasattr(self, '_conversion_load_in_progress') or not self._conversion_load_in_progress:
            return  # Already completed
        
        print("WARNING: Conversion load timed out, forcing completion")
        self._conversion_load_in_progress = False
    
        # Disconnect any pending signals
        try:
            self.web_view.loadFinished.disconnect()
        except TypeError:
            pass
    
        # Force cleanup
        if hasattr(self, '_pending_conversion_cleanup') and self._pending_conversion_cleanup:
            self._pending_conversion_cleanup = False
            self.cleanup_conversion_resources()
    
        # Notify user
        QMessageBox.warning(self, "Conversion Timeout", 
            "The preview generation process timed out. The transcript might be incomplete. "
            "You may need to try the conversion again with less content.")
        self.status_bar.showMessage('Preview generation timed out, content may be incomplete', 5000)

    # Add this to the BuildStylizedTranscript thread to validate HTML
    def validate_html_output(self, html_content):
        """Validate HTML output before returning it"""
        try:
            from lxml import etree
            parser = etree.HTMLParser()
            tree = etree.fromstring(html_content, parser)
        
            # Check if we have a complete HTML structure
            if tree is None or tree.find('body') is None:
                print("WARNING: Generated HTML is incomplete or malformed")
                return False, "Generated HTML is incomplete or malformed"
        
            # Check content length
            if len(html_content) < 1000:
                print("WARNING: Generated HTML is too short")
                return False, "Generated HTML content is too short"
            
            return True, None
        except Exception as e:
            print(f"HTML validation error: {e}")
            return False, str(e)

    def cleanup_conversion_resources(self, is_error=False):
        """Clean up temporary resources created during conversion OR session load."""
        try:
            # Force garbage collection
            import gc
            gc.collect()

            # --- (Cleanup for conversion thread temp_dir - unchanged) ---
            # ...

            # --- ADDED: Cleanup for session load temp file ---
            if hasattr(self, '_temp_html_path') and self._temp_html_path:
                temp_path = self._temp_html_path
                print(f"Cleaning up temporary session HTML file: {temp_path}")
                try:
                    if os.path.exists(temp_path):
                         os.remove(temp_path)
                         print(f"Successfully removed {temp_path}")
                    else:
                         print(f"Temporary file {temp_path} already removed.")
                except Exception as e:
                    print(f"Warning: Failed to remove temporary file {temp_path}: {str(e)}")
                finally:
                     # Clear the attribute regardless of success
                     self._temp_html_path = None
            # --- END ADDED ---

        except Exception as e:
            print(f"Error during resource cleanup: {str(e)}")

    def save_output(self):
        # Hide sticky header before capturing HTML to prevent it from being saved
        hide_header_script = """
        (function() {
            var stickyHeader = document.querySelector('.sticky-theme-header');
            var restoreBtn = document.querySelector('.restore-sticky-header-btn');
            if (stickyHeader) {
                stickyHeader.style.display = 'none';
                stickyHeader.setAttribute('data-temp-hidden', 'true');
            }
            if (restoreBtn) {
                restoreBtn.style.display = 'none';
                restoreBtn.setAttribute('data-temp-hidden', 'true');
            }
        })();
        """
        self.web_view.page().runJavaScript(hide_header_script)
        
        # Add delay to ensure hiding is complete before capturing HTML
        QTimer.singleShot(100, lambda: self.web_view.page().toHtml(self.save_html_with_restore))

    def save_html_with_restore(self, html_content):
        # Restore the sticky header visibility after capturing HTML
        restore_header_script = """
        (function() {
            var stickyHeader = document.querySelector('.sticky-theme-header[data-temp-hidden="true"]');
            var restoreBtn = document.querySelector('.restore-sticky-header-btn[data-temp-hidden="true"]');
            
            if (stickyHeader) {
                stickyHeader.style.display = '';
                stickyHeader.removeAttribute('data-temp-hidden');
            }
            if (restoreBtn) {
                restoreBtn.style.display = '';
                restoreBtn.removeAttribute('data-temp-hidden');
            }
        })();
        """
        self.web_view.page().runJavaScript(restore_header_script)
        
        # Clean filter classes from HTML before saving
        import re
        
        print("Cleaning filter classes from HTML export...")
        
        # List of filter classes that should be removed
        filter_classes = [
            'favorites-hidden',
            'used-hidden', 
            'unused-hidden',
            'tag-filtered-hidden',
            'theme-hidden'
        ]
        
        clean_html = html_content
        for filter_class in filter_classes:
            # Remove the class from class attributes
            # Pattern matches: class="other-class filter-class more-classes"
            pattern = r'class="([^"]*\s+)?' + re.escape(filter_class) + r'(\s+[^"]*)?'
            
            def clean_class_attr(match):
                full_match = match.group(0)
                before_class = match.group(1) or ''
                after_class = match.group(2) or ''
                
                # Reconstruct class attribute without the filter class
                remaining_classes = (before_class + after_class).strip()
                if remaining_classes:
                    return f'class="{remaining_classes}"'
                else:
                    return ''  # Remove empty class attribute
            
            clean_html = re.sub(pattern, clean_class_attr, clean_html)
            
            # Also handle cases where it's the only class: class="filter-class"
            clean_html = re.sub(f'class="{re.escape(filter_class)}"', '', clean_html)
            
            # Handle cases with single quotes
            clean_html = re.sub(f"class='{re.escape(filter_class)}'", '', clean_html)
        
        # Remove any empty class attributes that might remain
        clean_html = re.sub(r'\s+class=""', '', clean_html)
        clean_html = re.sub(r"\s+class=''", '', clean_html)
        
        print(f"Filter class cleaning completed for HTML export. Removed: {', '.join(filter_classes)}")
        
        # Call the original save_html function with cleaned HTML
        self.save_html(clean_html)

    def save_html(self, html_content):
        if not html_content.strip():
            QMessageBox.warning(self, 'Output Error', 'There is no converted HTML to save.')
            return
    
        file_name, _ = QFileDialog.getSaveFileName(
            self, "Save Converted HTML", "", "HTML Files (*.html *.htm);;All Files (*)"
        )
    
        if file_name:
            try:
                # Add tooltip functionality to the saved HTML
                enhanced_html = self.add_tooltip_functionality_for_export(html_content)
                
                # Add sticky header and filtering functionality
                enhanced_html = self.add_sticky_header_functionality_for_export(enhanced_html)
            
                with open(file_name, 'w', encoding='utf-8') as file:
                    file.write(enhanced_html)
            
                QMessageBox.information(self, 'Success', f'File saved successfully at {file_name}')
                self.status_bar.showMessage(f'Saved file: {file_name}', 5000)
                
                # Open file location in Explorer
                import subprocess
                import platform
                import os
                try:
                    if platform.system() == 'Windows':
                        # Convert forward slashes to backslashes for Windows
                        windows_path = file_name.replace('/', '\\')
                        subprocess.run(['explorer', '/select,', windows_path], check=False)
                    elif platform.system() == 'Darwin':  # macOS
                        subprocess.run(['open', '-R', file_name], check=False)
                    elif platform.system() == 'Linux':
                        subprocess.run(['xdg-open', os.path.dirname(file_name)], check=False)
                except Exception as e:
                    print(f"Could not open file location: {e}")
                    # Fallback: try to open just the directory
                    try:
                        if platform.system() == 'Windows':
                            subprocess.run(['explorer', os.path.dirname(file_name)], check=False)
                    except:
                        pass
            except Exception as e:
                QMessageBox.critical(self, 'Error', f'An error occurred while saving the file:\n{e}')



    def add_tooltip_functionality_for_export(self, html_content):
        """Adds tooltip functionality to the HTML content for export"""
        from bs4 import BeautifulSoup

        # Parse the HTML content
        soup = BeautifulSoup(html_content, 'html.parser')

        # Create transparent 1x1 pixel data URIs as fallbacks for bookmark images
        transparent_img_data_uri = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="

        # Replace all bookmark image references with data URIs
        for img in soup.find_all('img', {'class': 'bookmark-icon'}):
            img['src'] = transparent_img_data_uri

        # Create or find the script tag before the closing body tag
        script_tag = soup.new_tag('script', type='text/javascript')

        # Add the complete tooltip functionality JavaScript
        tooltip_js = """
        // Complete Tooltip functionality for exported HTML
        (function() {
            console.log('Initializing enhanced tooltip functionality for exported HTML...');

            // Prevent duplicate initialization in exported HTML
            if (window.__tooltipEnhancerInitialized__) {
                console.log('DEBUG: Tooltip enhancer already initialized; skipping duplicate init');
                return;
            }
            window.__tooltipEnhancerInitialized__ = true;
            // Initialize tooltip control variables
            window.tooltipsEnabled = true;
            window.tooltipCtrlPressed = false;
            window.tooltipPreferredPosition = "left";
            window.tooltipShowDelay = 300;
            window.tooltipHideDelay = 400;
            window.tooltipShowTimer = null;
            window.tooltipHideTimer = null;
            window.activeHighlight = null;

            // Function to add expand functionality to tooltips
            function initializeTooltipExpand() {
                console.log('DEBUG: ===== STARTING TOOLTIP EXPAND INITIALIZATION (SECOND METHOD) =====');
                console.log('DEBUG: Function called, about to search for tooltip...');
                
                var tooltip = document.querySelector('.notes-tooltip');
                console.log('DEBUG: Tooltip search result:', tooltip);
                if (!tooltip) {
                    console.error('DEBUG: Tooltip element not found for expand initialization');
                    return;
                }
                console.log('DEBUG: Found tooltip element:', tooltip);
            
                let expandButton = tooltip.querySelector('.tooltip-expand-button');
                let pinButton = tooltip.querySelector('.tooltip-pin-button');
                let controlsContainer = tooltip.querySelector('.tooltip-controls');
            
                // If buttons don't exist, create them
                if (!expandButton || !pinButton) {
                    console.log('DEBUG: Creating control buttons container and buttons');
                
                    // Remove any existing buttons first
                    const oldExpandButton = tooltip.querySelector('.tooltip-expand-button');
                    if (oldExpandButton) {
                        oldExpandButton.remove();
                    }
                    const oldPinButton = tooltip.querySelector('.tooltip-pin-button');
                    if (oldPinButton) {
                        oldPinButton.remove();
                    }
                    const oldControls = tooltip.querySelector('.tooltip-controls');
                    if (oldControls) {
                        oldControls.remove();
                    }
                
                    // Create controls container in right corner
                    controlsContainer = document.createElement('div');
                    controlsContainer.className = 'tooltip-controls';
                    controlsContainer.style.setProperty('position', 'absolute', 'important');
                    controlsContainer.style.setProperty('top', '10px', 'important');
                    controlsContainer.style.setProperty('right', '8px', 'important');
                    controlsContainer.style.setProperty('display', 'flex', 'important');
                    controlsContainer.style.setProperty('gap', '0px', 'important');
                    controlsContainer.style.setProperty('z-index', '9999', 'important');
                    tooltip.appendChild(controlsContainer);
                
                    // Create expand button first (left side of controls)
                    expandButton = document.createElement('button');
                    expandButton.className = 'tooltip-expand-button';
                    expandButton.innerHTML = '⤢';
                    expandButton.title = 'Expand tooltip';
                    controlsContainer.appendChild(expandButton);
                    console.log('DEBUG: Created expand button in controls');
                
                    // Create pin button second (right side of controls)
                    pinButton = document.createElement('button');
                    pinButton.className = 'tooltip-pin-button';
                    pinButton.innerHTML = '📌';
                    pinButton.title = 'Pin tooltip';
                    controlsContainer.appendChild(pinButton);
                    console.log('DEBUG: Created pin button in controls');
                
                    console.log('DEBUG: Created control buttons');
                }
            
                // Force visible styles
                pinButton.style.setProperty('display', 'flex', 'important');
                pinButton.style.setProperty('opacity', '1', 'important');
                pinButton.style.setProperty('width', '35px', 'important');
                pinButton.style.setProperty('height', '35px', 'important');
            
                expandButton.style.setProperty('display', 'flex', 'important');
                expandButton.style.setProperty('opacity', '1', 'important');
                expandButton.style.setProperty('width', '35px', 'important');
                expandButton.style.setProperty('height', '35px', 'important');
            
                console.log('DEBUG: Applied forced visible styles to buttons');
            
                // Force binding of controls (override double-binding protection for debugging)
                console.log('DEBUG: Forcing event listener binding regardless of controlsBound status');
                tooltip.dataset.controlsBound = '1';
                // Add expand button functionality
                expandButton.addEventListener('click', function(e) {
                    console.log('DEBUG: ===== EXPAND BUTTON CLICKED (SECOND METHOD) =====');
                    console.log('DEBUG: Event object:', e);
                    console.log('DEBUG: Button element:', this);
                    console.log('DEBUG: Button computed style:', window.getComputedStyle(this));
                    console.log('DEBUG: Button parent:', this.parentElement);
                    e.preventDefault();
                    e.stopPropagation();
                
                    // Prevent tooltip from hiding during expand
                    if (window.tooltipHideTimer) {
                        clearTimeout(window.tooltipHideTimer);
                        window.tooltipHideTimer = null;
                    }
                
                    const isExpanded = tooltip.classList.contains('expanded');
                    console.log('DEBUG: Current expanded state:', isExpanded);
                
                    if (isExpanded) {
                        // Collapse tooltip
                        tooltip.classList.remove('expanded');
                        expandButton.classList.remove('expanded');
                        expandButton.innerHTML = '⤢'; // Expand symbol
                        expandButton.title = 'Expand tooltip';
                        // Force style reset
                        tooltip.style.width = '350px';
                        tooltip.style.height = 'auto';
                        tooltip.style.maxHeight = '650px';
                        tooltip.style.minHeight = 'auto';
                    
                        // Remove force height class
                        tooltip.classList.remove('force-height-expanded');
                    } else {
                        // Expand tooltip
                        tooltip.classList.add('expanded');
                        expandButton.classList.add('expanded');
                        expandButton.innerHTML = '⤡'; // Collapse symbol
                        expandButton.title = 'Collapse tooltip';
                    
                        // Force style application with !important override
                        tooltip.style.setProperty('width', '650px', 'important');
                        tooltip.style.setProperty('height', '800px', 'important');
                        tooltip.style.setProperty('max-height', '1300px', 'important');
                        tooltip.style.setProperty('min-height', '800px', 'important');
                    
                        // Add a specific class for forcing height
                        tooltip.classList.add('force-height-expanded');
                    }
                
                    // Adjust tooltip content height for expanded state
                    const tooltipContent = tooltip.querySelector('.tooltip-content');
                    if (tooltipContent) {
                        if (isExpanded) {
                            // Reset to normal max-height when collapsing
                            tooltipContent.style.maxHeight = 'calc(400px - 24px)';
                            tooltipContent.style.minHeight = 'auto';
                            tooltipContent.style.height = 'auto';
                        
                            // Reset the scrollable notes area
                            const tooltipHtmlNotes = tooltip.querySelector('.tooltip-html-notes');
                            if (tooltipHtmlNotes) {
                                tooltipHtmlNotes.style.maxHeight = '500px';
                                tooltipHtmlNotes.style.minHeight = 'auto';
                            }
                        } else {
                            // Increase max-height and min-height when expanding
                            tooltipContent.style.maxHeight = 'calc(800px - 80px)';
                            tooltipContent.style.minHeight = '720px';
                            tooltipContent.style.height = '720px';
                        
                            // Also adjust the scrollable notes area
                            const tooltipHtmlNotes = tooltip.querySelector('.tooltip-html-notes');
                            if (tooltipHtmlNotes) {
                                tooltipHtmlNotes.style.maxHeight = '600px';
                                tooltipHtmlNotes.style.minHeight = '500px';
                            }
                        }
                    }
                
                    // Reposition tooltip after size change
                    setTimeout(() => {
                        const activeSpan = window.activeHighlight;
                        if (activeSpan && typeof positionTooltip === 'function') {
                            const spanRect = activeSpan.getBoundingClientRect();
                            const tooltipWidth = tooltip.offsetWidth;
                            const tooltipHeight = tooltip.offsetHeight;
                            const position = positionTooltip(spanRect, tooltipWidth, tooltipHeight);
                            tooltip.style.top = position.top + 'px';
                            tooltip.style.left = position.left + 'px';
                        }
                    }, 50);
                });
            
                // Initialize pin button functionality
                let isPinned = false;
                pinButton.addEventListener('click', function(e) {
                    console.log('DEBUG: Pin button clicked!', e);
                    e.preventDefault();
                    e.stopPropagation();
                
                    isPinned = !isPinned;
                
                    if (isPinned) {
                        // Pin the tooltip
                        pinButton.classList.add('pinned');
                        pinButton.innerHTML = '📍'; // Filled pin
                        pinButton.title = 'Unpin tooltip';
                    
                        // Clear any hide timers
                        if (window.tooltipHideTimer) {
                            clearTimeout(window.tooltipHideTimer);
                            window.tooltipHideTimer = null;
                        }
                    
                        // Add pinned class to tooltip to prevent hiding
                        tooltip.classList.add('pinned');
                        console.log('DEBUG: Tooltip pinned');
                    } else {
                        // Unpin the tooltip
                        pinButton.classList.remove('pinned');
                        pinButton.innerHTML = '📌'; // Outline pin
                        pinButton.title = 'Pin tooltip';
                    
                        // Remove pinned class
                        tooltip.classList.remove('pinned');
                        console.log('DEBUG: Tooltip unpinned');
                    }
                });
            
                console.log('DEBUG: Tooltip expand and pin functionality initialized');
            }

            // Function to enhance tooltip structure for scrolling
            function enhanceTooltipStructure() {
                console.log('Enhancing tooltip structure for scrolling...');
        
                // Get the tooltip element
                var tooltip = document.querySelector('.notes-tooltip');
                if (!tooltip) {
                    console.error('Tooltip element not found');
                    return false;
                }
        
                // Make sure tooltip has the proper structure for scrolling
                var tooltipContent = tooltip.querySelector('.tooltip-content');
                if (!tooltipContent) {
                    console.log('Creating tooltip content container');
                    tooltipContent = document.createElement('div');
                    tooltipContent.className = 'tooltip-content';
            
                    // Move all content except title into the content container
                    Array.from(tooltip.children).forEach(child => {
                        if (!child.classList.contains('tooltip-title') && !child.classList.contains('tooltip-controls')) {
                            tooltipContent.appendChild(child);
                        }
                    });
            
                    tooltip.appendChild(tooltipContent);
                }
        
                // Ensure the needed sections exist in the right order
                var tooltipTitle = tooltip.querySelector('.tooltip-title');
                var tooltipScene = tooltipContent.querySelector('.tooltip-scene');
                var tooltipTags = tooltipContent.querySelector('.tooltip-tags');
                var tooltipFootnote = tooltipContent.querySelector('.tooltip-footnote');
                var tooltipHtmlNotes = tooltipContent.querySelector('.tooltip-html-notes');
        
                // Create elements if they don't exist
                if (!tooltipTitle) {
                    tooltipTitle = document.createElement('div');
                    tooltipTitle.className = 'tooltip-title';
                    tooltipTitle.innerHTML = '<span class="tooltip-icon">ℹ</span><span>Annotation</span>';
                    tooltipTitle.style.cursor = 'default';
                    tooltip.insertBefore(tooltipTitle, tooltip.firstChild);
                    console.log('Created tooltip title');
                }
        
                if (!tooltipScene) {
                    tooltipScene = document.createElement('div');
                    tooltipScene.className = 'tooltip-scene';
                    tooltipContent.insertBefore(tooltipScene, tooltipContent.firstChild);
                    console.log('Created tooltip scene');
                }
        
                if (!tooltipTags) {
                    tooltipTags = document.createElement('div');
                    tooltipTags.className = 'tooltip-tags';
                    if (tooltipScene) {
                        tooltipContent.insertBefore(tooltipTags, tooltipScene.nextSibling);
                    } else {
                        tooltipContent.insertBefore(tooltipTags, tooltipContent.firstChild);
                    }
                    console.log('Created tooltip tags');
                }
        
                if (!tooltipFootnote) {
                    tooltipFootnote = document.createElement('div');
                    tooltipFootnote.className = 'tooltip-footnote';
            
                    if (tooltipTags) {
                        tooltipContent.insertBefore(tooltipFootnote, tooltipTags.nextSibling);
                    } else if (tooltipScene) {
                        tooltipContent.insertBefore(tooltipFootnote, tooltipScene.nextSibling);
                    } else {
                        tooltipContent.insertBefore(tooltipFootnote, tooltipContent.firstChild);
                    }
                    console.log('Created tooltip footnote');
                }
        
                if (!tooltipHtmlNotes) {
                    tooltipHtmlNotes = document.createElement('div');
                    tooltipHtmlNotes.className = 'tooltip-html-notes';
                    tooltipContent.appendChild(tooltipHtmlNotes);
                    console.log('Created tooltip HTML notes');
                }

                    console.log('Tooltip structure enhancement complete');
                    return true;
                }

                // Install scroll lock on tooltip HTML notes so page doesn't scroll when at edges
                function installNotesScrollLock(container) {
                    try {
                        if (!container || container.dataset.scrollLockInstalled) return;
                        const onWheel = function(e) {
                            try {
                                e.preventDefault();
                                e.stopPropagation();
                                const delta = (typeof e.deltaY === 'number') ? e.deltaY : (e.wheelDelta ? -e.wheelDelta : 0);
                                if (delta === 0) return;
                                const prev = container.scrollTop;
                                container.scrollTop = prev + delta;
                            } catch(_e) {}
                        };
                        container.addEventListener('wheel', onWheel, { passive: false });

                        let startY = 0;
                        container.addEventListener('touchstart', function(e){
                            if (e.touches && e.touches.length) startY = e.touches[0].clientY;
                        }, { passive: true });
                        container.addEventListener('touchmove', function(e){
                            try {
                                if (!e.touches || !e.touches.length) return;
                                const currentY = e.touches[0].clientY;
                                const delta = startY - currentY; // positive when moving up
                                const prev = container.scrollTop;
                                container.scrollTop = prev + delta;
                                startY = currentY;
                                e.preventDefault();
                                e.stopPropagation();
                            } catch(_e) {}
                        }, { passive: false });

                        container.dataset.scrollLockInstalled = '1';
                        console.log('[DEBUG] Installed tooltip notes scroll lock');
                    } catch (err) {
                        console.warn('[DEBUG] Failed to install notes scroll lock', err);
                    }
                }
    
            // Function to handle long HTML notes content
            function wrapLongHtmlNotes() {
                var tooltipHtmlNotes = document.querySelector('.tooltip-html-notes');
                if (!tooltipHtmlNotes) return;
        
                // If HTML notes content is exceptionally long, ensure it's properly contained
                if (tooltipHtmlNotes.scrollHeight > 250) {
                    console.log('Long HTML notes detected, ensuring proper containment');
            
                    tooltipHtmlNotes.style.overflowY = 'auto';
                    tooltipHtmlNotes.style.maxHeight = '250px';
            
                    // Ensure inline elements don't break out of container
                    var allElements = tooltipHtmlNotes.querySelectorAll('*');
                    allElements.forEach(el => {
                        el.style.maxWidth = '100%';
                        el.style.wordBreak = 'break-word';
                
                        if (el.tagName === 'IMG') {
                            el.style.maxWidth = '100%';
                            el.style.height = 'auto';
                        } else if (el.tagName === 'TABLE') {
                            el.style.width = '100%';
                            el.style.tableLayout = 'fixed';
                        } else if (el.tagName === 'PRE' || el.tagName === 'CODE') {
                            el.style.whiteSpace = 'pre-wrap';
                            el.style.wordWrap = 'break-word';
                        }
                    });
                }
            }

            // Create tooltip element if it doesn't exist
            var tooltip = document.querySelector('.notes-tooltip');
            if (!tooltip) {
                console.log('Creating tooltip element as it does not exist');
                tooltip = document.createElement('div');
                tooltip.className = 'notes-tooltip';
                tooltip.innerHTML = '<div class="tooltip-controls"><button class="tooltip-pin-button" title="Pin tooltip">📌</button><button class="tooltip-expand-button" title="Expand tooltip">⤢</button></div><div class="tooltip-title" style="cursor: default;"><span class="tooltip-icon">ℹ</span><span>Annotation</span></div><div class="tooltip-content"><div class="tooltip-scene"></div><div class="tooltip-tags"></div><div class="tooltip-footnote"></div><div class="tooltip-html-notes"></div></div>';
                document.body.appendChild(tooltip);
        
                // Initialize structure
                enhanceTooltipStructure();
        
                // Add expand functionality
                console.log('DEBUG: About to call initializeTooltipExpand');
                initializeTooltipExpand();
                console.log('DEBUG: Called initializeTooltipExpand');
            } else {
                // Ensure tooltip has the proper structure even if it already exists
                var tooltipTitle = tooltip.querySelector('.tooltip-title');
                if (!tooltipTitle) {
                    tooltipTitle = document.createElement('div');
                    tooltipTitle.className = 'tooltip-title';
                    tooltipTitle.innerHTML = '<span class="tooltip-icon">ℹ</span><span>Annotation</span>';
                    tooltip.insertBefore(tooltipTitle, tooltip.firstChild);
                }
                tooltipTitle.style.cursor = 'default';
        
                // Add control buttons if they don't exist
                if (!tooltip.querySelector('.tooltip-expand-button') || !tooltip.querySelector('.tooltip-pin-button')) {
                    console.log('DEBUG: Creating control buttons for existing tooltip');
                
                    let controlsContainer = tooltip.querySelector('.tooltip-controls');
                    if (!controlsContainer) {
                        controlsContainer = document.createElement('div');
                        controlsContainer.className = 'tooltip-controls';
                        tooltip.appendChild(controlsContainer);
                    }
                }
        
                // Enhance structure
                enhanceTooltipStructure();
        
                // Add expand functionality
                console.log('DEBUG: About to call initializeTooltipExpand');
                try {
                    initializeTooltipExpand();
                    console.log('DEBUG: Called initializeTooltipExpand successfully');
                } catch(error) {
                    console.error('DEBUG: Error calling initializeTooltipExpand:', error);
                    console.error('DEBUG: Error stack:', error.stack);
                }
            }

            // Add complete tooltip styling
            var style = document.createElement('style');
            style.textContent = `
                .notes-tooltip {
                    position: fixed !important;
                    background-color: #F8F8FC !important;
                    color: #2C3333 !important;
                    border-radius: 8px !important;
                    padding: 12px !important;
                    box-shadow: 0 3px 15px rgba(0, 0, 0, 0.15) !important;
                    z-index: 9999999 !important;
                    width: 350px !important;
                    height: auto !important;
                    max-height: 650px !important;
                    font-family: 'Segoe UI', Arial, sans-serif !important;
                    font-size: 14px !important;
                    border: 1px solid #E6E6EF !important;
                    pointer-events: auto !important;
                    display: none !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    overflow: hidden !important;
                    transition: width 0.3s ease, height 0.3s ease !important;
                }

                .notes-tooltip.visible.expanded {
                    width: 650px !important;
                    height: 800px !important;
                    max-height: 1300px !important;
                    min-height: 800px !important;
                    min-width: 650px !important;
                }
            
                body .notes-tooltip.visible.expanded {
                    height: 800px !important;
                }
            
                .force-height-expanded {
                    height: 800px !important;
                }

                .notes-tooltip.expanded .tooltip-content {
                    min-height: 720px !important;
                    height: 720px !important;
                    max-height: calc(800px - 80px) !important;
                }
            
                .notes-tooltip.expanded .tooltip-html-notes {
                    max-height: 600px !important;
                    min-height: 500px !important;
                    height: auto !important;
                }

                /* Control buttons container */
                .tooltip-controls {
                    position: absolute !important;
                    top: 10px !important;
                    right: 8px !important;
                    display: flex !important;
                    gap: 0px !important;
                    z-index: 9999 !important;
                }

                /* Expand button */
                .tooltip-expand-button {
                    width: 35px !important;
                    height: 35px !important;
                    background: none !important;
                    color: #7077A1 !important;
                    border: none !important;
                    cursor: pointer !important;
                    font-size: 20px !important;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    transition: color 0.2s ease !important;
                    position: relative !important;
                    flex-shrink: 0 !important;
                    top: 0px !important;
                    line-height: 1 !important;
                }

                .tooltip-expand-button:hover {
                    color: #4a5568 !important;
                    background: rgba(112, 119, 161, 0.1) !important;
                    border-radius: 6px !important;
                    transform: scale(1.1) !important;
                    transition: all 0.2s ease !important;
                }

                .tooltip-expand-button.expanded {
                    color: #4a5568 !important;
                    background: rgba(74, 85, 104, 0.15) !important;
                    border-radius: 6px !important;
                }

                /* Pin button */
                .tooltip-pin-button {
                    width: 35px !important;
                    height: 35px !important;
                    background: none !important;
                    color: #7077A1 !important;
                    border: none !important;
                    cursor: pointer !important;
                    font-size: 20px !important;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    transition: color 0.2s ease !important;
                    position: relative !important;
                    flex-shrink: 0 !important;
                    line-height: 1 !important;
                }

                .tooltip-pin-button:hover {
                    color: #4a5568 !important;
                    background: rgba(112, 119, 161, 0.1) !important;
                    border-radius: 6px !important;
                    transform: scale(1.1) !important;
                    transition: all 0.2s ease !important;
                }

                .tooltip-pin-button.pinned {
                    color: #e53e3e !important;
                    background: rgba(229, 62, 62, 0.1) !important;
                    border-radius: 6px !important;
                }

                .tooltip-pin-button.pinned:hover {
                    color: #c53030 !important;
                    background: rgba(197, 48, 48, 0.15) !important;
                    border-radius: 6px !important;
                    transform: scale(1.1) !important;
                    transition: all 0.2s ease !important;
                }

                .notes-tooltip.visible {
                    display: block !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                }

                body .notes-tooltip.visible {
                    display: block !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                }

                span[data-annotation-id] {
                    position: relative !important;
                    cursor: help !important;
                }

                .tooltip-title {
                    display: flex !important;
                    align-items: center !important;
                    margin-bottom: 10px !important;
                    font-weight: bold !important;
                    border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
                    padding-bottom: 8px !important;
                    color: #2D3250 !important;
                    cursor: default !important;
                    padding: 4px 6px !important;
                    border-radius: 4px !important;
                    margin: -4px -6px 6px -6px !important;
                    transition: background-color 0.15s ease !important;
                    position: sticky !important;
                    top: -12px !important;
                    background-color: #F8F8FC !important;
                    z-index: 2 !important;
                }

                .tooltip-title:hover {
                    background-color: transparent !important;
                    cursor: default !important;
                }

                .tooltip-icon {
                    margin-right: 8px !important;
                    font-size: 18px !important;
                    color: #7077A1 !important;
                }

                .tooltip-content {
                    line-height: 1.5 !important;
                    overflow-wrap: break-word !important;
                    max-height: calc(400px - 24px) !important;
                    min-height: 100px !important;
                    position: relative !important;
                    display: flex !important;
                    flex-direction: column !important;
                    flex-grow: 1 !important;
                }

                .tooltip-scene {
                    font-weight: bold !important;
                    margin-bottom: 8px !important;
                    color: #000000 !important;
                    position: sticky !important;
                    top: 30px !important;
                    background-color: #F8F8FC !important;
                    z-index: 1 !important;
                    padding: 4px 0 !important;
                }

                .tooltip-secondary {
                    font-size: 12px !important;
                    margin: 2px 0 6px 0 !important;
                    color: #7077A1 !important;
                }

                .tooltip-scene .label, .tooltip-secondary .label {
                    font-weight: 600 !important;
                    margin-right: 6px !important;
                    color: #000 !important; /* Label text in black */
                }

                .theme-chip {
                    display: inline-flex !important;
                    align-items: center !important;
                    gap: 4px !important;
                    margin-right: 6px !important;
                    margin-top: 2px !important;
                    color: #000 !important; /* Default chip text in black */
                    padding: 2px 6px !important; /* Add 2px padding off the text */
                    border-radius: 4px !important;
                    border: 1px solid rgba(0,0,0,0.15) !important;
                }

                .theme-dot {
                    display: inline-block !important;
                    width: 8px !important;
                    height: 8px !important;
                    border-radius: 50% !important;
                    border: 1px solid rgba(0,0,0,0.25) !important;
                    vertical-align: middle !important;
                }

                /* Emphasize primary theme chip slightly */
                .tooltip-scene .theme-chip {
                    font-size: 13px !important;
                    color: #000 !important;
                    font-weight: 700 !important; /* Emphasize primary theme */
                }
                .tooltip-scene .theme-name { color: #000 !important; font-weight: 700 !important; }

                /* De-emphasize secondary theme chips */
                .tooltip-secondary .theme-chip {
                    font-size: 11px !important;
                    padding: 2px 5px !important; /* Ensure 2px padding for secondary chips as well */
                    opacity: 0.95 !important;
                    color: #000 !important; /* Secondary theme text in black */
                    font-weight: 400 !important;
                }

                .tooltip-secondary .theme-name {
                    font-size: 11px !important;
                    color: #000 !important;
                    font-weight: 400 !important;
                }

                .tooltip-tags {
                    margin-bottom: 8px !important;
                    color: #6366F1 !important;
                    position: sticky !important;
                    top: 50px !important;
                    background-color: #F8F8FC !important;
                    z-index: 1 !important;
                    padding: 4px 0 !important;
                    font-size: 13px !important;
                }

                    .tooltip-tags .tag {
                        display: inline-block !important;
                        background: #EEF2FF !important;
                        color: #6366F1 !important;
                        padding: 2px 6px !important;
                        border-radius: 12px !important;
                    margin-right: 4px !important;
                    margin-bottom: 2px !important;
                    font-size: 12px !important;
                    border: 1px solid #C7D2FE !important;
                }

                .tooltip-footnote {
                    margin-bottom: 8px !important;
                    color: #4D4D4D !important;
                    position: sticky !important;
                    top: 70px !important;
                    background-color: #F8F8FC !important;
                    z-index: 1 !important;
                    padding: 4px 0 !important;
                }

                .tooltip-html-notes {
                    border-top: 3px solid rgba(0, 0, 0, 0.1) !important;
                    padding-top: 8px !important;
                    color: #333333 !important;
                    overflow-y: auto !important;
                    max-height: 500px !important;
                    margin-right: -6px !important;
                    padding-right: 6px !important;
                }

                .tooltip-html-notes::-webkit-scrollbar {
                    width: 6px !important;
                }

                .tooltip-html-notes::-webkit-scrollbar-track {
                    background: #F1F1F1 !important;
                    border-radius: 3px !important;
                }

                .tooltip-html-notes::-webkit-scrollbar-thumb {
                    background: #C0C0C0 !important;
                    border-radius: 3px !important;
                }

                .tooltip-html-notes::-webkit-scrollbar-thumb:hover {
                    background: #A0A0A0 !important;
                }

                /* Transparent selection styles */
                ::selection {
                    background-color: rgba(33, 150, 243, 0.6) !important;
                    color: white !important;
                    text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.6), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
                }
                ::-moz-selection {
                    background-color: rgba(33, 150, 243, 0.6) !important;
                    color: white !important;
                    text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.6), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
                }
            
                span[data-annotation-id]::selection {
                    background-color: rgba(33, 150, 243, 0.2) !important;
                    color: white !important;
                    text-shadow: 0 0 6px rgba(0, 0, 0, 1.0), 0 0 12px rgba(0, 0, 0, 0.8), 0 1px 3px rgba(0, 0, 0, 1.0), 1px 1px 2px rgba(0, 0, 0, 0.9) !important;
                }
                span[data-annotation-id]::-moz-selection {
                    background-color: rgba(33, 150, 243, 0.2) !important;
                    color: white !important;
                    text-shadow: 0 0 6px rgba(0, 0, 0, 1.0), 0 0 12px rgba(0, 0, 0, 0.8), 0 1px 3px rgba(0, 0, 0, 1.0), 1px 1px 2px rgba(0, 0, 0, 0.9) !important;
                }
            `;
            document.head.appendChild(style);

            // Function to truncate content
            function truncateText(text, maxLength) {
                if (!text) return '';
                if (text.length <= maxLength) return text;
                return text.substring(0, maxLength) + '...';
            }

            // Function to extract color from style string
            function extractColorFromStyle(styleString) {
                if (!styleString) return null;

                const bgColorMatch = styleString.match(/background-color:\\s*([^;]+)/i);
                if (bgColorMatch && bgColorMatch[1]) {
                    return bgColorMatch[1].trim();
                }

                const colorMatch = styleString.match(/color:\\s*([^;]+)/i);
                if (colorMatch && colorMatch[1]) {
                    return colorMatch[1].trim();
                }

                return null;
            }

            // Function to position tooltip based on preferred position
            function positionTooltip(spanRect, tooltipWidth, tooltipHeight) {
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                let topPosition, leftPosition;

                switch (window.tooltipPreferredPosition || "left") {
                    case "right":
                        leftPosition = spanRect.right + 10;
                        topPosition = spanRect.top + (spanRect.height / 2) - (tooltipHeight / 2);
                        if (leftPosition + tooltipWidth > viewportWidth - 10) {
                            leftPosition = spanRect.left - tooltipWidth - 10;
                        }
                        break;

                    case "left":
                        leftPosition = spanRect.left - tooltipWidth - 10;
                        topPosition = spanRect.top + (spanRect.height / 2) - (tooltipHeight / 2);
                        if (leftPosition < 10) {
                            leftPosition = spanRect.right + 10;
                        }
                        break;

                    case "top":
                        topPosition = spanRect.top - tooltipHeight - 10;
                        leftPosition = spanRect.left + (spanRect.width / 2) - (tooltipWidth / 2);
                        if (topPosition < 10) {
                            topPosition = spanRect.bottom + 10;
                        }
                        break;

                    case "bottom":
                        topPosition = spanRect.bottom + 10;
                        leftPosition = spanRect.left + (spanRect.width / 2) - (tooltipWidth / 2);
                        if (topPosition + tooltipHeight > viewportHeight - 10) {
                            topPosition = spanRect.top - tooltipHeight - 10;
                        }
                        break;

                    default:
                        leftPosition = spanRect.left - tooltipWidth - 10;
                        topPosition = spanRect.top + (spanRect.height / 2) - (tooltipHeight / 2);
                        if (leftPosition < 10) {
                            leftPosition = spanRect.right + 10;
                        }
                        break;
                }

                // Make sure tooltip stays within viewport boundaries
                if (topPosition < 10) {
                    topPosition = 10;
                } else if (topPosition + tooltipHeight > viewportHeight - 10) {
                    topPosition = viewportHeight - tooltipHeight - 10;
                }

                if (leftPosition < 10) {
                    leftPosition = 10;
                } else if (leftPosition + tooltipWidth > viewportWidth - 10) {
                    leftPosition = viewportWidth - tooltipWidth - 10;
                }

                return { top: topPosition, left: leftPosition };
            }

            // Enhanced showTooltip function with delay and control key support
            function showTooltipDirect(e) {
                console.log(`Enhanced showTooltipDirect called for span ${this.getAttribute('data-annotation-id')}`);

                if (window.tooltipShowTimer) {
                    clearTimeout(window.tooltipShowTimer);
                    window.tooltipShowTimer = null;
                }

                if (window.tooltipHideTimer) {
                    clearTimeout(window.tooltipHideTimer);
                    window.tooltipHideTimer = null;
                }

                if (window.tooltipsEnabled === false) {
                    console.log("Tooltip display skipped: Tooltips are disabled");
                    return;
                }

                if (window.tooltipCtrlPressed && window.activeHighlight) {
                    console.log("Tooltip display skipped: Ctrl pressed and tooltip already visible");
                    return;
                }

                const span = this;

                window.tooltipShowTimer = setTimeout(function() {
                    const scene = span.getAttribute('data-scene') || '';
                    const notes = span.getAttribute('data-notes') || '';
                    const notesHtml = span.getAttribute('data-notes-html') || '';
                    const tags = span.getAttribute('data-tags') || '[]';

                    console.log("Getting tooltip content:", {
                        scene: scene,
                        notes: notes ? notes.substring(0, 20) + '...' : 'none',
                        notesHtml: notesHtml ? notesHtml.substring(0, 20) + '...' : 'none',
                        tags: tags
                    });

                    // Check if there's any content to display
                    let hasTags = false;
                    try {
                        const tagsList = JSON.parse(tags);
                        hasTags = tagsList && tagsList.length > 0;
                    } catch (e) {
                        hasTags = false;
                    }

                    /* Theme chips inside tooltip: clickable + active state without changing background */
                    .tooltip-content .theme-chip {
                        cursor: pointer !important;
                        transition: box-shadow 0.15s ease, outline-color 0.15s ease !important;
                    }
                    .tooltip-content .theme-chip:hover {
                        box-shadow: 0 1px 4px rgba(0,0,0,0.25) !important;
                    }
                    .tooltip-content .theme-chip.active {
                        outline: 2px solid #2E7D32 !important;
                        box-shadow: 0 1px 4px rgba(46,125,50,0.35) !important;
                    }
                
                    if (!scene && !notes && !notesHtml && !hasTags) {
                        console.log("No content to display in tooltip, skipping");
                        return;
                    }

                    enhanceTooltipStructure();

                    // Update tooltip title if there's a speech title
                    const tooltipTitle = tooltip.querySelector('.tooltip-title');
                    if (tooltipTitle) {
                        let speechTitle = '';
                        const speechArticle = span.closest('.speech');
                        if (speechArticle) {
                            const speechTitleElement = speechArticle.querySelector('h2.speech-title');
                            if (speechTitleElement) {
                                speechTitle = speechTitleElement.textContent.trim();
                            }
                        }
                    
                        if (speechTitle) {
                            const truncatedTitle = speechTitle.length > 40 ? speechTitle.substring(0, 40) + '...' : speechTitle;
                            tooltipTitle.innerHTML = `<span class="tooltip-icon">ℹ</span><span style="font-size: 11px;">${truncatedTitle}</span>`;
                        } else {
                            tooltipTitle.innerHTML = '<span class="tooltip-icon">ℹ</span><span style="font-size: 11px;">Annotation</span>';
                        }
                    }

                    // Set tooltip content
                    const tooltipContent = tooltip.querySelector('.tooltip-content');
                    const tooltipScene = tooltipContent.querySelector('.tooltip-scene');
                    const tooltipTags = tooltipContent.querySelector('.tooltip-tags');
                    const tooltipFootnote = tooltipContent.querySelector('.tooltip-footnote');
                    const tooltipHtmlNotes = tooltipContent.querySelector('.tooltip-html-notes');

                    if (scene) {
                        tooltipScene.textContent = 'Theme: ' + scene;
                        tooltipScene.style.display = 'block';

                        if (window.sceneStyles && scene && window.sceneStyles[scene]) {
                            const sceneColor = extractColorFromStyle(window.sceneStyles[scene]);
                            if (sceneColor) {
                                tooltipScene.style.color = sceneColor;
                            } else {
                                tooltipScene.style.color = '#7077A1';
                            }
                        } else {
                            tooltipScene.style.color = '#7077A1';
                        }
                    } else {
                        tooltipScene.style.display = 'none';
                    }

                    // Set tags
                    console.log('DEBUG: Processing tags:', tags);
                    try {
                        const tagsList = JSON.parse(tags);
                        console.log('DEBUG: Parsed tagsList:', tagsList);
                        if (tagsList && tagsList.length > 0) {
                            const tagsHtml = tagsList.map(tag => `<span class="tag">#${tag}</span>`).join('');
                            tooltipTags.innerHTML = `<span style="font-weight: 500;">Tags: </span>${tagsHtml}`;
                            tooltipTags.style.display = 'block';
                        } else {
                            tooltipTags.style.display = 'none';
                        }
                    } catch (e) {
                        console.log('DEBUG: Error parsing tags:', e);
                        tooltipTags.style.display = 'none';
                    }

                    if (notes) {
                        tooltipFootnote.textContent = truncateText(notes, 100);
                        tooltipFootnote.style.display = 'block';
                    } else {
                        tooltipFootnote.style.display = 'none';
                    }

                    if (notesHtml) {
                        tooltipHtmlNotes.innerHTML = notesHtml;
                        tooltipHtmlNotes.style.display = 'block';
                        wrapLongHtmlNotes();
                    } else {
                        tooltipHtmlNotes.style.display = 'none';
                    }

                    // Position tooltip near the span
                    const spanRect = span.getBoundingClientRect();
                    tooltip.classList.add('visible');
                    const tooltipHeight = tooltip.offsetHeight;
                    const tooltipWidth = tooltip.offsetWidth;
                    const position = positionTooltip(spanRect, tooltipWidth, tooltipHeight);

                    tooltip.style.top = position.top + 'px';
                    tooltip.style.left = position.left + 'px';

                    window.activeHighlight = span;
                    console.log(`Tooltip positioned and shown`);
                }, window.tooltipShowDelay || 300);
            }

            function hideTooltipDirect(e) {
                console.log(`Enhanced hideTooltipDirect called for span ${this.getAttribute('data-annotation-id')}`);

                if (window.tooltipCtrlPressed) {
                    console.log("Tooltip hide skipped: Ctrl key is pressed");
                    return;
                }
            
                const tooltip = document.querySelector('.notes-tooltip');
                if (tooltip && tooltip.classList.contains('pinned')) {
                    console.log('Tooltip hide skipped: tooltip is pinned');
                    return;
                }

                if (window.tooltipShowTimer) {
                    clearTimeout(window.tooltipShowTimer);
                    window.tooltipShowTimer = null;
                }

                if (window.tooltipHideTimer) {
                    clearTimeout(window.tooltipHideTimer);
                }

                window.tooltipHideTimer = setTimeout(function() {
                    tooltip.classList.remove('visible');
                    window.activeHighlight = null;
                    window.tooltipHideTimer = null;
                }, window.tooltipHideDelay || 400);
            }

            // Function to select the entire annotation span on double-click
            function selectAnnotationSpan(e) {
                console.log('DEBUG: selectAnnotationSpan called on element:', this);
            
                e.preventDefault();
                e.stopPropagation();
            
                const span = this;
                const annotationId = span.getAttribute('data-annotation-id');
            
                console.log('DEBUG: Selecting annotation span text:', annotationId);
            
                const range = document.createRange();
                range.selectNodeContents(span);
            
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            
                console.log('DEBUG: Selected annotation span text:', selection.toString());
            }

            // Add direct event handlers to all annotation spans
            var spans = document.querySelectorAll('span[data-annotation-id]');
            console.log(`Adding enhanced direct event handlers to ${spans.length} annotation spans`);

            spans.forEach(span => {
                span.removeEventListener('mouseenter', showTooltipDirect);
                span.removeEventListener('mouseleave', hideTooltipDirect);
                span.removeEventListener('dblclick', selectAnnotationSpan);

                span.addEventListener('mouseenter', showTooltipDirect);
                span.addEventListener('mouseleave', hideTooltipDirect);
                span.addEventListener('dblclick', selectAnnotationSpan);
            });

            // Document-level event handlers as backup
            function documentMouseOver(e) {
                const span = e.target.closest('span[data-annotation-id]');
                if (span) {
                    console.log(`Document mouseover detected on span ${span.getAttribute('data-annotation-id')}`);
                    showTooltipDirect.call(span, e);
                }
            }

            function documentMouseOut(e) {
                const span = e.target.closest('span[data-annotation-id]');
                if (span) {
                    console.log(`Document mouseout detected on span ${span.getAttribute('data-annotation-id')}`);
                    hideTooltipDirect.call(span, e);
                }
            }

            document.removeEventListener('mouseover', documentMouseOver);
            document.removeEventListener('mouseout', documentMouseOut);

            document.addEventListener('mouseover', documentMouseOver);
            document.addEventListener('mouseout', documentMouseOut);

            // Add tooltip event handlers
            tooltip.addEventListener('mouseover', function() {
                console.log("Mouseover on tooltip itself");
                if (window.tooltipHideTimer) {
                    clearTimeout(window.tooltipHideTimer);
                    window.tooltipHideTimer = null;
                }
            });

            tooltip.addEventListener('mouseout', function() {
                console.log("Mouseout from tooltip itself");
                if (!window.tooltipCtrlPressed) {
                    hideTooltipDirect.call(window.activeHighlight || this);
                }
            });

            // Document click handler
            function handleDocumentClick(event) {
                const span = event.target.closest('span[data-annotation-id]');
                const titleClicked = event.target.closest('.tooltip-title');

                if (span && !titleClicked) { 
                    if (window.tooltipHideTimer) {
                        clearTimeout(window.tooltipHideTimer);
                        window.tooltipHideTimer = null;
                    }

                    if (window.activeHighlight === span && tooltip.classList.contains('visible')) {
                        console.log("Clicked on active span again, hiding tooltip");
                        tooltip.classList.remove('visible');
                        window.activeHighlight = null;
                    } else {
                        console.log("Clicked on new span or inactive span, showing tooltip");
                        showTooltipDirect.call(span, event);
                    }

                    event.stopPropagation();
                } else if (tooltip.classList.contains('visible') && !tooltip.contains(event.target)) {
                    console.log("Click outside tooltip and annotation, hiding tooltip");
                    tooltip.classList.remove('visible');
                    window.activeHighlight = null;
                }
            }

            document.removeEventListener('click', handleDocumentClick);
            document.addEventListener('click', handleDocumentClick);
        
            // Store right-click target for context menu (not applicable in exported HTML but keeping for completeness)
            document.addEventListener('contextmenu', function(e) {
                window.lastRightClickTarget = e.target;
            });
        
            // Global double-click handler for all annotation spans
            function globalAnnotationDoubleClick(e) {
                const span = e.target.closest('span[data-annotation-id]');
                if (span) {
                    console.log('DEBUG: Global double-click detected on annotation span:', span.getAttribute('data-annotation-id'));
                
                    e.preventDefault();
                    e.stopPropagation();
                
                    const annotationId = span.getAttribute('data-annotation-id');
                    console.log('DEBUG: Selecting full annotation text for:', annotationId);
                
                    const range = document.createRange();
                    range.selectNodeContents(span);
                
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                
                    console.log('DEBUG: Selected text:', selection.toString());
                }
            }
        
            document.removeEventListener('dblclick', globalAnnotationDoubleClick);
            document.addEventListener('dblclick', globalAnnotationDoubleClick);
            console.log('DEBUG: Global annotation double-click handler installed!');

            console.log('Enhanced tooltip functionality initialized successfully for exported HTML');
        })();
        """

        script_tag.string = tooltip_js

        # Add script right before the end of body
        if soup.body:
            soup.body.append(script_tag)

        return str(soup)

    def add_sticky_header_functionality_for_export(self, html_content):
        """Adds sticky header and filtering functionality to the HTML content for export"""
        from bs4 import BeautifulSoup
        import json
        import re
        
        # Parse the HTML content
        soup = BeautifulSoup(html_content, 'html.parser')
        
        # Extract themes from the HTML by looking at data-scene attributes
        themes = set()
        theme_colors = {}
        for span in soup.find_all('span', {'data-scene': True}):
            theme_name = span.get('data-scene')
            if theme_name:
                themes.add(theme_name)
                # Try to extract color from style attribute
                style = span.get('style', '')
                color_match = re.search(r'background-color:\s*([^;]+)', style)
                if color_match and theme_name not in theme_colors:
                    theme_colors[theme_name] = color_match.group(1).strip()
        
        # Extract tags from the HTML by looking at data-tags attributes
        all_tags = set()
        for span in soup.find_all('span', {'data-tags': True}):
            tags_str = span.get('data-tags', '[]')
            try:
                tags = json.loads(tags_str) if tags_str else []
                for tag in tags:
                    if tag:  # Only add non-empty tags
                        # Add # prefix if not present
                        tag = tag if tag.startswith('#') else f'#{tag}'
                        all_tags.add(tag)
            except:
                pass
        
        # Convert to sorted lists
        themes_list = sorted(list(themes))
        tags_list = sorted(list(all_tags))
        
        # Create themes data with colors and hotkeys
        themes_data = []
        for i, theme_name in enumerate(themes_list[:12]):  # Max 12 themes
            # Assign hotkeys
            if i < 9:
                hotkey = str(i + 1)
            elif i == 9:
                hotkey = "0"
            elif i == 10:
                hotkey = "-"
            elif i == 11:
                hotkey = "+"
            else:
                hotkey = ""
            
            themes_data.append({
                'name': theme_name,
                'color': theme_colors.get(theme_name, '#FFF0B3'),
                'hotkey': hotkey
            })
        
        # Detect existing sidebar width from HTML
        sidebar_width = "300px"  # Default fallback
        
        # Try to extract sidebar width from existing CSS
        existing_style = soup.find('style')
        if existing_style and existing_style.string:
            import re
            width_match = re.search(r'--sidebar-width:\s*([^;]+)', existing_style.string)
            if width_match:
                sidebar_width = width_match.group(1).strip()
        
        # Create the sticky header JavaScript and CSS
        sticky_header_code = f"""
<!-- Sticky Header and Filtering Functionality -->
<style id="scriptoria-sticky-header-export-styles">
    /* CSS Variables - respect existing sidebar width */
    :root {{
        --sidebar-width: {sidebar_width}; /* Use detected width */
    }}
    
    /* Sticky Header Styles for Export */
    .sticky-theme-header {{
        position: fixed;
        top: 0;
        left: var(--sidebar-width);
        right: 0;
        width: calc(100% - var(--sidebar-width));
        background: linear-gradient(180deg, rgba(255, 255, 255, 1.0) 0%, rgba(255, 255, 255, 0.95) 100%);
        border-bottom: 1px solid #dee2e6;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        z-index: 1001;
        transform: translateY(-100%);
        transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }}
    
    .sticky-theme-header.visible {{
        transform: translateY(0);
    }}
    
    .sticky-theme-header .header-content {{
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 12px 156px 12px 115px;  /* More balanced */
        width: 100%;
        box-sizing: border-box;
        position: relative;
    }}
    
    .tag-filter-btn {{
        width: 35px;
        height: 35px;
        background: transparent;
        border: none;
        border-radius: 19px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        padding: 17px 16px;
        font-size: 23px;
        font-weight: 500;
        z-index: 12;
        padding-top: 12px;
        padding-right: 14px;
    }}
    
    .tag-filter-btn:hover {{
        background: rgba(33, 150, 243, 0.1);
        border-color: #2196F3;
        transform: translateY(-1px) scale(1.1);
    }}
    
    .tag-filter-btn.active {{
        background: rgba(33, 150, 243, 0.15);
        border: 1px solid #2196F3;
    }}
    
    /* Original tag filter button positioning */
    #tag-filter-btn {{
        position: absolute;
        left: 16px;
        top: 9px;
    }}
    
    /* Position favorites button to the right of tag button */
    #favorites-filter-btn {{
        position: absolute;
        left: 57px;
        top: 9px;
        font-size: 22px;
        padding-right: 15px;
        z-index: 15;
        padding-top: 13px;
        /* padding: 17px 16px; */
        border-radius: 19px;
    }}
    
    /* Position used button to the right of favorites button */
    #used-filter-btn {{
        position: absolute;
        left: 97px;
        top: 9px;
        z-index: 15;
        font-size: 20px;
        padding-right: 15px;
        padding-top: 18px;
        padding: 17px 16px;
        border-radius: 19px;
        color: #4CAF50;
    }}
    
    
    /* Specific styling for favorites filter when active */
    #favorites-filter-btn.active {{
        background: rgba(255, 215, 0, 0.15);
        border: 1px solid #FFD700;
        color: #FFD700;
        padding-right: 16.5px;
        box-shadow: 0 0 6px rgba(33, 150, 243, 0.3);
        padding-top: 13px;
    }}
    
    /* Specific styling for used filter states */
    #used-filter-btn[data-state="1"] {{
        background: rgba(244, 67, 54, 0.1);
        border: 1px solid #f44336;
        color: #f44336;
        font-size: 18px;
        padding-right: 16px;
        padding-top: 15px;
    }}
    
    #used-filter-btn[data-state="2"] {{
        background: rgba(76, 175, 80, 0.15);
        border: 1px solid #4CAF50;
        color: #4CAF50;
        font-size: 24px;
        padding-top: 12px;
        padding-right: 16px;
        transform: translateY(-1px) scale(1.1);
    }}
    
    .theme-buttons-container {{
        display: flex;
        flex-wrap: wrap;
        gap: 8.12px;
        justify-content: center;
        align-items: center;
        flex: 1;
        overflow-x: auto;
        scrollbar-width: thin;
        scrollbar-color: #ccc transparent;
        max-width: calc(100% - 20px);
        padding-top: 2px;
    }}
    
    .theme-buttons-container::-webkit-scrollbar {{
        height: 4px;
    }}
    
    .theme-buttons-container::-webkit-scrollbar-track {{
        background: transparent;
    }}
    
    .theme-buttons-container::-webkit-scrollbar-thumb {{
        background: #ccc;
        border-radius: 2px;
    }}
    
    .sticky-theme-btn {{
        padding: 4px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background: #fff;
        color: #333;
        font-size: 11px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        user-select: none;
        min-height: 24px;
        display: flex;
        align-items: center;
    }}
    
    .sticky-theme-btn:hover {{
        border-color: #666;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        transform: translateY(-1px);
    }}
    
    .sticky-theme-btn.theme-hidden {{
        opacity: 0.5;
        background: #e8e8e8;
        text-decoration: line-through;
    }}
    
    .sticky-theme-btn.solo-mode {{
        border: 2px solid #ff6b35;
        box-shadow: 0 0 6px rgba(255, 107, 53, 0.3);
        font-weight: 600;
    }}
    
    /* Filter classes styling for export */
    .tag-filtered-hidden {{
        border: 1px dashed #ccc !important;
        background-color: #e8e8e8 !important;
        opacity: 0.3 !important;
    }}
    
    .favorites-hidden {{
        border: 1px dashed #ccc !important;
        background-color: #e8e8e8 !important;
        opacity: 0.3 !important;
    }}
    
    .used-hidden {{
        border: 1px dashed #ccc !important;
        background-color: #e8e8e8 !important;
        opacity: 0.3 !important;
    }}
    
    .unused-hidden {{
        border: 1px dashed #ccc !important;
        background-color: #e8e8e8 !important;
        opacity: 0.3 !important;
    }}
    
    .theme-hidden {{
        border: 1px dashed #ccc !important;
        background-color: #e8e8e8 !important;
        opacity: 0.3 !important;
    }}
    
    /* Dim pseudo-element icons for all hidden filter states in export */
    .favorites-hidden::before, .favorites-hidden::after,
    .used-hidden::before, .used-hidden::after,
    .unused-hidden::before, .unused-hidden::after, 
    .tag-filtered-hidden::before, .tag-filtered-hidden::after,
    .theme-hidden::before, .theme-hidden::after {{
        opacity: 0.3 !important;
    }}
    
    .header-controls {{
        position: absolute;
        right: 16px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        gap: 8px;
    }}
    
    .header-menu-container {{
        position: relative;
        display: inline-block;
    }}
    
    .header-menu-btn {{
        width: 35px;
        height: 35px;
        border: none;
        background: #f8f9fa;
        color: #666;
        border-radius: 50%;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        padding-bottom: 4px;
    }}
    
    .header-menu-btn:hover, .header-close-btn:hover {{
        background: #e9ecef;
        color: #495057;
        transform: scale(1.1);
    }}
    
    .header-menu-dropdown {{
        display: none;
        position: absolute;
        top: 100%;
        right: 0;
        background: white;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 1000;
        min-width: 160px;
        margin-top: 4px;
    }}
    
    .header-menu-dropdown.show {{
        display: block;
    }}
    
    .menu-item {{
        padding: 8px 12px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
        font-size: 13px;
        color: #333;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: background-color 0.2s ease;
    }}
    
    .menu-item:last-child {{
        border-bottom: none;
    }}
    
    .menu-item:hover {{
        background-color: #f8f9fa;
    }}
    
    .menu-separator {{
        height: 1px;
        background: #e0e0e0;
        margin: 4px 0;
    }}
    
    /* Hide mobile-only menu items on desktop */
    .mobile-only {{
        display: none;
    }}
    
    .header-close-btn {{
        width: 24px;
        height: 24px;
        border: none;
        background: #f8f9fa;
        color: #666;
        border-radius: 50%;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
    }}
    
    /* Restore button styles */
    #sticky-header-restore {{
        position: fixed !important;
        top: 15px !important;
        right: 30px !important;
        z-index: 10001 !important;
        opacity: 0 !important;
        transform: translateY(-20px) !important;
        transition: all 0.3s ease !important;
        pointer-events: none !important;
    }}
    
    #sticky-header-restore.visible {{
        opacity: 1 !important;
        transform: translateY(0) !important;
        pointer-events: auto !important;
    }}
    
    .restore-btn {{
        background: transparent !important;
        border: 2px solid #007acc !important;
        border-radius: 12px !important;
        padding: 12px 16px !important;
        color: #007acc !important;
        font-weight: bold !important;
        font-size: 11px !important;
        cursor: pointer !important;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
        transition: all 0.2s ease !important;
        white-space: nowrap !important;
        display: flex !important;
        align-items: center !important;
        gap: 6px !important;
    }}
    
    .restore-btn:hover {{
        background: rgba(255, 255, 255, 0.1) !important;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
        transform: translateY(-1px) !important;
    }}
    
    /* Hidden state styles */
    .theme-hidden {{
        border: 1px dashed #ccc !important;
        background-color: #e8e8e8 !important;
    }}
    
    .tag-filtered-hidden {{
        border: 1px dashed #ccc !important;
        background-color: #e8e8e8 !important;
    }}
    
    .favorites-hidden {{
        border: 1px dashed #ccc !important;
        background-color: #e8e8e8 !important;
    }}
    
    .used-hidden {{
        border: 1px dashed #ccc !important;
        background-color: #e8e8e8 !important;
    }}
    
    .unused-hidden {{
        border: 1px dashed #ccc !important;
        background-color: #e8e8e8 !important;
    }}
    
    /* Dim pseudo-element icons for all hidden filter states */
    .favorites-hidden::before, .favorites-hidden::after,
    .used-hidden::before, .used-hidden::after,
    .unused-hidden::before, .unused-hidden::after, 
    .tag-filtered-hidden::before, .tag-filtered-hidden::after,
    .theme-hidden::before, .theme-hidden::after {{
        opacity: 0.3 !important;
    }}
    
    /* Responsive design */
    @media (max-width: 768px) {{
        .sticky-theme-header {{
            left: 0;
            width: 100%;
        }}
        
        .sticky-theme-header .header-content {{
            padding: 8.5px 85px 8.5px 60px !important;  /* Adjusted for vertical buttons layout */
        }}
        
        .theme-buttons-container {{
            padding-left: 0 !important;
            max-width: calc(100% - 25px) !important;
            margin-left: 0 !important;  /* Remove any left margin */
        }}
        
        /* Arrange filter buttons vertically on mobile instead of hiding */
        #tag-filter-btn,
        #favorites-filter-btn,
        #used-filter-btn {{
            position: absolute !important;
            left: 8px !important;
            width: 30px !important;
            height: 30px !important;
            padding: 8px !important;
            font-size: 16px !important;
        }}
        
        #tag-filter-btn {{
            top: 8px !important;
        }}
        
        #favorites-filter-btn {{
            top: 43px !important;
        }}
        
        #used-filter-btn {{
            top: 78px !important;
        }}
        
        /* Hide mobile menu options since we're keeping buttons visible */
        .mobile-only {{
            display: none !important;
        }}
        
        .sticky-theme-btn {{
            padding: 3px 6px;
            font-size: 10px;
        }}
        
        .header-controls {{
            right: 12px;
        }}
        
        /* Show menu toggle on mobile */
        .menu-toggle {{
            display: block !important;
        }}
        
        /* Hide bookmark images on mobile to save space */
        .bookmark-container,
        .bookmark-icon {{
            display: none !important;
        }}
    }}
    
    /* Tag Filter Dialog Styles */
    .tag-filter-dialog-overlay {{
        position: relative;
        display: inline-block;
        z-index: 10002;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
    }}
    
    .tag-filter-dialog-overlay.visible {{
        opacity: 1;
        pointer-events: auto;
    }}
    
    .tag-filter-dialog {{
        position: absolute;
        top: 100%;
        left: 0;
        transform: translateY(-10px) scale(0.9);
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.15);
        z-index: 10003;
        padding: 24px;
        min-width: 400px;
        max-width: 500px;
        max-height: 70vh;
        display: flex;
        flex-direction: column;
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        margin-top: 5px;
    }}
    
    .tag-filter-dialog.visible {{
        transform: translateY(0) scale(1);
        opacity: 1;
    }}
    
    .tag-filter-header {{
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 1px solid #e0e0e0;
    }}
    
    .tag-filter-title {{
        font-size: 18px;
        font-weight: 600;
        color: #333;
        display: flex;
        align-items: center;
        gap: 8px;
    }}
    
    .tag-filter-close {{
        background: none;
        border: none;
        font-size: 24px;
        color: #666;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
    }}
    
    .tag-filter-close:hover {{
        background: #f0f0f0;
        color: #333;
    }}
    
    .tag-filter-controls {{
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
        gap: 12px;
    }}
    
    .tag-filter-mode {{
        display: flex;
        background: #f8f9fa;
        border-radius: 6px;
        padding: 2px;
        gap: 0;
    }}
    
    .mode-toggle-btn {{
        flex: 1;
        padding: 6px 12px;
        border: none;
        background: transparent;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        color: #666;
        transition: all 0.2s ease;
        white-space: nowrap;
    }}
    
    .mode-toggle-btn:hover {{
        background: rgba(33, 150, 243, 0.1);
        color: #2196F3;
    }}
    
    .mode-toggle-btn.active {{
        background: #2196F3;
        color: white;
        box-shadow: 0 1px 3px rgba(33, 150, 243, 0.3);
    }}
    
    .tag-filter-actions {{
        display: flex;
        gap: 8px;
    }}
    
    .tag-filter-action-btn {{
        padding: 4px 8px;
        border: 1px solid #dee2e6;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s ease;
    }}
    
    .tag-filter-action-btn:hover {{
        background: #f0f0f0;
    }}
    
    .tag-filter-list {{
        flex: 1;
        overflow-y: auto;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        padding: 8px;
        background: #fafafa;
        margin-bottom: 20px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px;
        max-height: 400px;
    }}
    
    .tag-filter-item {{
        display: flex;
        align-items: center;
        padding: 4px 8px;
        background: white;
        border-radius: 4px;
        border: 1px solid #e8e8e8;
        transition: all 0.2s ease;
    }}
    
    .tag-filter-item:hover {{
        background: #f8f9fa;
        border-color: #2196F3;
    }}
    
    .tag-filter-checkbox {{
        width: 18px;
        height: 18px;
        margin-right: 6px;
        cursor: pointer;
        position: relative;
        border: 2px solid #ccc;
        border-radius: 3px;
        background: white;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        color: white;
        user-select: none;
    }}
    
    .tag-filter-checkbox.checked {{
        background: #2196F3;
        border-color: #2196F3;
    }}
    
    .tag-filter-checkbox.excluded {{
        background: #f44336;
        border-color: #f44336;
    }}
    
    .tag-filter-label {{
        flex: 1;
        cursor: pointer;
        font-size: 14px;
        color: #333;
    }}
    
    .tag-filter-footer {{
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
    }}
    
    .tag-filter-status {{
        font-size: 12px;
        color: #666;
        flex: 1;
    }}
    
    .tag-filter-no-tags {{
        text-align: center;
        padding: 40px;
        color: #999;
        font-size: 14px;
    }}
    
    /* Tag filter dialog button styles (different from header buttons) */
    .tag-filter-dialog .tag-filter-btn {{
        padding: 17px 16px;
        border-radius: 19px;
        border: none;
        cursor: pointer;
        font-size: 23px;
        font-weight: 500;
        transition: all 0.2s ease;
        padding-top: 12px;
        padding-right: 14px;
    }}
    
    
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {{
    console.log('[Export] Initializing sticky header functionality');
    
    // Configuration
    const themes = {json.dumps(themes_data)};
    const availableTags = {json.dumps(tags_list)};
    
    // State management
    const state = {{
        hiddenThemes: new Set(),
        soloTheme: null,
        headerVisible: false,
        favoritesFilter: false,
        usedFilter: 0  // 0 = show all, 1 = show unused, 2 = show used
    }};
    
    // Create sticky header HTML
    const headerHTML = `
        <div id="scriptoria-sticky-header" class="sticky-theme-header">
            <button id="tag-filter-btn" class="tag-filter-btn" title="Filter by Tags (${{availableTags.length}} available)">
                🏷️
            </button>
            <button id="favorites-filter-btn" class="tag-filter-btn" title="Filter Favorites (Showing All)">
                ☆
            </button>
            <button id="used-filter-btn" class="tag-filter-btn" data-state="0" title="Filter Used (Showing All Used and Unused)">
                ◪
            </button>
            <div class="header-content">
                <div class="theme-buttons-container" id="sticky-theme-buttons">
                    <!-- Theme buttons will be added here -->
                </div>
            </div>
            <div class="header-controls">
                <div class="header-menu-container">
                    <button id="sticky-header-menu" class="header-menu-btn" title="Filter actions">☰</button>
                    <div id="sticky-header-menu-dropdown" class="header-menu-dropdown">
                        <div class="menu-item" id="menu-navigate-next">▼ Navigate Next Match</div>
                        <div class="menu-item" id="menu-navigate-prev">▲ Navigate Previous Match</div>
                        <div class="menu-separator"></div>
                        <div class="menu-item mobile-only" id="menu-tag-filter">🏷️ Toggle Tag Filter</div>
                        <div class="menu-item mobile-only" id="menu-favorites-filter">☆ Toggle Favorites</div>
                        <div class="menu-item mobile-only" id="menu-used-filter">◪ Cycle Used Filter</div>
                        <div class="menu-separator mobile-only"></div>
                        <div class="menu-item" id="menu-refresh-filters">⟳ Refresh Filters</div>
                        <div class="menu-item" id="menu-clear-filters">◯ Clear All Filters</div>
                    </div>
                </div>
                <button id="sticky-header-close" class="header-close-btn" title="Hide sticky header">×</button>
            </div>
        </div>
    `;
    
    // Create restore button HTML
    const restoreHTML = `
        <div id="sticky-header-restore">
            <button class="restore-btn" title="Show sticky header">
                Show Header
            </button>
        </div>
    `;
    
    // Insert header and restore button into document
    document.body.insertAdjacentHTML('afterbegin', headerHTML);
    document.body.insertAdjacentHTML('beforeend', restoreHTML);
    
    const header = document.getElementById('scriptoria-sticky-header');
    const themeContainer = document.getElementById('sticky-theme-buttons');
    const tagFilterBtn = document.getElementById('tag-filter-btn');
    const favoritesFilterBtn = document.getElementById('favorites-filter-btn');
    const usedFilterBtn = document.getElementById('used-filter-btn');
    const closeBtn = document.getElementById('sticky-header-close');
    const menuBtn = document.getElementById('sticky-header-menu');
    const menuDropdown = document.getElementById('sticky-header-menu-dropdown');
    const restoreBtn = document.getElementById('sticky-header-restore');
    const restoreButton = restoreBtn.querySelector('.restore-btn');
    
    // Populate theme buttons
    themes.forEach(theme => {{
        const button = document.createElement('button');
        button.className = 'sticky-theme-btn';
        button.dataset.theme = theme.name;
        button.style.backgroundColor = theme.color;
        button.textContent = theme.hotkey ? `${{theme.hotkey}}: ${{theme.name}}` : theme.name;
        button.title = `Theme: ${{theme.name}} (Click to toggle, Double-click for solo)`;
        
        // Single/double click handling
        let clickTimer = null;
        button.addEventListener('click', function(e) {{
            if (clickTimer) {{
                // Double click - solo mode
                clearTimeout(clickTimer);
                clickTimer = null;
                toggleSoloMode(theme.name);
            }} else {{
                // Single click - wait for potential double click
                clickTimer = setTimeout(() => {{
                    clickTimer = null;
                    toggleThemeVisibility(theme.name);
                }}, 300);
            }}
        }});
        
        themeContainer.appendChild(button);
    }});
    
    // Initialize tag filter state
    window.stickyHeaderTagState = {{
        tagStates: {{}}, // Object to track tri-state: 'unchecked', 'included', 'excluded'
        isActive: false,
        availableTags: availableTags,
        strictMode: true // Default to strict (AND) mode
    }};
    
    // Theme visibility functions
    function toggleThemeVisibility(themeName) {{
        const button = document.querySelector(`[data-theme="${{themeName}}"]`);
        if (state.hiddenThemes.has(themeName)) {{
            // Show theme
            state.hiddenThemes.delete(themeName);
            button.classList.remove('theme-hidden');
            showThemeHighlights(themeName);
        }} else {{
            // Hide theme
            state.hiddenThemes.add(themeName);
            button.classList.add('theme-hidden');
            hideThemeHighlights(themeName);
        }}
        
        // Update scrollbar indicators after toggling theme visibility
        if (window.updateScrollbarIndicators) {{
            window.updateScrollbarIndicators();
        }}
        
        // Update navigation menu state after toggling theme visibility
        if (window.updateNavigationMenuState) {{
            window.updateNavigationMenuState();
        }}
    }}
    
    function toggleSoloMode(themeName) {{
        if (state.soloTheme === themeName) {{
            // Exit solo mode
            state.soloTheme = null;
            state.hiddenThemes.clear();
            themes.forEach(theme => {{
                const button = document.querySelector(`[data-theme="${{theme.name}}"]`);
                button.classList.remove('solo-mode', 'theme-hidden');
                showThemeHighlights(theme.name);
            }});
            
            // Update navigation menu state after exiting solo mode
            if (window.updateNavigationMenuState) {{
                window.updateNavigationMenuState();
            }}
        }} else {{
            // Enter solo mode
            state.soloTheme = themeName;
            themes.forEach(theme => {{
                const button = document.querySelector(`[data-theme="${{theme.name}}"]`);
                if (theme.name === themeName) {{
                    button.classList.add('solo-mode');
                    button.classList.remove('theme-hidden');
                    showThemeHighlights(theme.name);
                }} else {{
                    button.classList.add('theme-hidden');
                    button.classList.remove('solo-mode');
                    hideThemeHighlights(theme.name);
                    state.hiddenThemes.add(theme.name);
                }}
            }});
            
            // Update navigation menu state after entering solo mode
            if (window.updateNavigationMenuState) {{
                window.updateNavigationMenuState();
            }}
        }}
    }}
    
    function exitSoloMode() {{
        state.soloTheme = null;
        state.hiddenThemes.clear();
        
        // Restore all themes to visible state
        themes.forEach(theme => {{
            const button = document.querySelector(`[data-theme="${{theme.name}}"]`);
            if (button) {{
                button.classList.remove('solo-mode', 'theme-hidden');
            }}
            showThemeHighlights(theme.name);
        }});
        
        // Update navigation menu state after exiting solo mode
        if (window.updateNavigationMenuState) {{
            window.updateNavigationMenuState();
        }}
        
        console.log('[Export] Exited solo mode');
    }}
    
    // Tag filter dialog functions
    window.createTagFilterDialog = function() {{
        // Remove existing dialog if present
        const existingOverlay = document.getElementById('tag-filter-overlay');
        if (existingOverlay) {{
            existingOverlay.remove();
        }}
        
        const state = window.stickyHeaderTagState;
        // Ensure availableTags is always an array
        if (!state.availableTags) {{
            state.availableTags = [];
        }}
        // Initialize tagStates if it doesn't exist
        if (!state.tagStates) {{
            state.tagStates = {{}};
        }}
        
        // Create overlay and dialog HTML
        const dialogHTML = `
            <div id="tag-filter-overlay" class="tag-filter-dialog-overlay">
                <div class="tag-filter-dialog">
                    <div class="tag-filter-header">
                        <div class="tag-filter-title">
                            <span>🏷️</span>
                            <span>Filter by Tags</span>
                        </div>
                        <button class="tag-filter-close">×</button>
                    </div>
                    
                    <div class="tag-filter-controls">
                        <div class="tag-filter-mode">
                            <button class="mode-toggle-btn ${{state.strictMode ? 'active' : ''}}" data-mode="strict">Strict</button>
                            <button class="mode-toggle-btn ${{!state.strictMode ? 'active' : ''}}" data-mode="loose">Loose</button>
                        </div>
                        <div class="tag-filter-actions">
                            <button class="tag-filter-action-btn" id="select-all-tags">Select All</button>
                            <button class="tag-filter-action-btn" id="clear-all-tags">Clear All</button>
                        </div>
                    </div>
                    
                    <div class="tag-filter-list" id="tag-filter-list">
                        ${{state.availableTags && state.availableTags.length > 0 ? 
                            state.availableTags.map(tag => {{
                                const tagId = tag.replace('#', '');
                                const tagState = state.tagStates ? (state.tagStates[tag] || 'unchecked') : 'unchecked';
                                
                                // Set the checkbox appearance based on state
                                let checkboxClass = '';
                                let checkboxContent = '';
                                let checkboxStyle = '';
                                
                                if (tagState === 'included') {{
                                    checkboxClass = 'checked';
                                    checkboxContent = '✓';
                                    checkboxStyle = 'background: #2196F3; border-color: #2196F3; color: white;';
                                }} else if (tagState === 'excluded') {{
                                    checkboxClass = 'excluded';
                                    checkboxContent = '✕';
                                    checkboxStyle = 'background: #f44336; border-color: #f44336; color: white;';
                                }} else {{
                                    checkboxStyle = 'background: white; border-color: #ccc;';
                                }}
                                
                                return `
                                    <div class="tag-filter-item">
                                        <div class="tag-filter-checkbox ${{checkboxClass}}" 
                                             data-tag="${{tag}}"
                                             data-state="${{tagState}}"
                                             style="${{checkboxStyle}}">
                                            ${{checkboxContent}}
                                        </div>
                                        <label class="tag-filter-label" data-tag="${{tag}}">${{tag}}</label>
                                    </div>
                                `;
                            }}).join('') :
                            '<div class="tag-filter-no-tags">No tags available. Create tags in the Tag Manager first.</div>'
                        }}
                    </div>
                    
                    <div class="tag-filter-footer">
                        <div class="tag-filter-status">
                            <span id="tag-included-count">0</span> included, <span id="tag-excluded-count">0</span> excluded
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Get the tag filter button to position relative to it
        const tagFilterBtn = document.getElementById('tag-filter-btn');
        if (!tagFilterBtn) {{
            console.error('Tag filter button not found');
            return;
        }}
        
        // Insert dialog into DOM relative to the button
        tagFilterBtn.parentElement.insertAdjacentHTML('beforeend', dialogHTML);
        
        // Get dialog elements
        const overlay = document.getElementById('tag-filter-overlay');
        const dialog = overlay.querySelector('.tag-filter-dialog');
        
        // Position the overlay relative to button
        const buttonRect = tagFilterBtn.getBoundingClientRect();
        const containerRect = tagFilterBtn.parentElement.getBoundingClientRect();
        
        // Calculate position relative to container
        overlay.style.position = 'absolute';
        overlay.style.left = (buttonRect.left - containerRect.left) + 'px';
        overlay.style.top = (buttonRect.bottom - containerRect.top) + 'px';
        
        // Setup event listeners
        setupTagFilterListeners(overlay, dialog);
        
        // Add backdrop click handler
        const handleBackdropClick = (e) => {{
            if (!dialog.contains(e.target) && !tagFilterBtn.contains(e.target)) {{
                window.closeTagFilterDialog();
                document.removeEventListener('click', handleBackdropClick);
            }}
        }};
        
        // Show dialog with animation
        requestAnimationFrame(() => {{
            overlay.classList.add('visible');
            dialog.classList.add('visible');
            // Add backdrop click listener after a longer delay to prevent immediate closure
            setTimeout(() => {{
                document.addEventListener('click', handleBackdropClick);
            }}, 300);
        }});
    }};
    
    window.setupTagFilterListeners = function(overlay, dialog) {{
        const state = window.stickyHeaderTagState;
        
        // Close button
        dialog.querySelector('.tag-filter-close').addEventListener('click', () => {{
            closeTagFilterDialog();
        }});
        
        // Tri-state checkbox click handler
        dialog.querySelectorAll('.tag-filter-checkbox, .tag-filter-label').forEach(elem => {{
            elem.addEventListener('click', (e) => {{
                e.preventDefault();
                e.stopPropagation();
                
                const checkbox = elem.classList.contains('tag-filter-checkbox') ? 
                    elem : elem.previousElementSibling;
                const tag = checkbox.dataset.tag;
                const currentState = checkbox.dataset.state || 'unchecked';
                
                // Cycle through states: unchecked -> included -> excluded -> unchecked
                let newState;
                if (!currentState || currentState === 'unchecked') {{
                    newState = 'included';
                    checkbox.classList.remove('excluded');
                    checkbox.classList.add('checked');
                    checkbox.style.background = '#2196F3';
                    checkbox.style.borderColor = '#2196F3';
                    checkbox.innerHTML = '✓';
                    checkbox.style.color = 'white';
                }} else if (currentState === 'included') {{
                    newState = 'excluded';
                    checkbox.classList.remove('checked');
                    checkbox.classList.add('excluded');
                    checkbox.style.background = '#f44336';
                    checkbox.style.borderColor = '#f44336';
                    checkbox.innerHTML = '✕';
                    checkbox.style.color = 'white';
                }} else {{
                    newState = 'unchecked';
                    checkbox.classList.remove('excluded');
                    checkbox.classList.remove('checked');
                    checkbox.style.background = 'white';
                    checkbox.style.borderColor = '#ccc';
                    checkbox.innerHTML = '';
                }}
                
                checkbox.dataset.state = newState;
                state.tagStates[tag] = newState;
                updateTagFilterCount();
                
                // Apply filter instantly
                applyTagFilter();
            }});
        }});
        
        // Select All / Clear All
        const selectAllBtn = document.getElementById('select-all-tags');
        const clearAllBtn = document.getElementById('clear-all-tags');
        
        if (selectAllBtn) {{
            selectAllBtn.addEventListener('click', () => {{
                dialog.querySelectorAll('.tag-filter-checkbox').forEach(cb => {{
                    cb.dataset.state = 'included';
                    cb.classList.remove('excluded');
                    cb.classList.add('checked');
                    cb.style.background = '#2196F3';
                    cb.style.borderColor = '#2196F3';
                    cb.innerHTML = '✓';
                    cb.style.color = 'white';
                    state.tagStates[cb.dataset.tag] = 'included';
                }});
                updateTagFilterCount();
                applyTagFilter(); // Apply instantly
            }});
        }}
        
        if (clearAllBtn) {{
            clearAllBtn.addEventListener('click', () => {{
                dialog.querySelectorAll('.tag-filter-checkbox').forEach(cb => {{
                    cb.dataset.state = 'unchecked';
                    cb.classList.remove('excluded');
                    cb.classList.remove('checked');
                    cb.style.background = 'white';
                    cb.style.borderColor = '#ccc';
                    cb.innerHTML = '';
                    state.tagStates[cb.dataset.tag] = 'unchecked';
                }});
                updateTagFilterCount();
                applyTagFilter(); // Apply instantly
            }});
        }}
        
        // Filter mode toggle button handlers
        dialog.querySelectorAll('.mode-toggle-btn').forEach(btn => {{
            btn.addEventListener('click', () => {{
                const mode = btn.dataset.mode;
                state.strictMode = mode === 'strict';
                
                // Update button states
                dialog.querySelectorAll('.mode-toggle-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                console.log('[Export] Filter mode changed to:', state.strictMode ? 'strict' : 'loose');
                // Immediately reapply filters with new mode
                applyTagFilter();
            }});
        }});
        
        // Click outside to close
        overlay.addEventListener('click', (e) => {{
            if (e.target === overlay) {{
                closeTagFilterDialog();
            }}
        }});
        
        // Initial count
        updateTagFilterCount();
    }};
    
    window.updateTagFilterCount = function() {{
        const state = window.stickyHeaderTagState;
        let includedCount = 0;
        let excludedCount = 0;
        
        if (state.tagStates) {{
            Object.values(state.tagStates).forEach(tagState => {{
                if (tagState === 'included') includedCount++;
                else if (tagState === 'excluded') excludedCount++;
            }});
        }}
        
        const includedSpan = document.getElementById('tag-included-count');
        const excludedSpan = document.getElementById('tag-excluded-count');
        if (includedSpan) includedSpan.textContent = includedCount;
        if (excludedSpan) excludedSpan.textContent = excludedCount;
    }};
    
    window.closeTagFilterDialog = function() {{
        const overlay = document.getElementById('tag-filter-overlay');
        if (overlay) {{
            const dialog = overlay.querySelector('.tag-filter-dialog');
            overlay.classList.remove('visible');
            dialog.classList.remove('visible');
            setTimeout(() => overlay.remove(), 300);
        }}
    }};
    
    function showThemeHighlights(themeName) {{
        const elements = document.querySelectorAll(`[data-scene="${{themeName}}"]`);
        const themeData = themes.find(t => t.name === themeName);
        const themeColor = themeData ? themeData.color : '#FFF0B3';
        
        elements.forEach(element => {{
            element.classList.remove('theme-hidden');
            if (!element.classList.contains('tag-filtered-hidden')) {{
                element.style.opacity = '1.0';
                element.style.border = '';
                element.style.backgroundColor = themeColor;
            }}
        }});
    }}
    
    function hideThemeHighlights(themeName) {{
        const elements = document.querySelectorAll(`[data-scene="${{themeName}}"]`);
        elements.forEach(element => {{
            element.classList.add('theme-hidden');
            element.style.border = '1px dashed #ccc';
            element.style.backgroundColor = '#e8e8e8';
        }});
    }}
    
    // Favorites filter functions
    function toggleFavoritesFilter() {{
        state.favoritesFilter = !state.favoritesFilter;
        
        if (state.favoritesFilter) {{
            favoritesFilterBtn.classList.add('active');
            favoritesFilterBtn.innerHTML = '★';
            favoritesFilterBtn.title = 'Filter Favorites (Showing Favorites Only)';
        }} else {{
            favoritesFilterBtn.classList.remove('active');
            favoritesFilterBtn.innerHTML = '☆';
            favoritesFilterBtn.title = 'Filter Favorites (Showing All)';
        }}
        
        // Apply all filters including scrollbar indicators update
        applyCombinedFilters();
    }}
    
    function showAllByFavorites() {{
        const annotations = document.querySelectorAll('[data-annotation-id]');
        annotations.forEach(annotation => {{
            annotation.classList.remove('favorites-hidden');
        }});
        console.log('[Export] Showing all annotations (favorites filter off)');
    }}
    
    function hideNonFavorites() {{
        const annotations = document.querySelectorAll('[data-annotation-id]');
        annotations.forEach(annotation => {{
            const isFavorite = annotation.getAttribute('data-favorite') === 'true';
            if (!isFavorite) {{
                annotation.classList.add('favorites-hidden');
            }} else {{
                annotation.classList.remove('favorites-hidden');
            }}
        }});
        console.log('[Export] Hiding non-favorite annotations');
    }}
    
    // Used filter functions (tri-state)
    function cycleUsedFilter() {{
        state.usedFilter = (state.usedFilter + 1) % 3;
        
        if (state.usedFilter === 0) {{  // Show all
            usedFilterBtn.setAttribute('data-state', '0');
            usedFilterBtn.innerHTML = '◪';
            usedFilterBtn.title = 'Filter Used (Showing All Used and Unused)';
        }} else if (state.usedFilter === 1) {{  // Show unused
            usedFilterBtn.setAttribute('data-state', '1');
            usedFilterBtn.innerHTML = '☐';
            usedFilterBtn.title = 'Filter Used (Showing Unused)';
        }} else {{  // Show used
            usedFilterBtn.setAttribute('data-state', '2');
            usedFilterBtn.innerHTML = '■';
            usedFilterBtn.title = 'Filter Used (Showing Used)';
        }}
        
        // Apply all filters including scrollbar indicators update
        applyCombinedFilters();
    }}
    
    function showAllByUsage() {{
        const annotations = document.querySelectorAll('[data-annotation-id]');
        annotations.forEach(annotation => {{
            annotation.classList.remove('used-hidden', 'unused-hidden');
        }});
        console.log('[Export] Showing all annotations (used filter off)');
    }}
    
    function hideUsedAnnotations() {{
        const annotations = document.querySelectorAll('[data-annotation-id]');
        annotations.forEach(annotation => {{
            const isUsed = annotation.getAttribute('data-used') === 'true';
            if (isUsed) {{
                annotation.classList.add('used-hidden');
                annotation.classList.remove('unused-hidden');
            }} else {{
                annotation.classList.remove('used-hidden', 'unused-hidden');
            }}
        }});
        console.log('[Export] Hiding used annotations');
    }}
    
    function hideUnusedAnnotations() {{
        const annotations = document.querySelectorAll('[data-annotation-id]');
        annotations.forEach(annotation => {{
            const isUsed = annotation.getAttribute('data-used') === 'true';
            if (!isUsed) {{
                annotation.classList.add('unused-hidden');
                annotation.classList.remove('used-hidden');
            }} else {{
                annotation.classList.remove('used-hidden', 'unused-hidden');
            }}
        }});
        console.log('[Export] Hiding unused annotations');
    }}
    
    function applyTagFilter() {{
        const state = window.stickyHeaderTagState;
    
        // Ensure tagStates exists
        if (!state.tagStates) {{
            state.tagStates = {{}};
        }}
    
        // Check if any filters are active
        const hasFilters = Object.values(state.tagStates).some(s => s !== 'unchecked');
    
        // Update button state
        const filterBtn = document.getElementById('tag-filter-btn');
        if (hasFilters) {{
            state.isActive = true;
            filterBtn.classList.add('active');
            const included = Object.values(state.tagStates).filter(s => s === 'included').length;
            const excluded = Object.values(state.tagStates).filter(s => s === 'excluded').length;
            filterBtn.title = `Filtering: ${{included}} included, ${{excluded}} excluded`;
        }} else {{
            state.isActive = false;
            filterBtn.classList.remove('active');
            filterBtn.title = `Filter by Tags (${{state.availableTags.length}} available)`;
        }}
    
        // Apply filtering to annotations
        const annotations = document.querySelectorAll('[data-annotation-id]');
    
        // Get included and excluded tags (normalize by removing # prefix for comparison)
        const includedTags = [];
        const excludedTags = [];
        if (state.tagStates) {{
            Object.entries(state.tagStates).forEach(([tag, tagState]) => {{
                const normalizedTag = tag.startsWith('#') ? tag.substring(1) : tag;
                if (tagState === 'included') includedTags.push(normalizedTag);
                else if (tagState === 'excluded') excludedTags.push(normalizedTag);
            }});
        }}
    
        // Check if any filters are active
        state.isActive = includedTags.length > 0 || excludedTags.length > 0;
    
        annotations.forEach(span => {{
            const tagsAttr = span.getAttribute('data-tags');
            let annotationTags = [];
        
            // Handle missing data-tags attribute
            if (tagsAttr === null || tagsAttr === undefined) {{
                annotationTags = [];
            }} else {{
                try {{
                    annotationTags = JSON.parse(tagsAttr) || [];
                }} catch (e) {{
                    console.error('Error parsing tags:', e);
                    annotationTags = [];
                }}
            }}
        
            // Convert to set for easier comparison (keep original format - no # prefix)
            const annoTagSet = new Set(annotationTags);
        
            let shouldShow = true;
        
            if (state.isActive) {{
                // If annotation has NO TAGS and any filter is active, hide it
                if (annoTagSet.size === 0) {{
                    shouldShow = false;
                }} else {{
                    // Check excluded tags first (they take precedence)
                    if (excludedTags.length > 0) {{
                        const hasExcludedTag = excludedTags.some(tag => annoTagSet.has(tag));
                        if (hasExcludedTag) {{
                            shouldShow = false;
                        }}
                    }}
                
                    // Check included tags based on strict/loose mode
                    if (shouldShow && includedTags.length > 0) {{
                        if (state.strictMode) {{
                            // Strict mode: annotation must have ALL included tags (AND logic)
                            const hasAllIncludedTags = includedTags.every(tag => annoTagSet.has(tag));
                            if (!hasAllIncludedTags) {{
                                shouldShow = false;
                            }}
                        }} else {{
                            // Loose mode: annotation must have ANY included tag (OR logic)
                            const hasAnyIncludedTag = includedTags.some(tag => annoTagSet.has(tag));
                            if (!hasAnyIncludedTag) {{
                                shouldShow = false;
                            }}
                        }}
                    }}
                }}
            }}
        
            if (shouldShow) {{
                // Remove tag filtering class
                span.classList.remove('tag-filtered-hidden');
            
                // Only restore full visibility if ALSO not hidden by theme
                if (!span.classList.contains('theme-hidden')) {{
                    const scene = span.getAttribute('data-scene');
                    const themeData = themes.find(t => t.name === scene);
                    const themeColor = themeData ? themeData.color : '#FFF0B3';
                
                    span.style.opacity = '1.0';
                    span.style.border = '';
                    span.style.backgroundColor = themeColor;
                    span.style.color = '';
                }}
            }} else {{
                // Hide annotation due to tag filter
                span.classList.add('tag-filtered-hidden');
                span.style.opacity = '0.3';
                span.style.backgroundColor = '#e8e8e8';
                span.style.border = '1px dashed #ccc';
                span.style.color = '#666';
            }}
        }});
    
        console.log('[Export] Tag filter applied:', {{
            tagStates: state.tagStates,
            active: state.isActive,
            strictMode: state.strictMode
        }});
    }}
    
    // Scrollbar Indicators System for Export
    window.updateScrollbarIndicators = function() {{
        console.log('[Export] Updating scrollbar indicators');
        
        // Remove existing indicators
        document.querySelectorAll('.scroll-indicator').forEach(el => el.remove());
        
        // Only show indicators when filters are active
        if (!window.hasActiveFilters()) {{
            console.log('[Export] No active filters - hiding scrollbar indicators');
            return;
        }}
        
        // Get visible annotations
        const visibleAnnotations = window.getMatchedAnnotations();
        if (visibleAnnotations.length === 0) {{
            console.log('[Export] No visible annotations - no indicators to show');
            return;
        }}
        
        // Calculate document dimensions
        const documentHeight = Math.max(
            document.body.scrollHeight,
            document.documentElement.scrollHeight
        );
        const viewportHeight = window.innerHeight;
        
        // Account for scrollbar arrow buttons and track margins
        const scrollbarArrowHeight = 12;
        const scrollbarMargin = 2;
        const scrollbarTrackOffset = scrollbarArrowHeight + scrollbarMargin;
        const availableTrackHeight = viewportHeight - (2 * scrollbarTrackOffset);
        const scrollableHeight = documentHeight - viewportHeight;
        
        console.log(`[Export] Creating ${{visibleAnnotations.length}} scrollbar indicators`);
        console.log(`[Export] Document height: ${{documentHeight}}px, Viewport height: ${{viewportHeight}}px`);
        
        // Create indicators for each visible annotation
        visibleAnnotations.forEach((annotation, index) => {{
            // Position indicator based on annotation's actual position in document with adjustment
            const annotationRatio = annotation.top / documentHeight;
            const adjustedRatio = annotationRatio + 0.002; // Fine-tuned offset
            
            // Convert to scrollbar track position
            const scrollRatio = adjustedRatio;
            const trackPosition = scrollbarTrackOffset + (scrollRatio * availableTrackHeight);
            const position = (trackPosition / viewportHeight) * 100;
            
            const scene = annotation.element.getAttribute('data-scene') || 'default';
            
            // Get theme color for this annotation
            let themeColor = '#FFF0B3'; // Default yellow
            // Use simple color mapping for export
            const colorMap = {{
                'Miscellaneous': '#FFF0B3',
                'Theology': '#E1F5FE',
                'Prophets': '#F3E5F5',
                'Stories': '#E8F5E8',
                'Law': '#FFF3E0',
                'Wisdom': '#F1F8E9',
                'Prophecy': '#FCE4EC',
                'History': '#EFEBE9',
                'Poetry': '#F8BBD9',
                'Apocalyptic': '#B39DDB',
                'default': '#FFF0B3'
            }};
            themeColor = colorMap[scene] || colorMap['default'];
            
            const indicator = document.createElement('div');
            indicator.className = 'scroll-indicator';
            indicator.style.cssText = `
                position: fixed;
                right: 2px;
                width: 12px;
                height: 8px;
                background-color: ${{themeColor}};
                border: 1px solid rgba(0,0,0,0.3);
                border-radius: 2px;
                z-index: 25000; /* Above sticky header and menus */
                pointer-events: auto; /* Allow click interactions */
                top: ${{position}}%;
                box-shadow: 0 1px 2px rgba(0,0,0,0.2);
                cursor: pointer;
                transition: all 0.2s ease;
            `;
            
            // Add hover effect
            indicator.addEventListener('mouseenter', function() {{
                this.style.width = '15px';
                this.style.right = '0px';
                this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.4)';
            }});
            
            indicator.addEventListener('mouseleave', function() {{
                this.style.width = '12px';
                this.style.right = '2px';
                this.style.boxShadow = '0 1px 2px rgba(0,0,0,0.2)';
            }});
            
            // Click to scroll to annotation
            indicator.addEventListener('click', function() {{
                annotation.element.scrollIntoView({{ behavior: 'smooth', block: 'center' }});
                window.scrollToAndHighlightAnnotation(annotation);
            }});
            
            // Add tooltip showing scene name and position
            indicator.title = `${{scene}} (${{index + 1}}/${{visibleAnnotations.length}})`;
            
            document.body.appendChild(indicator);
        }});
        
        console.log('[Export] Scrollbar indicators updated');
    }};
    
    // Update indicators on window resize
    window.addEventListener('resize', function() {{
        setTimeout(window.updateScrollbarIndicators, 100);
    }});
    
    // Update indicators on scroll
    let scrollTimeout;
    window.addEventListener('scroll', function() {{
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(function() {{
            if (window.hasActiveFilters()) {{
                window.updateScrollbarIndicators();
            }}
        }}, 200);
    }});
    
    // Combined filter application
    function applyCombinedFilters() {{
        // Apply favorites filter
        if (state.favoritesFilter) {{
            hideNonFavorites();
        }} else {{
            showAllByFavorites();
        }}
    
        // Apply used filter
        if (state.usedFilter === 1) {{
            hideUsedAnnotations();
        }} else if (state.usedFilter === 2) {{
            hideUnusedAnnotations();
        }} else {{
            showAllByUsage();
        }}
    
        // Apply tag filters using the tri-state system
        if (window.stickyHeaderTagState && window.stickyHeaderTagState.isActive) {{
            applyTagFilter();
        }} else {{
            // Clear tag filter classes when not active
            const annotations = document.querySelectorAll('[data-annotation-id]');
            annotations.forEach(annotation => {{
                annotation.classList.remove('tag-filtered-hidden');
            }});
        }}
        
        // Update navigation menu state after applying filters
        if (window.updateNavigationMenuState) {{
            window.updateNavigationMenuState();
        }}
        
        // Update scrollbar indicators after applying filters
        if (window.updateScrollbarIndicators) {{
            window.updateScrollbarIndicators();
        }}
    }}
    
    // Event handlers for filter buttons
    tagFilterBtn.addEventListener('click', function(e) {{
        e.stopPropagation();
        window.createTagFilterDialog();
    }});
    
    favoritesFilterBtn.addEventListener('click', function() {{
        toggleFavoritesFilter();
    }});
    
    usedFilterBtn.addEventListener('click', function() {{
        cycleUsedFilter();
    }});
    
    // Menu button handlers
    menuBtn.addEventListener('click', function(e) {{
        e.stopPropagation();
        menuDropdown.classList.toggle('show');
    }});
    
    // Menu actions
    
    // Navigation handlers
    const menuNavigateNext = document.getElementById('menu-navigate-next');
    const menuNavigatePrev = document.getElementById('menu-navigate-prev');
    
    if (menuNavigateNext) {{
        menuNavigateNext.addEventListener('click', function() {{
            console.log('[Export] Navigate next match clicked');
            // Don't close menu - allow multiple navigation clicks
            if (window.navigateToNextMatch) {{
                window.navigateToNextMatch();
            }}
        }});
    }}
    
    if (menuNavigatePrev) {{
        menuNavigatePrev.addEventListener('click', function() {{
            console.log('[Export] Navigate previous match clicked');
            // Don't close menu - allow multiple navigation clicks
            if (window.navigateToPreviousMatch) {{
                window.navigateToPreviousMatch();
            }}
        }});
    }}
    
    document.getElementById('menu-refresh-filters').addEventListener('click', function() {{
        console.log('[Export] Refresh filters clicked');
        menuDropdown.classList.remove('show');
        applyCombinedFilters();
    }});
    
    // Mobile filter menu items for export
    const menuTagFilter = document.getElementById('menu-tag-filter');
    const menuFavoritesFilter = document.getElementById('menu-favorites-filter');
    const menuUsedFilter = document.getElementById('menu-used-filter');
    
    if (menuTagFilter) {{
        menuTagFilter.addEventListener('click', function() {{
            console.log('[Export] Mobile tag filter menu clicked');
            menuDropdown.classList.remove('show');
            toggleTagFilter();
        }});
    }}
    
    if (menuFavoritesFilter) {{
        menuFavoritesFilter.addEventListener('click', function() {{
            console.log('[Export] Mobile favorites filter menu clicked');
            menuDropdown.classList.remove('show');
            toggleFavoritesFilter();
        }});
    }}
    
    if (menuUsedFilter) {{
        menuUsedFilter.addEventListener('click', function() {{
            console.log('[Export] Mobile used filter menu clicked');
            menuDropdown.classList.remove('show');
            cycleUsedFilter();
        }});
    }}
    
    document.getElementById('menu-clear-filters').addEventListener('click', function() {{
        console.log('[Export] Clear filters clicked');
        menuDropdown.classList.remove('show');
        
        // Clear all filters
        state.favoritesFilter = false;
        state.usedFilter = 0;
        state.selectedTags.clear();
        state.isTagFilterActive = false;
        
        // Reset button states
        favoritesFilterBtn.classList.remove('active');
        favoritesFilterBtn.innerHTML = '☆';
        favoritesFilterBtn.title = 'Filter Favorites (Showing All)';
        
        usedFilterBtn.setAttribute('data-state', '0');
        usedFilterBtn.innerHTML = '◪';
        usedFilterBtn.title = 'Filter Used (Showing All Used and Unused)';
        
        tagFilterBtn.classList.remove('active');
        
        // Clear tag filter state
        if (window.stickyHeaderTagState) {{
            window.stickyHeaderTagState.tagStates = {{}};
            window.stickyHeaderTagState.isActive = false;
        }}
        
        // Clear theme filters (exit solo mode and show all themes)
        if (state.soloTheme) {{
            exitSoloMode();
        }}
        
        if (state.hiddenThemes.size > 0) {{
            const hiddenThemes = Array.from(state.hiddenThemes);
            state.hiddenThemes.clear();
            
            hiddenThemes.forEach(themeName => {{
                showThemeHighlights(themeName);
                const button = document.querySelector(`[data-theme="${{themeName}}"]`);
                if (button) {{
                    button.classList.remove('theme-hidden');
                }}
            }});
        }}
        
        applyCombinedFilters();
    }});
    
    // Close dropdown when clicking outside
    document.addEventListener('click', function(e) {{
        if (!menuBtn.contains(e.target) && !menuDropdown.contains(e.target)) {{
            menuDropdown.classList.remove('show');
        }}
        // Tag filter dialog has its own backdrop click handling
    }});
    
    // Scroll detection
    let scrollThreshold = 100;
    let manuallyClosed = false;  // Track if user manually closed header
    
    window.addEventListener('scroll', function() {{
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
        // Only auto-show if not manually closed
        if (scrollTop > scrollThreshold && !state.headerVisible && !manuallyClosed) {{
            header.classList.add('visible');
            restoreBtn.classList.remove('visible');
            state.headerVisible = true;
        }} else if (scrollTop <= scrollThreshold && state.headerVisible && !manuallyClosed) {{
            header.classList.remove('visible');
            state.headerVisible = false;
        }}
    }});
    
    // Close button
    closeBtn.addEventListener('click', function() {{
        header.classList.remove('visible');
        state.headerVisible = false;
        restoreBtn.classList.add('visible');
        manuallyClosed = true;  // Mark as manually closed
    }});
    
    // Restore button
    restoreButton.addEventListener('click', function() {{
        header.classList.add('visible');
        state.headerVisible = true;
        restoreBtn.classList.remove('visible');
        manuallyClosed = false;  // Clear manual close flag
    }});
    
    // Keyboard shortcuts for themes
    document.addEventListener('keydown', function(e) {{
        if (e.altKey && !e.ctrlKey && !e.shiftKey) {{
            const key = e.key;
            let themeIndex = -1;
            
            if (key >= '1' && key <= '9') {{
                themeIndex = parseInt(key) - 1;
            }} else if (key === '0') {{
                themeIndex = 9;
            }} else if (key === '-') {{
                themeIndex = 10;
            }} else if (key === '=' || key === '+') {{
                themeIndex = 11;
            }}
            
            if (themeIndex >= 0 && themeIndex < themes.length) {{
                e.preventDefault();
                toggleThemeVisibility(themes[themeIndex].name);
            }}
        }}
    }});
    
    // Navigation functionality for export
    window.currentMatchIndex = -1;
    window.matchedAnnotations = [];
    
    // Function to check if any filters are active
    window.hasActiveFilters = function() {{
        // Check favorites filter
        if (state.favoritesFilter) {{
            return true;
        }}
        
        // Check used filter (0 = show all, 1 = show only used, 2 = show only unused)
        if (state.usedFilter !== 0) {{
            return true;
        }}
        
        // Check tag filters
        if (state.isTagFilterActive) {{
            return true;
        }}
        
        // Check theme filters (hidden themes or solo mode)
        if (state.soloTheme || (state.hiddenThemes && state.hiddenThemes.size > 0)) {{
            return true;
        }}
        
        return false;
    }};
    
    // Function to get all visible annotations that match current filters
    window.getMatchedAnnotations = function() {{
        const annotations = document.querySelectorAll('[data-annotation-id]');
        const matched = [];
        
        annotations.forEach(function(annotation) {{
            // Check if annotation is currently visible (not filtered out)
            const computedStyle = window.getComputedStyle(annotation);
            if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {{
                // Also check if annotation is not hidden by any filter classes
                const isFilteredOut = annotation.classList.contains('tag-filtered-hidden') ||
                                    annotation.classList.contains('favorites-hidden') ||
                                    annotation.classList.contains('used-hidden') ||
                                    annotation.classList.contains('unused-hidden') ||
                                    annotation.classList.contains('theme-hidden');
                
                if (!isFilteredOut) {{
                    const rect = annotation.getBoundingClientRect();
                    if (rect.height > 0) {{
                        matched.push({{
                            element: annotation,
                            id: annotation.getAttribute('data-annotation-id'),
                            top: annotation.offsetTop
                        }});
                    }}
                }}
            }}
        }});
        
        // Sort by document order (top position)
        matched.sort((a, b) => a.top - b.top);
        return matched;
    }};
    
    // Function to find current position in matched annotations
    window.getCurrentMatchIndex = function() {{
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const windowHeight = window.innerHeight;
        const currentViewCenter = scrollTop + windowHeight / 2;
        
        for (let i = 0; i < window.matchedAnnotations.length; i++) {{
            const annotation = window.matchedAnnotations[i];
            if (annotation.top > currentViewCenter) {{
                return i - 1; // Return previous annotation index
            }}
        }}
        
        return window.matchedAnnotations.length - 1; // Return last annotation if at bottom
    }};
    
    // Function to get complementary color for highlighting
    function getComplementaryColor(bgColor) {{
        // Parse RGB values from background color
        const rgbMatch = bgColor.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);
        if (!rgbMatch) return 'rgba(255, 255, 255, 0.8)'; // fallback
        
        const r = parseInt(rgbMatch[1]);
        const g = parseInt(rgbMatch[2]);
        const b = parseInt(rgbMatch[3]);
        
        // Calculate luminance to determine if color is light or dark
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        
        // Return complementary color with transparency
        if (luminance > 0.5) {{
            // Light color - return darker complement
            return `rgba(${{255-r}}, ${{255-g}}, ${{255-b}}, 0.6)`;
        }} else {{
            // Dark color - return lighter complement
            return `rgba(${{255-r}}, ${{255-g}}, ${{255-b}}, 0.8)`;
        }}
    }}
    
    // Function to scroll to and highlight an annotation
    window.scrollToAndHighlightAnnotation = function(annotation) {{
        if (!annotation || !annotation.element) return;
        
        // Scroll to the annotation
        annotation.element.scrollIntoView({{ behavior: 'smooth', block: 'center' }});
        
        // Apply highlight animation
        const span = annotation.element;
        const bgColor = window.getComputedStyle(span).backgroundColor;
        const complementaryColor = getComplementaryColor(bgColor);
        
        span.style.boxShadow = '0 0 10px 3px ' + complementaryColor;
        span.classList.add('annotation-highlight');
        
        // Fade out after delay (same as theme view)
        setTimeout(() => {{
            span.classList.add('annotation-highlight-fadeout');
            
            setTimeout(() => {{
                span.style.boxShadow = '';
                span.classList.remove('annotation-highlight', 'annotation-highlight-fadeout');
            }}, 600);
        }}, 1000);
        
        console.log(`[Export] Navigated to annotation: ${{annotation.id}}`);
    }};
    
    // Navigate to next match function
    window.navigateToNextMatch = function() {{
        if (!window.hasActiveFilters()) {{
            console.log('[Export] No active filters - navigation disabled');
            return;
        }}
        
        window.matchedAnnotations = window.getMatchedAnnotations();
        if (window.matchedAnnotations.length === 0) {{
            console.log('[Export] No matching annotations found');
            return;
        }}
        
        const currentIndex = window.getCurrentMatchIndex();
        let nextIndex = currentIndex + 1;
        
        // Wrap around to beginning if at end
        if (nextIndex >= window.matchedAnnotations.length) {{
            nextIndex = 0;
        }}
        
        window.currentMatchIndex = nextIndex;
        window.scrollToAndHighlightAnnotation(window.matchedAnnotations[nextIndex]);
    }};
    
    // Navigate to previous match function
    window.navigateToPreviousMatch = function() {{
        if (!window.hasActiveFilters()) {{
            console.log('[Export] No active filters - navigation disabled');
            return;
        }}
        
        window.matchedAnnotations = window.getMatchedAnnotations();
        if (window.matchedAnnotations.length === 0) {{
            console.log('[Export] No matching annotations found');
            return;
        }}
        
        const currentIndex = window.getCurrentMatchIndex();
        let prevIndex = currentIndex - 1;
        
        // Wrap around to end if at beginning
        if (prevIndex < 0) {{
            prevIndex = window.matchedAnnotations.length - 1;
        }}
        
        window.currentMatchIndex = prevIndex;
        window.scrollToAndHighlightAnnotation(window.matchedAnnotations[prevIndex]);
    }};
    
    // Function to update menu item states based on active filters
    window.updateNavigationMenuState = function() {{
        const hasFilters = window.hasActiveFilters();
        const menuNavigateNext = document.getElementById('menu-navigate-next');
        const menuNavigatePrev = document.getElementById('menu-navigate-prev');
        
        if (menuNavigateNext) {{
            if (hasFilters) {{
                menuNavigateNext.classList.remove('disabled');
                menuNavigateNext.style.opacity = '1';
                menuNavigateNext.style.pointerEvents = 'auto';
            }} else {{
                menuNavigateNext.classList.add('disabled');
                menuNavigateNext.style.opacity = '0.5';
                menuNavigateNext.style.pointerEvents = 'none';
            }}
        }}
        
        if (menuNavigatePrev) {{
            if (hasFilters) {{
                menuNavigatePrev.classList.remove('disabled');
                menuNavigatePrev.style.opacity = '1';
                menuNavigatePrev.style.pointerEvents = 'auto';
            }} else {{
                menuNavigatePrev.classList.add('disabled');
                menuNavigatePrev.style.opacity = '0.5';
                menuNavigatePrev.style.pointerEvents = 'none';
            }}
        }}
    }};
    
    // Update menu state initially
    window.updateNavigationMenuState();
    
    console.log('[Export] Sticky header initialized with', themes.length, 'themes and', availableTags.length, 'tags');
}});
</script>
"""
        
        # Add the sticky header code to the head of the document
        if soup.head:
            # Parse the sticky header code as HTML and append to head
            sticky_soup = BeautifulSoup(sticky_header_code, 'html.parser')
            for element in sticky_soup:
                if element.name:  # Skip text nodes
                    soup.head.append(element)
        
        return str(soup)

    def manage_gemini_keys(self):
        """Open the Gemini API Keys management dialog"""
        try:
            dialog = GeminiAPIKeysDialog(self)
            dialog.exec()
        except Exception as e:
            print(f"Error opening Gemini API Keys dialog: {e}")
            QMessageBox.critical(self, "Error", f"Failed to open API Keys dialog: {str(e)}")

    def show_settings_dialog(self):
        """Open the Settings dialog (wrapper for web_view method)"""
        if hasattr(self, 'web_view') and self.web_view:
            self.web_view.show_settings_dialog()
        else:
            print("Warning: web_view not initialized yet")
            QMessageBox.warning(self, "Error", "Settings dialog not available yet.")

    def clear_input(self):
        self.input_text.clear()
        self.status_bar.showMessage('Input cleared', 2000)

    def clear_output(self):
        self.output_text.clear()
        self.web_view.setHtml('')
        self.status_bar.showMessage('Output cleared', 2000)

    def show_about_dialog(self):
        QMessageBox.information(
            self, 'About Transcript Manager',
            'Transcript Manager\nVersion 2.2\n\n'
            'This application converts plain text content with structured speech sections into a stylized HTML format '
            'and provides transcript cleaning and annotation capabilities.\n'
            'Developed with PyQt6 and BeautifulSoup.'
        )

    def show_keyboard_shortcuts(self):
        scene_shortcuts = '\n'.join(
            [f'{(i % 10) + 1 if i < 9 else 0} - {scene}' for i, scene in enumerate(self.web_view.scene_styles.keys())]
        )
        QMessageBox.information(
            self, 'Keyboard Shortcuts',
            f'Assign selected text to scenes using the following shortcuts:\n\n'
            f'{scene_shortcuts}\n\n'
            'Press the Delete key to remove highlight from selected text.\n\n'
            'Select text in the preview and press the corresponding number key.'
        )

    def save_annotations(self):
        file_name, _ = QFileDialog.getSaveFileName(
            self, "Save Annotations", "", "JSON Files (*.json);;All Files (*)"
        )
        if file_name:
            try:
                with open(file_name, 'w', encoding='utf-8') as file:
                    data = {
                        'annotations': self.web_view.annotations,
                        'scene_styles': self.web_view.scene_styles
                    }
                    json.dump(data, file, ensure_ascii=False, indent=4)
                QMessageBox.information(self, 'Success', f'Annotations saved to {file_name}')
                self.status_bar.showMessage(f'Annotations saved: {file_name}', 5000)
            except Exception as e:
                QMessageBox.critical(self, 'Error', f'Could not save annotations:\n{e}')

    def load_annotations(self):
        file_name, _ = QFileDialog.getOpenFileName(
            self, "Load Annotations", "", "JSON Files (*.json);;All Files (*)"
        )
        if file_name:
            try:
                with open(file_name, 'r', encoding='utf-8') as file:
                    data = json.load(file)
                    self.web_view.annotations = data.get('annotations', [])
                    self.web_view.scene_styles = data.get('scene_styles', {})
                self.apply_annotations()
                QMessageBox.information(self, 'Success', f'Annotations loaded from {file_name}')
                self.status_bar.showMessage(f'Annotations loaded: {file_name}', 5000)
            except Exception as e:
                QMessageBox.critical(self, 'Error', f'Could not load annotations:\n{e}')

    def apply_annotations(self):
        html_content = self.output_text.toPlainText()
        self.web_view.setHtml(html_content)
        for anno in self.web_view.annotations:
            annotation_id = anno.get('id')
            if not annotation_id:
                annotation_id = str(uuid.uuid4())
                anno['id'] = annotation_id
            self.web_view.highlight_text(anno['text'], anno['scene'], annotation_id)

    def update_annotations_view(self):
        # Update the annotations view when highlights are added or removed
        pass

    def view_annotations(self):
        self.show_annotations_dialog()

    def show_annotations_dialog(self):
        if not self.web_view.annotations:
            QMessageBox.information(self, 'Theme View', 'No content has been marked yet.')
            return

        dialog = QDialog(self)
        dialog.setWindowTitle('Theme View')
        dialog.resize(900, 700)
        # Remove modal flag to allow interaction with main window
        dialog.setWindowModality(Qt.WindowModality.NonModal)
    
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)

        tabs = QTabWidget()
        tabs.setStyleSheet("""
            QTabWidget::pane {
                border: 1px solid #e0e0e0;
                border-radius: 5px;
                background: white;
                padding: 10px;
            }
            QTabBar::tab {
                background: #f5f5f5;
                padding: 10px 15px;
                min-width: 100px;
                margin-right: 2px;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
            }
            QTabBar::tab:selected {
                background: white;
                border: 1px solid #e0e0e0;
                border-bottom: none;
            }
            QTabBar::tab:hover:!selected {
                background: #eeeeee;
            }
        """)

        scene_order = list(self.web_view.scene_styles.keys())
        scene_annotations = {scene: [] for scene in scene_order}

        for anno in self.web_view.annotations:
            scene = anno['scene']
            text = anno['text']
            used = anno.get('used', False)  # Get the used state from annotation
            if scene in scene_annotations:
                scene_annotations[scene].append((text, used))
            else:
                scene_annotations[scene] = [(text, used)]

        self.annotation_widgets = {}

        for scene in scene_order:
            tab = QWidget()
            tab_layout = QVBoxLayout(tab)
            tab_layout.setSpacing(10)
            tab_layout.setContentsMargins(10, 10, 10, 10)

            header = QLabel(scene)
            header.setStyleSheet("""
                QLabel {
                    font-size: 16px;
                    font-weight: bold;
                    color: #203740;
                    padding: 5px 0;
                }
            """)
            tab_layout.addWidget(header)

            list_widget = AnnotationListWidget()
            list_widget.setFont(QFont('Segoe UI', 12))

            texts = scene_annotations.get(scene, [])
            for text, used in texts:
                list_widget.add_item_with_checkbox(text, used, speech_title='')

            self.annotation_widgets[scene] = list_widget
            tab_layout.addWidget(list_widget)
            tabs.addTab(tab, scene)

        layout.addWidget(tabs)

        instructions = QLabel("Use checkboxes to mark text blocks as used")
        instructions.setStyleSheet("""
            QLabel {
                color: #666666;
                font-style: italic;
                padding: 10px;
                background: #f8f9fa;
                border-radius: 4px;
                border: 1px solid #e9ecef;
            }
        """)
        layout.addWidget(instructions)

        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | 
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.setStyleSheet("""
            QPushButton {
                padding: 8px 16px;
                min-width: 80px;
                border-radius: 4px;
                border: none;
                background-color: #203740;
                color: white;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
            QPushButton:pressed {
                background-color: #1A5E5C;
            }
        """)

        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)

        # Connect the annotation_deleted signal to update the script view
        self.web_view.annotation_deleted.connect(
            lambda deletion_info: self.update_script_view(deletion_info, dialog))
        
        # Show dialog non-modally
        dialog.show()

    def update_script_view(self, deletion_info_json):
        """Update the script view when an annotation is deleted"""
        try:
            deletion_info = json.loads(deletion_info_json)
            text = deletion_info['text']
            scene = deletion_info['scene']
            annotation_id = deletion_info['id']
        
            # Find the tab index for the scene
            for i in range(self.scene_tabs.count()):
                if self.scene_tabs.tabText(i) == scene:
                    list_widget = self.scene_tabs.widget(i)
                    if list_widget:
                        items_to_remove = []
                        for j in range(list_widget.count()):
                            item = list_widget.item(j)
                            item_widget = list_widget.itemWidget(item)
                            if item_widget:
                                label = item_widget.findChild(QLabel)
                                # Check if text matches and optionally verify annotation ID
                                if label and label.text().strip() == text.strip():
                                    items_to_remove.append(j)
                    
                        # Remove items in reverse order to maintain correct indices
                        for index in reversed(items_to_remove):
                            list_widget.takeItem(index)
                    
                        # If this was the last item in the scene, refresh the panel
                        if list_widget.count() == 0:
                            self.show_theme_view()
                    break

            # Update the script panel if it's visible
            if self.theme_view and self.theme_view.isVisible():
                self.update_theme_view()

        except json.JSONDecodeError:
            print(f"Error decoding deletion info: {deletion_info_json}")
        except KeyError as e:
            print(f"Missing key in deletion info: {e}")
        except Exception as e:
            print(f"Error updating script view: {e}")

    def update_annotations(self, dialog):
        new_annotations = []
        for scene, list_widget in self.annotation_widgets.items():
            for index in range(list_widget.count()):
                text = list_widget.item(index).text()
                annotation_id = next(
                    (anno['id'] for anno in self.web_view.annotations if anno['text'] == text),
                    str(uuid.uuid4())
                )
                new_annotations.append({
                    'id': annotation_id,
                    'text': text,
                    'scene': scene
                })

        self.web_view.annotations = new_annotations
        dialog.accept()


    def manage_scenes(self):
        dialog = QDialog(self)
        dialog.setWindowTitle('Manage Themes')
        dialog.resize(600, 500)

        main_layout = QVBoxLayout(dialog)
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(15, 15, 15, 15)

        # Create a group box for themes
        themes_group = QGroupBox("Themes")
        themes_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                font-size: 13px;
                border: 1px solid #ddd;
                border-radius: 6px;
                margin-top: 12px;
                background-color: transparent;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px;
            }
        """)
        group_layout = QVBoxLayout(themes_group)
        group_layout.setContentsMargins(10, 10, 10, 10)
        group_layout.setSpacing(10)

        # Scroll area for themes
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setStyleSheet("QScrollArea { border: none; background-color: transparent;; }")

        container_widget = QWidget()
        form_layout = QFormLayout(container_widget)
        form_layout.setSpacing(8)
        scroll_area.setWidget(container_widget)

        group_layout.addWidget(scroll_area)
        main_layout.addWidget(themes_group)

        # Store original scene names and order
        original_scenes = list(self.web_view.scene_styles.keys())
        scene_edits = []  # stores tuples of (scene_name, QLineEdit, row_number)

        def renumber_themes():
            """Update the labels for each theme row to reflect current numbering."""
            for i in range(form_layout.rowCount()):
                label_item = form_layout.itemAt(i, QFormLayout.ItemRole.LabelRole)
                if label_item:
                    label_widget = label_item.widget()
                    if label_widget and isinstance(label_widget, QLabel):
                        label_widget.setText(f"Theme {i+1}:")

        def add_scene_row(scene_name=''):
            if form_layout.rowCount() >= 12:
                QMessageBox.warning(dialog, "Limit Reached", "You can only have up to 12 themes.")
                return None

            # Create a horizontal layout for a single scene row
            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 0, 0, 0)
            row_layout.setSpacing(10)

            line_edit = QLineEdit(scene_name)
            line_edit.setMaxLength(40)
            line_edit.setMinimumWidth(200)
            line_edit.setPlaceholderText("Enter theme name (max 30 chars)...")
            line_edit.setToolTip("Specify a theme name (maximum 30 characters).")
            line_edit.setStyleSheet("""
                QLineEdit {
                    padding: 6px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-size: 13px;
                }
                QLineEdit:focus {
                    border-color: #2196F3;
                }
            """)

            # Add character count label
            char_count_label = QLabel(f"{len(scene_name)}/40")
            char_count_label.setStyleSheet("color: #666666; font-size: 11px;")

            # Update character count when text changes
            def update_char_count(text):
                char_count_label.setText(f"{len(text)}/40")
                if len(text) >= 30:
                    char_count_label.setStyleSheet("color: #d32f2f; font-size: 11px; font-weight: bold;")
                else:
                    char_count_label.setStyleSheet("color: #666666; font-size: 11px;")

            line_edit.textChanged.connect(update_char_count)

            row_layout.addWidget(line_edit, stretch=1)
            row_layout.addWidget(char_count_label)

            remove_button = QToolButton()
            remove_button.setText('🗙')
            remove_button.setToolTip("Remove this theme.")
            remove_button.setFixedSize(30, 30)
            remove_button.setStyleSheet("""
                QToolButton {
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    color: #666;
                    font-size: 14px;
                }
                QToolButton:hover {
                    background-color: #ffebee;
                    border-color: #f44336;
                    color: #f44336;
                }
            """)
            row_layout.addWidget(remove_button)

            label = QLabel(f"Theme {form_layout.rowCount() + 1}:")
            label.setStyleSheet("font-weight: normal; color: #444;")

            form_layout.addRow(label, row_widget)
            row_number = form_layout.rowCount() - 1
            scene_edits.append((scene_name, line_edit, row_number))

            def remove_this_scene():
                for i, (name, le, rnum) in enumerate(scene_edits):
                    if rnum == row_number:
                        scene_edits.pop(i)
                        form_layout.removeRow(rnum)
                        for j in range(i, len(scene_edits)):
                            scene_edits[j] = (scene_edits[j][0], scene_edits[j][1], scene_edits[j][2]-1)
                        renumber_themes()
                        break

            remove_button.clicked.connect(remove_this_scene)
            renumber_themes()
            return line_edit

        # Add existing scenes with their current names
        for scene in original_scenes:
            add_scene_row(scene)

        # Button to add new themes
        add_button_layout = QHBoxLayout()
        add_button = QPushButton('Add Theme')
        add_button.setToolTip("Add a new theme to the list (max 10).")
        add_button.setFixedWidth(100)
        add_button.setStyleSheet("""
            QPushButton {
                background-color: #203740;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: 500;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
            QPushButton:disabled {
                background-color: #BDBDBD;
            }
        """)
        add_button_layout.addWidget(add_button)
        add_button_layout.addStretch()
        group_layout.addLayout(add_button_layout)

        def add_scene():
            next_num = form_layout.rowCount() + 1
            add_scene_row(f"Theme {next_num}")

        add_button.clicked.connect(add_scene)

        def validate_scene_names():
            """Validate all scene names before accepting changes."""
            seen_names = set()
            for _, line_edit, _ in scene_edits:
                name = line_edit.text().strip()
                if not name:
                    QMessageBox.warning(
                        dialog,
                        "Invalid Theme Name",
                        "Theme names cannot be empty."
                    )
                    return False
                if name in seen_names:
                    QMessageBox.warning(
                        dialog,
                        "Duplicate Theme Name",
                        f"Theme name '{name}' is used multiple times. Each theme must have a unique name."
                    )
                    return False
                if len(name) > 40:
                    QMessageBox.warning(
                        dialog,
                        "Theme Name Too Long",
                        f"Theme name '{name}' exceeds 40 characters. Please shorten it."
                    )
                    return False
                seen_names.add(name)
            return True

        def on_accepted():
            if not validate_scene_names():
                return
        
            # Get new scene names (after any additions/removals)
            new_scene_names = [le.text().strip() for _, le, _ in scene_edits]

            # Create initial index-based mapping of old names to new names (row-wise)
            index_name_mapping = {}
            for i, old_name in enumerate(original_scenes):
                if i < len(new_scene_names):
                    index_name_mapping[old_name] = new_scene_names[i]

            # Create ordered backup of current annotations by timestamp
            backup_annotations = sorted(
                self.web_view.annotations,
                key=lambda x: (
                    x.get('timestamp', ''),
                    original_scenes.index(x.get('scene', None)) if x.get('scene', None) in original_scenes else float('inf'),
                    self.web_view.annotations.index(x)
                )
            )

            # Update scene_styles while preserving colors and order
            new_scene_styles = {}
            for new_name in new_scene_names:
                old_name = next((old for old, new in index_name_mapping.items() if new == new_name), None)
                if old_name and old_name in self.web_view.scene_styles:
                    # Use existing color for renamed scene
                    new_scene_styles[new_name] = self.web_view.scene_styles[old_name]
                else:
                    # Generate new color for new scene
                    color = self.generate_pastel_colors(1)[0]
                    new_scene_styles[new_name] = f'background-color: {color};'

            # Build a robust style-based mapping old_name -> new_name so renames persist across insertions
            try:
                old_style_to_name = {style: name for name, style in self.web_view.scene_styles.items()}
                new_style_to_name = {style: name for name, style in new_scene_styles.items()}
                style_name_mapping = {}
                for style, old_name in old_style_to_name.items():
                    new_name = new_style_to_name.get(style)
                    if new_name:
                        style_name_mapping[old_name] = new_name
                # Use style-based mapping; fallback to index mapping if empty
                self.scene_name_mapping = style_name_mapping if style_name_mapping else index_name_mapping
            except Exception as _e:
                print(f"DEBUG: style-based mapping failed, falling back to index mapping: {_e}")
                self.scene_name_mapping = index_name_mapping

            # Store the current timestamp for new annotations
            current_time = datetime.datetime.now().isoformat()

            # Update annotations while preserving order and all data
            updated_annotations = []
            default_scene = new_scene_names[0] if new_scene_names else ''

            # Process annotations in their original order
            for anno in backup_annotations:
                new_annotation = anno.copy()
                old_scene = anno.get('scene', None)  # Safely get 'scene'
                if old_scene in self.scene_name_mapping:
                    new_annotation['scene'] = self.scene_name_mapping[old_scene]
                else:
                    new_annotation['scene'] = default_scene

                # Remap secondary_scenes to reflect theme renames
                try:
                    sec = new_annotation.get('secondary_scenes', [])
                    if isinstance(sec, list):
                        # Map names using the same mapping as primary
                        mapped = [self.scene_name_mapping.get(s, s) for s in sec]
                        # Filter to valid scenes and remove duplicates while preserving order
                        valid_set = set(new_scene_names)
                        cleaned = []
                        seen = set()
                        for s in mapped:
                            if s in valid_set and s not in seen:
                                seen.add(s)
                                cleaned.append(s)
                        new_annotation['secondary_scenes'] = cleaned
                        # Sanitize to ensure primary is not duplicated in secondaries
                        if hasattr(self.web_view, '_sanitize_secondary_scenes'):
                            self.web_view._sanitize_secondary_scenes(new_annotation)
                except Exception as _e:
                    print(f"DEBUG: remapping secondary_scenes during theme rename failed: {_e}")

                # Ensure all required fields exist
                new_annotation['timestamp'] = new_annotation.get('timestamp', current_time)
                new_annotation['id'] = new_annotation.get('id', str(uuid.uuid4()))
                new_annotation['notes'] = new_annotation.get('notes', '')
                new_annotation['used'] = new_annotation.get('used', False)

                updated_annotations.append(new_annotation)

            # Update the web view with preserved order
            self.web_view.scene_styles = new_scene_styles
            self.web_view.annotations = updated_annotations

            # Update the HTML content
            self.web_view.page().toHtml(self.update_html_with_new_scenes)

            # Ensure live DOM reflects remapped secondary_scenes by emitting updates with the field included
            try:
                def _emit_secondary_sync():
                    mapping = getattr(self, 'scene_name_mapping', {}) or {}
                    valid_set = set(self.web_view.scene_styles.keys())
                    for a in self.web_view.annotations:
                        try:
                            sec = a.get('secondary_scenes', [])
                            if not isinstance(sec, list):
                                sec = []
                            # Remap using mapping as a final guard
                            remapped = [mapping.get(s, s) for s in sec]
                            # Filter/dedupe and drop primary
                            cleaned = []
                            seen = set()
                            primary = a.get('scene')
                            for s in remapped:
                                if s == primary:
                                    continue
                                if s in valid_set and s not in seen:
                                    seen.add(s)
                                    cleaned.append(s)
                            # Persist back to model
                            print(f"DEBUG[Apply Sync]: id={a.get('id')} primary='{primary}' old_sec={sec} remapped={remapped} cleaned={cleaned}")
                            a['secondary_scenes'] = cleaned
                            payload = {
                                'id': a.get('id'),
                                'text': a.get('text', ''),
                                'notes': a.get('notes', ''),
                                'notes_html': a.get('notes_html', ''),
                                'used': a.get('used', False),
                                'favorite': a.get('favorite', False),
                                'tags': a.get('tags', []),
                                'secondary_scenes': cleaned
                            }
                            print(f"DEBUG[Apply Sync]: emitting annotation_updated payload={payload}")
                            self.web_view.annotation_updated.emit(json.dumps(payload))
                        except Exception as _e:
                            print(f"DEBUG: emit annotation_updated for secondary sync failed: {_e}")
                QTimer.singleShot(100, _emit_secondary_sync)
            except Exception as _e:
                print(f"DEBUG: scheduling secondary_scenes sync failed: {_e}")

            # Force a complete refresh of the script panel
            if self.theme_view and self.theme_view.isVisible():
                # Store current state using a stable identifier
                current_tab_index = self.scene_tabs.currentIndex()
                if current_tab_index >= 0 and current_tab_index < self.scene_tabs.count():
                    current_tab_widget = self.scene_tabs.widget(current_tab_index)
                    current_tab_scene = getattr(current_tab_widget, 'scene_name', None)
                else:
                    current_tab_scene = None

                scroll_positions = {}
                selected_items = {}
                for i in range(self.scene_tabs.count()):
                    list_widget = self.scene_tabs.widget(i)
                    if hasattr(list_widget, 'count'):
                        scroll_positions[i] = list_widget.verticalScrollBar().value()
                        selected = []
                        for j in range(list_widget.count()):
                            item = list_widget.item(j)
                            if item.isSelected():
                                widget = list_widget.itemWidget(item)
                                if widget:
                                    label = widget.findChild(QLabel)
                                    notes_edit = widget.findChild(QLineEdit)
                                    item_id = item.data(Qt.ItemDataRole.UserRole)
                                    if label:
                                        selected.append({
                                            'text': label.text(),
                                            'notes': notes_edit.text() if notes_edit else '',
                                            'id': item_id
                                        })
                        selected_items[i] = selected

                # Update script panel
                self.update_theme_view()

                # Restore state after update
                QTimer.singleShot(100, lambda: self.restore_theme_view_state(
                    current_tab_scene, scroll_positions, selected_items
                ))

            QMessageBox.information(dialog, 'Success', 'Themes have been updated successfully.')
            dialog.accept()

        def on_rejected():
            dialog.reject()

        # Dialog buttons
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Cancel)
        buttons.setStyleSheet("""
            QPushButton {
                padding: 8px 16px;
                min-width: 50px;
                border-radius: 4px;
                border: none;
                background-color: #203740;
                color: white;
            }
            QPushButton:hover {
                background-color: #2C4952;
            }
        """)
        main_layout.addWidget(buttons)

        buttons.accepted.connect(on_accepted)
        buttons.rejected.connect(on_rejected)

        # Execute the dialog
        dialog.exec()

    def restore_theme_view_state(self, scroll_positions, selected_items, current_states):
        """Restore the theme view state after updates"""
        try:
            # print("\n=== DEBUG: Restoring Theme View State ===")
            # print(f"Scroll Positions: {scroll_positions}")
            # print(f"Selected Items: {selected_items}")
            # print(f"Current States: {current_states}")

            for tab_index in range(self.scene_tabs.count()):
                list_widget = self.scene_tabs.widget(tab_index)
                if list_widget is None:
                    print(f"=== DEBUG: Tab {tab_index} has no widget, skipping ===")
                    continue
                if not isinstance(list_widget, AnnotationListWidget):
                    print(f"=== DEBUG: Tab {tab_index} is not an AnnotationListWidget, skipping ===")
                    continue


                # Restore scroll position
                if tab_index in scroll_positions:
                    list_widget.verticalScrollBar().setValue(scroll_positions[tab_index])

                # Restore item states and selections
                if tab_index in current_states:
                    for state in current_states[tab_index]:
                        for i in range(list_widget.count()):
                            item = list_widget.item(i)
                            if not item:
                                print(f"=== DEBUG: Missing item at index {i} in tab {tab_index}, skipping ===")
                                continue
    
                            item_id = item.data(Qt.ItemDataRole.UserRole)
                            if not item_id:
                                print(f"=== DEBUG: Missing item ID in tab {tab_index}, skipping ===")
                                continue
    
                            if item_id == state.get('id'):
                                item_widget = list_widget.itemWidget(item)
                                if item_widget:
                                    # Restore notes safely
                                    notes_edit = item_widget.findChild(QLineEdit)
                                    if notes_edit and 'notes' in state:
                                        notes_edit.setText(state['notes'])

                                    # Restore selection state safely
                                    if state.get('selected'):
                                        item.setSelected(True)

            print("=== DEBUG: Theme View State Restored ===")

        except Exception as e:
            print(f"Error restoring theme view state: {e}")
            print("\n=== DEBUG: Exception Traceback ===")
            import traceback
            print(traceback.format_exc())

    def update_html_with_new_scenes(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')

        # Update existing highlighted spans
        sec_updated_count = 0
        for span in soup.find_all('span', attrs={'data-scene': True}):
            old_scene = span['data-scene']
            # Find new scene name or use first scene as fallback
            new_scene = next((new for old, new in self.scene_name_mapping.items() if old == old_scene), 
                            list(self.web_view.scene_styles.keys())[0])
            if old_scene != new_scene:
                print(f"DEBUG[HTML Remap]: data-scene '{old_scene}' -> '{new_scene}'")
            span['data-scene'] = new_scene
            span['style'] = self.web_view.scene_styles[new_scene]

            # Also remap secondary scenes on the span if present
            try:
                if span.has_attr('data-secondary-scenes'):
                    raw = span['data-secondary-scenes']
                    sec_list = []
                    try:
                        sec_list = json.loads(raw) if raw else []
                    except Exception:
                        # Fall back to parsing a comma-separated string
                        if isinstance(raw, str) and raw.strip():
                            sec_list = [s.strip() for s in raw.strip('[]').split(',') if s.strip().strip('"\'')]  # best-effort
                    # Map using scene_name_mapping
                    mapped = [self.scene_name_mapping.get(s, s) for s in sec_list]
                    # Filter to valid new scene names and dedupe
                    valid_set = set(self.web_view.scene_styles.keys())
                    cleaned = []
                    seen = set()
                    for s in mapped:
                        if s in valid_set and s not in seen:
                            seen.add(s)
                            cleaned.append(s)
                    # Remove the span's primary scene from secondaries if present
                    cleaned = [s for s in cleaned if s != new_scene]
                    if sec_list != cleaned:
                        print(f"DEBUG[HTML Remap]: span secondary {sec_list} -> {cleaned}")
                    span['data-secondary-scenes'] = json.dumps(cleaned)
                    sec_updated_count += 1
            except Exception as _e:
                print(f"DEBUG: remapping data-secondary-scenes in HTML failed: {_e}")

        # Additionally, remap any spans that might lack data-scene but have data-secondary-scenes
        try:
            for span in soup.find_all('span', attrs={'data-secondary-scenes': True}):
                # If processed above, skip
                if span.has_attr('data-scene'):
                    continue
                raw = span.get('data-secondary-scenes', '')
                sec_list = []
                try:
                    sec_list = json.loads(raw) if raw else []
                except Exception:
                    txt = (raw or '').strip()
                    if txt.startswith('[') and txt.endswith(']'):
                        parts = [p.strip().strip('"\'') for p in txt[1:-1].split(',') if p.strip()]
                        sec_list = parts
                mapped = [self.scene_name_mapping.get(s, s) for s in sec_list]
                valid_set = set(self.web_view.scene_styles.keys())
                cleaned = []
                seen = set()
                for s in mapped:
                    if s in valid_set and s not in seen:
                        seen.add(s)
                        cleaned.append(s)
                if sec_list != cleaned:
                    print(f"DEBUG[HTML Remap][no-scene]: {sec_list} -> {cleaned}")
                span['data-secondary-scenes'] = json.dumps(cleaned)
                sec_updated_count += 1
        except Exception as _e:
            print(f"DEBUG: secondary-only remap failed: {_e}")

        print(f"DEBUG[HTML Remap]: Completed. Updated secondary on {sec_updated_count} spans.")

        # Update color key
        color_key_div = soup.find('div', {'class': 'color-key'})
        if color_key_div:
            color_key_div.clear()
            
            for scene, style in self.web_view.scene_styles.items():
                key_item_div = soup.new_tag('div', attrs={'class': 'key-item'})
                color_box_span = soup.new_tag('span', attrs={'class': 'color-box'})
                
                match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', style)
                bg_color = match.group(1) if match else '#FFFFFF'
                color_box_span['style'] = f'background-color: {bg_color};'
                
                key_item_div.append(color_box_span)
                key_item_div.append(' ' + scene)
                color_key_div.append(key_item_div)

        # Update the web view with the modified HTML
        self.web_view.setHtml(str(soup))

        # Reapply all annotations to ensure consistency
        for anno in self.web_view.annotations:
            self.web_view.highlight_text(anno['text'], anno['scene'], anno['id'])

    def rebuild_color_key(self):
        # Extract current HTML
        self.web_view.page().toHtml(self.update_color_key)

    def update_color_key(self, html_content):
        # Parse HTML and update color key
        soup = BeautifulSoup(html_content, 'html.parser')

        # Remove old color key
        color_key_div = soup.find('div', {'class': 'color-key'})
        if color_key_div:
            color_key_div.decompose()

        # Recreate color key
        content_div = soup.find('div', {'class': 'content'})
        if content_div:
            new_color_key_div = soup.new_tag('div', attrs={'class': 'color-key'})
            content_div.insert(1, new_color_key_div)
        else:
            body_tag = soup.body
            new_color_key_div = soup.new_tag('div', attrs={'class': 'color-key'})
            body_tag.insert(1, new_color_key_div)

        for scene, style in self.web_view.scene_styles.items():
            key_item_div = soup.new_tag('div', attrs={'class': 'key-item'})
            color_box_span = soup.new_tag('span', attrs={'class': 'color-box'})
            match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', style)
            if match:
                bg_color = match.group(1)
            else:
                bg_color = '#FFFFFF'
            color_box_span.attrs['style'] = f'background-color: {bg_color};'
            key_item_div.append(color_box_span)
            scene_text = soup.new_string(' ' + scene)
            key_item_div.append(scene_text)
            new_color_key_div.append(key_item_div)

        # Update the web view
        self.web_view.setHtml(str(soup))

        # Reapply annotations
        for anno in self.web_view.annotations:
            self.web_view.highlight_text(anno['text'], anno['scene'], anno['id'])


    def change_scene_color(self, scene):
        """Handle color change for a scene"""
        try:
            current_color = self.get_color_from_style(self.web_view.scene_styles[scene])
            color = QColorDialog.getColor(QColor(current_color), self, f"Select Color for {scene}")
        
            if color.isValid():
                color_hex = color.name()
                # Update scene style immediately
                self.web_view.scene_styles[scene] = f'background-color: {color_hex};'
            
                # Update the button color in the color key panel
                for i in range(self.color_key_form.rowCount()):
                    label = self.color_key_form.itemAt(i, QFormLayout.ItemRole.LabelRole).widget()
                    if label and label.text().startswith(scene):
                        button = self.color_key_form.itemAt(i, QFormLayout.ItemRole.FieldRole).widget()
                        if button:
                            button.setStyleSheet(f"""
                                QPushButton {{
                                    background-color: {color_hex};
                                    min-width: 60px;
                                    min-height: 30px;
                                    border: 1px solid #ccc;
                                    border-radius: 4px;
                                }}
                            """)
            
                # Update all highlights in the web view
                self.web_view.page().toHtml(self.update_html_with_colors)
            
                # Mark the window as having unsaved changes
                if self.current_session_file and not self.windowTitle().startswith('*'):
                    self.setWindowTitle(f'*{self.windowTitle()}')
            
        except Exception as e:
            print(f"Error in change_scene_color: {e}")
            self.status_bar.showMessage(f"Error changing color: {str(e)}", 5000)
            
    def update_html_with_colors(self, html_content):
        """Update the HTML content with new colors while preserving scroll position"""
        # Get current scroll position first
        self.web_view.page().runJavaScript(
            "window.pageYOffset",
            lambda pos: self._update_html_with_colors_and_scroll(html_content, pos)
        )

    def _update_html_with_colors_and_scroll(self, html_content, scroll_pos):
        """Internal method to update colors and restore scroll position"""
        soup = BeautifulSoup(html_content, 'html.parser')

        # Batch update existing highlighted spans
        for span in soup.find_all('span', attrs={'data-scene': True}):
            scene = span['data-scene']
            if scene in self.web_view.scene_styles:
                span['style'] = self.web_view.scene_styles[scene]

        # Batch update color key
        color_key_div = soup.find('div', {'class': 'color-key'})
        if color_key_div:
            color_key_div.clear()
    
            for i, (scene, style) in enumerate(self.web_view.scene_styles.items()):
                key_item_div = soup.new_tag('div', attrs={'class': 'key-item'})
                color_box_span = soup.new_tag('span', attrs={'class': 'color-box'})
        
                match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', style)
                bg_color = match.group(1) if match else '#FFFFFF'
                color_box_span['style'] = f'background-color: {bg_color};'
        
                key_item_div.append(color_box_span)
                hotkey = str((i % 10) + 1 if i < 9 else 0)
                key_item_div.append(f' {scene}')
                color_key_div.append(key_item_div)

        # Convert the modified BeautifulSoup object back to a string
        updated_html = str(soup)

        # Update the web view with the modified HTML in a single operation
        self.web_view.setHtml(updated_html)

        # Restore scroll position after content loads and reapply annotations
        def restore_state():
            default_scene = 'Unknown'

            self.web_view.page().runJavaScript(f"window.scrollTo(0, {scroll_pos})")

            for anno in self.web_view.annotations:
                text = anno.get('text', '')
                scene = anno.get('scene', default_scene)
                anno_id = anno.get('id', None)

                if 'scene' not in anno:
                    print(f"Info: Annotation with text '{text}' is missing 'scene' key. Assigned default_scene='{default_scene}'.")

                if anno_id is not None:
                    self.web_view.highlight_text(text, scene, anno_id)
                else:
                    print(f"Warning: Annotation with text '{text}' is missing an 'id' and will be skipped.")

        # Use QTimer to ensure the HTML is fully loaded before restoring state
        QTimer.singleShot(100, restore_state)

            
    def get_color_from_style(self, style):
        match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', style)
        if match:
            return match.group(1)
        return '#FFFFFF'

    def apply_color_changes(self):
        if self.updated_styles != self.web_view.scene_styles:
            self.web_view.scene_styles = self.updated_styles.copy()
            self.web_view.page().toHtml(self.update_html_with_colors)
            self.status_bar.showMessage('Colors updated successfully.', 5000)

class BuildStylizedTranscript(QThread):
    conversion_done = pyqtSignal(tuple)

    def __init__(self, raw_text, title, scene_styles, transcript_type='video'):
        """
        transcript_type can be:
            'video' -> Use original logic (with dividers for normal headers)
            'book'  -> Skip dividers between normal headers and don't break whitespace lines between normal headers
        """
        super().__init__()
        self.raw_text = raw_text
        self.title = title
        self.scene_styles = scene_styles
        self.temp_dir = None  # Add this attribute
        self.transcript_type = transcript_type  # 'video' (default) or 'book'

    def run(self):
        try:
            speeches = self.extract_speeches(self.raw_text)
            if not speeches:
                raise ValueError('No headers found in the input text. Use **placeholder** or [[placeholder]] for headers.')
            stylized_html = self.build_stylized_html(speeches)
            self.conversion_done.emit((True, stylized_html))
        except Exception as e:
            self.conversion_done.emit((False, str(e)))

    def extract_speeches(self, text):
        """
        Detects two types of headers:
          1) Normal headers: **Some Header**
          2) Main headers:   [[Main Header]]
    
        Returns list of speech dictionaries with structure:
        {
            'type': 'main' or 'normal',
            'title': string,
            'content': list of strings
        }
        """
        lines = text.splitlines()
        speeches = []
        current_speech = None
        pending_empty_line = False
    
        # Common separators to clean up
        separators = ['--', '—', '.', '-', ':', ';']

        for i, line in enumerate(lines):
            line = line.rstrip('\r\n')

            # 1) Check for MAIN headers with pattern [[Some Main Title]]
            if line.startswith('[[') and ']]' in line[2:]:
                if current_speech:
                    speeches.append(current_speech)
                    current_speech = None

                main_header_end = line[2:].find(']]') + 2
                main_header_content = line[2:main_header_end].strip('[] ').strip()
                speeches.append({
                    'type': 'main',
                    'title': main_header_content,
                    'content': []
                })

            # 2) Check for NORMAL headers with pattern **Some Header**
            elif line.startswith('**') and '**' in line[2:]:
                header_end = line[2:].find('**') + 2
                header_content = line[2:header_end].strip()
                remaining_text = line[header_end + 2:].strip()

                # Clean up common separators at start of remaining text
                while any(remaining_text.startswith(sep) for sep in separators):
                    for sep in separators:
                        if remaining_text.startswith(sep):
                            remaining_text = remaining_text[len(sep):].strip()
                            break

                if current_speech:
                    speeches.append(current_speech)

                current_speech = {
                    'type': 'normal',
                    'title': header_content,
                    'content': []
                }

                if remaining_text:
                    current_speech['content'].append(remaining_text)

            # Handle regular content lines
            else:
                if current_speech:
                    if not line.strip():  # Empty line
                        pending_empty_line = True
                    else:
                        if pending_empty_line:
                            current_speech['content'].append('')  # Preserve empty line for paragraph break
                            pending_empty_line = False
                        current_speech['content'].append(line)

        # Don't forget the last speech if exists
        if current_speech:
            speeches.append(current_speech)

        return speeches

    def build_stylized_html(self, speeches):
        # Get absolute paths for bookmark images
        app_dir = os.path.dirname(os.path.abspath(__file__))
        bookmark_path = os.path.join(app_dir, 'Img', 'bookmark.png')
        bookmark_filled_path = os.path.join(app_dir, 'Img', 'bookmark-filled.png')
        
        # Convert to file:// URLs for web view
        from PyQt6.QtCore import QUrl
        import urllib.parse
        
        # Create proper file URLs with percent encoding for special characters
        bookmark_url = QUrl.fromLocalFile(bookmark_path).toString()
        bookmark_filled_url = QUrl.fromLocalFile(bookmark_filled_path).toString()
        
        # Ensure URLs are properly encoded for spaces and special characters
        if ' ' in bookmark_url:
            bookmark_url = bookmark_url.replace(' ', '%20')
        if ' ' in bookmark_filled_url:
            bookmark_filled_url = bookmark_filled_url.replace(' ', '%20')
        
        html_doc = BeautifulSoup(features='html.parser')
        doctype = '<!DOCTYPE html>'
        html_tag = html_doc.new_tag('html', lang='en')
        html_doc.append(html_tag)

        head_tag = html_doc.new_tag('head')
        html_tag.append(head_tag)

        meta_charset = html_doc.new_tag('meta', charset='UTF-8')
        meta_viewport = html_doc.new_tag(
            'meta', 
            attrs={'name': 'viewport', 'content': 'width=device-width, initial-scale=1.0'}
        )
        head_tag.append(meta_charset)
        head_tag.append(meta_viewport)

        title_tag = html_doc.new_tag('title')
        title_tag.string = self.title
        head_tag.append(title_tag)

        style_tag = html_doc.new_tag('style')
        style_tag.string = self.get_css_styles()
        head_tag.append(style_tag)

        # First add a script to detect environment
        detect_script = html_doc.new_tag('script', type='text/javascript')
        detect_script.string = '''
            window.isQtEnvironment = false;
            try {
                window.isQtEnvironment = (typeof qt !== 'undefined' && qt.webChannelTransport);
            } catch(e) {
                console.log("Not running in Qt environment");
            }
        '''
        head_tag.append(detect_script)

        # Then conditionally load QWebChannel only in Qt environment
        conditional_script = html_doc.new_tag('script', type='text/javascript')
        conditional_script.string = '''
            // Conditionally load QWebChannel only if we're in a Qt environment
            try {
                if (typeof qt !== 'undefined' && qt.webChannelTransport) {
                    var qwebchannelScript = document.createElement('script');
                    qwebchannelScript.src = 'qrc:///qtwebchannel/qwebchannel.js';
                    document.head.appendChild(qwebchannelScript);
                }
            } catch(e) {
                console.warn("Not running in Qt environment");
            }
        '''
        head_tag.append(conditional_script)

        body_tag = html_doc.new_tag('body')
        if self.transcript_type == 'book':
            body_tag['class'] = 'book-transcript'
        else:
            body_tag['class'] = 'video-transcript'
        html_tag.append(body_tag)

        menu_toggle = html_doc.new_tag(
            'button', 
            attrs={'class': 'menu-toggle', 'aria-label': 'Toggle navigation'}
        )
        menu_toggle.string = 'Nav'
        body_tag.append(menu_toggle)

        # Sidebar structure
        sidebar_div = html_doc.new_tag('div', attrs={'class': 'sidebar'})
        sticky_header = html_doc.new_tag('div', attrs={'class': 'sidebar-sticky-header'})

        # Navigation title
        header_title = html_doc.new_tag('div', attrs={'class': 'sidebar-title'})
        header_title.string = 'Navigation'
        sticky_header.append(header_title)

        # Progress container
        progress_container = html_doc.new_tag('div', attrs={'class': 'progress-container'})
        progress_info = html_doc.new_tag('div', attrs={'class': 'progress-info'})
        progress_text = html_doc.new_tag('span', attrs={'class': 'progress-text'})
        progress_text.string = 'Reading Progress'
        progress_percentage = html_doc.new_tag('span', attrs={'class': 'progress-percentage'})
        progress_percentage.string = '0%'
        progress_info.append(progress_text)
        progress_info.append(progress_percentage)
        progress_container.append(progress_info)

        # Progress bar
        progress_bar = html_doc.new_tag('div', attrs={'class': 'progress-bar'})
        progress_fill = html_doc.new_tag('div', attrs={'class': 'progress-fill'})
        progress_bar.append(progress_fill)
        progress_container.append(progress_bar)
        sticky_header.append(progress_container)

        # Only create top nav if there are enough headers
        header_count = len([s for s in speeches if s['type'] != 'main']) + len([s for s in speeches if s['type'] == 'main'])

        if header_count >= 5:
            # Create a container for both buttons
            top_nav_container = html_doc.new_tag('div', attrs={'class': 'top-nav-container'})
    
            # Back to Top button (half-width)
            top_nav_item = html_doc.new_tag('div', attrs={'class': 'nav-item-top'})
            top_nav_link = html_doc.new_tag(
                'a',
                attrs={
                    'class': 'nav-link nav-link-top',
                    'href': '#top'
                }
            )
            top_nav_link.string = 'Top'
            top_nav_item.append(top_nav_link)
            top_nav_container.append(top_nav_item)
    
            # Table of Contents button (always present)
            toc_nav_item = html_doc.new_tag('div', attrs={'class': 'nav-item-top'})
            toc_nav_link = html_doc.new_tag(
                'a',
                attrs={
                    'class': 'nav-link nav-link-toc',
                    'href': '#',
                    'id': 'toc-button'
                }
            )
            toc_nav_link.string = 'Contents'
            toc_nav_item.append(toc_nav_link)
            top_nav_container.append(toc_nav_item)
    
            sticky_header.append(top_nav_container)

        sidebar_div.append(sticky_header)

        nav_container = html_doc.new_tag('div', attrs={'class': 'nav-container'})
        nav_list = html_doc.new_tag('ul', attrs={'class': 'nav-list'})
        nav_container.append(nav_list)
        sidebar_div.append(nav_container)

        body_tag.append(sidebar_div)

        content_div = html_doc.new_tag('main', attrs={'class': 'content'})
        body_tag.append(content_div)

        # Create the TOC modal container
        toc_modal = html_doc.new_tag('div', attrs={'class': 'toc-modal', 'id': 'toc-modal'})
        toc_modal_content = html_doc.new_tag('div', attrs={'class': 'toc-modal-content'})

        # Add header
        toc_header = html_doc.new_tag('div', attrs={'class': 'toc-header'})
        toc_title = html_doc.new_tag('h3')
        toc_title.string = 'Table of Contents'
        toc_close = html_doc.new_tag('span', attrs={'class': 'toc-close'})
        toc_close.string = '×'
        toc_header.append(toc_title)
        toc_header.append(toc_close)
        toc_modal_content.append(toc_header)

        # Add search bar
        search_container = html_doc.new_tag('div', attrs={'class': 'toc-search-container'})
        search_input = html_doc.new_tag('input', attrs={
            'type': 'text',
            'id': 'toc-search',
            'class': 'toc-search-input',
            'placeholder': 'Search content...',
            'autocomplete': 'off'
        })
        search_icon = html_doc.new_tag('span', attrs={'class': 'toc-search-icon'})
        search_icon.string = '🔍'
        # search_container.append(search_input)
        # search_container.append(search_icon)
        # search_results = html_doc.new_tag('div', attrs={'id': 'toc-search-results', 'class': 'toc-search-results'})
        # search_container.append(search_results)
        # toc_modal_content.append(search_container)

        # Create two-column layout
        toc_grid = html_doc.new_tag('div', attrs={'class': 'toc-grid'})

        # Create 2 columns
        toc_columns = []
        for i in range(2):
            column = html_doc.new_tag('div', attrs={'class': 'toc-column'})
            toc_columns.append(column)
            toc_grid.append(column)

        # Add navigation items to grid in horizontal order
        # Replace the entire TOC item creation and distribution section with this code

        # Add navigation items to grid in chronological order
        for idx, speech in enumerate(speeches):
            speech_id = f'speech-{idx}'

            # Truncate title to 50 characters if needed
            title = speech['title']
            if len(title) > 43:
                title = title[:40] + '...'

            # Create appropriate item based on type
            if speech['type'] == 'main':
                # Create main header with distinctive styling
                toc_item = html_doc.new_tag('a', attrs={
                    'class': 'toc-item toc-item-main',  # Set both classes directly
                    'href': f'#{speech_id}',
                    'data-speech-id': speech_id,
                    'data-type': 'main',  # Add a data attribute for debugging
                    'title': speech['title']  # Full title as tooltip
                })
                # Add a square symbol prefix
                main_label = html_doc.new_tag('span', attrs={'class': 'toc-main-label'})
                main_label.string = '■ '  # Square symbol prefix
                toc_item.append(main_label)
                toc_item.append(title)
            else:
                # Create normal item
                toc_item = html_doc.new_tag('a', attrs={
                    'class': 'toc-item toc-item-normal',  # Set both classes directly
                    'href': f'#{speech_id}',
                    'data-speech-id': speech_id,
                    'data-type': 'normal',  # Add a data attribute for debugging
                    'title': speech['title']  # Full title as tooltip
                })
                toc_item.string = title

            # Calculate chronological distribution
            total_items = len(speeches)
            items_in_first_column = (total_items + 1) // 2  # Round up for first column

            # Determine which column this item belongs to
            column_idx = 0 if idx < items_in_first_column else 1

            # Add to appropriate column
            toc_columns[column_idx].append(toc_item)

        toc_modal_content.append(toc_grid)
        toc_modal.append(toc_modal_content)
        body_tag.append(toc_modal)

        # When creating the bookmark image (using absolute path)
        bookmark_img = html_doc.new_tag('img', 
            attrs={
                'src': bookmark_url,
                'class': 'bookmark-icon',
                'data-bookmarked': 'false'
            }
        )

        h1_tag = html_doc.new_tag('h1', attrs={'class': 'page-title', 'id': 'top'})
        h1_tag.string = self.title
        content_div.append(h1_tag)

        color_key_div = html_doc.new_tag('div', attrs={'class': 'color-key'})
        content_div.append(color_key_div)
        for scene, style in self.scene_styles.items():
            key_item_div = html_doc.new_tag('div', attrs={'class': 'key-item'})
            color_box_span = html_doc.new_tag('span', attrs={'class': 'color-box'})
            match = re.search(r'background-color:\s*(#[A-Fa-f0-9]{6}|[a-zA-Z]+);', style)
            if match:
                bg_color = match.group(1)
            else:
                bg_color = '#FFFFFF'
            color_box_span.attrs['style'] = f'background-color: {bg_color};'
            key_item_div.append(color_box_span)
            key_item_div.append(' ' + scene)
            color_key_div.append(key_item_div)

        for idx, speech in enumerate(speeches):
            speech_id = f'speech-{idx}'

            nav_item_classes = "nav-item"
            nav_link_classes = "nav-link"
            if speech['type'] == 'main':
                nav_item_classes += " nav-item-main"
                nav_link_classes += " nav-link-main"

            nav_item = html_doc.new_tag('li', attrs={'class': nav_item_classes})
            nav_link = html_doc.new_tag(
                'a', 
                attrs={
                    'class': nav_link_classes,
                    'href': f'#{speech_id}',
                    'data-speech-id': speech_id
                }
            )
            nav_link.string = speech['title']
            nav_item.append(nav_link)
            nav_list.append(nav_item)

            if speech['type'] == 'main':
                main_header_div = html_doc.new_tag('div', attrs={'class': 'main-header-section'})
                main_header_div['id'] = speech_id
                h2_main = html_doc.new_tag('h2', attrs={'class': 'main-header'})
                h2_main.string = speech['title']
                main_header_div.append(h2_main)
                content_div.append(main_header_div)
            else:
                speech_article = html_doc.new_tag('article', attrs={'class': 'speech'})
                content_div.append(speech_article)

                # Add header container
                header_container = html_doc.new_tag('div', attrs={'class': 'speech-header'})
    
                # Add checkbox
                checkbox = html_doc.new_tag('input', attrs={
                    'type': 'checkbox',
                    'class': 'speech-checkbox',
                    'data-speech-id': speech_id
                })
    
                header_container.append(checkbox)

                # Add title
                h2_tag = html_doc.new_tag(
                    'h2', 
                    attrs={'class': 'speech-title', 'id': speech_id}
                )
                h2_tag.string = speech['title']
                header_container.append(h2_tag)

                # Add bookmark container and image (using absolute path)
                bookmark_container = html_doc.new_tag('div', attrs={'class': 'bookmark-container'})
                bookmark_img = html_doc.new_tag('img', 
                    attrs={
                        'src': bookmark_url,
                        'class': 'bookmark-icon',
                        'data-speech-id': speech_id,
                        'data-bookmarked': 'false'
                    }
                )
                bookmark_container.append(bookmark_img)
                header_container.append(bookmark_container)

                speech_article.append(header_container)

                speech_content = html_doc.new_tag('div', attrs={'class': 'speech-content'})
                speech_article.append(speech_content)

                if self.transcript_type == 'video':
                    # Create single paragraph for all content
                    p_tag = html_doc.new_tag('p')

                    for i, line in enumerate(speech['content']):
                        if i > 0:  # Not first line
                            if not line.strip():  # If empty line
                                p_tag.append('\r\n')  # Double newline for paragraph break
                            else:
                                p_tag.append('\r\n')  # Single newline for line break

                        # Only append the line if it's not empty
                        if line.strip():
                            # Process superscript notation with caret symbols (^1^)
                            parts = re.split(r'(\^\d+\^|\^[a-z]\^)', line)
                            for part in parts:
                                if re.match(r'^\^(\d+|[a-z])\^$', part):
                                    # This is a superscript - extract the number/letter
                                    sup_content = part.strip('^')
                                    sup_tag = html_doc.new_tag('sup')
                                    sup_tag.string = sup_content
                                    p_tag.append(sup_tag)
                                else:
                                    # Regular text
                                    p_tag.append(part)

                    # Add the style to preserve whitespace
                    p_tag['style'] = 'white-space: pre-wrap; white-space-collapse: preserve;'
                    speech_content.append(p_tag)

                else:  # book type
                    # 1) Remove leading empty lines so no gap appears immediately after the header.
                    while speech['content'] and not speech['content'][0].strip():
                        speech['content'].pop(0)

                    # Create single paragraph for all content
                    p_tag = html_doc.new_tag('p')

                    for i, line in enumerate(speech['content']):
                        if i > 0:  # Not first line
                            if not line.strip():  # If empty line
                                p_tag.append('\r\n')  # Double newline for paragraph break
                            else:
                                p_tag.append('\r\n')  # Single newline for line break

                        # Only append the line if it's not empty
                        if line.strip():
                            # Process superscript notation with caret symbols (^1^)
                            parts = re.split(r'(\^\d+\^|\^[a-z]\^)', line)
                            for part in parts:
                                if re.match(r'^\^(\d+|[a-z])\^$', part):
                                    # This is a superscript - extract the number/letter
                                    sup_content = part.strip('^')
                                    sup_tag = html_doc.new_tag('sup')
                                    sup_tag.string = sup_content
                                    p_tag.append(sup_tag)
                                else:
                                    # Regular text
                                    p_tag.append(part)

                    # Add the style to preserve whitespace
                    p_tag['style'] = 'white-space: pre-wrap; white-space-collapse: preserve;'
                    speech_content.append(p_tag)

                # Clean up trailing <br> tags for video type only
                if self.transcript_type == 'video':
                    for p in speech_content.find_all('p'):
                        if p.contents and p.contents[-1].name == 'br':
                            p.contents[-1].extract()
    
                    # Add dividers between normal sections for video type
                    if idx < len(speeches) - 1 and speeches[idx+1]['type'] == 'normal':
                        divider = html_doc.new_tag('div', attrs={'class': 'divider'})
                        divider_icon = html_doc.new_tag('span', attrs={'class': 'divider-icon'})
                        divider_icon.string = '✧'
                        divider.append(divider_icon)
                        content_div.append(divider)

        script_tag = html_doc.new_tag('script', type='text/javascript')
        #Replace the existing script_content in your build_stylized_html method with this fixed version:

        # Use JSON encoding for proper escaping
        import json
        
        # Debug output
        print(f"[DEBUG] Bookmark URL: {bookmark_url}")
        print(f"[DEBUG] Bookmark Filled URL: {bookmark_filled_url}")
        print(f"[DEBUG] JSON encoded: {json.dumps(bookmark_url)}")
        
        script_content = '''
            // Variables to store bookmark image paths (set at generation time)
            window.bookmarkImagePath = BOOKMARK_PATH_PLACEHOLDER;
            window.bookmarkFilledImagePath = BOOKMARK_FILLED_PATH_PLACEHOLDER;
            console.log('Bookmark paths set:', window.bookmarkImagePath, window.bookmarkFilledImagePath);
            

            // Check if running in Qt environment or standalone browser
            try {
                if (typeof qt !== 'undefined' && qt.webChannelTransport) {
                    // We're in Qt - initialize QWebChannel
                    new QWebChannel(qt.webChannelTransport, function(channel) {
                        window.jsHandler = channel.objects.jsHandler;
                        console.log("Qt WebChannel initialized successfully");
                    });
                } else {
                    // We're in a standalone browser - create mock handler
                    console.log("Running in standalone browser - creating mock jsHandler");
                    window.jsHandler = {
                        bookmarkToggledFromJs: function(isBookmarked) { 
                            console.log("Bookmark toggled:", isBookmarked);
                        },
                        checkboxToggledFromJs: function(isChecked) {
                            console.log("Checkbox toggled:", isChecked);
                        },
                        requestAnnotationNavigation: function(annotationId, scene) {
                            console.log("Annotation navigation requested to:", annotationId, scene);
                        },
                        requestAiQuery: function(selectedText, title) {
                            console.log("AI query requested:", selectedText, title);
                        }
                    };
                }
            } catch (e) {
                console.warn("QWebChannel initialization failed, creating mock handler:", e);
                // Fallback for any errors
                window.jsHandler = {
                    bookmarkToggledFromJs: function() { console.log("Mock bookmark toggle"); },
                    checkboxToggledFromJs: function() { console.log("Mock checkbox toggle"); },
                    requestAnnotationNavigation: function() { console.log("Mock navigation request"); },
                    requestAiQuery: function() { console.log("Mock AI query request"); }
                };
            }

            // Handle bookmark clicks
            console.log('Registering bookmark click handler...');
            document.addEventListener('click', (e) => {
                console.log('Click detected on:', e.target);
                if (e.target.classList.contains('bookmark-icon')) {
                    console.log('Bookmark icon clicked!');
                    const bookmarkIcon = e.target;
                    const isBookmarked = bookmarkIcon.getAttribute('data-bookmarked') === 'true';
                    const speechId = bookmarkIcon.dataset.speechId;
                    
                    console.log('Bookmark state:', isBookmarked, 'Speech ID:', speechId);
                    console.log('Image paths:', window.bookmarkImagePath, window.bookmarkFilledImagePath);

                    if (isBookmarked) {
                        // Use the window variable instead of hardcoded path
                        bookmarkIcon.src = window.bookmarkImagePath || 'Img/bookmark.png';
                        bookmarkIcon.setAttribute('data-bookmarked', 'false');
                    } else {
                        // Use the window variable instead of hardcoded path
                        bookmarkIcon.src = window.bookmarkFilledImagePath || 'Img/bookmark-filled.png';
                        bookmarkIcon.setAttribute('data-bookmarked', 'true');
                    }

                    if (window.jsHandler && window.jsHandler.bookmarkToggledFromJs) {
                        window.jsHandler.bookmarkToggledFromJs(!isBookmarked);
                    }
                }
            });

            const initializeBookmarks = () => {
                console.log('Initializing bookmarks...');
                const bookmarkIcons = document.querySelectorAll('.bookmark-icon');
                console.log('Found bookmark icons:', bookmarkIcons.length);
                bookmarkIcons.forEach(icon => {
                    const isBookmarked = icon.getAttribute('data-bookmarked') === 'true';
                    icon.src = isBookmarked ? 
                        (window.bookmarkFilledImagePath || 'Img/bookmark-filled.png') : 
                        (window.bookmarkImagePath || 'Img/bookmark.png');
                });
            };

            function updateProgress() {
                const checkboxes = document.querySelectorAll('.speech-checkbox');
                const normalCheckboxes = Array.from(checkboxes);
                const total = normalCheckboxes.length;
                const completed = normalCheckboxes.filter(checkbox => checkbox.checked).length;
                const percentage = total === 0 ? 0 : Math.round((completed / total) * 100);

                const percentageEl = document.querySelector('.progress-percentage');
                const progressFill = document.querySelector('.progress-fill');
                const progressBar = document.querySelector('.progress-bar');

                if (percentageEl) percentageEl.textContent = `${percentage}%`;

                if (progressFill) {
                    progressFill.style.width = `${percentage}%`;
                    progressFill.style.backgroundColor = percentage >= 100 ? 'var(--success-color)' : 'var(--accent-color)';
                }

                if (progressBar) {
                    progressBar.classList.toggle('completed', percentage >= 100);
                }

                return percentage;
            }

            document.addEventListener('DOMContentLoaded', () => {
                initializeBookmarks();

                const speeches = document.querySelectorAll('article.speech');
                speeches.forEach(article => {
                    const checkbox = article.querySelector('.speech-checkbox');
                    if (checkbox) {
                        checkbox.checked = article.getAttribute('data-checked') === 'true';
                        const speechId = checkbox.dataset.speechId;
                        const navLink = document.querySelector(`a[data-speech-id="${speechId}"]`);
                        if (navLink) {
                            navLink.classList.toggle('completed', checkbox.checked);
                        }
                    }
                });

                const headers = document.querySelectorAll('.speech-title, .main-header');
                const topNavContainer = document.querySelector('.top-nav-container');
                if (headers.length < 5 && topNavContainer) {
                    topNavContainer.style.display = 'none';
                }

                updateProgress();
                
                // Add hamburger menu toggle functionality
                const menuToggle = document.querySelector('.menu-toggle');
                const sidebar = document.querySelector('.sidebar');
                
                if (menuToggle && sidebar) {
                    menuToggle.addEventListener('click', () => {
                        console.log('Menu toggle clicked');
                        sidebar.classList.toggle('active');
                        
                        // Optionally add a body class to prevent scrolling when menu is open
                        document.body.classList.toggle('menu-open');
                    });
                    
                    // Close menu when clicking outside the menu
                    document.addEventListener('click', (e) => {
                        // If sidebar is active and click is outside sidebar and not on the toggle button
                        if (sidebar.classList.contains('active') && 
                            !sidebar.contains(e.target) && 
                            e.target !== menuToggle) {
                            sidebar.classList.remove('active');
                            document.body.classList.remove('menu-open');
                        }
                    });
                }
            });

            document.addEventListener('change', (e) => {
                if (e.target.classList.contains('speech-checkbox')) {
                    const checkbox = e.target;
                    const article = checkbox.closest('article.speech');
                    const isChecked = checkbox.checked;
                    const speechId = checkbox.dataset.speechId;

                    if (article) {
                        article.setAttribute('data-checked', isChecked);
                    }

                    const navLink = document.querySelector(`a[data-speech-id="${speechId}"]`);
                    if (navLink) {
                        navLink.classList.toggle('completed', isChecked);
                    }

                    updateProgress();

                    if (window.jsHandler && window.jsHandler.checkboxToggledFromJs) {
                        window.jsHandler.checkboxToggledFromJs(isChecked);
                    }
                }
            });

            document.querySelectorAll('.nav-link').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    if (this.getAttribute('href') === '#top') {
                        window.scrollTo({
                            top: 0,
                            behavior: 'smooth'
                        });

                        const navContainer = document.querySelector('.nav-container');
                        if (navContainer) {
                            navContainer.scrollTo({
                                top: 0,
                                behavior: 'smooth'
                            });
                        }
                    } else {
                        const target = document.querySelector(this.getAttribute('href'));
                        const offset = 100;
                        const bodyRect = document.body.getBoundingClientRect().top;
                        const elementRect = target.getBoundingClientRect().top;
                        const elementPosition = elementRect - bodyRect;
                        const offsetPosition = elementPosition - offset;

                        window.scrollTo({
                            top: offsetPosition,
                            behavior: 'smooth'
                        });
                    }

                    document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
                    this.classList.add('active');

                    if (window.innerWidth <= 768) {
                        const sidebar = document.querySelector('.sidebar');
                        if (sidebar) {
                            sidebar.classList.remove('active');
                        }
                    }
                });
            });

            window.addEventListener('scroll', () => {
                const speeches = document.querySelectorAll('.speech, .main-header-section');
                const navLinks = document.querySelectorAll('.nav-link');
                const navContainer = document.querySelector('.nav-container');
                const offsetThreshold = 120;
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const maxScroll = document.documentElement.scrollHeight - window.innerHeight;

                // When transcript scroll reaches top, bring nav scroll to top
                if (scrollTop <= 10) {
                    if (navContainer) {
                        navContainer.scrollTop = 0;
                    }
                }

                // When transcript scroll reaches bottom, bring nav scroll to bottom
                if (scrollTop >= maxScroll - 10) {
                    if (navContainer) {
                        navContainer.scrollTop = navContainer.scrollHeight - navContainer.clientHeight;
                    }
                }

                if (scrollTop < offsetThreshold) {
                    navLinks.forEach(link => link.classList.remove('active'));
                    const topLink = document.querySelector('.nav-link-top');
                    if (topLink) {
                        topLink.classList.add('active');
                    }
                } else {
                    speeches.forEach((speech) => {
                        const rect = speech.getBoundingClientRect();
                        if (rect.top <= offsetThreshold && rect.bottom >= offsetThreshold) {
                            navLinks.forEach(link => link.classList.remove('active'));
        
                            // Get the actual ID from the speech element instead of relying on index
                            const speechId = speech.id || 
                                            speech.querySelector('[id^="speech-"]')?.id;
        
                            if (speechId) {
                                const navLink = document.querySelector(`a[href="#${speechId}"]`);
                                if (navLink) {
                                    navLink.classList.add('active');
                                    navLink.scrollIntoView({
                                        block: 'nearest',
                                        behavior: 'smooth'
                                    });
                                }
                            }
                        }
                    });
                }
            });

            // Table of Contents Modal functionality
            const tocButton = document.getElementById('toc-button');
            const tocModal = document.getElementById('toc-modal');
            const tocClose = document.querySelector('.toc-close');
            const tocGrid = document.querySelector('.toc-grid');

            if (tocButton && tocModal) {
                tocButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    tocModal.style.display = 'flex';
                });
    
                // Close modal when clicking the X
                if (tocClose) {
                    tocClose.addEventListener('click', function() {
                        tocModal.style.display = 'none';
                    });
                }
    
                // Close modal when clicking outside the content
                tocModal.addEventListener('click', function(e) {
                    if (e.target === tocModal) {
                        tocModal.style.display = 'none';
                    }
                });
    
                // Handle item clicks in TOC
                document.querySelectorAll('.toc-item').forEach(item => {
                    item.addEventListener('click', function(e) {
                        e.preventDefault();
            
                        // Close the modal
                        tocModal.style.display = 'none';
            
                        // Scroll to the target section
                        const targetId = this.getAttribute('href');
                        const targetElement = document.querySelector(targetId);
            
                        if (targetElement) {
                            const offset = 100;
                            const bodyRect = document.body.getBoundingClientRect().top;
                            const elementRect = targetElement.getBoundingClientRect().top;
                            const elementPosition = elementRect - bodyRect;
                            const offsetPosition = elementPosition - offset;
                
                            window.scrollTo({
                                top: offsetPosition,
                                behavior: 'smooth'
                            });
                
                            // Update active state in main nav
                            document.querySelectorAll('.nav-link').forEach(link => {
                                link.classList.remove('active');
                            });
                
                            const navLink = document.querySelector(`a[href="${targetId}"]`);
                            if (navLink) {
                                navLink.classList.add('active');
                            }
                        }
                    });
                });
            }

            // TOC Search functionality with selector validation
            document.addEventListener('DOMContentLoaded', function() {
                const tocSearch = document.getElementById('toc-search');
                const tocSearchResults = document.getElementById('toc-search-results');
                const tocClose = document.querySelector('.toc-close');
                const tocModal = document.getElementById('toc-modal');

                if (!tocSearch || !tocSearchResults) return;

                // Force redraw of search field
                tocSearch.style.display = 'none';
                setTimeout(() => { tocSearch.style.display = 'block'; }, 0);

                // Multiple event listeners for reliability
                ['input', 'keyup'].forEach(function(event) {
                    tocSearch.addEventListener(event, function() {
                        handleSearch();
                    });
                });

                function handleSearch() {
                    const tocGrid = document.querySelector('.toc-grid');
                    const searchTerm = tocSearch.value.toLowerCase().trim();
                    const tocItems = document.querySelectorAll('.toc-item');
    
                    // Clear previous results
                    tocSearchResults.innerHTML = '';
    
                    if (searchTerm.length < 2) {
                        tocSearchResults.style.display = 'none';
                        if (tocGrid) tocGrid.style.display = 'grid';
                        return;
                    }
    
                    // Show search results, hide regular grid
                    tocSearchResults.style.display = 'block';
                    if (tocGrid) tocGrid.style.display = 'none';
    
                    // Find matching items
                    let matchCount = 0;
                    tocItems.forEach(item => {
                        const itemText = item.textContent.toLowerCase();
                        // Safely access title attribute
                        const itemTitle = item.hasAttribute('title') ? 
                            item.getAttribute('title').toLowerCase() : '';
        
                        if (itemText.includes(searchTerm) || itemTitle.includes(searchTerm)) {
                            matchCount++;
                            const resultItem = item.cloneNode(true);
                            tocSearchResults.appendChild(resultItem);
                        }
                    });
    
                    // Show message if no results
                    if (matchCount === 0) {
                        const noResults = document.createElement('div');
                        noResults.className = 'toc-no-results';
                        noResults.textContent = 'No matches found';
                        tocSearchResults.appendChild(noResults);
                    }
                }

                // Clear search when closing modal
                if (tocClose) {
                    tocClose.addEventListener('click', function() {
                        const tocGrid = document.querySelector('.toc-grid');
                        tocSearch.value = '';
                        tocSearchResults.innerHTML = '';
                        tocSearchResults.style.display = 'none';
                        if (tocGrid) tocGrid.style.display = 'grid';
                    });
                }

                // Handle clicks on search results
                tocSearchResults.addEventListener('click', function(e) {
                    // Find the closest .toc-item if the click was on a child element
                    const targetItem = e.target.closest('.toc-item');
    
                    if (targetItem) {
                        e.preventDefault();
        
                        // Clear search
                        const tocGrid = document.querySelector('.toc-grid');
                        tocSearch.value = '';
                        tocSearchResults.innerHTML = '';
                        tocSearchResults.style.display = 'none';
                        if (tocGrid) tocGrid.style.display = 'grid';
        
                        // Close the modal
                        if (tocModal) tocModal.style.display = 'none';
        
                        // Get the target ID and validate it
                        const targetId = targetItem.getAttribute('href');
        
                        // Make sure targetId is a valid selector
                        if (!targetId || targetId === '#' || targetId === '') {
                            console.error('Invalid target ID:', targetId);
                            return;
                        }
        
                        // Now it's safe to use querySelector
                        const targetElement = document.querySelector(targetId);
        
                        if (targetElement) {
                            const offset = 100;
                            const bodyRect = document.body.getBoundingClientRect().top;
                            const elementRect = targetElement.getBoundingClientRect().top;
                            const elementPosition = elementRect - bodyRect;
                            const offsetPosition = elementPosition - offset;
            
                            window.scrollTo({
                                top: offsetPosition,
                                behavior: 'smooth'
                            });
            
                            // Update active state in main nav
                            document.querySelectorAll('.nav-link').forEach(link => {
                                link.classList.remove('active');
                            });
            
                            // Validate the selector before using it
                            if (targetId && targetId !== '#' && targetId !== '') {
                                const navLink = document.querySelector(`a[href="${targetId}"]`);
                                if (navLink) {
                                    navLink.classList.add('active');
                                }
                            }
                        }
                    }
                });
            });
        '''
        
        # Replace the placeholders with properly escaped paths
        script_content = script_content.replace('BOOKMARK_PATH_PLACEHOLDER', json.dumps(bookmark_url))
        script_content = script_content.replace('BOOKMARK_FILLED_PATH_PLACEHOLDER', json.dumps(bookmark_filled_url))
        
        script_tag.string = script_content
        body_tag.append(script_tag)

        return doctype + '\n' + str(html_doc)

    def get_css_styles(self):
        return '''
            /* =========================================================
               GLOBAL RESET + CUSTOM PROPERTIES  (keep DOM spacing same)
            --------------------------------------------------------- */
            *, *::before, *::after {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            :root {
                --primary-color:      #2D3250;
                --accent-color:       #7077A1;
                --background-color:   #faf9f8;
                --text-color:         #2C3333;
                --sidebar-width:      300px;
                --content-max-width:  900px;
                --spacing-unit:       1rem;
                --success-color:      #4CAF50;
                --success-bg:         #E8F5E9;
                --success-hover:      #C8E6C9;
            }

            /* ---------- load the font & apply it ---------- */
            @import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap');

            body {
                font-family: 'Open Sans', Roboto, 'Helvetica Neue', Arial, sans-serif;
                line-height: 1.65;
                background-color: var(--background-color);
                color: var(--text-color);
            }

            /* default (arrow) everywhere */
            html, body, p, h1, h2, h3, h4, h5, h6, span, div {
                cursor: default !important;
            }

            /* pointer on interactive elements */
            a, button, .menu-toggle, .bookmark-icon, .bookmark-container,
            .speech-checkbox, .toc-close, .toc-item, .nav-link, .nav-link-top,
            .nav-link-toc, input[type="checkbox"], .tooltip-title {
                cursor: pointer !important;
            }


            /* =========================================================
               SCOPED reset — only inside #transcript (redundant‑safe)
            --------------------------------------------------------- */
            #transcript,
            #transcript *,
            #transcript *::before,
            #transcript *::after {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }
            #transcript { cursor: default; }
            #transcript a,
            #transcript button,
            #transcript .menu-toggle,
            #transcript .bookmark-icon,
            #transcript .bookmark-container,
            #transcript .speech-checkbox,
            #transcript .toc-close,
            #transcript .toc-item,
            #transcript .nav-link,
            #transcript .nav-link-top,
            #transcript .nav-link-toc,
            #transcript input[type="checkbox"],
            #transcript .tooltip-title {
                cursor: pointer !important;
            }

            /* =========================================================
               FIX highlight icon sizing that the global reset shrank
            --------------------------------------------------------- */
            span[data-annotation-id]::before,
            span[data-annotation-id]::after {
                box-sizing: content-box;   /* restore original circle size */
            }


            /* NOTES HTML / FAVORITE / USED INDICATORS */
            /* Base highlight enhancement */
            span[data-annotation-id] {
                transition: all 0.2s ease;
                position: relative;   /* context for icons */
                overflow: visible;
                display: inline;      /* keeps inline flow */
                white-space: pre-wrap;/* preserves manual line‑breaks */
                /* no extra padding, margin, or width tweaks */
            }

            span[data-annotation-id]:hover {
                filter: brightness(1.1);
                box-shadow: 0 0 5px rgba(255, 165, 0, 0.5);
            }

            /* Common styles for icon pseudo-elements */
            span[data-annotation-id]::before,
            span[data-annotation-id]::after {
                position: absolute;
                top: -10px;
                font-size: 10px;
                color: white;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                display: none; /* Hide by default */
                align-items: center;
                justify-content: center;
                line-height: 1;
                font-weight: bold;
                pointer-events: none;
                border: 1px solid white;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
                z-index: 100;
            }

            /* Info icon (::before) - Appears if either notes_html or notes has content */
            span[data-annotation-id][data-notes-html]:not([data-notes-html=""]):not([data-notes-html="null"])::before {
                content: "ℹ";
                background-color: #2196F3; /* Blue */
                left: -5px; /* Primary position */
                display: flex; /* Show it */
            }
            
            span[data-annotation-id][data-notes]:not([data-notes=""]):not([data-notes="null"])::before {
                content: "ℹ";
                background-color: #2196F3; /* Blue */
                left: -5px; /* Primary position */
                display: flex; /* Show it */
            }

            /* Star icon (::after) - Only appears if favorited */
            span[data-annotation-id][data-favorite="true"]::after {
                content: "★";
                background-color: #FFD700; /* Gold */
                /* Default to adjacent position */
                left: 9px;
                display: flex; /* Show it */
            }

            /* --- Override Star Position WHEN Info Icon is ABSENT --- */
            /* Star moves to primary position when both notes and notes_html are empty/missing */
            span[data-annotation-id][data-favorite="true"][data-notes-html=""][data-notes=""]::after,
            span[data-annotation-id][data-favorite="true"][data-notes-html=""][data-notes="null"]::after,
            span[data-annotation-id][data-favorite="true"][data-notes-html="null"][data-notes=""]::after,
            span[data-annotation-id][data-favorite="true"][data-notes-html="null"][data-notes="null"]::after,
            span[data-annotation-id][data-favorite="true"]:not([data-notes-html])[data-notes=""]::after,
            span[data-annotation-id][data-favorite="true"]:not([data-notes-html])[data-notes="null"]::after,
            span[data-annotation-id][data-favorite="true"]:not([data-notes-html]):not([data-notes])::after,
            span[data-annotation-id][data-favorite="true"][data-notes-html=""]:not([data-notes])::after,
            span[data-annotation-id][data-favorite="true"][data-notes-html="null"]:not([data-notes])::after {
                left: -5px; /* Move to the primary position */
            }

            /* Ensure star sits in adjacent slot when any notes exist (prevents overlap) */
            span[data-annotation-id][data-favorite="true"][data-notes]:not([data-notes=""]):not([data-notes="null"])::after,
            span[data-annotation-id][data-favorite="true"][data-notes-html]:not([data-notes-html=""]):not([data-notes-html="null"])::after {
                left: 9px !important;
            }
            

            /* Used indicator - Enhanced prominence */
            span[data-annotation-id][data-used="true"] {
               /* More prominent green styling for used annotations */
               border: 3px solid #2E7D32 !important; /* Extra thick, darker green border */
               box-shadow: 0 0 6px rgba(76, 175, 80, 0.4) !important; /* Subtle green glow */
               position: relative !important;
            }
            
            
            
            /* Add a subtle green tint to used annotation backgrounds */
            span[data-annotation-id][data-used="true"]:not(.favorites-hidden):not(.used-hidden):not(.unused-hidden):not(.tag-filtered-hidden):not(.theme-hidden) {
               background-color: color-mix(in srgb, var(--annotation-bg-color, #FFF0B3) 85%, #4CAF50 15%) !important;
            }
            
            
            
            
        
            /* Updated Tooltip Styles with Scroll and Sticky Headers */
            .notes-tooltip {
                position: absolute;
                background-color: #F8F8FC; /* Lighter background for better contrast */
                color: #2C3333;
                border-radius: 8px;
                padding: 12px;
                box-shadow: 0 3px 15px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                max-width: 350px;
                max-height: 650px; /* Set maximum height */
                width: auto;
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 14px;
                border: 1px solid #E6E6EF;
                overflow: hidden; /* Hide overflow on the main tooltip container */
            }

            .notes-tooltip.visible {
                opacity: 1;
                visibility: visible;
            }

            .tooltip-title {
                display: flex;
                align-items: center;
                margin-bottom: 10px;
                font-weight: bold;
                border-bottom: 1px solid rgba(0, 0, 0, 0.1);
                padding-bottom: 8px;
                color: #2D3250; /* Match primary color from your CSS */
                cursor: pointer; /* Make it clear this is clickable */
                padding: 4px 6px;
                border-radius: 4px;
                margin: -4px -6px 6px -6px;
                transition: background-color 0.15s ease;
                position: sticky;
                top: -12px; /* Offset by the tooltip's padding */
                background-color: #F8F8FC; /* Match tooltip background */
                z-index: 2;
            }
            
            .tooltip-title:hover {
                background-color: transparent; /* NO hover effect */
                cursor: default;
            }

            .tooltip-icon {
                margin-right: 8px;
                font-size: 18px;
                color: #7077A1; /* Match accent color from your CSS */
            }

            .tooltip-content {
                line-height: 1.5;
                overflow-wrap: break-word;
                max-height: calc(400px - 24px); /* Adjust for padding */
                min-height: 100px; /* Minimum height to allow spacing */
                position: relative;
                display: flex;
                flex-direction: column;
                flex-grow: 1;
            }

            .tooltip-scene {
                font-weight: bold;
                margin-bottom: 8px;
                /* Default color - will be overridden by JavaScript for specific scenes */
                color: black;
                position: sticky;
                top: 30px; /* Position below the title */
                background-color: #F8F8FC; /* Match tooltip background */
                z-index: 1;
                padding: 4px 0;
            }

            .tooltip-tags {
                margin-bottom: 8px;
                color: #6366F1;
                position: sticky;
                top: 50px; /* Position below the scene */
                background-color: #F8F8FC; /* Match tooltip background */
                z-index: 1;
                padding: 4px 0;
                font-size: 13px;
            }

            .tooltip-tags .tag {
                display: inline-block;
                background: #EEF2FF;
                color: #6366F1;
                padding: 2px 6px;
                border-radius: 12px;
                margin-right: 4px;
                margin-bottom: 2px;
                font-size: 12px;
                border: 1px solid #C7D2FE;
            }

            .tooltip-footnote {
                margin-bottom: 8px;
                color: #4D4D4D;
                position: sticky;
                top: 70px; /* Position below the tags */
                background-color: #F8F8FC; /* Match tooltip background */
                z-index: 1;
                padding: 4px 0;
            }

            .tooltip-html-notes {
                border-top: 3px solid rgba(0, 0, 0, 0.1);
                padding-top: 8px;
                color: #333333;
                overflow-y: auto; /* Add scrolling to this section only */
                max-height: 500px; /* Limit height for scrolling */
                margin-right: -6px; /* Compensate for scrollbar */
                padding-right: 6px; /* Add padding for scrollbar */
            }

            /* Style for the tooltip scrollbar */
            .tooltip-html-notes::-webkit-scrollbar {
                width: 6px;
            }

            .tooltip-html-notes::-webkit-scrollbar-track {
                background: #F1F1F1;
                border-radius: 3px;
            }

            .tooltip-html-notes::-webkit-scrollbar-thumb {
                background: #C0C0C0;
                border-radius: 3px;
            }

            .tooltip-html-notes::-webkit-scrollbar-thumb:hover {
                background: #A0A0A0;
            }

            /* Sidebar Layout */
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                width: var(--sidebar-width);
                height: 100vh;
                background: white;
                border-right: 1px solid rgba(0, 0, 0, 0.05);
                display: flex;
                flex-direction: column;
                z-index: 100;
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
            }

                /* Bookmark Styles */
                .bookmark-container {
                    position: absolute;
                    top: 0rem;
                    right: .05rem;
                    cursor: pointer;
                    z-index: 2;
                }

                .bookmark-icon {
                    width: 24px;
                    height: 32px;
                    transition: transform 0.2s ease;
                }

                .bookmark-icon:hover {
                    transform: scale(1.1);
                }

                .speech-header {
                    position: relative;  /* Added to support absolute positioning of bookmark */
                }

                /* Update existing speech header styles */
                .speech-header {
                    display: flex;
                    align-items: center;
                    position: relative;
                    margin-bottom: 1.3rem;
                    padding-right: 40px;  /* Make room for bookmark */
                }

            .speech-checkbox {
                position: absolute;
                left: 0;
                top: 50%;
                transform: translateY(-50%);
                appearance: none;
                -webkit-appearance: none;
                width: 24px;
                height: 24px;
                border: 2px solid var(--accent-color);
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                margin-left: 0px; /* Add some space from the left edge */
                margin-right:5px;
            }

            .speech-title {
                flex: 1;
                text-align: left;
                font-size: 1.8rem;
                font-weight: 700;
                color: var(--primary-color);
                margin: 0;
                letter-spacing: -0.02em;
                padding: 0 35px; /* Add padding to account for checkbox width */
            }

            /* Progress Bar Styles */
            .progress-container {
                padding: .35rem var(--spacing-unit);
                border-bottom: 0px solid rgba(0, 0, 0, 0.1);
                background: white;
            }

            .progress-info {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.25rem;
                font-size: 0.9rem;
                color: var(--text-color);
            }

            .progress-percentage {
                font-weight: 600;
                color: var(--success-color);
            }

            /* Add or update these styles in get_css_styles */
            .progress-bar {
                width: 100%;
                height: 8px;
                background: rgba(0, 0, 0, 0.1);
                border-radius: 4px;
                overflow: hidden;
                transition: all 0.3s ease;
            }

            .progress-fill {
                height: 100%;
                background: var(--accent-color);
                border-radius: 4px;
                transition: all 0.3s ease;
                width: 0;
            }

            .progress-bar.completed .progress-fill {
                background: var(--success-color);
            }

            /* Top Nav Container - New */
            .top-nav-container {
                display: flex;
                gap: 0.5rem;
                justify-content: center;
                margin-bottom: 0.5rem;
            }

            /* Back to Top Link - Make it smaller */
            .nav-item-top {
                margin-bottom: 0;
                padding: 0;
                flex: 1;
            }

            /* Base style for both buttons */
            .nav-link-top, .nav-link-toc {
                display: block;
                font-size: 0.85rem;
                font-weight: 600;
                text-align: center;
                color: var(--accent-color);
                text-decoration: none;
                padding: 0.2rem 0.4rem;
                border-radius: 4px;
                background-color: rgba(112, 119, 161, 0.1);
                transition: all 0.2s ease;
                width: 100%;
            }

            /* Shared hover style for both buttons */
            .nav-link-top:hover, .nav-link-toc:hover {
                background-color: rgba(112, 119, 161, 0.2);
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(112, 119, 161, 0.1);
            }

            /* Consistent active state */
            .nav-link-top.active, .nav-link-toc.active {
                background-color: rgba(112, 119, 161, 0.25);
                color: var(--primary-color);
                font-weight: 700;
            }

            .book-transcript .nav-link-top:hover,
            .video-transcript .nav-link-top:hover {
                background-color: rgba(112, 119, 161, 0.2) !important;
            }

            /* Ensure the container is styled properly */
            .top-nav-container {
                display: flex;
                gap: 0.5rem;
                justify-content: center;
                margin-bottom: 0.5rem;
            }

            .nav-item-top {
                margin-bottom: 0;
                padding: 0;
                flex: 1;
            }

            .nav-item-top {
                margin-bottom: 0;
                padding: 0;
                flex: 1;
            }
        
            /* Table of Contents Modal */
            .toc-modal {
                display: none;
                position: fixed;
                z-index: 1000;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                justify-content: center;
                align-items: center;
            }

            .toc-modal-content {
                position: relative;
                background-color: white;
                margin: auto;
                padding: 1.5rem;
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
                max-width: 900px;
                width: 95%;
                max-height: 85vh;
                overflow-y: auto;
            }

            .toc-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
                padding-bottom: 0.5rem;
                border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            }

            .toc-header h3 {
                margin: 0;
                font-size: 1.5rem;
                color: var(--primary-color);
            }

            .toc-close {
                font-size: 1.8rem;
                font-weight: bold;
                cursor: pointer;
                color: var(--text-color);
            }

            /* Search bar */
            .toc-search-container {
                position: relative;
                margin-bottom: 1rem;
            }

            .toc-search-input {
                width: 100%;
                padding: 0.5rem 2.5rem 0.5rem 0.75rem;
                font-size: 0.95rem;
                border: 1px solid #ccc;
                border-radius: 6px;
                outline: none;
                transition: border-color 0.2s;
            }

            .toc-search-input:focus {
                border-color: var(--accent-color);
            }

            .toc-search-icon {
                position: absolute;
                right: 0.75rem;
                top: 50%;
                transform: translateY(-50%);
                color: #777;
                pointer-events: none;
            }

            .toc-search-results {
                display: none;
                margin-top: 0.5rem;
                max-height: 50vh;
                overflow-y: auto;
                border: 1px solid #eee;
                border-radius: 6px;
                padding: 0.5rem;
            }

            .toc-no-results {
                padding: 1rem;
                text-align: center;
                color: #777;
                font-style: italic;
            }

            /* Two-column grid */
            .toc-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }

            .toc-column {
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
            }

            .toc-item {
                display: block;
                padding: 0.4rem 0.6rem;
                text-decoration: none;
                border-radius: 4px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                transition: all 0.2s;
            }

            /* Normal header styling - blue */
            .toc-item-normal {
                color: #2563EB; /* Blue with good contrast */
                font-size: 0.9rem;
            }

            .toc-item-normal:hover {
                background-color: rgba(37, 99, 235, 0.1);
            }

            /* Main header styling in TOC - Enhanced with gold color and container */
            .toc-item-main {
                color: #7077A1; /* Purple accent color */
                font-size: 1.05rem; /* Slightly larger */
                font-weight: 600;
                background-color: rgba(112, 119, 161, 0.08); /* Very subtle purple background */
                border-left: 3px solid #7077A1;
                border-radius: 4px;
                padding: 0.5rem 0.6rem;
                margin-bottom: 0.4rem; /* Add some space below main headers */
                box-shadow: 0 1px 3px rgba(112, 119, 161, 0.1); /* Subtle shadow */
                position: relative;
                overflow: visible; /* Allow pseudo-elements to extend outside */
            }

            .toc-item-main:hover {
                background-color: rgba(112, 119, 161, 0.15);
                box-shadow: 0 1px 4px rgba(112, 119, 161, 0.2);
            }

            /* Small indicator before main headers */
            .toc-item-main::before {
                content: "◆"; /* Diamond symbol */
                position: absolute;
                left: 0.2rem;
                top: 50%;
                transform: translateY(-50%);
                color: #7077A1;
                font-size: 0.7em;
            }


            /* Top Nav Container */
            .top-nav-container {
                display: flex;
                gap: 0.5rem;
                justify-content: center;
                margin-bottom: 0.5rem;
            }

            /* Back to Top and Contents links */
            .nav-item-top {
                margin-bottom: 0;
                padding: 0;
                flex: 1;
            }

            .nav-link-top, .nav-link-toc {
                display: block;
                font-size: 0.85rem;
                font-weight: 600;
                text-align: center;
                color: var(--accent-color);
                text-decoration: none;
                padding: 0.2rem 0.4rem;
                border-radius: 4px;
                background-color: rgba(112, 119, 161, 0.1);
                transition: background-color 0.2s;
                width: 100%;
            }

            .nav-link-top:hover, .nav-link-toc:hover {
                background-color: rgba(112, 119, 161, 0.2);
            }

            /* Responsive adjustments */
            @media (max-width: 768px) {
                .toc-grid {
                    grid-template-columns: 1fr;
                }
                
                /* Hide bookmark images on mobile to save space */
                .bookmark-container,
                .bookmark-icon {
                    display: none !important;
                }
            }

            @media (max-width: 480px) {
                .toc-grid {
                    grid-template-columns: 1fr;
                }
            }

            .speech-checkbox:checked {
                background-color: var(--success-color);
                border-color: var(--success-color);
            }

            .speech-checkbox:checked::after {
                content: "✓";
                position: absolute;
                color: white;
                font-size: 16px;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }

            .speech-checkbox:checked ~ .speech-title {
                color: var(--success-color);
            }

            /* Navigation Link Completed State */
            .nav-link.completed {
                background: var(--success-bg);
                color: var(--text-color); /* Keep text color unchanged */
                border-color: var(--success-color);
            }

            .nav-link.completed:hover {
                background: var(--success-hover);
                color: var(--text-color); /* Keep text color unchanged on hover too */
            }

            /* Sticky Header */
            .sidebar-sticky-header {
                position: sticky;
                top: 0;
                background: white;
                padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 2) var(--spacing-unit);
                border-bottom: 2px solid #f0f0f0;
                z-index: 10;
                display: flex;
                flex-direction: column;
                gap: 1rem;
            }

            .sidebar-title {
                font-size: 1.2rem;
                font-weight: 600;
                color: var(--primary-color);
            }

            /* Navigation Container */
            .nav-container {
                flex: 1;
                overflow-y: auto;
                padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
            }

            .nav-list {
                list-style: none;
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
            }

            /* Main vs Normal Nav Items */
            .nav-item-main .nav-link-main {
                font-weight: 700;
                text-transform: uppercase;
                background: var(--accent-color);
                color: white;
            }

            .nav-item-main .nav-link-main:hover {
                background: var(--primary-color);
                color: white;
            }

            .nav-item-top {
                margin-bottom: .10rem;
                padding: 0.25rem 0.25rem;
                border-bottom: 1px solid var(--border-color);
            }

            .nav-link-top {
                display: inline-flex; /* Keeps the element inline and allows flex properties */
                align-items: center;  /* Vertically centers the content */
                justify-content: center; /* Horizontally centers the content */
                font-size: .9rem; /* Reduced font size for a smaller button */
                font-weight: 600;
                text-align: center
                color: var(--accent-color);
                text-decoration: none;
                padding: 0.2rem 0.4rem; /* Reduced padding for a smaller button */
                border-radius: 4px;
                transition: background-color 0.2s;
                margin: 0 auto; /* Centers the button within its container */
                display: block; /* Allows margin auto to center the button */
            }

            .nav-link-top:hover {
                background-color: var(--bg-color-hover);
            }


            .nav-item {
                margin-bottom: 0.5rem;
            }

            .nav-link {
                display: block;
                padding: 0.75rem 1rem;
                color: var(--text-color);
                text-decoration: none;
                border-radius: 12px;
                transition: all 0.2s ease;
                font-weight: 500;
                text-align: left;
                background: white;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
                border: 1px solid rgba(0, 0, 0, 0.1);
            }

            .nav-link:hover {
                background: rgba(112, 119, 161, 0.2);
                color: var(--primary-color);
                box-shadow: 0 2px 6px rgba(112, 119, 161, 0.2);
            }

            .nav-link.active {
                background: var(--primary-color);
                color: white;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            }

            /* Content Layout */
            .content {
                margin-left: var(--sidebar-width);
                padding: calc(var(--spacing-unit) * 3);
                max-width: calc(var(--content-max-width) + var(--sidebar-width));
                margin: 0 auto;
                padding-left: calc(var(--sidebar-width) + var(--spacing-unit) * 3);
            }

            .page-title {
                font-size: 2.5rem;
                font-weight: 800;
                color: var(--primary-color);
                margin-bottom: calc(var(--spacing-unit) * 2);
                letter-spacing: -0.03em;
                text-align: center;
                padding-bottom: calc(var(--spacing-unit) * 1.5);
                border-bottom: 2px solid rgba(0, 0, 0, 0.1);
            }

            /* Color Key */
            .color-key {
                display: flex;
                flex-wrap: wrap;
                gap: 1rem;
                padding: 1.5rem;
                border-radius: 16px;
                margin-bottom: calc(var(--spacing-unit) * 2);
                justify-content: center;
            }

            .key-item {
                display: flex;
                align-items: center;
                gap: 0.75rem;
                padding: 0.5rem 1rem;
                border-radius: 8px;
                font-weight: 500;
            }

            .color-box {
                width: 24px;
                height: 24px;
                border-radius: 6px;
                border: 2px solid rgba(0, 0, 0, 0.1);
            }

            /* Speeches and Content */
            .speech {
                background: white;
                padding: calc(var(--spacing-unit) * 2);
                margin-bottom: calc(var(--spacing-unit) * 2);
                border-radius: 16px;
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                           0 2px 4px -1px rgba(0, 0, 0, 0.06);
                transition: transform 0.2s ease;
            }

            .speech-title {
                font-size: 1.8rem;
                font-weight: 700;
                color: var(--primary-color);
                margin: 0;
                letter-spacing: -0.02em;
            }

            .speech-content {
                font-size: 1.05rem;
                line-height: 1.8;
                color: var(--text-color);
            }

            .speech-content p {
                margin-bottom: 1rem;
                text-align: justify;
            }

            .speech-content p:last-child {
                margin-bottom: 0;
            }

            /* Divider */
            .divider {
                text-align: center;
                margin: calc(var(--spacing-unit) * 3) 0;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 1rem;
            }

            .divider::before,
            .divider::after {
                content: "";
                flex: 1;
                height: 2px;
                background: linear-gradient(to right, transparent, var(--accent-color), transparent);
            }

            .divider-icon {
                color: var(--accent-color);
                font-size: 1.5rem;
            }

            /* Update the Main Headers in the content area */
            .main-header-section {
                margin: 3.0rem 0 4.0rem 0; /* Increased margin, especially after */
                text-align: center;
                position: relative;
                padding-bottom: 2.5rem; /* Add some padding at bottom */
                padding-top: .85rem;
            }

            .main-header {
                font-size: 2.0rem; /* Slightly larger */
                font-weight: 800;
                color: var(--primary-color);
                text-transform: uppercase;
                letter-spacing: 0.05em;
                margin-bottom: 1rem;
                border-bottom: 2px solid var(--accent-color);
                display: inline-block;
                padding: 0.25rem 0.75rem 0.5rem; /* Add side padding */
            }

            /* Menu Toggle */
            .menu-toggle {
                display: none;
                position: fixed;
                top: 8rem;
                left: -.3rem;
                z-index: 5000;
                padding: 0.5rem;
                background: white;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                border: none;
                cursor: pointer;
            }

            .book-transcript .nav-link-top {
                color: var(--text-color);
                background-color: var(--bg-color-secondary);
            }

            .video-transcript .nav-link-top {
                color: var(--accent-color);
                background-color: var(--bg-color-hover);
            }

            /* Book Transcript Specific Styles */
            .book-transcript .nav-link {
                font-size: 0.9rem;
                padding: 0.5rem 0.75rem;
            }

            .book-transcript .page-title {
                font-size: 2rem;
                margin-bottom: 1.5rem;
            }

            .book-transcript .speech-title {
                font-size: 1.4rem;
                margin-bottom: 0.00rem;
                text-align: left;
            }

            .book-transcript .speech-header {
                margin-bottom: 0.00rem;
                text-align: left;
            }

            .book-transcript .speech-content p {
                margin-top: 0.25rem;
            }

            .book-transcript .speech {
                margin-bottom: 1rem !important;
            }

            .book-transcript .sidebar-sticky-header {
                padding: calc(var(--spacing-unit) * 1.5) var(--spacing-unit);
            }

            /* Responsive Design */
            @media (max-width: 1024px) {
                :root {
                    --sidebar-width: 250px;
                }
            }

            /* Responsive Design - completing the mobile styles */
            @media (max-width: 768px) {
                .sidebar {
                    transform: translateX(-100%);
                    transition: transform 0.3s ease;
                }

                .sidebar.active {
                    transform: translateX(0);
                }

                .content {
                    margin-left: 0;
                    padding: var(--spacing-unit);
                }

                .menu-toggle {
                    display: block;
                }

                .sidebar-sticky-header {
                    padding: var(--spacing-unit);
                }

                .nav-container {
                    padding: var(--spacing-unit);
                }
            
                .toc-columns {
                    flex-direction: column;
                }
            }

            /* Custom scrollbar styles */
            .nav-container {
                scrollbar-width: thin;
                scrollbar-color: var(--accent-color) transparent;
            }

            .nav-container::-webkit-scrollbar {
                width: 6px;
            }

            .nav-container::-webkit-scrollbar-track {
                background: transparent;
            }

            .nav-container::-webkit-scrollbar-thumb {
                background-color: var(--accent-color);
                border-radius: 3px;
            }
        '''

if __name__ == '__main__':
    # Enable high DPI scaling
    # Enable high DPI scaling
    try:
        # For Qt 6.0+
        if hasattr(Qt.ApplicationAttribute, 'AA_UseHighDpiPixmaps'):
            QApplication.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps, True)
    
        # For Qt 6.1+
        if hasattr(Qt, 'HighDpiScaleFactorRoundingPolicy'):
            QApplication.setHighDpiScaleFactorRoundingPolicy(
                Qt.HighDpiScaleFactorRoundingPolicy.PassThrough)
    except Exception as e:
        print(f"Warning: Error setting high DPI attributes: {e}")
    app = QApplication.instance()
    if app is None:
        app = QApplication(sys.argv)

    
    # Set application-wide properties
    app.setApplicationName('Scriptoria')
    app.setOrganizationName('Delisi Media')
    app.setOrganizationDomain('delisi.media')

class AppInitializer:
    def __init__(self, existing_splash=None):
        self.main_window = None
        self.splash = existing_splash  # Use the early splash screen if provided
        self.loading_dots = 0
        self.dot_timer = None
        
        # Only initialize a new splash screen if we don't have one already
        if self.splash is None:
            self.initialize_splash()
        
        # *** Initialize theme AFTER splash screen is shown ***
        self.initialize_theme()
        
        # Start main window initialization process with animated dots
        if self.splash:
            self.animate_main_window_loading()
            # Use timer to continue with main window initialization 
            QTimer.singleShot(100, self.initialize_main_window)
    
    def animate_main_window_loading(self):
        """Show animated dots for main window loading"""
        import time
        for i in range(4):  # 4 iterations of dot animation
            dots = "." * ((i % 4) + 1)
            if self.splash:
                self.splash.showMessage(f"Starting main window{dots}", Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignCenter, QColor("white"))
                QApplication.instance().processEvents()
                time.sleep(0.1)

    def initialize_theme(self):
        """Sets the application style and a light color palette."""
        # Don't print during startup to avoid console output before splash
        # print("Initializing Light Theme (Attempting Native Style with Palette Override)...")

        # Get the QApplication instance
        app = QApplication.instance()
        if app is None:
            print("  - Warning: No QApplication instance found")
            return

        # 1. Create and configure a light palette
        palette = QPalette()

        # Define light theme colors (same as before)
        WINDOW_BG = QColor("#f3f3f3")
        WINDOW_TEXT = QColor("#000000")
        BASE_BG = QColor("#FFFFFF")
        TEXT_COLOR = QColor("#000000")
        BUTTON_BG = QColor("#F0F0F0")
        BUTTON_TEXT = QColor("#000000")
        HIGHLIGHT_BG = QColor("#3399FF")
        HIGHLIGHT_TEXT = QColor("#FFFFFF")
        TOOLTIP_BG = QColor("#FFFFE0")
        TOOLTIP_TEXT = QColor("#000000")
        PLACEHOLDER_TEXT = QColor("#A0A0A0")
        DISABLED_TEXT = QColor("#A0A0A0")
        DISABLED_BUTTON_TEXT = QColor("#707070")
        LINK_COLOR = QColor("#0000EE")
        LINK_VISITED_COLOR = QColor("#551A8B")
        BORDER_COLOR = QColor("#C0C0C0")
        SHADOW_COLOR = QColor("#808080")

        # Apply colors to all relevant groups
        for group in [QPalette.ColorGroup.Active, QPalette.ColorGroup.Inactive, QPalette.ColorGroup.Disabled]:
            palette.setColor(group, QPalette.ColorRole.Window, WINDOW_BG)
            palette.setColor(group, QPalette.ColorRole.WindowText, WINDOW_TEXT)
            palette.setColor(group, QPalette.ColorRole.Base, BASE_BG)
            palette.setColor(group, QPalette.ColorRole.AlternateBase, QColor("#F5F5F5"))
            palette.setColor(group, QPalette.ColorRole.ToolTipBase, TOOLTIP_BG)
            palette.setColor(group, QPalette.ColorRole.ToolTipText, TOOLTIP_TEXT)
            palette.setColor(group, QPalette.ColorRole.Text, TEXT_COLOR)
            palette.setColor(group, QPalette.ColorRole.Button, BUTTON_BG)
            palette.setColor(group, QPalette.ColorRole.ButtonText, BUTTON_TEXT)
            palette.setColor(group, QPalette.ColorRole.BrightText, QColor("#FF0000"))
            palette.setColor(group, QPalette.ColorRole.Link, LINK_COLOR)
            palette.setColor(group, QPalette.ColorRole.LinkVisited, LINK_VISITED_COLOR)
            palette.setColor(group, QPalette.ColorRole.Highlight, HIGHLIGHT_BG)
            palette.setColor(group, QPalette.ColorRole.HighlightedText, HIGHLIGHT_TEXT)
            palette.setColor(group, QPalette.ColorRole.PlaceholderText, PLACEHOLDER_TEXT)

            # Set border and shadow colors
            palette.setColor(group, QPalette.ColorRole.Dark, BORDER_COLOR.darker(120))
            palette.setColor(group, QPalette.ColorRole.Mid, BORDER_COLOR)
            palette.setColor(group, QPalette.ColorRole.Light, BORDER_COLOR.lighter(120))
            palette.setColor(group, QPalette.ColorRole.Shadow, SHADOW_COLOR)

            # Set specific disabled colors
            if group == QPalette.ColorGroup.Disabled:
                palette.setColor(group, QPalette.ColorRole.Text, DISABLED_TEXT)
                palette.setColor(group, QPalette.ColorRole.WindowText, DISABLED_TEXT)
                palette.setColor(group, QPalette.ColorRole.ButtonText, DISABLED_BUTTON_TEXT)
                palette.setColor(group, QPalette.ColorRole.Highlight, QColor("#D0D0D0"))
                palette.setColor(group, QPalette.ColorRole.HighlightedText, QColor("#707070"))

        # print("  - Configured light palette")

        # 2. Apply the palette globally to the application
        app.setPalette(palette)
        # print("  - Applied light palette globally")

        # 3. Add global stylesheet for menus
        menu_stylesheet = """
        QMenu {
            background-color: #ffffff;
            color: #333333;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 4px;
        }
        QMenu::item {
            padding: 6px 24px;
            border-radius: 2px;
            color: #333333;
        }
        QMenu::item:selected {
            background-color: #e3f2fd;
            color: #2C4952;
        }
        QMenu::separator {
            height: 1px;
            background: #e0e0e0;
            margin: 4px 0;
        }
        QMenu::icon {
            margin-left: 6px;
        }
        QToolTip {
            background-color: #FFFFE0;
            color: #000000;
            border: 1px solid #c0c0c0;
            padding: 5px;
        }

        /* Progress Dialog Styling */
        QProgressDialog {
            background-color: #ffffff;
            color: #333333;
        }

        QProgressDialog QLabel {
            color: #333333;
            font-family: "Segoe UI", Arial, sans-serif;
            font-size: 11px;
        }

        QProgressDialog QProgressBar {
            border: 1px solid #d0d0d0;
            border-radius: 3px;
            background-color: #f5f5f5;
            text-align: center;
        }

        QProgressDialog QProgressBar::chunk {
            background-color: #3498db;
            width: 10px;
        }

        /* Minimal styling for message box buttons */
        QMessageBox QPushButton {
            background-color: #f5f5f5;
            border: 1px solid #d5d5d5;
            padding: 4px 8px;
            min-width: 40px;
            color: #333333;
        }
        QMessageBox QPushButton:hover {
            background-color: #f0f0f0;
        }
        QMessageBox QPushButton:default {
            border-color: #b0b0b0;
        }
        """
    
        # Apply the menu stylesheet to the app instance
        app.setStyleSheet(menu_stylesheet)
        # print("  - Applied global menu stylesheet")
    
        # print("Light Theme Initialized (Native Style with Global Menu Styling).")

    # --- Keep initialize_splash, update_loading_text, initialize_main_window, ---
    # --- and maximize_and_show_welcome methods exactly as they were in the     ---
    # --- previous 'Force Light Mode' example.                                ---

    def initialize_splash(self):
        # (Keep the implementation from the previous example)
        try:
            if getattr(sys, 'frozen', False): base_path = os.path.dirname(sys.executable)
            else: base_path = os.path.dirname(os.path.abspath(__file__))
            splash_path = os.path.join(base_path, 'Img', 'splash-screen.png')
        except Exception as e:
             print(f"Error determining splash path: {e}")
             splash_path = 'Img/splash-screen.png'
        splash_pix = QPixmap(splash_path)
        if splash_pix.isNull():
            print(f"Warning: Could not load splash screen from {splash_path}")
            QTimer.singleShot(0, self.initialize_main_window)
        else:
            splash_pix = splash_pix.scaled(500, 500, Qt.AspectRatioMode.IgnoreAspectRatio, Qt.TransformationMode.SmoothTransformation)
            self.splash = QSplashScreen(splash_pix, Qt.WindowType.WindowStaysOnTopHint | Qt.WindowType.FramelessWindowHint)
            screen = QApplication.primaryScreen().geometry()
            x = (screen.width() - 500) // 2
            y = (screen.height() - 500) // 2
            self.splash.move(x, y)
            self.splash.show()
            self.update_loading_text()
            QApplication.processEvents()
            self.dot_timer = QTimer()
            self.dot_timer.timeout.connect(self.update_loading_text)
            self.dot_timer.start(150)
            QTimer.singleShot(1500, self.initialize_main_window)

    def update_loading_text(self):
        # (Keep the implementation from the previous example)
        dots = "." * ((self.loading_dots % 4) + 1)
        self.loading_dots += 1
        styled_text = f"""
            <div style='color: white; font-family: Arial, sans-serif; font-size: 10px;
                       font-weight: bold; padding: 5px;'>Loading{dots}</div>"""
        if self.splash and self.splash.isVisible():
            self.splash.showMessage(styled_text,
                Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignCenter, QColor("white"))
            QApplication.processEvents()

    def initialize_main_window(self):
        # (Keep the implementation from the previous example)
        if self.dot_timer: self.dot_timer.stop()
        self.main_window = ScriptoriaMain() # Ensure this is your main window class name
        print(f"Python version: {platform.python_version()}")
        # self.main_window.setGeometry(100, 100, 1400, 1000) # Let main window decide its default size
        # screen = QApplication.primaryScreen().geometry()
        # window_geometry = self.main_window.geometry()
        # center_x = (screen.width() - window_geometry.width()) // 2
        # center_y = (screen.height() - window_geometry.height()) // 2
        # self.main_window.move(center_x, center_y)
        if self.splash: QTimer.singleShot(100, lambda: self.splash.finish(self.main_window) if self.splash else None)
        QTimer.singleShot(275, lambda: self.maximize_and_show_welcome())

    def maximize_and_show_welcome(self):
        # Show the window maximized in one clean operation
        self.main_window.showMaximized()
        # Ensure the window is properly activated and brought to front
        self.main_window.raise_()
        self.main_window.activateWindow()
        QTimer.singleShot(100, self.main_window.show_welcome_dialog)


# --- SIMPLIFIED Main Execution Block ---
if __name__ == '__main__':
    # All splash screen setup was done at the top of the file
    # Now just initialize the app with the existing splash
    if app and splash:
        initializer = AppInitializer(existing_splash=splash)
        sys.exit(app.exec())
    else:
        # Fallback if splash creation failed
        app = QApplication(sys.argv)
        initializer = AppInitializer()
        sys.exit(app.exec())
